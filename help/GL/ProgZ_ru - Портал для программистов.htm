<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0040)http://www.progz.ru/articles.php?view=66 -->
<HTML><HEAD><TITLE>ProgZ.ru - Портал для программистов</TITLE>
<META http-equiv=content-type content="text/html; charset=windows-1251"><LINK 
href="ProgZ_ru - Портал для программистов.files/style.css" type=text/css 
rel=stylesheet>
<META content="MSHTML 6.00.2800.1106" name=GENERATOR></HEAD>
<BODY>
<TABLE width="100%" align=center>
  <TBODY>
  <TR>
    <TD align=left width=220><IMG title="Портал для программистов ProgZ.ru" 
      height=80 alt="Портал для программистов ProgZ.ru" 
      src="ProgZ_ru - Портал для программистов.files/logo_progz3c.gif" width=268 
      border=0>
      <DIV align=center><B><A class=main href="http://www.ipipe.ru/">платный 
      хостинг Ipipe.ru</A></B></DIV><BR></TD>
    <TD align=middle></TD></TR></TBODY></TABLE>
<TABLE height=600 cellSpacing=0 cellPadding=0 width="100%" align=center 
valign="top">
  <TBODY>
  <TR>
    <TD vAlign=top align=left width=180 bgColor=#f3f3f3>
      <TABLE cellSpacing=0 cellPadding=0 width=180 align=center>
        <TBODY>
        <TR>
          <TD class=caption><A class=menu 
            href="http://www.progz.ru/index.php">ProgZ.ru</A></TD></TR>
        <TR>
          <TD class=caption><A class=menu 
            href="http://www.progz.ru/news.php">Новости</A></TD></TR>
        <TR>
          <TD class=caption><A class=menu 
            href="http://www.progz.ru/articles.php">Статьи</A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/articles.php?issue=2">Система<A></A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/articles.php?issue=5">OpenGL<A></A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/articles.php?issue=7">Мысли 
        вслух<A></A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/articles.php?issue=8">Теория 
            программирования<A></A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/articles.php?issue=9">DLL<A></A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/articles.php?issue=10">Языки 
            программирования<A></A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/articles.php?issue=11">Eclipse<A></A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/articles.php?issue=12">Shaders<A></A></TD></TR>
        <TR>
          <TD class=caption><A class=menu 
            href="http://www.progz.ru/docs.php">Документация</A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/docs.php?issue=1">Протоколы<A></A></TD></TR>
        <TR>
          <TD class=caption><A class=menu 
            href="http://www.progz.ru/faq.php">FAQ</A></TD></TR>
        <TR>
          <TD class=caption><A class=menu 
            href="http://www.progz.ru/sources.php">Исходники</A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/sources.php?issue=1">Visual 
        C++<A></A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/sources.php?issue=2">Delphi<A></A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/sources.php?issue=3">JavaScript<A></A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/sources.php?issue=4">C++ 
        Builder<A></A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/sources.php?issue=5">OpenGL<A></A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/sources.php?issue=6">PHP<A></A></TD></TR>
        <TR>
          <TD class=caption><A class=menu 
            href="http://www.progz.ru/books.php">Книги</A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/books.php?issue=1">Веб-дизайн<A></A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/books.php?issue=2">Искусство 
            программирования<A></A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/books.php?issue=3">Матчасть<A></A></TD></TR>
        <TR>
          <TD class=caption><A class=menu 
            href="http://www.progz.ru/links.php">Ссылки</A></TD></TR>
        <TR>
          <TD class=issue>»&nbsp;<A class=menu 
            href="http://www.progz.ru/links.php?issue=1">Сайты<A></A></TD></TR>
        <TR>
          <TD class=caption><A class=menu 
            href="http://www.progz.ru/forum"><STRONG>Форум</STRONG></A></TD></TR>
        <TR>
          <TD vAlign=top align=left width=180 bgColor=#f3f3f3>&nbsp;</TD></TR>
        <TR>
          <TD class=caption>Партнеры</TD></TR>
        <TR>
          <TD class=issue align=middle><A href="http://www.rushelp.com/" 
            target=_blank><IMG height=31 
            alt="RusHelp.com - вся компьютерная документация на русском!" 
            src="ProgZ_ru - Портал для программистов.files/knopka.gif" width=88 
            border=0></A></TD></TR>
        <TR>
          <TD class=issue align=middle><A href="http://pascal.dax.ru/" 
            target=_blank><IMG height=31 alt="Все о программировании на Паскале" 
            src="" width=88 border=0></A></TD></TR>
        <TR>
          <TD class=issue align=middle><A 
            title="WinCity.Ru - город компьютерной документации. Документация на самые различные темы, Каталог программ, Электронные руководства и многое другое Вы найдете на WinCity.Ru" 
            href="http://www.wincity.ru/" target=_blank><IMG height=31 src="" 
            width=88 border=0></A></TD></TR>
        <TR>
          <TD class=issue align=middle><A href="http://www.getinfo.ru/" 
            target=_blank><IMG height=31 
            alt="GetInfo.Ru - Компьютерная библиотека" 
            src="ProgZ_ru - Портал для программистов.files/getinfo88x31.gif" 
            width=88 border=0></A></TD></TR>
        <TR>
          <TD class=issue align=middle><A href="http://allcheats.ru/" 
            target=_blank><IMG height=30 alt=AllCheats src="" width=88 
            border=0></A></TD></TR>
        <TR>
          <TD class=issue align=middle><A href="http://www.ishodniki.ru/" 
            target=_blank>Ishodniki.Ru - портал программиста!</A></TD></TR>
        <TR>
          <TD vAlign=top align=left width=180 bgColor=#f3f3f3>&nbsp;</TD></TR>
        <TR>
          <TD class=caption>Счетчики</TD></TR>
        <TR>
          <TD class=issue align=middle><!--Rating@Mail.ru COUNTER-->
            <SCRIPT language=JavaScript type=text/javascript><!--
d=document;var a='';a+=';r='+escape(d.referrer)
js=10//--></SCRIPT>

            <SCRIPT language=JavaScript1.1 type=text/javascript><!--
a+=';j='+navigator.javaEnabled()
js=11//--></SCRIPT>

            <SCRIPT language=JavaScript1.2 type=text/javascript><!--
s=screen;a+=';s='+s.width+'*'+s.height
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth)
js=12//--></SCRIPT>

            <SCRIPT language=JavaScript1.3 
            type=text/javascript><!--
js=13//--></SCRIPT>

            <SCRIPT language=JavaScript type=text/javascript><!--
d.write('<a href="http://top.mail.ru/jump?from=335931"'+
' target=_top><img src="http://top.list.ru/counter'+
'?id=335931;t=49;js='+js+a+';rand='+Math.random()+
'" alt="Рейтинг@Mail.ru"'+' border=0 height=31 width=88><\/a>')
if(11<js)d.write('<'+'!-- ')//--></SCRIPT>
            <NOSCRIPT><A href="http://top.mail.ru/jump?from=335931" 
            target=_top><IMG height=31 alt=Рейтинг@Mail.ru src="" width=88 
            border=0></A></NOSCRIPT>
            <SCRIPT language=JavaScript type=text/javascript><!--
if(11<js)d.write('--'+'>')//--></SCRIPT>
<!--/COUNTER--></TD></TR>
        <TR>
          <TD class=issue align=middle><!-- HotLog -->
            <SCRIPT language=javascript>
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=41445&im=134&r="+escape(document.referrer)+"&pg="+
escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</SCRIPT>

            <SCRIPT language=javascript1.1>
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")</SCRIPT>

            <SCRIPT language=javascript1.2>
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</SCRIPT>

            <SCRIPT language=javascript1.3>hotlog_js="1.3"</SCRIPT>

            <SCRIPT language=javascript>hotlog_r+="&js="+hotlog_js;
document.write("<a href='http://www3.hotlog.ru/cgi-bin/hotlog/site_stat/?id=41445' target='_top'><img "+
" src='http://hit3.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog></a>")</SCRIPT>
            <NOSCRIPT><A 
            href="http://www3.hotlog.ru/cgi-bin/hotlog/site_stat/?id=41445" 
            target=_top><IMG height=31 alt=HotLog src="" width=88 
            border=0></A></NOSCRIPT> <!-- /HotLog --></TD></TR>
        <TR>
          <TD class=issue align=middle><A 
            href="http://www.yandex.ru/cy?base=0&amp;host=progz.ru"><IMG 
            height=31 alt="Яндекс цитирования" 
            src="ProgZ_ru - Портал для программистов.files/cycounter.gif" 
            width=88 border=0></A></TD></TR>
        <TR>
          <TD vAlign=top align=left width=180 
        bgColor=#f3f3f3>&nbsp;</TD></TR></TBODY></TABLE></TD>
    <TD width=1>&nbsp;<BR></TD>
    <TD vAlign=top align=left width="100%" bgColor=#ffffff>
      <TABLE cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=caption><A class=menu 
            href="http://www.progz.ru/articles.php">Статьи</A> » <A class=menu 
            href="http://www.progz.ru/articles.php?issue=5">OpenGL</A> » Глава 
            13. Режим выбора и обратный режим</TD></TR>
        <TR>
          <TD>&nbsp;<BR></TD></TR>
        <TR>
          <TD class=text>
            <H1>Глава 13. Режим выбора и обратный режим</H1></TD></TR>
        <TR>
          <TD align=middle><SPAN class=black-small>Автор: </SPAN><A 
            class=main-small href="mailto:ahinar@list.ru">Максим 
        Каверин</A></TD></TR>
        <TR>
          <TD class=text align=left>
            <LI><A class=main-small 
            href="http://www.progz.ru/print.php?articles=66" 
            target=_blank>Версия для печати</A>
            <P></P></LI></TD></TR>
        <TR>
          <TD class=text>
            <P class=text>Некоторые графические приложения просто рисуют 
            статические изображения двумерных или трехмерных объектов. Другие 
            приложения позволяют пользователю выбирать объект на экране, а затем 
            двигать, изменять, удалять или как-либо еще манипулировать этим 
            объектом. OpenGL разработана для поддержки именно таких 
            интерактивных приложений. Поскольку объекты, рисуемые на экране 
            обычно претерпевают множественные повороты, переносы и перспективные 
            преобразования, для вас может быть достаточно сложно определить, 
            какой объект в трехмерной сцене выбрал пользователь. Чтобы помочь 
            вам, OpenGL предоставляет механизм выбора (selection mechanism), 
            который автоматически вычисляет и сообщает вам, какие объекты 
            нарисованы внутри заданного региона окна. Вы можете использовать 
            этот механизм совместно со специальной утилитарной функцией, 
            определяющей внутри региона конкретный объект, который пользователь 
            <I>указал</I> (<I>picking</I>) с помощью курсора.</P>
            <P class=text>На самом деле выбор – это один из режимов выполнения 
            операций OpenGL; отклик (feedback) является еще одним таким режимом. 
            В режиме отклика ваша графическая аппаратура и OpenGL используются 
            для выполнения обычных расчетов для визуализации. Однако вместо 
            того, чтобы использовать вычисленные величины для рисования 
            изображения на экране, OpenGL возвращает информацию о рисовании вам. 
            Например, если вы хотите отобразить трехмерную сцену на плоттере, а 
            не на экране, вы можете нарисовать объекты в режиме отклика, собрать 
            инструкции, необходимые для рисования и преобразовать их в команды, 
            которые плоттер может понять и выполнить.</P>
            <P class=text>И в режиме выбора, и в режиме отклика информация о 
            рисовании возвращается приложению, а не отсылается в буфер кадра, 
            как происходит в режиме визуализации. Таким образом, изображение на 
            экране не меняется – ничего не рисуется, пока OpenGL находится в 
            режимах выбора или отклика. В этих режимах цветовой буфер, буфер 
            глубины, буфер трафарета и аккумуляторный буфер не используются. В 
            данной главе каждый из указанных режимов описан в отдельном 
            разделе.</P>
            <H2>13.1 Выбор</H2>
            <P class=text>Обычно, когда вы планируете использовать механизм 
            выбора OpenGL, вы сначала рисуете вашу сцену в буфере кадра, а затем 
            переходите в режим выбора и перерисовываете сцену. Однако после 
            того, как вы вошли в режим выбора, содержимое буфера кадра не 
            меняется до тех пор, пока вы не покинете этот режим. Когда вы 
            выходите из режима выбора, OpenGL возвращает список примитивов, 
            пересекающих объем видимости (помните, что объем видимости 
            определяется текущими видовой и проекционной матрицами, а также 
            дополнительными плоскостями отсечения). Каждый примитив, имеющий 
            пересечение с объемом видимости вызывает то, что называется 
            <I>попаданием</I> (<I>hit</I>). На самом деле список примитивов 
            возвращается в виде массива целочисленных <I>имен</I> и связанных 
            данных – <I>записей о попаданиях</I> (<I>hitrecords</I>) – 
            соответствующих текущему содержимому <I>стека имен</I>. Находясь в 
            режиме выбора, вы конструируете стек имен, загружая в него имена 
            одновременно с выполнением команд для рисования примитивов. Таким 
            образом, когда список имен возвращается в программу, вы можете 
            использовать его для определения тех примитивов, которые 
            пользователь мог выбрать на экране.</P>
            <P class=text>Вдобавок к этому механизму выбора OpenGL предоставляет 
            утилитарную функцию, разработанную для упрощения процесса выбора в 
            некоторых случаях, путем ограничения рисования небольшой областью 
            порта просмотра. Обычно эта функция используется для обнаружения 
            объектов, нарисованных вблизи курсора, чтобы вы могли 
            идентифицировать каждый объект, который указал пользователь. (Вы 
            также можете ограничить область выбора за счет добавления 
            дополнительных плоскостей отсечения. Помните, что эти плоскости 
            действуют в мировом пространстве, а не в экранном.) Поскольку 
            указание объектов (picking) это специальный случай выбора как 
            такового, в данной главе выбор описывается первым, а указание за 
            ним.</P>
            <H2>13.1.1 Основные шаги</H2>
            <P class=text>Чтобы использовать механизм выбора, вам нужно 
            выполнить следующие шаги.</P>
            <OL>
              <LI>
              <P class=text>С помощью команды <B>glSelectBuffer()</B> задайте 
              массив, который будет использоваться для возвращения записей о 
              попаданиях. </P>
              <LI>
              <P class=text>Перейдите в режим выбора, передав аргумент GL_SELECT 
              команде <B>glRenderMode()</B>. </P>
              <LI>
              <P class=text>Инициализируйте стек имен с помощью команд 
              <B>glInitNames()</B> и <B>glPushName()</B>. </P>
              <LI>
              <P class=text>Определите объем видимости, который вы хотите 
              использовать для режима выбора. Обычно этот объем отличается от 
              того, который изначально использовался для рисования сцены, так 
              что, скорее всего, вам нужно будет сохранить и позже восстановить 
              состояние преобразований с помощью команд <B>glPushMatrix()</B> и 
              <B>glPopMatrix()</B>. </P>
              <LI>
              <P class=text>Чередуйте выполнение команд для рисования примитивов 
              с командами для манипуляций со стеком имен, дабы быть уверенными в 
              том, что каждый интересующий вас полигон получил соответствующее 
              имя. </P>
              <LI>
              <P class=text>Выйдите из режима выбора и обработайте возвращенные 
              данные о выборе (записи о попаданиях). </P></LI></OL>
            <TABLE class=code width="90%" align=center>
              <TBODY>
              <TR>
                <TD>void <B>glSelectBuffer</B> (GLsizei <I>size</I>, GLuint* 
                  <I>buffer</I>);</TD></TR></TBODY></TABLE>
            <P class=text>Задает массив, который будет использоваться для 
            возвращения информации о выбранных примитивах. Аргумент <I>buffer 
            </I>должен быть указателем на массив беззнаковых целых, в который 
            будут помещаться данные, а аргумент <I>size</I>– задает максимальное 
            количество величин, которые могут быть записаны в этот массив. Вы 
            должны вызвать команду <B>glSelectBuffer()</B> до перехода в режим 
            выбора.</P>
            <TABLE class=code id=table1 width="90%" align=center>
              <TBODY>
              <TR>
                <TD>GLint <B>glRenderMode</B> 
              (GLenum<I>mode</I>);</TD></TR></TBODY></TABLE>
            <P class=text>Управляет тем, в каком режиме приложение находится в 
            текущий момент. Аргумент <I>mode </I>может принимать значения 
            GL_RENDER (режим визуализации, значение по умолчанию), GL_SELECTION 
            (режим выбора) или GL_FEEDBACK (режим отклика). Приложение остается 
            в заданном режиме до того, как команда <B>glRenderMode()</B> не 
            будет вызвана снова с другим аргументом. До перехода в режим выбора 
            вы должны задать буфер выбора с помощью команды 
            <B>glSelectBuffer()</B>. Похожим образом, до перехода в режим 
            отклика с помощью команды <B>glFeedbackBuffer()</B> должен быть 
            задан массив отклика. Возвращаемое значение команды 
            <B>glRenderMode()</B> имеет смысл, только если текущим режимом 
            визуализации (именно текущим, а не заданным в аргументе) является 
            GL_SELECT или GL_FEEDBACK. Возвращаемое значение представляет собой 
            число записей о попаданиях или число величин, занесенных в массив 
            отклика при выходе из режимов GL_SELECT или GL_FEEDBACK 
            соответственно; отрицательная величина означает, что буфер выбора 
            или отклика переполнен. Для выяснения того, в каком режиме вы 
            находитесь в данный момент, используйте аргумент GL_RENDER_MODE в 
            команде <B>glGetIntegerv()</B>.</P>
            <H2>13.1.2 Создание стека имен</H2>
            <P class=text>Как было указано ранее, стек имен формирует базис для 
            информации о выборе, которая к вам возвращается. Чтобы создать стек 
            имен, сначала инициализируйте его командой <B>glInitNames()</B>, 
            которая просто очищает стек, а затем добавляйте в него целочисленные 
            имена в процессе исполнения соответствующих команд рисования. Как вы 
            можете ожидать, команды манипулирования стеком имен позволяют 
            поместить имя на вершину стека с продвижением всех, содержащихся в 
            нем, глубже (<B>glPushName()</B>), поднять имя из стека на вершину, 
            потеряв при этом предыдущее имя на вершине (<B>glPopName()</B>) и 
            заменить имя на вершине стека каким-либо другим 
            (<B>glLoadName()</B>). Пример кода, манипулирующего стеком имен, 
            продемонстрирован в примере 13-1.</P>
            <P class=text>Пример 13-1. Создание стека имен</P>
            <TABLE class=code id=table2 width="90%" align=center>
              <TBODY>
              <TR>
                <TD><PRE>glInitStack();
glPushName(0);

glPushMatrix();   /* сохраняем текущее состояние преобразований */

/* здесь создается требуемый объем видимости */

      glLoadName(1);
      нарисовать_Какой_либо_Объект();
      glLoadName(2);
      нарисовать_Другой_Объект();
      glLoadName(3);
      нарисовать_Еще_Один_Объект();
      нарисовать_Последний_Объект();

glPopMatrix();    /* восстанавливаем предыдущее состояние преобразований */</PRE></TD></TR></TBODY></TABLE>
            <P class=text>В этом примере первые два рисуемых объекта имеют свои 
            собственные имена, а третий и четвертый объекты разделяют одно общее 
            имя. При такой настройке, если третий или четвертый объект или оба 
            сразу вызовут попадание, вам будет возвращена только одна запись о 
            попадании. Вы можете заставить несколько объектов разделять одно 
            общее имя, если вам не нужно разделять их при обработке записей.</P>
            <TABLE class=code id=table3 width="90%" align=center>
              <TBODY>
              <TR>
                <TD>void <B>glInitNames</B> (void);</TD></TR></TBODY></TABLE>
            <P class=text>Полностью очищает стек имен.</P>
            <TABLE class=code id=table4 width="90%" align=center>
              <TBODY>
              <TR>
                <TD>void <B>glPushName</B> (GLuint 
            <I>name</I>);</TD></TR></TBODY></TABLE>
            <P class=text>Помещает name на вершину стека. Помещение имени, в 
            полный стек генерирует ошибку GL_STACK_OVERFLOW. Размер стека имен 
            может быть разным в разных реализациях OpenGL, но в любой реализации 
            стек должен иметь вместимость, как минимум, для 64 имен. Для 
            выяснения реальной глубины стека имен вы можете использовать 
            аргумент GL_NAME_STACK_DEPTH в команде <B>glGetIntegerv()</B>.</P>
            <TABLE class=code id=table5 width="90%" align=center>
              <TBODY>
              <TR>
                <TD>void <B>glPopName</B> (void);</TD></TR></TBODY></TABLE>
            <P class=text>Поднимает имя из стека на вершину. Извлечение имени из 
            пустого стека генерирует ошибку GL_STACK_UNDERFLOW.</P>
            <TABLE class=code id=table6 width="90%" align=center>
              <TBODY>
              <TR>
                <TD>void <B>glLoadName</B> (GLuint 
            <I>name</I>);</TD></TR></TBODY></TABLE>
            <P class=text>Заменяет имя на вершине стека величиной <I>name</I>. 
            Если стек пуст, что вполне нормально после вызова 
            <B>glInitNames()</B>, вызов команды <B>glLoadName()</B> сгенерирует 
            ошибку GL_INVALID_OPERATION. Чтобы этого избежать, сразу после 
            инициализации стека поместите что-либо на его вершину командой 
            <B>glPushName()</B> до вызова <B>glLoadName()</B>.</P>
            <P class=text>Обращения к <B>glPushName()</B>, <B>glPopName()</B> и 
            <B>glLoadName()</B> игнорируются, если программа не находится в 
            режиме выбора. Вы можете обнаружить, что этот факт упрощает 
            смешивание этих команд с командами рисования – вы можете 
            использовать такой смешанный код для отображения объектов на экране, 
            а затем использовать его же для получения информации о выборе.</P>
            <H2>13.1.3 Запись о попадании</H2>
            <P class=text>В режиме выбора примитивы, имеющие пересечения с 
            объемом видимости, вызывают попадание. Каждый раз, когда выполняется 
            команда манипулирования стеком имен или команда 
            <B>glRenderMode()</B>, OpenGL записывает запись о попадании в буфер 
            выбора, если попадание было зафиксировано после последней 
            манипуляции со стеком или выполнения команды <B>glRenderMode()</B>. 
            В течение этого процесса объекты, разделяющие общее имя – например, 
            объекты, состояние из нескольких примитивов – не генерируют 
            множественных записей о попаданиях. Кроме того, не гарантируется, 
            что записи о попаданиях будут записаны в буфер выбора до вызова 
            команды <B>glRenderMode()</B>.</P>
            <P class=warning>Замечание: Помимо примитивов попадание могут 
            вызвать допустимые координаты, обозначенные в команде 
            <B>glRasterPos()</B>. Кроме того, в случае полигонов попадания не 
            происходит, если полигон отбрасывается механизмом удаления нелицевых 
            граней.</P>
            <P class=text>Каждая запись о попадании состоит из 4 элементов (они 
            перечислены по порядку):</P>
            <UL>
              <LI>
              <P class=text>Количество имен в стеке в момент попадания. </P>
              <LI>
              <P class=text>Минимальная и максимальная координата <I>z 
              </I>(оконная) всех вершин примитивов, пересекающих объем видимости 
              с момента последнего попадания. Эти две величины, лежащие в 
              диапазоне [<I>0</I>, <I>1</I>] умножаются на <IMG height=25 
              src="ProgZ_ru - Портал для программистов.files/form001.jpg" 
              width=55 align=textTop border=0>&nbsp;и округляются до ближайшего 
              беззнакового целого.</P>
              <LI>
              <P class=text>Содержимое стека имен на момент попадания. При этом 
              первым элементом стоит элемент со дна стека.</P></LI></UL>
            <P class=text>Когда вы переходите в режим выбора, OpenGL 
            инициализирует указатель на начало массива выбора. Каждый раз, когда 
            запись о попадании записывается в массив, значение указателя 
            обновляется. Если занесение записи о попадании должно привести к 
            тому, что общее количество величин превысит аргумент size указанный 
            в команде <B>glSelectBuffer()</B>, OpenGL записывает в буфер 
            допустимую часть записи и устанавливает флаг переполнения. Когда вы 
            выходите из режима выбора командой <B>glRenderMode()</B>, эта 
            команда возвращает общее количество записей о попаданиях, занесенных 
            в массив выбора (включая и частично записанную запись, если таковая 
            была), очищает стек имен, сбрасывает флаг переполнения и сбрасывает 
            указатель стека. Если флаг переполнения был установлен, возвращаемое 
            значение равно -1.</P>
            <H2>13.1.4 Пример реализации выбора</H2>
            <P class=text>В примере 13-2 на экране с помощью функции 
            <B>drawTriangle()</B> рисуются 4 треугольника: зеленый, красный и 
            два желтых, а также каркасный параллепипед, представляющий объем 
            видимости (функция <B>drawViewVolume()</B>). Затем треугольники 
            визуализируются еще раз, но на этот раз в режиме выбора (функция 
            <B>selectObjects()</B>). Соответствующие записи о попаданиях 
            обрабатываются в функции <B>processHits()</B> и массив выбора 
            распечатывается в консольном окне. Первый треугольник генерирует 
            попадание, второй не генерирует его, а третий и четвертый вместе 
            генерируют одно попадание. Результат работы программы показан на 
            рисунке 13-1.</P>
            <P class=text>Рисунок 13-1. Пример реализации выбора
            <P align=center><IMG height=280 
            src="ProgZ_ru - Портал для программистов.files/13-1.jpg" width=280 
            border=0></P>
            <P class=text>Пример 13-2. Пример реализации выбора: файл 
            select.cpp</P>
            <TABLE class=code id=table7 width="90%" align=center>
              <TBODY>
              <TR>
                <TD><PRE>#include <WINDOWS.H>
#include <GLUT.H>
#include <STDIO.H>

void drawTriangle(GLfloat x1,GLfloat y1,GLfloat x2,GLfloat y2,GLfloat x3,GLfloat y3,GLfloat z)
{
      glBegin(GL_TRIANGLES);
            glVertex3f(x1,y1,z);
            glVertex3f(x2,y2,z);
            glVertex3f(x3,y3,z);
      glEnd();
}

void drawViewVolume(GLfloat x1,GLfloat x2,GLfloat y1,GLfloat y2,GLfloat z1,GLfloat z2)
{
      glColor3f(1.0,1.0,1.0);
      glBegin(GL_LINE_LOOP);
            glVertex3f(x1,y1,-z1);
            glVertex3f(x2,y1,-z1);
            glVertex3f(x2,y2,-z1);
            glVertex3f(x1,y2,-z1);
      glEnd();

      glBegin(GL_LINE_LOOP);
            glVertex3f(x1,y1,-z2);
            glVertex3f(x2,y1,-z2);
            glVertex3f(x2,y2,-z2);
            glVertex3f(x1,y2,-z2);
      glEnd();

      glBegin(GL_LINES);
            glVertex3f(x1,y1,-z1);
            glVertex3f(x1,y1,-z2);
            glVertex3f(x1,y2,-z1);
            glVertex3f(x1,y2,-z2);
            glVertex3f(x2,y1,-z1);
            glVertex3f(x2,y1,-z2);
            glVertex3f(x2,y2,-z1);
            glVertex3f(x2,y2,-z2);
      glEnd();
}

void drawScene()
{
      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();
      gluPerspective(40.0,4.0/3.0,1.0,100.0);

      glMatrixMode(GL_MODELVIEW);
      glLoadIdentity();
      gluLookAt(7.5,7.5,12.5,2.5,2.5,-5.0,0.0,1.0,0.0);

      glColor3f(0.0,1.0,0.0);
      drawTriangle(2.0,2.0,3.0,2.0,2.5,3.0,-5.0);

      glColor3f(1.0,0.0,0.0);
      drawTriangle(2.0,7.0,3.0,7.0,2.5,9.0,-5.0);

      glColor3f(1.0,1.0,0.0);
      drawTriangle(2.0,2.0,3.0,2.0,2.5,3.0,0.0);
      drawTriangle(2.0,2.0,3.0,2.0,2.5,3.0,-10.0);

      drawViewVolume(0.0,5.0,0.0,5.0,0.0,10.0);
}

void processHits(GLint hits,GLuint buffer[])
{
      int i,j;
      GLuint names, *ptr;
      printf("hits=%d\n",hits);
      ptr=(GLuint*)buffer;
      for (i=0;i<HITS;I++) pre }< 0; return glutMainLoop(); glutDisplayFunc(display); init(); Example?); glutCreateWindow(?Selection glutInitWindowPosition(100,100); glutInitWindowSize(200,200); glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH); glutInit(&argc,argv); { argv[]) char* argc, main(int int } selectObjects(); drawScene(); glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT); display() void glShadeModel(GL_FLAT); glEnable(GL_DEPTH_TEST); glClearColor(0.0,0.0,0.0,0.0); init() processHits(hits,selectBuf); hits="glRenderMode(GL_RENDER);" glFlush(); glPopMatrix(); drawTriangle(2.0,2.0,3.0,2.0,2.5,3.0,-10.0); drawTriangle(2.0,2.0,3.0,2.0,2.5,3.0,0.0); 3\n?); are name triangles printf(?Yellow glLoadName(3); drawTriangle(2.0,7.0,3.0,7.0,2.5,9.0,-5.0); 2\n?); is triangle printf(?Red glLoadName(2); drawTriangle(2.0,2.0,3.0,2.0,2.5,3.0,-5.0); 1\n?); printf(?Green glLoadName(1); glLoadIdentity(); glMatrixMode(GL_MODELVIEW); glOrtho(0.0,5.0,0.0,5.0,0.0,10.0); glMatrixMode(GL_PROJECTION); glPushMatrix(); glPushName(0); glInitNames(); glRenderMode(GL_SELECT); glSelectBuffer(BUFSIZE,selectBuf); hits; GLint selectBuf[BUFSIZE]; GLuint selectObjects() 512 BUFSIZE #define printf(?\n?); ptr++; ?,*ptr); printf(?%d for(j="0;j<names;j++)" ?); names="*ptr;" the printf(? 0x7fffffff); %g;\n?,(float)*ptr z2 %g;?,(float)*ptr z1 hit='%d\n",names);' for of number>
	</PRE></TD></TR></TBODY></TABLE>
            <P class=text>Эта программа генерирует следующий вывод:</P>
            <TABLE class=code id=table8 width="90%" align=center>
              <TBODY>
              <TR>
                <TD><PRE>Green triangle name is 1
Red triangle name is 2
Yellow triangles name are 3
hits=2
 number of names for hit=1
 z1 is 0.999999; z2 is 0.999999;
 the names are 1 
 number of names for hit=1
  z1 is 0; z2 is 2;
 the names are 3</PRE></TD></TR></TBODY></TABLE>
            <H2>13.1.5 Указание</H2>
            <P class=text>В качестве расширения процесса, описанного в 
            предыдущем разделе, вы можете использовать механизм выбора для 
            определения того, какие объекты указаны пользователем. Чтобы это 
            сделать, в сочетании с проекционной матрицей вы используете 
            специальную матрицу указания, ограничивающую область рисования малым 
            регионом порта просмотра, который обычно находится вблизи курсора. 
            Затем вы выбираете какую-либо форму ввода, например, щелчок мышью, 
            которая будет активизировать режим выбора. В режиме выбора с 
            использованием матрицы указания попадание генерируют только объекты, 
            которые нарисованы вблизи курсора. Таким образом, по время указания 
            вы обычно определяете объекты, нарисованные вблизи курсора.</P>
            <P class=text>Указание настраивается практически так же, как и 
            обычный выбор, но присутствуют и важные отличия:</P>
            <UL>
              <LI>
              <P class=text>Указание обычно активизируется с помощью устройства 
              ввода. В следующих примерах кода нажатие левой кнопки мыши 
              запускает функцию, производящую указание.</P>
              <LI>
              <P class=text>Вы используете функцию <B>gluPickMatrix()</B> для 
              умножения текущей проекционной матрицы на специальную матрицу 
              указания. Эта функция должна быть вызвана до установления 
              стандартной проекционной матрицы (например, командами 
              <B>glOrtho()</B> или <B>glFrustum()</B>). Вероятно перед этим 
              процессом вам потребуется сохранить предыдущую матрицу проекции, 
              так что ваш код будет похож на следующий:</P></LI></UL>
            <TABLE class=code id=table9 width="90%" align=center>
              <TBODY>
              <TR>
                <TD><PRE>glMatrixMode(GL_PROJECTION);
glPushMatrix();
glLoadIdentity();
gluPickMatrix(...);
gluPerspective, glOrtho, gluOrtho2D или glFrustum
      /* ... нарисовать сцену для указания, произвести указание ... */
glPopMatrix();</PRE></TD></TR></TBODY></TABLE>
            <P></P>
            <TABLE class=code id=table10 width="90%" align=center>
              <TBODY>
              <TR>
                <TD>void <B>gluPickMatrix</B> (GLdouble <I>x</I>, GLdouble 
                  <I>y</I>, GLdouble <I>width</I>, GLdouble <I>height</I>, GLint 
                  <I>viewport[4]</I>);</TD></TR></TBODY></TABLE>
            <P class=text>Создает проекционную матрицу, ограничивающую область 
            рисования малым регионом порта просмотра и умножает текущую 
            проекционную матрицу на нее. Центром региона указания становится 
            точка (<I>x</I>, <I>y</I>) в оконных координатах (обычно в это время 
            там находится курсор). Аргументы <I>width </I>и <I>height </I>задают 
            размеры (ширину и высоту) региона указания в экранных координатах. 
            (Вы можете считать ширину и высоту области указания 
            чувствительностью устройства ввода.) Аргумент <I>viewport[]</I> 
            должен содержать текущие границы порта просмотра, которые могут быть 
            получены с помощью следующего вызова</P>
            <TABLE class=code id=table11 width="90%" align=center>
              <TBODY>
              <TR>
                <TD>glGetIntegerv(GL_VIEWPORT, GLint 
            *viewport);</TD></TR></TBODY></TABLE>
            <P class=text><B>Дополнительно:</B> Действие матрицы, созданной с 
            помощью <B>gluPickMatrix()</B> заключается в преобразовании 
            отсекающего региона к единичному кубу 
            -1&lt;=(<I>x</I>,<I>y</I>,<I>z</I>)&lt;=1&nbsp;(или 
            -<I>w</I>&lt;=(<I>wx</I>,<I>wy</I>,<I>wz</I>)&lt;=<I>w</I>). Матрица 
            указания производит ортогональное преобразование, отображающее 
            регион отсечения на единичный куб. Поскольку преобразование может 
            быть произвольным, вы можете заставить указание работать с 
            различными регионами – например, с вращающимися прямоугольными 
            областями окна. Однако в некоторых случаях для определения области 
            указания может быть проще создавать дополнительные плоскости 
            отсечения.&nbsp;</P>
            <P class=text>Пример 13-3 иллюстрирует простое указание. Он также 
            демонстрирует&nbsp; технику использования множественных имен для 
            идентификации различных компонентов примитива, в данном случае – 
            строки и столбца выбранного объекта. На экране рисуется сетка 
            размером 33x3, состоящая из квадратов разного размера. Массив 
            <I>board[3][3]</I> хранит текущее количество синего в цвете каждого 
            квадрата. Когда нажимается левая кнопка мыши, вызывается функция 
            <B>pickSquares()</B>, определяющая квадраты, которые были указаны 
            мышью. Каждый квадрат в сетке идентифицируется двумя именами – одно 
            имя для строки и одно для столбца. Кроме того, когда нажимается 
            левая кнопка мыши, изменяется цвет всех квадратов, находящихся 
            вблизи курсора. Начальное изображение, генерируемое примером, 
            показано на рисунке 13-2.</P>
            <P class=text>Рисунок 13-2. Простой пример указания
            <P align=center><IMG height=300 
            src="ProgZ_ru - Портал для программистов.files/13-2.jpg" width=300 
            border=0></P>
            <P class=text>Пример 13-3. Пример указания: файл picksquares.cpp</P>
            <TABLE class=code id=table12 width="90%" align=center>
              <TBODY>
              <TR>
                <TD><PRE>#include <WINDOWS.H>
#include <GLUT.H>
#include <STDIO.H>

int board[3][3]; //количество синего в цвете каждого квадрата

void init()
{
      int i,j;
      for(i=0;i&lt;3;i++)
            for(j=0;j&lt;3;j++)
                  board[i][j]=0;
      glClearColor(0.0,0.0,0.0,0.0);
}

void drawSquares(GLenum mode)
{
      GLuint i,j;
      for (i=0;i&lt;3;i++)
      {
            if (mode==GL_SELECT)
                  glLoadName(i);
            for(j=0;j&lt;3;j++)
            {
                  if(mode==GL_SELECT)
                        glPushName(j);
                  glColor3f((GLfloat)i/3.0,(GLfloat)j/3.0,(GLfloat)board[i][j]/3.0);
                  glRecti(i,j,i+1,j+1);
                  if (mode==GL_SELECT)
                        glPopName();
            }
      }
}

void processHits(GLint hits,GLuint buffer[])
{
      int i,j;

      GLuint ii, jj, names, *ptr;

      printf("hits=%d\n",hits);
      ptr=(GLuint*)buffer;
      for (i=0;i<HITS;I++) pre }< 0; return glutMainLoop(); glutDisplayFunc(display); init(); Example?); glutInitWindowPosition(100,100); glutInit(&argc,argv); { argv[]) char* argc, main(int int } display() void processHits(hits,selectBuf); hits="glRenderMode(GL_RENDER);" glFlush(); glPopMatrix(); are is glLoadIdentity(); glMatrixMode(GL_MODELVIEW); glMatrixMode(GL_PROJECTION); glPushMatrix(); glPushName(0); glInitNames(); glRenderMode(GL_SELECT); glSelectBuffer(BUFSIZE,selectBuf); hits; GLint selectBuf[BUFSIZE]; GLuint 512 BUFSIZE #define printf(?\n?); ptr++; ?,*ptr); printf(?%d for(j="0;j<names;j++)" ?); names="*ptr;" the printf(? 0x7fffffff); %g;\n?,(float)*ptr z2 %g;?,(float)*ptr z1 hit='%d\n",names);' for of number glutReshapeFunc(reshape); glutMouseFunc(pickSquares); glutCreateWindow(?Picking glutInitWindowSize(300,300); glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB); gluOrtho2D(0.0,3.0,0.0,3.0); glViewport(0,0,w,h); h) w, reshape(int drawSquares(GL_RENDER); glClear(GL_COLOR_BUFFER_BIT); glutPostRedisplay(); drawSquares(GL_SELECT); gluPickMatrix((GLdouble)x,(GLdouble)(viewport[3]-y),5.0,5.0,viewport); location cursor near region picking pixel 5x5 Create glGetIntegerv(GL_VIEWPORT,viewport); return; state!="GLUT_DOWN)" || if(button!="GLUT_LEFT_BUTTON" viewport[4]; y) x,int state,int button,int pickSquares(int board[ii][jj]="(board[ii][jj]+1)%3;" jj="*ptr;" (j="=1)" if else ii="*ptr;" if(j="=0)" this>
	</PRE></TD></TR></TBODY></TABLE>
            <H2>13.1.5.1 Указание с использованием множественных имен в 
            иерархической модели</H2>
            <P class=text>Множественные имена могут также использоваться для 
            выбора частей иерархического объекта сцены. Например, если бы вы 
            визуализировали сборочную линию автомобилей, вам могла бы 
            потребоваться возможность, с помощью которой пользователь мог бы 
            выбрать третий болт переднего левого колеса второй машины на линии. 
            На каждом уровне иерархии можно было бы применить свой набор имен 
            для идентификации конкретного объекта на этом уровне. В качестве 
            другого примера, одно имя могло бы идентифицировать всю молекулу 
            среди других молекул, а другое – атомы внутри молекулы.</P>
            <P class=text>Пример 13-4 рисует автомобиль с четырьмя колесами, 
            параллельно манипулируя стеком имен согласно объектной иерархии.</P>
            <P class=text>Пример 13-4. Создание множественных имен</P>
            <TABLE class=code id=table13 width="90%" align=center>
              <TBODY>
              <TR>
                <TD><PRE>нарисовать_колесо_и_болты()
{
      long i;

      нарисовать_колесо();
      for(i=0;i&lt;5;i++)
      {
            glPushMatrix();
                  glRotate(72.0*i,0.0,0.0,1.0);
                  glTranslate(3.0,0.0,0.0);
                  glPushName(i);
                        нарисовать_болт();
                  glPopName();
            glPopMatrix();
      }
}

нарисовать_корпус_колеса_и_болты()
{
      нарисовать_корпус();
      glPushMatrix();
            glTranslate(40,0,20);   /* позиция первого колеса */
            glPushName(1);          /* имя колеса №1 */
                  нарисовать_колесо_и_болты();
            glPopName();
      glPopMatrix();
      glPushMatrix();
            glTranslate(40,0,-20);  /* позиция второго колеса */
            glPushName(1);          /* имя колеса №2 */
                  нарисовать_колесо_и_болты();
            glPopName();
      glPopMatrix();

      /* нарисовать два последних колеса */
}</PRE></TD></TR></TBODY></TABLE>
            <P class=text>Пример 13-5 использует функции примера 13-4 для 
            рисования трех разных автомобилей, пронумерованных 1, 2 и 3.</P>
            <P class=text>Пример 13-5. Использование множественных имен</P>
            <TABLE class=code id=table14 width="90%" align=center>
              <TBODY>
              <TR>
                <TD><PRE>нарисовать_три_автомобиля()
{
      glInitNames();
      glPushMatrix();
            выполнить_перенос_к_позиции_первой_машины();
            glPushName(1);
                  нарисовать_корпус_колеса_и_болты();
            glPopName();
      glPopMatrix();

      glPushMatrix();
            выполнить_перенос_к_позиции_второй_машины();
            glPushName(2);
                  нарисовать_корпус_колеса_и_болты();
            glPopName();
      glPopMatrix();

      glPushMatrix();
            выполнить_перенос_к_позиции_третьей_машины();
            glPushName(3);
                  нарисовать_корпус_колеса_и_болты();
            glPopName();
      glPopMatrix();
}</PRE></TD></TR></TBODY></TABLE>
            <P class=text>Если предположить, что производится указание, далее 
            приводятся несколько примеров величин, которые могут быть 
            возвращены, а также их интерпретация. В этих примерах возвращается 
            максимум одна запись о попадании; <I>d1</I> и <I>d2</I> представляют 
            значения глубины.</P>
            <P class=text>2&nbsp;&nbsp; <I>d1</I>&nbsp;&nbsp; 
            <I>d2</I>&nbsp;&nbsp; 2&nbsp;&nbsp; 
            1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            Машина 1, колесо 1</P>
            <P class=text>1&nbsp;&nbsp; <I>d1</I>&nbsp;&nbsp; 
            <I>d2</I>&nbsp;&nbsp; 
            3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Корпус 
            машины 3</P>
            <P class=text>3&nbsp;&nbsp; <I>d1</I>&nbsp;&nbsp; 
            <I>d2</I>&nbsp;&nbsp; 1&nbsp;&nbsp; 1&nbsp;&nbsp; 
            0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Болт 0 
            на колесе 1 машины 1</P>
            <P 
            class=text>пусто&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            Указание не коснулось ни одной из машин</P>
            <P class=text>В этих интерпретациях предполагается, что болт и 
            колесо не оккупируют один и тот же регион указания. Пользователь же 
            может легко выбрать и колесо и болт одновременно, в результате чего 
            вы получите 2 попадания. Если вы получили несколько записей о 
            попаданиях, вы должны решить, какую из них обрабатывать, базируясь, 
            возможно, на величинах глубины, чтобы определить какое из попаданий 
            находится ближе к точке наблюдения. Использование величин глубины 
            исследуется в следующем разделе.</P>
            <H2>13.1.5.2 Указание и величина глубины</H2>
            <P class=text>Пример 13-6 демонстрирует, как при указании 
            использовать величины глубины для определения указанного объекта. В 
            режиме визуализации эта программа рисует три перекрывающихся 
            прямоугольника. При нажатии левой кнопки мыши, вызывается функция 
            <B>pickRects()</B>. Эта функция получает позицию курсора, переходит 
            в режим выбора, инициализирует стек имен и умножает матрицу указания 
            на текущую матрицу ортографического проецирования. Попадание 
            возникает для каждого треугольника, который находится под курсором 
            мыши в момент нажатия левой кнопки. В конце, изучается содержимое 
            буфера выбора для определения тех именованных объектов, которые 
            находились внутри региона выбора вблизи курсора. Изображение, 
            генерируемое программой, показано на рисунке 13-3.</P>
            <P class=text>Рисунок 13-3. Указание и величина глубины
            <P align=center><IMG height=400 
            src="ProgZ_ru - Портал для программистов.files/13-3.jpg" width=400 
            border=0></P>
            <P class=text>В этой программе прямоугольники рисуются на разной 
            глубине, то есть с разными величинами z. Поскольку для идентификации 
            всех прямоугольников используется одно имя, может быть записано 
            только одно попадание. Однако, в зависимости от того, сколько 
            треугольников было указано и какие именно, это попадание имеет 
            разные значения минимальной и максимальной координаты z.</P>
            <P class=text>Пример 13-6. Указание и величина глубины: файл 
            pickdepth.cpp</P>
            <TABLE class=code id=table15 width="90%" align=center>
              <TBODY>
              <TR>
                <TD><PRE>#include <WINDOWS.H>
#include <GLUT.H>
#include <STDIO.H>

void init()
{
      glClearColor(0.0,0.0,0.0,0.0);
      glEnable(GL_DEPTH_TEST);
      glShadeModel(GL_FLAT);
      glDepthRange(0.0,1.0);             /* отображение z по умолчанию */
}

void drawRects(GLenum mode)
{
      if (mode==GL_SELECT)
            glLoadName(1);
      glBegin(GL_QUADS);
            glColor3f(1.0,1.0,0.0);
            glVertex3i(2,0,0);
            glVertex3i(2,6,0);
            glVertex3i(6,6,0);
            glVertex3i(6,0,0);
      glEnd();
      if (mode==GL_SELECT)
            glLoadName(2);
      glBegin(GL_QUADS);
            glColor3f(0.0,1.0,1.0);
            glVertex3i(3,2,-1);
            glVertex3i(3,8,-1);
            glVertex3i(8,8,-1);
            glVertex3i(8,2,-1);
      glEnd();
      if (mode==GL_SELECT)
            glLoadName(3);
      glBegin(GL_QUADS);
            glColor3f(1.0,0.0,1.0);
            glVertex3i(0,2,-2);
            glVertex3i(0,7,-2);
            glVertex3i(5,7,-2);
            glVertex3i(5,2,-2);
      glEnd();
}

void processHits(GLint hits,GLuint buffer[])
{
      int i,j;
      GLuint names, *ptr;

      printf("hits=%d\n",hits);
      ptr=(GLuint*)buffer;
      for (i=0;i<HITS;I++) pre }< 0; return glutMainLoop(); glutDisplayFunc(display); init(); glutInitWindowPosition(100,100); glutInit(&argc,argv); { argv[]) char* argc, main(int int } glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT); display() void processHits(hits,selectBuf); hits="glRenderMode(GL_RENDER);" glFlush(); glPopMatrix(); are is glLoadIdentity(); glMatrixMode(GL_MODELVIEW); glMatrixMode(GL_PROJECTION); glPushMatrix(); glPushName(0); glInitNames(); glRenderMode(GL_SELECT); glSelectBuffer(BUFSIZE,selectBuf); hits; GLint selectBuf[BUFSIZE]; GLuint 512 BUFSIZE #define printf(?\n?); ptr++; ?,*ptr); printf(?%d for(j="0;j<names;j++)" ?); names="*ptr;" the printf(? 0x7fffffff); %g;\n?,(float)*ptr z2 %g;?,(float)*ptr z1 hit='%d\n",names);' for of number glutReshapeFunc(reshape); glutMouseFunc(pickSquares); glutCreateWindow(?Picking glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB); glViewport(0,0,w,h); h) w, reshape(int gluPickMatrix((GLdouble)x,(GLdouble)(viewport[3]-y),5.0,5.0,viewport); location cursor near region picking pixel 5x5 Create glGetIntegerv(GL_VIEWPORT,viewport); return; state!="GLUT_DOWN)" || if(button!="GLUT_LEFT_BUTTON" viewport[4]; y) x,int state,int button,int pickSquares(int this Values?); Depth with glutInitWindowSize(400,400); glOrtho(0.0,8.0,0.0,8.0,-0.5,2.5); drawRects(GL_RENDER); drawRects(GL_SELECT);>
	</PRE></TD></TR></TBODY></TABLE>
            <H2>13.1.6 Советы по написанию программ с использованием механизма 
            выбора</H2>
            <P class=text>Большинство программ, позволяющих пользователю 
            интерактивно редактировать геометрические объекты, предоставляют 
            механизм, позволяющий пользователю указать элемент или группу 
            элементов для редактирования. Для программ двумерного рисования 
            (вроде текстовых редакторов или программ форматирования страниц) 
            может быть проще создать свой собственный механизм для обнаружения 
            указанных объектов, чем использовать механизм выбора OpenGL. Часто, 
            проще найти ограничивающие прямоугольники двумерных объектов и 
            организовать их в подобие иерархии для ускорения поиска. Например, 
            указание в стиле OpenGL может работать довольно медленно в 
            программе, содержащей миллионы прямоугольников. Однако, если 
            выравнивать прямоугольники на экране каким-либо образом и 
            использовать только информацию об их границах, указание должно 
            работать достаточно быстро. Кроме того, код для такого механизма 
            проще писать и понимать.</P>
            <P class=text>Рассмотрим другой пример. Поскольку попадания 
            происходят только для геометрических объектов, вам, возможно, 
            понадобится собственная функция для указания символов текста. 
            Установление текущей позиции растра является геометрической 
            операцией, но создает только одну точку, которую можно выбрать. Эта 
            точка находится, как правило, в нижнем левом углу текста. Если 
            вашему редактору требуется возможность манипуляции с индивидуальными 
            символами внутри текстовой строки, нужно использовать какой-либо 
            другой механизм указания. Конечно, вы можете нарисовать небольшой 
            прямоугольник вокруг каждого символа в режиме выбора, но, скорее 
            всего, будет проще обрабатывать текст каким-либо специальным 
            образом.</P>
            <P class=text>Если вы решите использовать механизм указания OpenGL, 
            организуйте программу и ее данные таким образом, чтобы рисовать 
            списки объектов в режимах визуализации и выбора было достаточно 
            просто. При таком подходе, когда пользователь выберет что-либо на 
            экране, вы сможете использовать в режиме выбора тот же код, который 
            использовался для фактического рисования сцены. Кроме того, заранее 
            определитесь с тем, позволять ли пользователю выбирать несколько 
            объектов одновременно. Одним из способов сделать это является 
            хранение для каждого объекта бита информации, показывающего выбран 
            объект или нет (однако при таком методе вам нужно пройти через весь 
            массив битов для выявления выбранных объектов). Вы хранить список 
            указателей на объекты для ускорения этого поиска. Хранение бита 
            выбора может быть полезно и в случае, если вы хотите отображать 
            выбранные объекты как-либо иначе (другим цветом или внутри 
            параллепипеда выбора). Наконец, определитесь с пользовательским 
            интерфейсом для выбора. Вы можете позволить пользователю:</P>
            <UL>
              <LI>
              <P class=text>выбирать элемент</P>
              <LI>
              <P class=text>выбирать группу элементов с помощью резинового 
              контура</P>
              <LI>
              <P class=text>добавлять элемент к группе выбранных</P>
              <LI>
              <P class=text>&nbsp;добавлять группу элементов к выбранным</P>
              <LI>
              <P class=text>удалить элемент из выбранных</P>
              <LI>
              <P class=text>выбирать один элемент из группы перекрывающихся 
              элементов</P></LI></UL>
            <P class=text>Типичное решение для двумерной программы может 
            заключаться в следующем:</P>
            <OL>
              <LI>Весь выбор осуществляется с помощью курсора мыши и ее левой 
              кнопки. В дальнейшем описании «курсор» всегда означает курсор 
              мыши, а «кнопка» – левую кнопку мыши. 
              <LI>Кликанье на элементе выбирает его и отменяет выбор всех 
              остальных выбранных в данный момент элементов. Если курсор 
              находится поверх нескольких элементов, выбирает наименьший из них. 
              (В трех измерения существует множество других стратегий для 
              устранения неоднозначности выбора.) 
              <LI>Кликанье в точке экрана, где нет объектов, перемещение мыши с 
              нажатой кнопкой и отпускание кнопки приводит к выбору всех 
              объектов, находящихся внутри экранного прямоугольника, чьими 
              углами являются точка, где кнопка была нажата, и точка, где кнопка 
              была отпущена. Это называется выбором с помощью <I>резинового 
              контура</I>. При этом отменяется выбор всех элементов находящихся 
              вне прямоугольника резинового контура. (Вы должны решить, должен 
              ли элемент быть выбран, только если он целиком попадает в 
              прямоугольник или если любая его часть попадает в прямоугольник 
              контура. Обычно первый вариант работает наилучшим образом.) 
              <LI>Если пользователь кликнул в объект, который не выбран, и 
              одновременно держал нажатой кнопку Shift, объект добавляется к 
              списку выбранных. Если указанный объект был выбранным, его следует 
              удалить из списка выбранных. 
              <LI>Если резиновый контур растягивается при нажатой кнопке Shift, 
              объекты внутри контура добавляются к выбранным. 
              <LI>Часто бывает трудно использовать резиновый конур в сильно 
              загроможденных областях экрана. Когда нажимается кнопка (то есть 
              происходит кликанье) курсор может находиться над каким-либо 
              элементом, и в принципе, должен быть выбран этот элемент. Однако 
              типичный интерфейс пользователя интерпретирует нажатие кнопки и 
              перемещение мыши как растягивание резинового контура. Чтобы 
              разрешить эту проблему, вы можете реализовать возможность 
              принудительного запуска резинового контура с помощью удержания 
              какой-либо кнопки (например, Alt). При таком подходе, для 
              растягивания контура нужно выполнить следующие операции: нажать 
              кнопку Alt, растянуть контур, отпустить кнопку Alt. В течение 
              удержания Alt следует игнорировать элемент, на котором 
              непосредственно произошел щелчок. 
              <LI>Если кнопка Shift нажата в течение выделения элементов 
              резиновым контуром, эти элементы должны быть добавлены к уже 
              выбранным. 
              <LI>и, наконец, если пользователь кликает на нескольких объектах, 
              выделяйте только один из них. Если курсор не двигался (или 
              сдвигался не более, чем на один пиксель), и пользователь кликает 
              снова, в том же месте, отмените выбор первоначально выбранного 
              элемента и выберите другой, из находящихся под курсором. 
              Используйте повторные клики в одной точке для циклического 
              перехода по всем возможностям. </LI></OL>
            <P class=text>В определенных ситуациях могут применяться разные 
            правила. В текстовом редакторе вам, вероятно, не придется 
            волноваться о том, что символы находятся один поверх другого, а 
            выбор нескольких символов предусматривает только соседние символы в 
            документе. Таким образом, вам нужно определить только первый и 
            последний символы для идентификации всей выборки. Кроме того, в 
            случае текста иногда легче идентифицировать промежутки между 
            символами, а не сами символы. Такой подход позволяет вам реализовать 
            пустую выборку, когда ее начало и конец находятся в одном и том же 
            месте; он также позволяет вам поместить курсор перед первым символом 
            текста и после последнего символа без дополнительного 
            кодирования.</P>
            <P class=text>В трехмерном редакторе вы можете предоставить 
            возможность поворачивать и перемещать выборки, так что нет смысла 
            циклически проходить через их возможные варианты. С другой стороны 
            выбор в трехмерном пространстве довольно сложен, поскольку 
            координаты курсора на экране не предоставляют информации о 
            глубине.</P>
            <H2>13.2 Отклик</H2>
            <P class=text>Откат похож на выбор в том, что, когда вы находитесь в 
            обоих режимах, реальный вывод пикселей не осуществляется, и 
            изображение на экране остается неизменным. Рисования не происходит, 
            вместо этого информация о примитивах, которые должны быть 
            нарисованы, возвращается приложению. Ключевое отличие между режимами 
            выбора и отката заключается в типе информации, которая отсылается 
            приложению. В режиме выбора возвращают ассоциированные имена в виде 
            массива целочисленных величин. В режиме отката информация о 
            преобразованных примитивах возвращается в виде массива чисел с 
            плавающей точкой. Величины, отсылаемые приложению в массиве отката, 
            состоят из элемента, идентифицирующего тип обработанного и 
            преобразованного примитива (точка, линия, полигон, изображение или 
            битовая карта), за которым следуют вершины, цвета и другая 
            информация об этом примитиве. Величины возвращаются после того, как 
            они были преобразованы освещением и видовыми операциями. Режим 
            отклика инициализируется вызовом команды <B>glRenderMode()</B> с 
            аргументом GL_FEEDBACK.
            <P class=text>Далее приводится процедура входа и выхода из режима 
            отклика.</P>
            <OL>
              <LI>
              <P class=text>Вызовите <B>glFeedbackBuffer()</B>, чтобы задать 
              массив, в котором будут сохраняться данные отклика. Аргументы этой 
              команды задают тип и количество информации, которые будут 
              сохраняться в массиве. </P>
              <LI>
              <P class=text>Вызовите <B>glRenderMode()</B>, чтобы войти в режим 
              отклика. (На данный момент вы можете игнорировать значение, 
              возвращенное <B>glRenderMode()</B>.) После этого шага примитивы не 
              будут растеризоваться в пиксели, и содержимое буфера кадра не 
              изменяется до тех пор, пока вы не выйдите из режима отклика. </P>
              <LI>
              <P class=text>Нарисуйте ваши примитивы. Между вызовами команд 
              рисования вы можете один или несколько раз вызвать команду 
              <B>glPassThrough()</B> для добавления маркеров к данным отклика, 
              чтобы упростить дальнейший разбор. </P>
              <LI>
              <P class=text>Выйдите из режима отклика, вызвав 
              <B>glRenderMode()</B> с аргументом GL_RENDER, если вы хотите 
              вернуться к режиму визуализации. Целочисленная величина, 
              возвращенная <B>glRenderMode()</B>, соответствует числу записей, 
              занесенных в буфер отклика. </P>
              <LI>
              <P class=text>Обработайте данные в массиве отклика. </P></LI></OL>
            <TABLE class=code id=table16 width="90%" align=center>
              <TBODY>
              <TR>
                <TD>void <B>glFeedbackBuffer</B> (GLsizei <I>size</I>, GLenum 
                  <I>type</I>, GLfloat* <I>buffer</I>);</TD></TR></TBODY></TABLE>
            <P class=text>Устанавливает буфер для данных отклика: <I>buffer 
            </I>должен быть указателем на массив, где будут сохраняться данные. 
            Аргумент <I>size </I>индицирует максимальное число величин, которые 
            могут быть сохранены в массиве. Аргумент <I>type </I>задает тип 
            информации, которая будет сохраняться в массиве для каждой вершины; 
            его возможные значения и их смысл показаны в таблице 13-1. 
            <B>glFeedbackBuffer()</B> должна быть вызвана до входа в режим 
            отклика. В таблице 13-1 <I>k </I>равно 1 в индексном режиме и 4 – в 
            режиме RGBA.</P>
            <P class=text>Таблица 13-1. Значения аргумента type команды 
            glFeedbackBuffer()</P>
            <TABLE class=normal align=center>
              <TBODY>
              <TR>
                <TD><B>Аргумент <I>type</I> </B></TD>
                <TD><B>Координаты</B></TD>
                <TD><B>Цвет</B></TD>
                <TD><B>Текстура</B></TD>
                <TD><B>Всего величин</B></TD></TR>
              <TR>
                <TD>GL_2D</TD>
                <TD><I>x</I>, <I>y</I></TD>
                <TD>-</TD>
                <TD>-</TD>
                <TD>2</TD></TR>
              <TR>
                <TD>GL_3D</TD>
                <TD><I>x</I>, <I>y</I>, <I>z</I></TD>
                <TD>-</TD>
                <TD>-</TD>
                <TD>3</TD></TR>
              <TR>
                <TD>GL_3D_COLOR</TD>
                <TD><I>x</I>, <I>y</I>, <I>z</I> </TD>
                <TD><I>k</I></TD>
                <TD>-</TD>
                <TD>3+<I>k</I> </TD></TR>
              <TR>
                <TD>GL_3D_COLOR_TEXTURE </TD>
                <TD><I>x</I>, <I>y</I>, <I>z</I> </TD>
                <TD><I>k</I></TD>
                <TD>4</TD>
                <TD>7+<I>k</I> </TD></TR>
              <TR>
                <TD>GL_4D_COLOR_TEXTURE </TD>
                <TD><I>x</I>, <I>y</I>, <I>z</I>, <I>w</I> </TD>
                <TD><I>k</I></TD>
                <TD>4</TD>
                <TD>8+<I>k</I> </TD></TR></TBODY></TABLE>
            <P class=warning>Замечание: Если поддерживается 
            мультитекстурирование, режим отклика возвращает координаты текстуры 
            только для текстурного блока 0.</P>
            <H2>13.2.1 Массив отклика</H2>
            <P class=text>В режиме отклика каждый примитив, который должен быть 
            растеризован (а также каждое обращение к командам <B>glBitmap()</B>, 
            <B>glDrawPixels()</B> и <B>glCopyPixels()</B> в том случае если 
            текущая позиция растра допустима) генерирует блок величин, которые 
            копируются в буфер отклика. Количество величин определяется 
            аргументом <I>type</I>команды <B>glFeedbackBuffer()</B>. Используйте 
            значение этого аргумента, соответствующее тому, что вы рисуете: 
            GL_2D или GL_3D для освещенных двумерных или трехмерных примитивов, 
            GL_3D_COLOR для освещенных трехмерных примитивов, 
            GL_3D_COLOR_TEXTURE или GL_4D_COLOR_TEXTURE для освещенных, 
            тектурированных трехмерных или четырехмерных примитивов.</P>
            <P class=text>Каждый блок величин отклика начинается с кода, 
            позволяющего идентифицировать тип примитива. За этим кодом следуют 
            величины, описывающие вершины примитива и ассоциированные с ними 
            данные. Могут также присутствовать записи о прямоугольниках 
            пикселей. Кроме того, в массиве могут возвращаться сквозные маркеры, 
            созданные вами (эти маркеры описаны в следующем разделе). В таблице 
            13-2 приводится синтаксис массива отклика. Помните, что данные, 
            ассоциированные с каждой возвращаемой вершиной, описаны в таблице 
            13-1. Заметьте, что для полигона может быть возвращено 
            <I>n</I>вершин. Координаты <I>x</I>, <I>y</I>и <I>z</I>, 
            возвращаемые в массиве, являются оконными. Если же возвращается еще 
            и <I>w</I>, то координаты являются усеченными. Для битовых карт и 
            изображений возвращаемые координаты являются текущей позицией растра 
            на момент вывода соответствующего примитива. Обратите внимание, что 
            GL_LINE_RESET_TOKEN возвращается только, когда ломаная 
            прерывается.</P>
            <P class=text>Таблица 13-2. Синтаксис массива отклика</P>
            <TABLE class=normal align=center>
              <TBODY>
              <TR>
                <TD><B>Тип примитива</B></TD>
                <TD><B>Код</B></TD>
                <TD><B>Ассоциированные данные</B></TD></TR>
              <TR>
                <TD>Точка</TD>
                <TD>GL_POINT_TOKEN</TD>
                <TD>вершина</TD></TR>
              <TR>
                <TD>Линия</TD>
                <TD>GL_LINE_TOKEN или GL_LINE_RESET_TOKEN</TD>
                <TD>вершина вершина</TD></TR>
              <TR>
                <TD>Полигон</TD>
                <TD>GL_POLYGON_TOKEN</TD>
                <TD>n вершинавершина ... вершина</TD></TR>
              <TR>
                <TD>Битоваякарта </TD>
                <TD>GL_BITMAP_TOKEN</TD>
                <TD>вершина </TD></TR>
              <TR>
                <TD>Пиксельныйпрямоугольник </TD>
                <TD>GL_DRAW_PIXEL_TOKEN или GL_COPY_PIXEL_TOKEN</TD>
                <TD>вершина</TD></TR>
              <TR>
                <TD>Сквозной маркер</TD>
                <TD>GL_PASS_THROUGH_TOKEN</TD>
                <TD>число с плавающей точкой</TD></TR></TBODY></TABLE>
            <H2>13.2.2 Использование маркеров в режиме отклика</H2>
            <P class=text>Отклик происходит после преобразований, расчета 
            освещенности, удаления обратных граней и интерпретации полигонов в 
            зависимости от команды <B>glPolygonMode()</B>. Также он происходит 
            после того, как полигоны, имеющие более трех ребер, разбиваются на 
            треугольники (если ваша реализация OpenGL визуализирует полигоны, 
            производя такую декомпозицию). Таким образом, вам может быть сложно 
            опознать те примитивы, что вы рисуете, в тех данных, которые были 
            возвращены. Чтобы упростить процесс разбора данных отклика, в своем 
            коде вставляйте маркеры с помощью команды <B>glPassThrough()</B>. Вы 
            можете использовать маркеры для разделения величин отклика, 
            относящихся к разным примитивам. Эта команда приводит к тому, что в 
            массив отклика записывается код GL_PASS_THROUGH_TOKEN, за которым 
            следует число с плавающей точкой, которое вы передали в качестве 
            аргумента команды.</P>
            <TABLE class=code id=table17 width="90%" align=center>
              <TBODY>
              <TR>
                <TD>void <B>glPassThrough</B> (GLfloat 
              <I>token</I>);</TD></TR></TBODY></TABLE>
            <P class=text>Если вызывается в режиме отклика, вставляет маркер в 
            поток величин, записываемых в массив отклика. Маркер состоит из кода 
            GL_PASS_THROUGH_TOKEN, за которым следует величина с плавающей 
            точкой <I>token</I>. Если команда вызывается не в режиме отклика, 
            она ничего не делает. Вызов команды <B>glPassThrough()</B> между 
            командами <B>glBegin()</B> и <B>glEnd()</B> генерирует ошибку 
            GL_INVALID_OPERATION.</P>
            <H2>13.2.3 Пример использования отклика</H2>
            <P class=text>Пример 13-7 демонстрирует использование режима 
            отклика. Эта программа рисует освещенную трехмерную сцену в 
            нормальном режиме визуализации. Затем она входит в режим отклика и 
            перерисовывает сцену. Поскольку программа рисует освещенную 
            нетекстурированную трехмерную сцену, типом данных отклика является 
            GL_3D_COLOR, а поскольку она работает в режиме RGBA, каждая 
            неотсеченная вершина генерирует 7 величин в массиве отклика: 
            <I>x</I>, <I>y</I>, <I>z</I>, <I>r</I>, <I>g</I>, <I>b </I>и 
            <I>a</I>.</P>
            <P class=text>В режиме отклика программа рисует две линии как часть 
            ломаной, а затем вставляет сквозной маркер. Далее рисуется точка с 
            координатами <I>(-100.0</I>, <I>-100.0</I>, <I>-100.0</I>), 
            выпадающая из ортографического объема видимости и, таким образом, не 
            генерирующая записей в массиве отклика. Наконец, вставляется еще 
            один маркер и рисуется еще одна точка. Изображение, генерируемое 
            программой, изображено на рисунке 13-4.</P>
            <P class=text>Рисунок 13-4. Пример использования режима отклика
            <P align=center><IMG height=166 
            src="ProgZ_ru - Портал для программистов.files/13-4.jpg" width=179 
            border=0></P>
            <P class=text>Пример 13-7. Режим отклика: файл feedback.cpp</P>
            <TABLE class=code id=table18 width="90%" align=center>
              <TBODY>
              <TR>
                <TD><PRE>#include <WINDOWS.H>

#include <GLUT.H>
#include <STDIO.H>

void init()
{
      glEnable(GL_LIGHTING);
      glEnable(GL_LIGHT0);
}

void drawGeometry(GLenum mode)
{
      glBegin(GL_LINE_STRIP);
            glNormal3f(0.0,0.0,1.0);
            glVertex3f(30.0,30.0,0.0);
            glVertex3f(50.0,60.0,0.0);
            glVertex3f(70.0,40.0,0.0);
      glEnd();

      if(mode==GL_FEEDBACK)
            glPassThrough(1.0);

      glBegin(GL_POINTS);
            glVertex3f(-100.0,-100.0,-100.0); //Будетотсечена 
      glEnd();

      if(mode==GL_FEEDBACK)
            glPassThrough(2.0);

      glBegin(GL_POINTS);
            glNormal3f(0.0,0.0,1.0);
            glVertex3f(50.0,50.0,0.0);
      glEnd();
      glFlush();
}

void print3DcolorVertex(GLint size,GLint *count,GLfloat *buffer)
{
      int i;

      printf("   ");
      for(i=0;i&lt;7;i++)
      {
            printf("%4.2f ",buffer[size-(*count)]);
            *count=*count-1;
      }
      printf("\n");
}

void printBuffer(GLint size,GLfloat *buffer)
{
      GLint count;
      GLfloat token;

      count=size;
      while(count)
      {
            token=buffer[size-count];
            count--;
            if(token==GL_PASS_THROUGH_TOKEN)
            {
                  printf("GL_PASS_THROUGH_TOKEN\n");
                  printf("   %4.2f\n",buffer[size-count]);
                  count--;
            }
            else
                  if(token==GL_POINT_TOKEN)
                  {
                        printf("GL_POINT_TOKEN\n");
                        print3DcolorVertex(size,&amp;count,buffer);
                  }
                  else
                        if(token==GL_LINE_TOKEN)
                        {
                             printf("GL_LINE_TOKEN\n");
                             print3DcolorVertex(size,&amp;count,buffer);
                             print3DcolorVertex(size,&amp;count,buffer);
                        }
                        else
                             if(token==GL_LINE_RESET_TOKEN)
                             {
                                   printf("GL_LINE_RESET_TOKEN\n");
                                   print3DcolorVertex(size,&amp;count,buffer);
                                   print3DcolorVertex(size,&amp;count,buffer);
                             }
      }
}

void display()
{
      GLfloat feedBuffer[1024];
      GLint size;

      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();
      glOrtho(0.0,100.0,0.0,100.0,0.0,1.0);

      glClearColor(0.0,0.0,0.0,0.0);
      glClear(GL_COLOR_BUFFER_BIT);
      drawGeometry(GL_RENDER);

      glFeedbackBuffer(1024,GL_3D_COLOR,feedBuffer);
      glRenderMode(GL_FEEDBACK);

      drawGeometry(GL_FEEDBACK);

      size=glRenderMode(GL_RENDER);
      printBuffer(size,feedBuffer);
}

int main(int argc, char* argv[])
{
      glutInit(&amp;argc,argv);
      glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
      glutInitWindowSize(100,100);
      glutInitWindowPosition(100,100);
      glutCreateWindow("Feedback Mode");
      init();
      glutDisplayFunc(display);
      glutMainLoop();
      return 0;   
}</PRE></TD></TR></TBODY></TABLE>
            <P class=text>Запуск программы генерирует следующий вывод:</P>
            <TABLE class=code id=table19 width="90%" align=center>
              <TBODY>
              <TR>
                <TD><PRE>GL_LINE_RESET_TOKEN
30.00 30.00 0.00 0.84 0.84 0.84 1.0
50.00 60.00 0.00 0.84 0.84 0.84 1.0
GL_LINE_RESET_TOKEN
50.00 60.00 0.00 0.84 0.84 0.84 1.0
70.00 40.00 0.00 0.84 0.84 0.84 1.0
GL_PASS_THROUGH_TOKEN
1.00
GL_PASS_THROUGH_TOKEN
2.00
GL_POINT_TOKEN
50.00 50.00 0.00 0.84 0.84 0.84 1.0</PRE></TD></TR></TBODY></TABLE>
            <P class=text>Таким образом, ломаная, рисуемая следующими командами, 
            отображается в два примитива:</P>
            <TABLE class=code id=table20 width="90%" align=center>
              <TBODY>
              <TR>
                <TD><PRE>glBegin(GL_LINE_STRIP);
      glNormal3f(0.0,0.0,1.0);
      glVertex3f(30.0,30.0,0.0);
      glVertex3f(50.0,60.0,0.0);
      glVertex3f(70.0,40.0,0.0);
glEnd();</PRE></TD></TR></TBODY></TABLE>
            <P class=text>Первый примитив начинается с кода GL_LINE_RESET_TOKEN. 
            Это означает, что первым примитивом является сегмент линии, и что 
            шаблон для линий сброшен. Второй примитив начинается с 
            GL_LINE_TOKEN, то есть это тоже сегмент линии, но ломаная не 
            прерывается и, следовательно, продолжается из той точки, где 
            закончился предыдущий сегмент. Каждая из двух вершин этих линий 
            генерирует по 7 величин в массиве отклика. Заметьте, что RGBA 
            величины для всех четырех точек этих двух линий равны (<I>0.84</I>, 
            <I>0.84</I>, <I>0.84</I>, <I>1.0</I>), что является очень светлым 
            оттенком серого цвета с максимальным значением альфа. Эти цветовые 
            величины – результат взаимодействия вектора нормали и параметров 
            освещения.</P>
            <P class=text>Поскольку между первым и вторым сквозными маркерами не 
            было сгенерировано данных отклика, вы можете сделать вывод о том, 
            что примитивы, нарисованные между первыми двумя вызовами 
            <B>glPassThrough()</B> были отсечены по объему видимости. Наконец, 
            рисуется точка с координатами (<I>50.0</I>, <I>50.0</I>, 
            <I>0.0</I>), и ассоциированные с ней данные заносятся в буфер 
            отклика.</P>
            <P class=warning>Замечание: И в режиме отклика, и в режиме выбора 
            информация возвращается до выполнения всех тестов над фрагментами. 
            Таким образом, данные об объектах, которые не были бы нарисованы 
            из-за неудачи во время теста отреза, альфа, глубины или трафарета, 
            тем не менее, обрабатываются и возвращаются в обоих режимах (выбора 
            и отклика).</P>
            <H2>13.3 Ссылки на примеры главы</H2>
            <P class=text>Приложение <B>select</B>: пример реализации 
            выбора.<BR><A 
            href="http://www.progz.ru/download/opengl/chapter13/select.zip">Скачать</A></P>
            <P class=text>Приложение <B>picksquare</B>: пример реализации 
            указания объектов мышью.<BR><A 
            href="http://www.progz.ru/download/opengl/chapter13/picksquare.zip">Скачать</A></P>
            <P class=text>Приложение <B>pickdepth</B>: пример указания в 
            трехмерном пространстве, использование значений глубины.<BR><A 
            href="http://www.progz.ru/download/opengl/chapter13/pickdepth.zip">Скачать</A></P>
            <P class=text>Приложение <B>feedback</B>: пример использования 
            режима отклика.<BR><A 
            href="http://www.progz.ru/download/opengl/chapter13/feedback.zip">Скачать</A> 
            &nbsp;<BR>&nbsp;<BR></P></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<TABLE width="100%" align=center>
  <TBODY>
  <TR>
    <TD class=caption align=middle>All Right Reserved © 2003 <A class=menu 
      href="mailto:info@progz.ru">ProgZ.ru</A> | Programming &amp; Design © 2003 
      <A class=menu href="mailto:ex@progz.ru">Ex</A></TD>
  <TR></TR></TBODY></TABLE></BODY></HTML>
