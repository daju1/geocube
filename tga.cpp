//Теперь, посмотрим cpp файл и основную часть кода. 
//Для того чтобы обучение было короче и более читаемо, 
//я опустил часть кода используемого при обработке ошибок. 
//Это вы можете увидеть в файле с исходным кодом, прилагаемым к статье. 

//Теперь мы должны подключит только что сделанный файл.

#include "stdafx.h"        // Подключаем сделанный файл
#include "tga.h"        // Подключаем сделанный файл
 

//Далее мы займемся функцией называемой LoadTGA(...).
// Загрузить файл TGA!
bool LoadTGA(Texture * texture, char * filename)
{
	//Функция принимает 2 параметра. Первый, указатель на структуру с текстурой, 
	//которую вы должны объявить где-то в вашем коде (смотрите пример). 
	//Второй параметр указывает место нахождения файла.

	//Первые две строки кода объявляют указатель на файл, 
	//а затем этот файл открывается, используя имя файла 
	//указанного как второй параметр функции.
	
	FILE * fTGA; // Объявляем указатель на файл
	fTGA = fopen(filename, "rb"); // Открываем файл на чтение
	if(fTGA == NULL)        // Если была ошибка
	{
		printf("...Error code...fTGA == NULL \n");
		return false;         // Возвращаем False
	}
	//Далее мы пытаемся прочитать первые двенадцать байт файла в нашу структуру 
	//TGAHeader и проверить тип файла. Если чтение неудачно, закрываем файл, 
	//выводим сообщение об ошибке, и функция возвращает false.
	
	// Попытка прочитать заголовок файла
	if(fread(&tgaheader, sizeof(TGAHeader), 1, fTGA) == 0)
	{
		printf("...Здесь код ошибки...чтение неудачно\n");
		return false;        // При ошибки возвращаем false		
	}  
	//Далее мы пытаемся определить какой это тип файла, 
	//сравнивая его с определенными нами заголовками файла TGA. 
	//Это даст нам знать, что этот файл сжатый, несжатый или неправильный. 
	//Для этого мы будем использовать функцию memcmp(…).
	
	// Если заголовок файла соответствует заголовку несжатого файла
	if(memcmp(uTGAcompare, &tgaheader, sizeof(tgaheader)) == 0)
	{
		// Загружаем несжатый TGA
		LoadUncompressedTGA(texture, filename, fTGA);
	}
	// Если заголовок файла соответствует заголовок сжатого файла
	else if(memcmp(cTGAcompare, &tgaheader, sizeof(tgaheader)) == 0)
	{   
		// Загружаем сжатый TGA
		LoadCompressedTGA(texture, filename, fTGA);
	}
	else            // Если не соответствует никакому
	{
		 printf("... Здесь код ошибки... не соответствует никакому\n");		 
		 return false;        // Возвращаем false False
	} 
	return true;
}

//Мы начнем эту часть с загрузки несжатого файла. 
//В основном это функция основана на Уроке 25.

//Сначала, как обычно, мы начинаем с заголовка функции.
// Загружаем несжатый TGA!
bool LoadUncompressedTGA(Texture * texture, char * filename, FILE * fTGA)
{
	//Эта функция получает три параметра. 
	//Первые два параметра такие же, как и в LoadTGA и передаются без изменения. 
	//Третий параметр, указатель на файл TGA, 
	//и поэтому позиция чтения в файле сохранится.
	
	//Далее мы пытаемся прочитать следующие 6 байт, 
	//и записать их в tga.header. Если ничего не выходит, 
	//мы устанавливаем код ошибки и возвращаем false.
	
	// Пытаемся прочитать следующие 6 байт
	if(fread(tga.header, sizeof(tga.header), 1, fTGA) == 0)
	{
		printf("...Здесь код ошибки...\n");
		return false;        // Возвращаем False
	}
	//Теперь у нас есть вся информация для расчета высоты, 
	//ширины и цветности нашего изображения. Мы храним это в текстуре 
	//и в локальной структуре tga.
	
	texture->width  = tga.header[1] * 256 + tga.header[0];  // Вычисляем высоту
	texture->height = tga.header[3] * 256 + tga.header[2];  // Вычисляем ширину
	texture->bpp = tga.header[4]; // Вычисляем количество бит на пиксель
	tga.Width = texture->width;   // Вычисляем высоту в локальной структуре
	tga.Height = texture->height; // Вычисляем ширину в локальной структуре
	tga.Bpp = texture->bpp;       // Вычисляем количество бит на пиксель в локальной структуре
	
	//Теперь мы проверяем, чтобы высота и ширина была хотя бы в один пиксель, 
	//и чтобы bpp было 24 или 32. Если какое-то значение находится вне пределов, 
	//то мы опять выводим сообщение об ошибке, закрываем файл и покидаем функцию.
	
	// Убеждаемся что вся информация корректна
	if((texture->width <= 0) || (texture->height <= 0) || ((texture->bpp != 24) && (texture->bpp !=32)))
	{
		printf("...Здесь код ошибки...Убеждаемся что вся информация корректна\n");
		return false;        // Возвращаем False
	}

	//Здесь мы устанавливаем тип изображения: 24 бита – GL_RGB, 32 бита – GL_RGBA.	
	if(texture->bpp == 24)        // Это изображение 24bpp?
		texture->type  = GL_RGB;    // Если да, устанавливаем GL_RGB
	else                          // если не 24, тогда 32
		texture->type  = GL_RGBA;   // устанавливаем GL_RGBA
	
	//Теперь мы высчитываем количество байт на пиксель 
	//и высчитываем полный размер изображения.	
	tga.bytesPerPixel = (tga.Bpp / 8); // Высчитываем количество байт на пиксель
	
	// Считаем размер памяти необходимый для хранения изображения
	tga.imageSize = (tga.bytesPerPixel * tga.Width * tga.Height);
	
	//Нам нужно некоторое количество памяти для размещения изображения, 
	//мы будем использовать функцию malloc для выделения нужного количества памяти.
	
	//Затем, мы должны проверить, выделился ли нужный объем памяти. 
	//Если возникла ошибка, вызываем обработчик ошибки. 
	
	// Выделяем память
	texture->imageData = (GLubyte *)malloc(tga.imageSize);
	if(texture->imageData == NULL)      // Убеждаемся что она была выделена
	{
		printf("...Здесь код ошибки...Убеждаемся что она была выделена\n");
		return false;        // Если нет, возвращаем False
	}
	
	//Здесь мы попытаемся считать изображение. Если не сможем, 
	//опять переключимся на код ошибки.
	
	// Пытаемся считать все изображение
	if(fread(texture->imageData, 1, tga.imageSize, fTGA) != tga.imageSize)
	{
		printf("...Здесь код ошибки...\n");
		return false;        // Если не получилось, возвращаем False
	}
	
	//TGA хранит цвета в порядке, обратно тому, который нужен OpenGL так, 
	//что мы должны изменить его с BGR на RGB. Для этого мы меняем местами первый 
	//и третий байт в каждом пикселе.
	
	//Стив Томас добавляет: Я получил небольшое ускорение в коде загрузки TGA. 
	//Это касается конвертирования с BGR в RGB, используя всего 3 бинарные операции. 
	//Вместо использования временной переменной вы делаете 3 раза XOR этих двух байт.
	
	//Затем мы закрываем файл и успешно выходим из функции.
	
	// Начинаем цикл
	for(GLuint cswap = 0; cswap < (int)tga.imageSize; cswap += tga.bytesPerPixel)
	{
		// Первый байт XOR третий байт XOR первый байт XOR третий байт
		texture->imageData[cswap] ^= texture->imageData[cswap+2] ^=
			texture->imageData[cswap] ^= texture->imageData[cswap+2];
	}
	fclose(fTGA);          // Закрываем файл
	return true;          // Возвращаем true
}


//Это все относилось к загрузке несжатого TGA файла. 
//Загрузка файла сжатого RLE немного сложнее. Как обычно мы читаем заголовок, 
//чтобы узнать высоту, ширину и bpp, также как и в несжатом варианте, 
//так что я буду использовать предыдущий код, и вы можете к нему, 
//обратится для полного понимания. 
bool LoadCompressedTGA(Texture * texture, char * filename, FILE * fTGA)
{ 
    if(fread(tga.header, sizeof(tga.header), 1, fTGA) == 0)
    {
		printf("...Здесь код ошибки...\n");
    }
	
	texture->width  = tga.header[1] * 256 + tga.header[0];
    texture->height = tga.header[3] * 256 + tga.header[2];
    texture->bpp  = tga.header[4];
    tga.Width  = texture->width;
    tga.Height  = texture->height;
    tga.Bpp  = texture->bpp;
    if((texture->width <= 0) || (texture->height <= 0) ||
		((texture->bpp != 24) && (texture->bpp !=32)))
    {
		printf("...Здесь код ошибки...\n");
    }
	if(texture->bpp == 24)        // Это изображение 24bpp?
		texture->type  = GL_RGB;    // Если да, устанавливаем GL_RGB
	else                          // если не 24, тогда 32		
		texture->type  = GL_RGBA;   // устанавливаем GL_RGBA
    
	tga.bytesPerPixel  = (tga.Bpp / 8);
    tga.imageSize    = (tga.bytesPerPixel * tga.Width * tga.Height);
	
	//Теперь мы должны выделить память для хранения изображения 
	//ПОСЛЕ декомпрессии и будем использовать malloc. 
	//Если невозможно выделить память, выполняем код ошибки, и возвращаем false. 
	
	// Выделяем память для хранения изображения
	texture->imageData  = (GLubyte *)malloc(tga.imageSize);
	if(texture->imageData == NULL)      // Если невозможно выделить память..
	{
		printf("...Здесь код ошибки...\n");
		return false;        // Возвращаем False
	}
	
	//Далее нам нужно определить из какого количества пикселей состоит изображение. 
	//Мы будем хранить это значение в переменной "pixelcount".
	
	//Также мы должны определить, на каком пикселе находимся, 
	//и в какой байт imageData сейчас выводим, чтобы предотвратить переполнение 
	//и перезапись предыдущих данных.
	
	//Мы выделим достаточно памяти для хранения одного пикселя.
	
	GLuint pixelcount = tga.Height * tga.Width;  // Количество пикселей в изображении
	GLuint currentpixel  = 0;     // Пиксель с который мы сейчас считываем
	GLuint currentbyte  = 0;      // Байт который мы зарисуем в Imagedata
	
	// Хранилище для одного пикселя
	GLubyte * colorbuffer = (GLubyte *)malloc(tga.bytesPerPixel);
	
	//Затем идет большой цикл.
	
	//Давайте разобьем его на несколько частей.
	
	//Сначала мы объявляем переменную для хранения идентификатора секции данных, 
	//он определяет, является следующая секция RLE или RAW и какого она размера. 
	//Если идентификатор меньше или равняется 127, тогда это RAW секция, 
	//и при этом значение идентификатора – это количество цветов минус один, 
	//которые надо считать и скопировать в память перед переходом к другому байту  
	//идентификатора. Следовательно, мы прибавляем единицу к полученному значению 
	//и затем считываем все эти пиксели и копируем в ImageData, также как мы делали 
	//и с несжатыми данными. Если идентификатор больше 127, то это количество раз, 
	//которое непрерывно повторяется пиксель. Для получения количества повторений 
	//мы берем полученное значение и отнимаем от него 127. Затем мы считываем пиксель 
	//и непрерывно копируем его в память указанное количество раз.
	
	//Сначала мы читаем заголовок в один байт.
	do  // Начало цикла
	{
		GLubyte chunkheader = 0; // Значение для хранения идентификатора секции
		// Пытаемся считать идентификатора секции
		if(fread(&chunkheader, sizeof(GLubyte), 1, fTGA) == 0)
		{
			printf("...Здесь код ошибки...\n");
			return false;        // Если неудача, возвращаем False
		}
		//Далее мы проверяем, является ли это RAW секцией. 
		//Если да, мы должны добавить единицу к значению 
		//для получения количества пикселей следующих за идентификатором.
		
		if(chunkheader < 128)   // Если секция является 'RAW' секцией
		{
			chunkheader++;        // Добавляем единицу для получения количества RAW пикселей
			
			//Затем запускаем еще один цикл для чтения информации о цветах. 
			//Он будет выполняться количество раз указанных в идентификаторе секции, 
			//и считывать один пиксель за раз.
			
			//Сначала мы считываем и проверяем информацию о пикселе. 
			//Информация об одном пикселе хранится в переменной colorbuffer. 
			//Затем мы проверяем, является ли это RAW идентификатором. Если да, 
			//прибавляем единицу и получаем количество пикселей следующих за ним. 
			
			// Начало цикла чтения пикселей
			for(short counter = 0; counter < chunkheader; counter++)
			{
				// Пытаемся прочитать 1 пиксель
				if(fread(colorbuffer, 1, tga.bytesPerPixel, fTGA) != tga.bytesPerPixel)
				{
					printf("...код ошибки...\n");
					return false;      // Если ошибка, возвращаем False
				}
				//Следующая часть нашего цикла будет брать значения цветов 
				//сохраненных в colorbuffer и записывать их в imageData для 
				//использования позже. В этом процессе пиксели будут зеркально 
				//отражены из BGR в RGB или из ABGR в RGBA в зависимости от 
				//количества бит на пиксель. После завершения мы инкрементируем 
				//текущий байт и текущего счетчика пикселей.
				
				texture->imageData[currentbyte] = colorbuffer[2];       // Записать байт 'R'
				texture->imageData[currentbyte + 1  ] = colorbuffer[1]; // Записать байт 'G'
				texture->imageData[currentbyte + 2  ] = colorbuffer[0]; // Записать байт 'B'
				
				if(tga.bytesPerPixel == 4)          // Если это 32bpp изображение...
				{
					texture->imageData[currentbyte + 3] = colorbuffer[3];  // Записать байт 'A'
				}

				// Увеличиваем счетчик байтов на значение равное количеству байт на пиксель
				currentbyte += tga.bytesPerPixel;
				currentpixel++;          // Увеличиваем количество пикселей на 1
			}
		}				
		//Следующая часть работает с идентификатором представляющим RLE секцию. 
		//Первое что мы делаем, это вычитаем 127 из chunkheader для получения 
		//количества повторений следующего цвета.
		else  //= Если это RLE идентификатор
		{
			chunkheader -= 127; // Вычитаем 127 для получения количества повторений
			
			//Затем мы пытаемся считать значение следующего цвета.
			// Читаем следующий пиксель
			if(fread(colorbuffer, 1, tga.bytesPerPixel, fTGA) != tga.bytesPerPixel)
			{ 
				printf("...код ошибки...\n");
				return false;        // Если ошибка, возвращаем False
			}
			
			//Далее начинаем цикл для копирования только что прочитанного пикселя 
			//в память количество раз, указанных в RLE идентификаторе.
			
			//Затем мы копируем значение цветов в imageData, меняя местами R и B.
			
			//Затем мы инкрементируем текущий пиксель и байт, так что мы находимся 
			//в правой части, когда снова зарисуем значение.
			
			// Начинаем цикл
			for(short counter = 0; counter < chunkheader; counter++)
			{
				// Копируем байт 'R'
				texture->imageData[currentbyte] = colorbuffer[2];
				// Копируем байт 'G'
				texture->imageData[currentbyte + 1  ] = colorbuffer[1];
				// Копируем байт 'B'
				texture->imageData[currentbyte + 2  ] = colorbuffer[0];
				if(tga.bytesPerPixel == 4)    // Если это 32bpp изображение
				{
					// Копируем байт 'A'
					texture->imageData[currentbyte + 3] = colorbuffer[3];
				}
				currentbyte += tga.bytesPerPixel;  // Инкрементируем счетчик байтов
				currentpixel++;        // Инкрементируем счетчик пикселей
			}
		}
		//Затем мы продолжаем основной цикл до тех пор, 
		//пока у нас справа есть пиксели для чтения.			
	}
	while(currentpixel < pixelcount); // Еще есть пиксели для чтения? ... Начинаем цикл с начала
		//Затем мы закрываем файл и возвращаем true.
	fclose(fTGA);        // Закрываем файл
	return true;        // Возвращаем true
}

 

//Теперь у нас есть изображение готовое для glGenTextures и glBindTexture. 
//Я предлагаю вам обратится к урокам №6 и №24 за более подробной информации 
//по этим командам. Я не гарантирую что мой код без ошибок, 
//но я приложил усилия на их устранение. Особые благодарности Джефу “NeHe” 
//Молофи за его великолепные уроки и Тренту “ShiningKnight ” 
//Полак за его помощь мне в корректировке этого урока. Спасибо.


