#include "StdAfx.h"

namespace geometry2D
{

/*
Конструктор ListNode неявно инициирует конструктор для 
базового класса Node, поскольку последний конструктор 
не имеет аргументов.

Мы не определяем здесь деструктора класса ListNode. 
Как только удаляется объект ListNode, автоматически 
инициируется деструктор базового класса Node::~Node, 
объявленный как виртуальный. Заметим, что элемент, 
указанный элементом данных ListNode::_val не разрушается. 
Было бы безопасно разрушить элемент только в том случае, 
если бы было известно, что он создан как новый (new), 
но нет никакой гарантии такой ситуации.
*/

/*

Конструкторы и деструкторы
Конструктор List создает и инициализирует пустой список, 
представленный одним головным узлом, со ссылками 
на самого себя:
*/
template<class T> List<T>::List(void) : 
  _length(0)
{
  header = new ListNode<T> (NULL);
  win = header;
}
/*
Деструктор класса разрушает узлы связанного списка:
*/
template<class T> List<T>::~List (void)
{
  while (length() > 0) {
    first();
	remove ();
  }
  delete header;
}
/*
Заметим, что деструктор не разрушает сами элементы данных.

Изменение списков
Компонентные функции insert, prepend и append 
используются для включения в список новых элементов. 
Ни одна из этих трех функций не изменяет позиции окна. 
Функция insert заносит новый элемент после окна и 
возвращает указатель на новый элемент:
*/
template<class T> T List<T>::insert(T val)
{
  win->insert(new ListNode<T>(val) );
  ++_length;
  return val;
}
/*
Компонентные функции prepend и append вставляют 
новый элемент в начало или в конец списка 
соответственно и возвращают указатель на новый элемент:
*/
template<class T> T List<T>::prepend(T val)
{
  header->insert (new ListNode<T> (val));
  ++_length;
  return val;
}

template<class T> T List<T>::append (T val)
{
  header->prev()->insert (new ListNode<T> (val) );
  ++_length;
  return val;
}
/*
Вторая версия компонентной функции append используется 
для добавления списка 1 в конец текущего списка — 
первый элемент списка 1 помещается после последнего 
элемента текущего списка. В процессе выполнения 
список 1 становится пустым. Возвращается указатель 
на текущий список:
*/
template<class T> List<T>* List<T>::append (List<T> *l)
{
  ListNode<T> *a = (ListNode<T>*) header->prev() ;
  a->splice(l->header);
  _length += l-> _length;
  l->header->remove();
  l->_length = 0;
  l->win = header;
  return this;
}
/*
Компонентная функция remove удаляет элемент, 
находящийся в окне, перемещает окно в предыдущую 
позицию и возвращает указатель на только что 
удаленный элемент. Если окно находится в головной позиции, 
то таких действий не производится:
*/
template<class T> T List<T>::remove (void)
{
  if (win == header) return NULL;
  void *val = (void*)win->_val;
  win = (ListNode<T>*) win->prev();
  delete (ListNode<T>*) win->next()->remove();
  -- _length ;
  return (T)val;
}
/*
Если вызывается компонентная функция val с именем 
некоторого элемента v, то происходит замена элемента, 
находящегося в текущем окне, на элемент v. Если окно 
находится в головной позиции, то никаких действий не 
производится.
*/
template<class T> void List<T>::val (T v)
{
  if (win != header) 
    win->_val = v;
}
/*
Доступ к элементам списка
Если обращение к компонентной функции val происходит 
без аргументов, то возвращается элемент, находящийся 
в окне, или нуль NULL, если окно располагается в 
головной позиции:
*/
template<class T> T List<T>::val(void)
{
  return win->_val;
}
/*
Компонентные функции next и prev перемещают окно 
в следующую или предыдущую позиции соответственно. 
Каждая из них возвращает указатель на элемент, 
расположенный в новой позиции окна. Заметим, что 
класс List обеспечивает операцию "заворачивания". 
Например, если окно находится в последней позиции, 
то выполнение операции next переместит окно в 
головную позицию, еще одно обращение к next 
переместит окно в первую позицию.
*/
template<class T> T List<T>::next(void)
{
  win = (ListNode<T>*) win->next();
  return win->_val;
}

template<class T> T List<T>::prev(void)
{
  win = (ListNode<T>*) win->prev();
  return win->_val;
}
/*
Компонентные функции first и last переносят 
окно в первую и последнюю позиции соответственно, 
они не производят никаких действий, если лист 
пустой. Каждая из этих функций возвращает указатель 
на элемент, записанный в новом положении окна:
*/
template<class T> T List<T>::first (void)
{
  win = (ListNode<T>*) header->next();
  return win->_val;
}

template<class T> T List<T>::last (void)
{
  win = (ListNode<T>*) header->prev();
  return win->_val;
}
/*
Компонентная функция length возвращает значение длины списка:
*/
template<class T> int List<T>::length (void)
{
  return _length;
}
/*
Компонентные функции isFirst, isLast и isHead возвращают значение TRUE (истина) только в случаях, если окно находится в первой, последней или головной позициях соответственно.
*/
template<class T> bool List<T>::isFirst(void)
{
  return ( (win == header->next() ) && (_length > 0) );
}

template<class T> bool List<T>::isLast (void)
{
  return ( (win == header->prev() ) && (_length > 0) );
}

template<class T> bool List<T>::isHead(void)
{
  return (win == header);
}






/*

Примеры списков
Два простых примера иллюстрируют использование списков. В первом примере шаблон функции arrayToList загружает n элементов массива а в список и возвращает указатель на этот список:

*/
template<class T> List<T> *arrayToList(T a[], int n)
{
  List<T> *s = new List<T>;
  for (int i = 0; i < n; i++)
    s->append(a[i]);
  return s;
}
/*
Например, если а представляет собой массив строк, то следующий фрагмент программы преобразует массив а в список строк s :

char *a[20];
  .
  .
// здесь должен быть определен массив а
  .
  .
List<char*> *s = arrayToList(a, 20);

Шаблон функции arrayToList мы будем впоследствии использовать как утилиту в некоторых программах.

В качестве второго примера рассмотрим шаблон функции leastltem, которая возвращает наименьший элемент в списке s. Два элемента сравниваются с помощью функции стр, в результате работы которой возвращаются значения -1, 0 или 1, если первый аргумент соответственно меньше, равен или больше второго аргумента:
*/
template<class T> T leastItem(List<T> &s, int(*cmp) (T,T) )
{
  if (s.length() == 0)
    return NULL;
   T v = s.first();
   for (s.next(); !s.isHead(); s.next() )
     if (cmp(s.val(), v) < 0)
       v = s.val();
   return v;
}
/*
Для определения, какой из списков строк появляется раньше в алфавитном порядке, следует обратиться к функции leastltem с функцией сравнения strcmp. Это стандартная библиотечная функция языка C++, которая при обработке двух строк выдает значения -1, 0 или 1 в зависимости от того, будет ли первая строка меньше, равна или больше второй строки в алфавитном порядке. Например, в результате работы следующего фрагмента программы будет напечатана строка ant:

List<char*> s;
s.append("bat");
s.append("ant");
s.append("cat");
cout << leastltem(s, strcmp);

* - примеры кода набраны вручную и не компилировались. Будут проблемы - пишите algolist@manual.ru. 
*/
} // namespace
