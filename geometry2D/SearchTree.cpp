#include "StdAfx.h"
#include ".\treenode.h"

namespace geometry2D
{
	/*
Конструкторы и деструкторы
Конструктор SearchTree инициализирует элементы данных cmp для функции сравнения и root для пустого дерева поиска:

*/
template<class T> SearchTree<T>::SearchTree( int (*c) (T,T) ) : cmp(c), root(NULL)
{
}
/*
Дерево поиска пусто только, если в элементе данных root содержится нуль (NULL) вместо разрешенного указателя:
*/
template<class T> int SearchTree<T>::isEmpty (void)
{
  return (root == NULL);
}
/*
Деструктор удаляет все дерево путем обращения к деструктору корня:
*/
template<class T> SearchTree<T>::~SearchTree (void)
{
  if (root) delete root;
}
/*
Поиск
Чтобы найти заданный элемент val, мы начинаем с корня и затем следуем вдоль ломаной линии уникального пути вниз до узла, содержащего val. В каждом узле n вдоль этого пути используем функцию сравнения для данного дерева на предмет сравнения val с элементом n->val, записанном в n. Если val меньше, чем n->val, то поиск продолжается, начиная с левого потомка узла n, если val больше, чем n->val, то поиск продолжается, начиная с правого потомка n, в противном случае возвращается значение n->val (и задача решена). Путь от корневого узла вниз до val называется путем поиска для val.

Этот алгоритм поиска реализуется в компонентной функции find, которая возвращает обнаруженный ею указатель на элемент или NULL, если такой элемент не существует в дереве поиска.
*/
template<class T> T SearchTree<T>::find (T val)
{
	TreeNode<T> *n = root;
	if (_find (val, n))           
		return (n ? n->val : NULL);
	return NULL;
}

template<class T> BOOL SearchTree<T>::_find (T val, TreeNode<T> *&n)
{
	n = root;
	while (n) 
	{
		int result = (*cmp) (val, n->val);
		if (result < 0)
			n = n->_lchild;
		else if (result > 0)
			n = n->_rchild;
		else
			return TRUE;
	}
	return  FALSE;
}
/*
Этот алгоритм поиска можно сравнить с турниром, в котором участвуют некоторые кандидаты. В начале, когда мы начинаем с корня, в состав кандидатов входят все элементы в дереве поиска. В общем случае для каждого узла n в состав кандидатов входят все потомки n. На каждом этапе производится сравнение val с n->val. Если val меньше, чем n->val, то состав кандидатов сужается до элементов, находящихся в левом поддереве, а элементы в правом поддереве n, как и сам элемент n->val, исключаются из соревнования. Аналогичным образом, если val больше, чем n->val, то состав кандидатов сужается до правого поддерева n. Процесс продолжается до тех пор, пока не будет обнаружен элемент val или не останется ни одного кандидата, что означает, что элемент val не существует в дереве поиска.
*/

/*
Для нахождения наименьшего элемента мы начинаем с корня и прослеживаем связи с левым потомком до тех пор, пока не достигнем узла n, левый потомок которого пуст — это означает, что в узле n содержится наименьший элемент. Этот процесс также можно уподобить турниру. Для каждого узла n состав кандидатов определяется потомками узла n. На каждом шаге из состава кандидатов удаляются те элементы, которые больше или равны n->val и левый потомок n будет теперь выступать в качестве нового n. Процесс продолжается до тех пор, пока не будет достигнут некоторый узел n с пустым левым потомком и, полагая, что не осталось кандидатов меньше, чем n->val, и будет возвращено значение n->val.

Компонентная функция findMin возвращает наименьший элемент в данном дереве поиска, в ней происходит обращение к компонентной функции _findMin, которая реализует описанный ранее алгоритм поиска, начиная с узла n :
*/
template<class T> T SearchTree<T>::findMin (void)
{
	if (root == NULL)
		return NULL;

	TreeNode<T> *n = _findMin (root);
	return (n ? n->val : NULL);
}

template<class T>
TreeNode<T> * SearchTree<T>::_findMin (TreeNode<T> *n)
{

	if (n == NULL)
	{
		return NULL;
	}

	while   (n->_lchild)
		n = n->_lchild;

	return n;
}
/*
Наибольший элемент в дереве поиска может быть найден аналогично, только отслеживаются связи с правым потомком вместо левого.
*/
template<class T> T SearchTree<T>::findMax (void)
{
	if (root == NULL)
		return NULL;
	
	TreeNode<T> *n = _findMax (root);
	return (n ? n->val : NULL);
}

template<class T>
TreeNode<T> * SearchTree<T>::_findMax (TreeNode<T> *n)
{

	if (n == NULL)
	{
		return NULL;
	}

	while   (n->_rchild)
		n = n->_rchild;

	return n;
}

/*
Симметричный обход
Обход двоичного дерева — это процесс, при котором каждый узел посещается точно только один раз. Компонентная функция inorder выполняет специальную форму обхода, известную как симметричный обход. Стратегия заключается сначала в симметричном обходе левого поддерева, затем посещения корня и потом в симметричном обходе правого поддерева. Узел посещается путем применения функции обращения к элементу, записанному в узле.

Компонентная функция inorder служит в качестве ведущей функции. Она обращается к собственной компонентной функции _inorder, которая выполняет симметричный обход от узла n и применяет функцию visit к каждому достигнутому узлу.
*/
template<class T> void SearchTree<T>::inorder (void (*visit)    (T, void * ), void * p )
{
  _inorder (root, visit, p);
}

template<class T>
void SearchTree<T>::_inorder (TreeNode<T> *n, void(*visit) (T, void * ), void * p)
{
	if (n) 
	{				
		_inorder (n->_lchild, visit, p);
		(*visit) (n->val, p);
		_inorder (n->_rchild, visit, p);
	}
}
/*
При симметричном обходе каждого из двоичных деревьев поиска, показанных на рис. 2, узлы посещаются в возрастающем порядке: 2, 3, 5, 7, 8. Конечно, при симметричном обходе любого двоичного дерева поиска все его элементы посещаются в возрастающем порядке. Чтобы выяснить, почему это так, заметим, что при выполнении симметричного обхода в некотором узле n элементы меньше, чем n->val посещаются до n, поскольку они принадлежат к левому поддереву n, а элементы больше, чем n->val посещаются после n, поскольку они принадлежат правому поддереву n. Следовательно, узел n посещается в правильной последовательности. Поскольку n — произвольный узел, то это же правило соблюдается для каждого узла.

Компонентная функция inorder обеспечивает способ перечисления элементов двоичного дерева поиска в отсортированном порядке. Например, если а является деревом поиска SearchTree для строк, то эти строки можем напечатать в лексикографическом порядке одной командой а.inorder(printstring). Для этого функция обращения printstring может быть определена как:

void printstring(char *s)
{
  cout << s << "\n";
}

При симметричном обходе двоичного дерева узел, посещаемый после некоторого узла n, называется последователем узла n, а узел, посещаемый непосредственно перед n, называется предшественником узла n. Не существует никакого предшественника для первого посещаемого узла и никакого последователя для последнего посещаемого узла (в двоичном дереве поиска эти узлы содержат наименьший и наибольший элемент соответственно).
*/

/*
Включение элементов
Для включения нового элемента в двоичное дерево поиска вначале нужно определить его точное положение — а именно внешний узел, который должен быть заменен путем отслеживания пути поиска элемента, начиная с корня. Кроме сохранения указателя n на текущий узел мы будем хранить указатель р на предка узла n. Таким образом, когда n достигнет некоторого внешнего узла, р будет указывать на узел, который должен стать предком нового узла. Для осуществления включения узла мы создадим новый узел, содержащий новый элемент, и затем свяжем предок р с этим новым узлом (рис. 3).

Компонентная функция insert включает элемент val в это двоичное дерево поиска:


Рис. 3: Включение элемента в двоичное дерево поиска
*/

#define TEST_INSERT 1
// если 1, то мы можем вставлять одинаковые элементы в дерево, иначе - нет
template<class T> void SearchTree<T>::insert(T val)
{
	if (root == NULL) 
	{
		root = new TreeNode<T>(val);
		return;
	} 
	else 
	{
		int result;
		TreeNode<T> *p, *n = root;
		while (n) {
			p = n;
			result = (*cmp) (val, p->val);
#if !TEST_INSERT
			if (result < 0)
				n = p->_lchild;
			else 
				if (result > 0)
					n = p->_rchild;
			else
				return;
#else
			if (result < 0)
				n = p->_lchild;
			else 
				n = p->_rchild;
#endif
		}
		if (result < 0)
			p->_lchild = new TreeNode<T>(val);
		else
			p->_rchild = new TreeNode<T>(val);

	}
}

/*
Удаление элементов
Удаление элемента из двоичного дерева поиска гораздо сложнее, чем включение, поскольку может быть значительно изменена форма дерева. Удаение узла, у которого есть не более чем один непустой потомок, является равнительно простой задачей — устанавливается ссылка от предка узла на потомок. Однако ситуация становится гораздо сложнее, если у подлежащего удалению узла есть два непустых потомка: предок узла может быть связан с одним из потомков, а что делать с другим? Решение может заключаться не в удалении узла из дерева, а скорее в замене элемента, содержащегося в нем, на последователя этого элемента, а затем в удалении узла, содержащего этот последователь.


Рис. 4: Три ситуации, возникающие при удалении элемента из двоичного дерева поиска
Чтобы удалить элемент из дерева поиска, вначале мы отслеживаем путь поиска элемента, начиная с корня и вниз до узла n, содержащего элемент. В этот момент могут возникнуть три ситуации, показанные на рис. 4:

Узел n имеет пустой левый потомок. В этом случае ссылка на n (записанная в предке n, если он есть) заменяется на ссылку на правого потомка n. 
У узла n есть непустой левый потомок, но правый потомок пустой. В этом случае ссылка вниз на n заменяется ссылкой на левый потомок узла n. 
Узел n имеет два непустых потомка. Найдем последователя для n (назовем его m), скопируем данные, хранящиеся в m, в узел n и затем рекурсивно удалим узел m из дерева поиска. 
Очень важно проследить, как будет выглядеть результирующее двоичное дерево поиска в каждом случае. Рассмотрим случай 1. Если подлежащий удалению узел n, является левым потомком, то элементы, относящиеся к правому поддереву n будут меньше, чем у узла р, предка узла n. При удалении узла n его правое поддерево связывается с узлом р и элементы, хранящиеся в новом левом поддереве узла р конечно остаются меньше элемента в узле р. Поскольку никакие другие ссылки не изменяются, то дерево остается двоичным деревом поиска. Аргументы остаются подобными, если узел n является правым потомком, и они тривиальны, если n — корневой узел. Случай 2 объясняется аналогично. В случае 3 элемент v, записанный в узле n, перекрывается следующим большим элементом, хранящимся в узле m (назовем его w), после чего элемент w удаляется из дерева. В получающемся после этого двоичном дереве значения в левом поддереве узла n будут меньше w, поскольку они меньше v. Более того, элементы в правом поддереве узла n больше, чем w, поскольку (1) они больше, чем v, (2) нет ни одного элемента двоичного дерева поиска, лежащего между v и w и (3) из них элемент w был удален.

Заметим, что в случае 3 узел m должен обязательно существовать, поскольку правое поддерево узла n непустое. Более того, рекурсивный вызов для удаления m не может привести к срыву рекурсивного вызова, поскольку если узел m не имел бы левого потомка, то был бы применен случай 1, когда его нужно было бы удалить.

На рис. 5 показана последовательность операций удаления, при которой возникают все три ситуации. Напомним, что симметричный обход каждого дерева в этой последовательности проходит все узлы в возрастающем порядке, проверяя, что в каждом случае это двоичные деревья поиска.

Компонентная функция remove является общедоступной компонентной функцией для удаления узла, содержащего заданный элемент. Она обращается к собственной компонентной функции _remove, которая выполняет фактическую работу:


Рис. 5: Последовательность операций удаления элемента: (а) и (б) — Случай 1: удаление из двоичного дерева элемента 8; (б) и (в) — Случай 2: удаление элемента 5; (в) и (г) - Случай 3: удаление элемента 3

*/
template<class T> void SearchTree<T>::remove(T val)
{
#if 1
	_remove(val, root); 
#else
	//ускорить функцию за счёт применения более быстрой версии _remove()
	TreeNode<T> *& n = root;
	if( _find(val, n) )
		if(n)
			_remove(n);
#endif
}

template<class T>
void SearchTree<T>::_remove(T val, TreeNode<T> * &n)
{
	if (n == NULL)
		return;

	int result = (*cmp) (val, n->val);
	if (result < 0)
		_remove(val, n->_lchild);
	else if (result > 0)
		_remove (val, n->_rchild);
	else 
	{    
		// случай 1
		if (n->_lchild == NULL) 
		{
			TreeNode<T> *old = n;
			n = old->_rchild;
			old->_rchild = NULL;
			delete old;
		}
		else if (n->_rchild == NULL )
		{     
			// случай 2
			TreeNode<T> *old = n;
			n = old->_lchild;
			old->_lchild = NULL;
			delete old;
		}
		else 
		{	
			// случай 3
			TreeNode<T> *m = _findMin(n->_rchild);
			n->val = m->val;
			_remove(m->val, n->_rchild);
		}
	}
}

/*
template<class T>
void SearchTree<T>::_remove(TreeNode<T> * n)
{
	if (n == NULL)
		return;
	else 
	{    
		// случай 1
		if (n->_lchild == NULL) 
		{
			TreeNode<T> *old = n;
			n = old->_rchild;
			old->_rchild = NULL;
			delete old;
		}
		else if (n->_rchild == NULL )
		{     
			// случай 2
			TreeNode<T> *old = n;
			n = old->_lchild;
			old->_lchild = NULL;
			delete old;
		}
		else 
		{	
			// случай 3
			TreeNode<T> *m = _findMin(n->_rchild); 			
			n->val = m->val;
			_remove(m);
		}
	}
}*/
/*
Параметр n (типа ссылки) служит в качестве псевдонима для поля ссылки, 
которое содержит ссылку вниз на текущий узел. При достижении узла, 
подлежащего удалению (old), n обозначает поле ссылки (в предке узла old), 
содержащее ссылку вниз на old. Следовательно команда n=old->_rchild заменяет 
ссылку на old ссылкой на правого потомка узла old.
*/

/*
Компонентная функция removeMin удаляет из дерева поиска наименьший элемент 
и возвращает его:
*/
template<class T> T SearchTree<T>::removeMin (void)
{
#if 1
	T v = findMin();
	remove (v);
	return v;
#else
	//ускорить функцию за счёт применения более быстрой версии _remove()
	if (root == NULL)
		return NULL;

	TreeNode<T> * m = _findMin(root);

	if(m)
	{
		T v = m->val;
		_remove(m);
		return v;
	}
	return NULL;
#endif
}
/*
Древовидная сортировка — способ сортировки массива элементов — 
реализуется в виде простой программы, использующей деревья поиска. 
Идея заключается в занесении всех элементов в дерево поиска и 
затем в интерактивном удалении наименьшего элемента до тех пор, 
пока не будут удалены все элементы. 

Программа heapSort(пирамидальная сортировка) сортирует 
массив s из n элементов, используя функцию сравнения cmp: 
*/
template<class T> void heapSort (T s[], int n, int(*cmp) (T,T) )
{
  SearchTree<T> t(cmp);
  for (int i = 0; i < n; i++)
    t.insert(s[i]);
  for (i = 0; i < n; i++)
    s[i] = t.removeMin();
}


} // namespace