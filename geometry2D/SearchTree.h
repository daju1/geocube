#pragma once

namespace geometry2D
{
	/*
Основное назначение двоичных деревьев заключается в повышении 
эффективности поиска. При поиске выполняются такие операции,
как нахождение заданного элемента из набора различных элементов, 
определение наибольшего или наименьшего элемента в наборе, 
фиксация факта, что набор содержит заданный элемент. Для эффективного поиска внутри двоичного дерева его элементы должны быть организованы соответствующим образом. Например, двоичное дерево будет называться двоичным деревом поиска, если его элементы расположены так, что для каждого элемента n все элементы в левом поддереве n будут меньше, чем n, а все элементы в правом поддереве — будут больше, чем n. На рис. 2 изображены три двоичных дерева поиска, каждое из которых содержит один и тот же набор целочисленных элементов.


Рис. 2: Три двоичных дерева поиска с одним и тем же набором элементов
В общем случае существует огромное число двоичных деревьев поиска (различной формы) для любого заданного набора элементов.

Предполагается, что элементы располагаются в линейном порядке и, следовательно, любые два элемента можно сравнить между собой. Примерами линейного порядка могут служить ряды целых или вещественных чисел в порядке возрастания, а также слов или строк символов, расположенных в лексикографическом (алфавитном, или словарном) порядке. Поиск осуществляется путем обращения к функции сравнения для сопоставления любых двух элементов относительно их линейного порядка. В нашей версии деревьев поиска действие функции сравнения ограничено только явно определенными объектами деревьев поиска.

Также очень полезны функции для обращения к элементам дерева поиска и воздействия на них. Такие функции обращения могут быть полезны для вывода на печать, редактирования и доступа к элементу или воздействия на него каким-либо иным образом. Функции обращения не принадлежат деревьям поиска, к элементам одного и того же дерева поиска могут быть применены различные функции обращения.
 

  Класс SearchTree (дерево поиска) 

 

 

Определим шаблон нового класса SearchTree для представления двоичного дерева поиска. Класс содержит элемент данных root, который указывает на корень двоичного дерева поиска (объект класса TreeNode) и элемент данных cmp, который указывает на функцию сравнения.
*/

template<class T> class TreeNode;

template<class T> class SearchTree {
 private:
  TreeNode<T> *root;
  //int  (*) (T,T) cmp;
  int  (*cmp) (T,T) ;
  TreeNode<T> * _findMin (TreeNode<T> *);
  TreeNode<T> * _findMax (TreeNode<T> *);
  //void _remove(TreeNode<T> *);
  void _remove(T, TreeNode<T> * &);
  void _inorder(TreeNode<T> *, void (*) (T, void * ), void *  );
  BOOL _find (T val, TreeNode<T> *&n);//my test
 public:
  SearchTree (int(*) (T, T) );
  SearchTree (SearchTree & tree)
  {
	  this->cmp = tree.cmp;
	  this->root = new TreeNode<T>(tree.root);
  }

  ~SearchTree (void);
  int isEmpty (void);
  T find(T);
  T findMin(void);
  T findMax(void);
  void inorder (void(*) (T, void * ), void * );
  void insert(T);
  void remove(T);
  T removeMin (void);
};
/*
Для упрощения реализации предположим, что элементами в дереве поиска являются указатели на объект заданного типа, когда шаблон класса SearchTree используется для создания действительного класса. Параметр Т передается в виде типа указателя.
*/
 
template<class T> void heapSort (T s[], int n, int(*cmp) (T,T) );


} // namespace

#include ".\searchtree.cpp"
