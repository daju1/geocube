#include <afxdisp.h>         // MFC core and standard components
#include "../../excel_connect/src/myexcel.h"



#include <windows.h>
#include <gdiplus.h>
using namespace Gdiplus;

#include "stdafx.h"
#include "math.h"
#include "lab.h"
#include "lab_cmd_dlg.h"
#if LABORATORY_WITH_SURFDOC
#include "../../wintools/src/project.h"
#endif
#include "../../wintools/src/win32_dialog.h"
#include <afxdb.h>
#include "../../lab/lab/labdoc.h"

#include "LabTrialsTree.h"
#include "LabParamTree.h"
char * SelectNameFromPath(const char * path, char * name, size_t len);
bool MinSqLinear(int min_n, vector<x_compression> & x, vector<trial_got_value> & y, int i0, int n, bool donot_shift, trial_value & a0, trial_value & a1, int & m, trial_value & Sy, bool to_printf = false);

bool linterp(int n, double* vx, double* vy, double x, double &y);
bool inline linterp2(int nx, double* vx, int ny, double* vy, double ** zz, double x, double y, double &z);

extern HINSTANCE hInst;
#define STEP 10

#define USE_e0_IN_E_CALCULATION 1

#include <iomanip>
#include <algorithm>
#include <fstream>
#include <strstream>
using namespace std;

#include "../../excel_connect/src/ExcelColChar.h"

bool Laboratory::context_with_plot = true;
double CompressionLabTrialResults::deformation_module_01_02_pressure_interval[2];

void ErrorExit(LPTSTR lpszFunction, bool toExitProcess);

const char * GetZrizHid(long id_hid)
{
	switch (CGround::s_Gender)
	{
	case CGround::Gender::male:
		{
			switch (BaseLab::PassportLanguage)
			{
			case BaseLab::language::russian:
				{
					switch(id_hid)
					{
					case 1:
						return "быстрый";
					case 2:
						return "ускоренный";
					case 3:
						return "медленный";
					case 4:
						return "плашка по плашке";
					}
				}
				break;
			case BaseLab::language::ukrainian:
				{
					switch(id_hid)
					{
					case 1:
						return "швидкий";
					case 2:
						return "прискорений";
					case 3:
						return "повільний";
					case 4:
						return "плашка по плашці";
					}
				}
				break;
			}
		}
		break;
	case CGround::Gender::female:
		{
			switch (BaseLab::PassportLanguage)
			{
			case BaseLab::language::russian:
				{
					switch(id_hid)
					{
					case 1:
						return "быстрая";
					case 2:
						return "ускоренная";
					case 3:
						return "медленная";
					case 4:
						return "плашка по плашке";
					}
				}
				break;
			case BaseLab::language::ukrainian:
				{
					switch(id_hid)
					{
					case 1:
						return "швидка";
					case 2:
						return "прискорена";
					case 3:
						return "повільна";
					case 4:
						return "плашка по плашці";
					}
				}
				break;
			}
		}
		break;
	case CGround::Gender::middle:
		{
			switch (BaseLab::PassportLanguage)
			{
			case BaseLab::language::russian:
				{
					switch(id_hid)
					{
					case 1:
						return "быстрое";
					case 2:
						return "ускоренное";
					case 3:
						return "медленное";
					case 4:
						return "плашка по плашке";
					}
				}
				break;
			case BaseLab::language::ukrainian:
				{
					switch(id_hid)
					{
					case 1:
						return "швидке";
					case 2:
						return "прискорене";
					case 3:
						return "повільне";
					case 4:
						return "плашка по плашці";
					}
				}
				break;
			}
		}
		break;
	}
				
	return "";

}

const char * GetZrizHid_small(long id_hid)
{
	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			switch(id_hid)
			{
			case 1:
				return "быстр.";
			case 2:
				return "уск.";
			case 3:
				return "медл.";
			case 4:
				return "пл.п/пл.";
			}
		}
		break;
	case BaseLab::language::ukrainian:
		{
			switch(id_hid)
			{
			case 1:
				return "швид.";
			case 2:
				return "приск.";
			case 3:
				return "повіл.";
			case 4:
				return "пл.п/пл.";
			}
		}
		break;
	}

				
	return "";
}


/*
Zriz_hid
ID	NAZVA_U	NAZVA_R
1	Швидкий	Быстрый
2	Прискорений	Ускоренный
3	Повільний	Медленный
4	Плашка по плашці	Плашка по плашке
*/
const char * GetZrizShema(long id_shema)
{
	switch (CGround::s_Gender)
	{
	case CGround::Gender::male:
		{
			switch (BaseLab::PassportLanguage)
			{
			case BaseLab::language::russian:
				{
					switch(id_shema)
					{
					case 1:
						return "неконсолидированно-недренированный";
					case 2:
						return "консолидированно-недренированный";
					case 3:
						return "консолидированно-дренированный";
					}
				}
				break;
			case BaseLab::language::ukrainian:
				{
					switch(id_shema)
					{
					case 1:
						return "неконсолідовано-недренований";
					case 2:
						return "консолідовано-недренований";
					case 3:
						return "консолідовано-дренований";
					}
				}
				break;
			}
		}
		break;
	case CGround::Gender::female:
		{
			switch (BaseLab::PassportLanguage)
			{
			case BaseLab::language::russian:
				{
					switch(id_shema)
					{
					case 1:
						return "неконсолидированно-недренированная";
					case 2:
						return "консолидированно-недренированная";
					case 3:
						return "консолидированно-дренированная";
					}
				}
				break;
			case BaseLab::language::ukrainian:
				{
					switch(id_shema)
					{
					case 1:
						return "неконсолідовано-недренована";
					case 2:
						return "консолідовано-недренована";
					case 3:
						return "консолідовано-дренована";
					}
				}
				break;
			}
		}
		break;
	case CGround::Gender::middle:
		{
			switch (BaseLab::PassportLanguage)
			{
			case BaseLab::language::russian:
				{
					switch(id_shema)
					{
					case 1:
						return "неконсолидированно-недренированное";
					case 2:
						return "консолидированно-недренированное";
					case 3:
						return "консолидированно-дренированное";
					}
				}
				break;
			case BaseLab::language::ukrainian:
				{
					switch(id_shema)
					{
					case 1:
						return "неконсолідовано-недреноване";
					case 2:
						return "консолідовано-недреноване";
					case 3:
						return "консолідовано-дреноване";
					}
				}
				break;
			}
		}
		break;
	}

	return "";

}
const char * GetZrizShema_small(long id_shema)
{
	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			switch(id_shema)
			{
			case 1:
				return "некон.-недр.";
			case 2:
				return "конс.-недр.";
			case 3:
				return "конс.-дрен.";
			}
		}
		break;
	case BaseLab::language::ukrainian:
		{
			switch(id_shema)
			{
			case 1:
				return "некон.-недр.";
			case 2:
				return "конс.-недр.";
			case 3:
				return "конс.-дрен.";
			}
		}
		break;
	}

	return "";

}
/*
Zriz_shema
ID	NAZVA_U	NAZVA_R
1	Неконсолідовано-недреноване	Неконсолидированно-недренированное
2	Консолідовано-недреноване	Консолидированно-недренированное
3	Консолідовано-дреноване	Консолидированно-дренированное
*/
const char * Pri_GetZrizStan(long id_stan)
{
	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			switch(id_stan)
			{
			case 1:
				return "естественной влажности";
			case 2:
				return "водонасыщении";
			}
		}
		break;
	case BaseLab::language::ukrainian:
		{
			switch(id_stan)
			{
			case 1:
				return "природної вологості";
			case 2:
				return "водонасичені";
			}
		}
		break;
	}



	return "";

}

const char * GetZrizStan(long id_stan)
{
	switch (CGround::s_Gender)
	{
	case CGround::Gender::male:
		{
			switch (BaseLab::PassportLanguage)
			{
			case BaseLab::language::russian:
				{
					switch(id_stan)
					{
					case 1:
						return "естественная влажность";
					case 2:
						return "водонасыщенный";
					}
				}
				break;
			case BaseLab::language::ukrainian:
				{
					switch(id_stan)
					{
					case 1:
						return "природної вологості";
					case 2:
						return "водонасичений";
					}
				}
				break;
			}
		}
		break;
	case CGround::Gender::female:
		{
			switch (BaseLab::PassportLanguage)
			{
			case BaseLab::language::russian:
				{
					switch(id_stan)
					{
					case 1:
						return "естественная влажность";
					case 2:
						return "водонасыщенный";
					}
				}
				break;
			case BaseLab::language::ukrainian:
				{
					switch(id_stan)
					{
					case 1:
						return "природної вологості";
					case 2:
						return "водонасичений";
					}
				}
				break;
			}
		}
		break;
	case CGround::Gender::middle:
		{
			switch (BaseLab::PassportLanguage)
			{
			case BaseLab::language::russian:
				{
					switch(id_stan)
					{
					case 1:
						return "естественная влажность";
					case 2:
						return "водонасыщенный";
					}
				}
				break;
			case BaseLab::language::ukrainian:
				{
					switch(id_stan)
					{
					case 1:
						return "природної вологості";
					case 2:
						return "водонасичений";
					}
				}
				break;
			}
		}
		break;
	}

	return "";

}

const char * GetZrizStan_small(long id_stan)
{
	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			switch(id_stan)
			{
			case 1:
				return "ест.влаж.";
			case 2:
				return "водонас.";
			}
		}
		break;
	case BaseLab::language::ukrainian:
		{
			switch(id_stan)
			{
			case 1:
				return "прир.волог.";
			case 2:
				return "водонас.";
			}
		}
		break;
	}


	return "";

}

/*
Zriz_stan
ID	NAZVA_U	NAZVA_R
1	Природної вологості	Естественная влажность
2	Водонасичений	Водонасыщенный
*/


LabTrial::LabTrial()
{
	this->Init();
}
LabTrial::~LabTrial()
{
}
void LabTrial::Init()
{
	this->lab_number = NULL;
	this->trial_indication = LabTrial::indication::undefined_lab_trial_indication;
	this->results = NULL;
}
const char * LabTrial::LabTrialTypeToString(LabTrial::indication t)
{
	switch (t)
	{
	case undefined_lab_trial_indication:
		return "undefined_lab_trial_indication";
	case physical:
		return "physical";
	case chemical:
		return "chemical";
	case fractions:
		return "fractions";
	case compression_3:
		return "compression_3";
	case compression_nature_condition_absolute_deformation:
		return "compression_nature_condition_absolute_deformation";
	case compression_task_condition_absolute_deformation:
		return "compression_task_condition_absolute_deformation";
	case compression_shrinkage_absolute_deformation:
		return "compression_shrinkage_absolute_deformation";
	case cut_resistance_nature_condition:
		return "cut_resistance_nature_condition";
	case cut_resistance_task_condition:
		return "cut_resistance_task_condition";
	case pressing:
		return "pressing";
	case filtration_coefficient_with_pressures:
		return "filtration_coefficient_with_pressures";
	case filtration_coefficient_with_densities:
		return "filtration_coefficient_with_densities";
	}
	return "";
}

const char * LabTrial::LabTrialTypeToStringRus(LabTrial::indication t)
{
	switch (t)
	{
	case undefined_lab_trial_indication:
		return "undefined_lab_trial_indication";
	case physical:
		return "Физические свойства";
	case chemical:
		return "Химические свойства";
	case fractions:
		return "Фракции";
	case compression_3:
		return "Компрессия";
	case compression_nature_condition_absolute_deformation:
		return "Компрессия в природном состоянии";
	case compression_task_condition_absolute_deformation:
		return "Компрессия в заданном состоянии";
	case compression_shrinkage_absolute_deformation:
		return "Компрессия на усадку";
	case cut_resistance_nature_condition:
		return "Сопротивление срезу в природном состоянии";
	case cut_resistance_task_condition:
		return "Сопротивление срезу в заданном состоянии";
	case pressing:
		return "Одноосное сжатие";
	case filtration_coefficient_with_pressures:
		return "Фильтрация при давлениях";
	case filtration_coefficient_with_densities:
		return "Фильтрация при плотности грунта";
	}
	return "";
}
#if USE_LAB_TRIALS_VECTOR
void * LabTrial::operator new  (size_t size, LabTrial::indication t, long id_vyprob)
{
	//printf("LabExperiment::operator new (size_t size = %d, LabExperiment::type(%d) = %s\n", size, int(t), LabExperiment::LabExperimentTypeToString(t));

	switch (t)
	{
	case undefined_lab_trial_indication:
		return NULL;
	case physical:
		return reinterpret_cast<void*>(new PhysicalLabTrial(id_vyprob));
	case chemical:
		return reinterpret_cast<void*>(new ChemicalLabTrial(id_vyprob));
	case fractions:
		return reinterpret_cast<void*>(new FractionsLabTrial(id_vyprob));
	case compression_nature_condition_absolute_deformation:
		return reinterpret_cast<void*>(new CompressionLabTrial(CompressionLabTrial::type::nature_condition, id_vyprob));
	case compression_task_condition_absolute_deformation:
		return reinterpret_cast<void*>(new CompressionLabTrial(CompressionLabTrial::type::task_condition, id_vyprob));
	case compression_shrinkage_absolute_deformation:
		return reinterpret_cast<void*>(new CompressionLabTrial(CompressionLabTrial::type::shrinkage, id_vyprob));
	case cut_resistance_nature_condition:
		return reinterpret_cast<void*>(new CutLabTrial(CutLabTrial::type::nature_condition, id_vyprob));
	case cut_resistance_task_condition:
		return reinterpret_cast<void*>(new CutLabTrial(CutLabTrial::type::task_condition, id_vyprob));
	case pressing:
		return reinterpret_cast<void*>(new PressingLabTrial(id_vyprob));
	case filtration_coefficient_with_pressures:
		return reinterpret_cast<void*>(new FiltrationLabTrial(FiltrationLabTrial::type::with_pressures, id_vyprob));
	case filtration_coefficient_with_densities:
		return reinterpret_cast<void*>(new FiltrationLabTrial(FiltrationLabTrial::type::with_densities, id_vyprob));
	case compression_3:
		return reinterpret_cast<void*>(new CompressionLabTrial3(id_vyprob));
	default:
		return NULL;

	}
	return NULL;
}

void LabTrial::operator delete(void * p, LabTrial::indication t, long id_vyprob)
{
	switch (t)
	{
	case undefined_lab_trial_indication:
		return;
	case physical:
		::operator delete(reinterpret_cast<PhysicalLabTrial*>(p));
		break;
	case chemical:
		::operator delete(reinterpret_cast<ChemicalLabTrial*>(p));
		break;
	case fractions:
		::operator delete(reinterpret_cast<FractionsLabTrial*>(p));
		break;
	case compression_nature_condition_absolute_deformation:
		::operator delete(reinterpret_cast<CompressionLabTrial*>(p));
		break;
	case compression_task_condition_absolute_deformation:
		::operator delete(reinterpret_cast<CompressionLabTrial*>(p));
		break;
	case compression_shrinkage_absolute_deformation:
		::operator delete(reinterpret_cast<CompressionLabTrial*>(p));
		break;
	case cut_resistance_nature_condition:
		::operator delete(reinterpret_cast<CutLabTrial*>(p));
		break;
	case cut_resistance_task_condition:
		::operator delete(reinterpret_cast<CutLabTrial*>(p));
		break;
	case pressing:
		::operator delete(reinterpret_cast<PressingLabTrial*>(p));
		break;
	case filtration_coefficient_with_pressures:
		::operator delete(reinterpret_cast<FiltrationLabTrial*>(p));
		break;
	case filtration_coefficient_with_densities:
		::operator delete(reinterpret_cast<FiltrationLabTrial*>(p));
		break;
	case compression_3:
		::operator delete(reinterpret_cast<CompressionLabTrial3*>(p));
		break;
	default:
		return;
	}
}
#else
void * LabTrial::operator new  (size_t size, LabTrial::indication t)
{
	//printf("LabExperiment::operator new (size_t size = %d, LabExperiment::type(%d) = %s\n", size, int(t), LabExperiment::LabExperimentTypeToString(t));

	switch (t)
	{
	case undefined_lab_trial_indication:
		return NULL;
	case physical:
		return reinterpret_cast<void*>(new PhysicalLabTrial);
	case chemical:
		return reinterpret_cast<void*>(new ChemicalLabTrial);
	case fractions:
		return reinterpret_cast<void*>(new FractionsLabTrial);
	case compression_nature_condition_absolute_deformation:
		return reinterpret_cast<void*>(new CompressionLabTrial(CompressionLabTrial::type::nature_condition));
	case compression_task_condition_absolute_deformation:
		return reinterpret_cast<void*>(new CompressionLabTrial(CompressionLabTrial::type::task_condition));
	case compression_shrinkage_absolute_deformation:
		return reinterpret_cast<void*>(new CompressionLabTrial(CompressionLabTrial::type::shrinkage));
	case cut_resistance_nature_condition:
		return reinterpret_cast<void*>(new CutLabTrial(CutLabTrial::type::nature_condition));
	case cut_resistance_task_condition:
		return reinterpret_cast<void*>(new CutLabTrial(CutLabTrial::type::task_condition));
	case pressing:
		return reinterpret_cast<void*>(new PressingLabTrial);
	case filtration_coefficient_with_pressures:
		return reinterpret_cast<void*>(new FiltrationLabTrial(FiltrationLabTrial::type::with_pressures));
	case filtration_coefficient_with_densities:
		return reinterpret_cast<void*>(new FiltrationLabTrial(FiltrationLabTrial::type::with_densities));
	case compression_3:
		return reinterpret_cast<void*>(new CompressionLabTrial3());
	default:
		return NULL;

	}
	return NULL;
}

void LabTrial::operator delete(void * p, LabTrial::indication t)
{
	switch (t)
	{
	case undefined_lab_trial_indication:
		return;
	case physical:
		::operator delete(reinterpret_cast<PhysicalLabTrial*>(p));
		break;
	case chemical:
		::operator delete(reinterpret_cast<ChemicalLabTrial*>(p));
		break;
	case fractions:
		::operator delete(reinterpret_cast<FractionsLabTrial*>(p));
		break;
	case compression_nature_condition_absolute_deformation:
		::operator delete(reinterpret_cast<CompressionLabTrial*>(p));
		break;
	case compression_task_condition_absolute_deformation:
		::operator delete(reinterpret_cast<CompressionLabTrial*>(p));
		break;
	case compression_shrinkage_absolute_deformation:
		::operator delete(reinterpret_cast<CompressionLabTrial*>(p));
		break;
	case cut_resistance_nature_condition:
		::operator delete(reinterpret_cast<CutLabTrial*>(p));
		break;
	case cut_resistance_task_condition:
		::operator delete(reinterpret_cast<CutLabTrial*>(p));
		break;
	case pressing:
		::operator delete(reinterpret_cast<PressingLabTrial*>(p));
		break;
	case filtration_coefficient_with_pressures:
		::operator delete(reinterpret_cast<FiltrationLabTrial*>(p));
		break;
	case filtration_coefficient_with_densities:
		::operator delete(reinterpret_cast<FiltrationLabTrial*>(p));
		break;
	case compression_3:
		::operator delete(reinterpret_cast<CompressionLabTrial3*>(p));
		break;
	default:
		return;
	}
}
#endif
void LabTrial::ReCalcProperties(bool labnumber_recalc_e_log_interp)
{
	if (results) 
		results->ReCalcProperties(labnumber_recalc_e_log_interp);
}

LabTrialResults::LabTrialResults(LabTrial * trial)
{
	this->calculed = false;
	this->lab_trial = trial;
}
LabTrialResults::~LabTrialResults()
{
}
#if USE_LAB_TRIALS_VECTOR
PhysicalLabTrial::PhysicalLabTrial(long id_vyprob)
{
	this->results = new PhysicalLabTrialResults(this);
	this->trial_indication = LabTrial::indication::physical;
	this->m_id_vyprob = id_vyprob;
}
#else
PhysicalLabTrial::PhysicalLabTrial()
{
	this->results = new PhysicalLabTrialResults(this);
	this->trial_indication = LabTrial::indication::physical;
}
#endif
PhysicalLabTrialResults::PhysicalLabTrialResults(LabTrial * trial) : LabTrialResults(trial)
{
	this->Init();
}
void PhysicalLabTrialResults::Init()
{
	// определяем тип грунта
	t = CGround::ground_type::Undefined_ground;
	this->m_sand_vlazhnost = PhysicalLabTrialResults::SandVlazhnost::undefined_vlazhnost;

	this->m_Consistencia_nature = Consistencia::undefined_cons;
	this->m_Consistencia_water_saturated = Consistencia::undefined_cons;

}
#if USE_LAB_TRIALS_VECTOR
ChemicalLabTrial::ChemicalLabTrial(long id_vyprob)
{
	this->results = new ChemicalLabTrialResults(this);
	this->trial_indication = LabTrial::indication::chemical;
	this->m_id_vyprob = id_vyprob;
}
#else
ChemicalLabTrial::ChemicalLabTrial()
{
	this->results = new ChemicalLabTrialResults(this);
	this->trial_indication = LabTrial::indication::chemical;
}
#endif

ChemicalLabTrialResults::ChemicalLabTrialResults(LabTrial * trial) : LabTrialResults(trial)
{
	m_zatorfovannost = ChemicalLabTrialResults::Zatorfovannost::undefined_zatorfovannost;
}
#if !USE_LAB_TRIALS_VECTOR
FractionsLabTrial::FractionsLabTrial()
{
#else
FractionsLabTrial::FractionsLabTrial(long id_vyprob)
{
	this->m_id_vyprob = id_vyprob;
#endif
	// количество фракций, 
	n_fractions = 0;
	// массив содержания фракций
	fractions_content = NULL;
	fractions_diameters = NULL;
		
	this->results = new FractionsLabTrialResults(this);
	this->trial_indication = LabTrial::indication::fractions;
}
FractionsLabTrialResults::FractionsLabTrialResults(LabTrial * trial) : LabTrialResults(trial)
{
}
#if !USE_LAB_TRIALS_VECTOR
CompressionLabTrial::CompressionLabTrial(CompressionLabTrial::type comtype)
{
#else
CompressionLabTrial::CompressionLabTrial(CompressionLabTrial::type comtype, long id_vyprob)
{
	this->m_id_vyprob = id_vyprob;
	id_phys_vyprob = 0;
#endif
	com_type = comtype;

	n_pressures = 0;
	absolute_deformations = NULL;

	this->results = new CompressionLabTrialResults(this, com_type);
	switch(com_type)
	{
	case CompressionLabTrial::type::nature_condition:
		{
			this->trial_indication = LabTrial::indication::compression_nature_condition_absolute_deformation;
			//id_phys_vyprob = this->lab_number->GetFizMehVyprobForCompress(this->m_id_vyprob, 1);
		}
		break;
	case CompressionLabTrial::type::task_condition:
		{
			this->trial_indication = LabTrial::indication::compression_task_condition_absolute_deformation;
			//id_phys_vyprob = this->lab_number->GetFizMehVyprobForCompress(this->m_id_vyprob, 2);
		}
		break;
	case CompressionLabTrial::type::shrinkage:
		{
			this->trial_indication = LabTrial::indication::compression_shrinkage_absolute_deformation;
			id_phys_vyprob = 1;
		}
		break;
	}
}
CompressionLabTrialResults::CompressionLabTrialResults(LabTrial * trial, CompressionLabTrial::type comtype) : LabTrialResults(trial), m_gurvich(this)
{
	this->com_type = comtype;

	zamachivanie = false;

	calc_e_log_interp = true;

	this->m_gurvich.SetParent(this);

}



#if USE_LAB_TRIALS_VECTOR
CompressionLabTrial3::CompressionLabTrial3(long id_vyprob)
{
	this->compression_passport_type = 0;
	this->otnosit_def_on_graph = true;

	this->m_id_vyprob = id_vyprob;

	p_trial_1 = new CompressionLabTrial(CompressionLabTrial::type::nature_condition, id_vyprob);
	p_trial_2 = new CompressionLabTrial(CompressionLabTrial::type::task_condition, id_vyprob);
	p_trial_3 = new CompressionLabTrial(CompressionLabTrial::type::shrinkage, id_vyprob);

	this->results = new CompressionLabTrialResults3(this);

	this->trial_indication = LabTrial::indication::compression_3;

	id_method = 0;
	this->zamach = false;

//	this->com_type = CompressionLabTrial::type::undefined;
}
#else
CompressionLabTrial3::CompressionLabTrial3()
{
	p_trial_1 = new CompressionLabTrial(CompressionLabTrial::type::nature_condition);
	p_trial_2 = new CompressionLabTrial(CompressionLabTrial::type::task_condition);
	p_trial_3 = new CompressionLabTrial(CompressionLabTrial::type::shrinkage);

	this->results = new CompressionLabTrialResults3(this);

	this->trial_indication = LabTrial::indication::compression_3;

	id_method = 0;
	this->zamach = false;

//	this->com_type = CompressionLabTrial::type::undefined;
}
#endif
void CompressionLabTrial3::SetLabNumber()
{
	if (p_trial_1) p_trial_1->SetLabNumber(this->GetLabNumber());
	if (p_trial_2) p_trial_2->SetLabNumber(this->GetLabNumber());
	if (p_trial_3) p_trial_3->SetLabNumber(this->GetLabNumber());
}


CompressionLabTrialResults3::CompressionLabTrialResults3(LabTrial * trial) : 
	LabTrialResults(trial)
{
	CompressionLabTrial3 * trial_3 = dynamic_cast<CompressionLabTrial3 *>(this->lab_trial);

	if (trial_3 && trial_3->p_trial_1  && trial_3->p_trial_2  && trial_3->p_trial_3 )
	{
		p_result_1 = dynamic_cast<CompressionLabTrialResults *>(trial_3->p_trial_1->results);
		p_result_2 = dynamic_cast<CompressionLabTrialResults *>(trial_3->p_trial_2->results);
		p_result_3 = dynamic_cast<CompressionLabTrialResults *>(trial_3->p_trial_3->results);
	}
	gurvich_shtamp_prosadka_calculed_po_dvum_krivym = false;
	gurvich_shtamp_prosadka_calculed_po_odnoj_krivoj = false;
	prosadka_calculed_po_dvum_krivym = false;
	prosadka_calculed_po_odnoj_krivoj = false;

	D2yDx2_calculed = false;
	gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_peregibu_vtoroj_krivoj_calculed = false;

	m_prosadochnost = CompressionLabTrialResults3::Prosadochnost::undefined_prosadocnist;
	m_nabuhanie = CompressionLabTrialResults3::Nabuhanie::undefined_nabuhanie;
}




#if !USE_LAB_TRIALS_VECTOR
CutLabTrial::CutLabTrial(CutLabTrial::type cuttype)
{
#else
CutLabTrial::CutLabTrial(CutLabTrial::type cuttype, long id_vyprob)
{
	this->m_id_vyprob = id_vyprob;
	cut_passport_type = 0;
#endif

	id_hid = -1;
	id_shema = -1;
	id_stan = -1;

	cut_type = cuttype;

	n_pressures = 0;
	cut_resistances = NULL;

	this->results = new CutLabTrialResults(this, cut_type);
	
	switch(cuttype)
	{
	case CutLabTrial::type::nature_condition:
		{
			this->trial_indication = LabTrial::indication::cut_resistance_nature_condition;
		}
		break;
	case CutLabTrial::type::task_condition:
		{
			this->trial_indication = LabTrial::indication::cut_resistance_task_condition;
		}
		break;

	}
}
CutLabTrialResults::CutLabTrialResults(LabTrial * trial, CutLabTrial::type cuttype) : LabTrialResults(trial)
{
	this->cut_type = cuttype;
}
#if !USE_LAB_TRIALS_VECTOR
PressingLabTrial::PressingLabTrial()
{
#else
PressingLabTrial::PressingLabTrial(long id_vyprob)
{
	this->m_id_vyprob = id_vyprob;
#endif
	for (int i = 0; i < 3; i++)
	{
		// нагрузки
		loads[i] = 0.0;
		// сечения
		sections[i] = 0.0;
	}
	this->results = new PressingLabTrialResults(this);
	this->trial_indication = LabTrial::indication::pressing;
}
PressingLabTrialResults::PressingLabTrialResults(LabTrial * trial) : LabTrialResults(trial)
{
}
#if !USE_LAB_TRIALS_VECTOR
FiltrationLabTrial::FiltrationLabTrial(FiltrationLabTrial::type filtrtype)
{
#else
FiltrationLabTrial::FiltrationLabTrial(FiltrationLabTrial::type filtrtype, long id_vyprob)
{
	this->m_id_vyprob = id_vyprob;
#endif
	filtr_type = filtrtype;

	for (int i = 0; i < 3; i++)
	{
		// нагрузки
		expenditures[i] = 0.0;
		// сечения
		densities[i] = 0.0;
	}
	this->results = new FiltrationLabTrialResults(this, filtr_type);
	switch(filtrtype)
	{
	case FiltrationLabTrial::type::with_pressures:
		{
			this->trial_indication = LabTrial::indication::filtration_coefficient_with_pressures;
		}
		break;	
	case FiltrationLabTrial::type::with_densities:
		{
			this->trial_indication = LabTrial::indication::filtration_coefficient_with_densities;
		}
		break;
	}
}
FiltrationLabTrialResults::FiltrationLabTrialResults(LabTrial * trial, FiltrationLabTrial::type filtrtype) : LabTrialResults(trial)
{
}
	
bool PhysicalLabTrial::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	v.trial = this;

	PhysicalLabTrial::value_type val_type = vt.vt_PhysicalLabTrial;
	switch(val_type)
	{
	case PhysicalLabTrial::value_type::vt_density_of_ground:
		{
			v = this->density_of_ground;
			if (*v.pf && v.v) return true;
		}
		break;
	case PhysicalLabTrial::value_type::vt_density_of_ground_particles:
		{
			v = this->density_of_ground_particles;
			if (*v.pf && v.v) return true;
		}
		break;
	case PhysicalLabTrial::value_type::vt_moisture_on_fluidity_border:
		{
			v = this->moisture_on_fluidity_border;
			if (*v.pf && v.v) return true;
		}
		break;
	case PhysicalLabTrial::value_type::vt_moisture_on_plasticity_border:
		{
			v = this->moisture_on_plasticity_border;
			if (*v.pf && v.v) return true;
		}
		break;
	case PhysicalLabTrial::value_type::vt_moisture_of_nature_large_exchange:
		{
			v = this->moisture_of_nature_large_exchange;
			if (*v.pf && v.v) return true;
		}
		break;
	case PhysicalLabTrial::value_type::vt_hygroscopic_moisture:
		{
			v = this->hygroscopic_moisture;
			if (*v.pf && v.v) return true;
		}
		break;
	case PhysicalLabTrial::value_type::vt_maximal_molecular_moisture_capacity:
		{
			v = this->maximal_molecular_moisture_capacity;
			if (*v.pf && v.v) return true;
		}
		break;
	case PhysicalLabTrial::value_type::vt_moisture_of_aggregate_sample:
		{
			v = this->moisture_of_aggregate_sample;
			if (*v.pf && v.v) return true;
		}
		break;
	}
	return false;
}

const char * PhysicalLabTrial::ValueTypeToString(PhysicalLabTrial::value_type vt)
{
	switch(vt)
	{
	case PhysicalLabTrial::value_type::vt_density_of_ground:        
		return "Плотность грунта, г/см3";
	case PhysicalLabTrial::value_type::vt_density_of_ground_particles:
		return "Плотность частиц грунта, г/см3";
	case PhysicalLabTrial::value_type::vt_moisture_on_fluidity_border:
		return "Влажность на границе текучести, д.е.";
	case PhysicalLabTrial::value_type::vt_moisture_on_plasticity_border:
		return "Влажность на границе раскатывания, д.е.";
	case PhysicalLabTrial::value_type::vt_moisture_of_nature_large_exchange:
		return "Влажность природного крупнообмена, д.е.";
	case PhysicalLabTrial::value_type::vt_hygroscopic_moisture:
		return "Гигроскопическая влажность, д.е.";
	case PhysicalLabTrial::value_type::vt_maximal_molecular_moisture_capacity:
		return "Максимальная молекулярная влагоёмкость, д.е.";
	case PhysicalLabTrial::value_type::vt_moisture_of_aggregate_sample:
		return "Влажность пробы заполнителя, д.е.";
	default:
		return "";
	}
	return "";
}

int PhysicalLabTrial::GetSignForReliabilityK(PhysicalLabTrial::value_type vt)
{
	switch(vt)
	{
	case PhysicalLabTrial::value_type::vt_density_of_ground:        
		return -1;//"Плотность грунта, г/см3";
	case PhysicalLabTrial::value_type::vt_density_of_ground_particles:
		return 0;//"Плотность частиц грунта, г/см3";
	case PhysicalLabTrial::value_type::vt_moisture_on_fluidity_border:
		return 0;//"Влажность на границе текучести";
	case PhysicalLabTrial::value_type::vt_moisture_on_plasticity_border:
		return 0;//"Влажность на границе раскатывания";
	case PhysicalLabTrial::value_type::vt_moisture_of_nature_large_exchange:
		return 0;//"Влажность природного крупнообмена";
	case PhysicalLabTrial::value_type::vt_hygroscopic_moisture:
		return 0;//"Гигроскопическая влажность";
	case PhysicalLabTrial::value_type::vt_maximal_molecular_moisture_capacity:
		return 0;//"Максимальная молекулярная влагоёмкость";
	case PhysicalLabTrial::value_type::vt_moisture_of_aggregate_sample:
		return 0;//"Влажность пробы заполнителя";
	default:
		return 0;
	}
	return 0;
}


void PhysicalLabTrial::PrintfProperties(void)
{
	printf("PhysicalLabTrial::PrintfProperties()\n");
	// влажность на границе текучести (доли ед.)                   .22
	printf("moisture_on_fluidity_border = %f\n", moisture_on_fluidity_border.v);
	// влажность на границе раскатывания (пластичности) (доли ед.)                .17
	printf("moisture_on_plasticity_border = %f\n", moisture_on_plasticity_border.v);
	// влажность природного крупнообмена
	printf("moisture_of_nature_large_exchange = %f\n", moisture_of_nature_large_exchange.v);
	// влажность пробы заполнителя
	printf("moisture_of_aggregate_sample = %f\n", moisture_of_aggregate_sample.v);
	// гигроскопическая влажность
	printf("hygroscopic_moisture = %f\n", hygroscopic_moisture.v);
	// максимальная молекулярная влагоёмкость
	printf("maximal_molecular_moisture_capacity = %f\n", maximal_molecular_moisture_capacity.v);
	// плотность частиц грунта,г/см3                   2.71
	printf("density_of_ground_particles = %f\n", density_of_ground_particles.v);
	// плотность грунта,г/см3                          2.00
	printf("density_of_ground = %f\n", density_of_ground.v);
}
void DeleteEndZeros(char * str);

void PhysicalLabTrial::PrintfProperties(vector<fmtstr> & text)
{
	char str[4098];
	sprintf(str, "Физические свойства (%s):", this->lab_number->GetPhysicalVyprobString(this->m_id_vyprob));
	text.push_back(fmtstr(str, NULL, true, false));

	PhysicalLabTrialResults * phys_res =  dynamic_cast<PhysicalLabTrialResults *>(this->results);
	
	if (LabNumber::context_with_results)
	{
		if (!phys_res) return;
		if (!phys_res->calculed)
			phys_res->CalcProperties();
	}

	if (moisture_on_fluidity_border.f && moisture_on_fluidity_border.v)
	{
		// влажность на границе текучести (доли ед.)                   .22
		sprintf(str, "Влажность на границе текучести ");
		text.push_back(fmtstr(str, NULL, false, true));

		sprintf(str, "%f\0", moisture_on_fluidity_border.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &moisture_on_fluidity_border.f, true, true));
	}

	if (moisture_on_plasticity_border.f && moisture_on_plasticity_border.v)
	{
		// влажность на границе раскатывания (пластичности) (доли ед.)                .17
		sprintf(str, "Влажность на границе раскатывания \0");
		text.push_back(fmtstr(str, NULL, false, true));

		sprintf(str, "%f\0", moisture_on_plasticity_border.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &moisture_on_plasticity_border.f, true, true));
	}

	if (moisture_of_nature_large_exchange.f && moisture_of_nature_large_exchange.v)
	{
		// влажность природного крупнообмена
		sprintf(str, "Влажность природная \0");
		text.push_back(fmtstr(str, NULL, false, true));

		sprintf(str, "%f\0", moisture_of_nature_large_exchange.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &moisture_of_nature_large_exchange.f, true, true));
	}

	if (moisture_of_aggregate_sample.f && moisture_of_aggregate_sample.v)
	{
		// влажность пробы заполнителя
		sprintf(str, "Влажность пробы заполнителя \0");
		text.push_back(fmtstr(str, NULL, false, true));

		sprintf(str, "%f\0", moisture_of_aggregate_sample.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &moisture_of_aggregate_sample.f, true, true));
	}

	if (hygroscopic_moisture.f && hygroscopic_moisture.v)
	{
		// гигроскопическая влажность
		sprintf(str, "Гигроскопическая влажность \0");
		text.push_back(fmtstr(str, NULL, false, true));

		sprintf(str, "%f\0", hygroscopic_moisture.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &hygroscopic_moisture.f, true, true));
	}

	if (maximal_molecular_moisture_capacity.f && maximal_molecular_moisture_capacity.v)
	{
		// максимальная молекулярная влагоёмкость
		sprintf(str, "Максимальная молекулярная влагоёмкость \0");
		text.push_back(fmtstr(str, NULL, false, true));
		
		sprintf(str, "%f\0", maximal_molecular_moisture_capacity.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &maximal_molecular_moisture_capacity.f, true, true));
	}

	if (density_of_ground_particles.f && density_of_ground_particles.v)
	{
		// плотность частиц грунта,г/см3                   2.71
		sprintf(str, "Плотность частиц грунта,г/см3 \0");
		text.push_back(fmtstr(str, NULL, false, true));
		
		sprintf(str, "%f\0", density_of_ground_particles.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &density_of_ground_particles.f, true, true));
	}

	if(density_of_ground.f && density_of_ground.v)
	{
		// плотность грунта,г/см3                          2.00
		sprintf(str, "Плотность грунта,г/см3 \0");
		text.push_back(fmtstr(str, NULL, false, true));

		sprintf(str, "%f\0", density_of_ground.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &density_of_ground.f, true, true));
	}
}

void PhysicalLabTrial::PrintfProperties(vector<LabData> & labdata)
{
	labdata.push_back(LabData());
	PrintfProperties(labdata.back().text);
}


//double PhysicalLabTrialResults::water_saturated_part_of_full_water_capacity = 0.95;
double PhysicalLabTrialResults::water_saturated_part_of_full_water_capacity = 1.00;
bool PhysicalLabTrialResults::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	v.trial = this;

	PhysicalLabTrialResults::value_type val_type = vt.vt_PhysicalLabTrialResults;
	switch(val_type)
	{
	case PhysicalLabTrialResults::value_type::vt_e:
		{
			v = this->e;
			if (*v.pf) return true;
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_water_full_capacity:
		{
			v = this->water_full_capacity;
			if (*v.pf) return true;
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_w_water_saturated:
		{
			v = this->w_water_saturated;
			if (*v.pf) return true;
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_lack_of_water_saturating:
		{
			v = this->lack_of_water_saturating;
			if (*v.pf) return true;
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_density_of_dry_ground:
		{
			v = this->density_of_dry_ground;
			if (*v.pf) return true;
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_density_of_water_saturated_ground:
		{
			v = this->density_of_water_saturated_ground;
			if (*v.pf) return true;
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_density_of_suspended_in_water_ground:
		{
			v = this->density_of_suspended_in_water_ground;
			if (*v.pf) return true;
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_n:
		{
			v = this->n;
			if (*v.pf) return true;
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_S:
		{
			v = this->S;
			if (*v.pf) return true;
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_vlazhnost:
		{
			v.v = (double)(int)this->m_sand_vlazhnost;
			v.pf = NULL;
			return true;
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_plasticity_index:
		{
			if (this->plasticity_index.v)
			{
				v = this->plasticity_index;
				if (*v.pf) return true;
			}
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_ground_type:
		{
			v.v = (double)this->t;
			v.pf = NULL;            
			return true;
		}
		break;	
	case PhysicalLabTrialResults::value_type::vt_fluidity_index_nature:
		{
			if (this->plasticity_index.v)
			{
				v = this->fluidity_index_nature;
				if (*v.pf) return true;
			}
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_fluidity_index_water_saturated:
		{
			if (this->plasticity_index.v)
			{
				v = this->fluidity_index_water_saturated;
				if (*v.pf) return true;
			}
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_Consistencia_nature:
		{
			v.v = (double)(int)this->m_Consistencia_nature;
			v.pf = NULL;
			if (v.v) return true;
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_Consistencia_water_saturated:
		{
			v.v = (double)(int)this->m_Consistencia_water_saturated;
			v.pf = NULL;
			if (v.v) return true;
		}
		break;

	case PhysicalLabTrialResults::value_type::vt_specific_gravity_of_ground_particles:
		{
			v = this->specific_gravity_of_ground_particles;
			if (*v.pf) return true;
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_specific_gravity_of_ground:
		{
			v = this->specific_gravity_of_ground;
			if (*v.pf) return true;
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_specific_gravity_of_dry_ground:
		{
			v = this->specific_gravity_of_dry_ground;
			if (*v.pf) return true;
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_specific_gravity_of_water_saturated_ground:
		{
			v = this->specific_gravity_of_water_saturated_ground;
			if (*v.pf) return true;
		}
		break;
	case PhysicalLabTrialResults::value_type::vt_specific_gravity_of_suspended_in_water_ground:
		{
			v = this->specific_gravity_of_suspended_in_water_ground;
			if (*v.pf) return true;
		}
		break;
	}
	return false;
}	
const char * PhysicalLabTrialResults::SandVlazhnostToString(PhysicalLabTrialResults::SandVlazhnost vzh)
{
	switch(CGround::s_Quantity)
	{
	case CGround::Quantity::singular:
		{
			switch(vzh)
			{
			case PhysicalLabTrialResults::SandVlazhnost::malovlazhnyj:
				return "маловлажный";
			case PhysicalLabTrialResults::SandVlazhnost::vlazhnyj:
				return "влажный";
			case PhysicalLabTrialResults::SandVlazhnost::nasyschennyj_vodoj:
				return "насыщенный водой";
			default:
				return "";
			}
		}
		break;
	case CGround::Quantity::plural:
		{
			switch(vzh)
			{
			case PhysicalLabTrialResults::SandVlazhnost::malovlazhnyj:
				return "маловлажные";
			case PhysicalLabTrialResults::SandVlazhnost::vlazhnyj:
				return "влажные";
			case PhysicalLabTrialResults::SandVlazhnost::nasyschennyj_vodoj:
				return "насыщенные водой";
			default:
				return "";
			}
		}
		break;
	}
	return "";
}
const char * PhysicalLabTrialResults::SandVlazhnostToStringSmall(PhysicalLabTrialResults::SandVlazhnost vzh)
{
	switch(vzh)
	{
	case PhysicalLabTrialResults::SandVlazhnost::malovlazhnyj:
		return "маловлаж";
	case PhysicalLabTrialResults::SandVlazhnost::vlazhnyj:
		return "влажн";
	case PhysicalLabTrialResults::SandVlazhnost::nasyschennyj_vodoj:
		return "нас.вод.";
	default:
		return "";
	}
	return "";
}

const char * PhysicalLabTrialResults::ValueTypeToString(PhysicalLabTrialResults::value_type vt)
{
	switch(vt)
	{
	case PhysicalLabTrialResults::value_type::vt_e:
		return "Коэффициент пористости";
	case PhysicalLabTrialResults::value_type::vt_water_full_capacity:
		return "Полная влагоёмкость";
	case PhysicalLabTrialResults::value_type::vt_w_water_saturated:
		return "Влажность водонасыщения";
	case PhysicalLabTrialResults::value_type::vt_lack_of_water_saturating:
		return "Недостаток водонасыщения";
	case PhysicalLabTrialResults::value_type::vt_density_of_dry_ground:
		return "Плотность сухого грунта, г/см3";
	case PhysicalLabTrialResults::value_type::vt_density_of_water_saturated_ground:
		return "Плотность водонасыщенного грунта, г/см3";
	case PhysicalLabTrialResults::value_type::vt_density_of_suspended_in_water_ground:
		return "Плотность взвешенного в воде грунта, г/см3";
	case PhysicalLabTrialResults::value_type::vt_n:
		return "Пористость";
	case PhysicalLabTrialResults::value_type::vt_S:
		return "Степень влажности";
	case PhysicalLabTrialResults::value_type::vt_vlazhnost:
		return "Влажность";
	case PhysicalLabTrialResults::value_type::vt_plasticity_index:
		return "Число пластичности";
	case PhysicalLabTrialResults::value_type::vt_ground_type:
		return "Тип грунта";
	case PhysicalLabTrialResults::value_type::vt_fluidity_index_nature:
		return "Показатель текучести (природн.)";
	case PhysicalLabTrialResults::value_type::vt_fluidity_index_water_saturated:
		return "Показатель текучести (водонас.)";

	case PhysicalLabTrialResults::value_type::vt_Consistencia_nature:
		return "Консистенция (природн.)";

	case PhysicalLabTrialResults::value_type::vt_Consistencia_water_saturated:
		return "Консистенция (водонас.)";

	case PhysicalLabTrialResults::value_type::vt_specific_gravity_of_ground_particles:
		return "Удельный вес частиц грунта, кН/м3";
	case PhysicalLabTrialResults::value_type::vt_specific_gravity_of_ground:
		return "Удельный вес грунта, кН/м3";
	case PhysicalLabTrialResults::value_type::vt_specific_gravity_of_dry_ground:
		return "Удельный вес сухого грунта, кН/м3";
	case PhysicalLabTrialResults::value_type::vt_specific_gravity_of_water_saturated_ground:
		return "Удельный вес водонасыщенного грунта, кН/м3";
	case PhysicalLabTrialResults::value_type::vt_specific_gravity_of_suspended_in_water_ground:
		return "Удельный вес взвешенного в воде грунта, кН/м3";

	default:
		return "";
	}
	return "";

}	
int PhysicalLabTrialResults::GetSignForReliabilityK(PhysicalLabTrialResults::value_type vt)
{
	switch(vt)
	{
	case PhysicalLabTrialResults::value_type::vt_e:
		return 1;//"Коэффициент пористости";
	case PhysicalLabTrialResults::value_type::vt_water_full_capacity:
		return 0;//"Полная влагоёмкость";
	case PhysicalLabTrialResults::value_type::vt_w_water_saturated:
		return 0;//"Влажность водонасыщения";
	case PhysicalLabTrialResults::value_type::vt_lack_of_water_saturating:
		return 0;//"Недостаток водонасыщения";
	case PhysicalLabTrialResults::value_type::vt_density_of_dry_ground:
		return 0;//"Плотность сухого грунта";
	case PhysicalLabTrialResults::value_type::vt_density_of_water_saturated_ground:
		return -1;//"Плотность водонасыщенного грунта";
	case PhysicalLabTrialResults::value_type::vt_density_of_suspended_in_water_ground:
		return -1;//"Плотность взвешенного в воде грунта";
	case PhysicalLabTrialResults::value_type::vt_n:
		return 0;//"Пористость";
	case PhysicalLabTrialResults::value_type::vt_S:
		return 0;//"Степень влажности";
	case PhysicalLabTrialResults::value_type::vt_plasticity_index:
		return 0;//"Число пластичности";
	case PhysicalLabTrialResults::value_type::vt_ground_type:
		return 0;//"Тип грунта";
	case PhysicalLabTrialResults::value_type::vt_fluidity_index_nature:
		return 0;//"Показатель текучести (природн.)";
	case PhysicalLabTrialResults::value_type::vt_fluidity_index_water_saturated:
		return 0;//"Показатель текучести (водонас.)";

	case PhysicalLabTrialResults::value_type::vt_specific_gravity_of_ground_particles:
		return 0;//"Удельный вес частиц грунта";
	case PhysicalLabTrialResults::value_type::vt_specific_gravity_of_ground:
		return -1;//"Удельный вес грунта";
	case PhysicalLabTrialResults::value_type::vt_specific_gravity_of_dry_ground:
		return -1;//"Удельный вес сухого грунта";
	case PhysicalLabTrialResults::value_type::vt_specific_gravity_of_water_saturated_ground:
		return -1;//"Удельный вес водонасыщенного грунта";
	case PhysicalLabTrialResults::value_type::vt_specific_gravity_of_suspended_in_water_ground:
		return -1;//"Удельный вес взвешенного в воде грунта";
	default:
		return 0;
	}
	return 0;
}	
CGround::ground_type DefineGroundType(double plasticity_index)
{
	// определяем тип грунта
	CGround::ground_type t = CGround::ground_type::Undefined_ground;
	if (plasticity_index < 0.01)
		t = CGround::ground_type::Sand;
	if (plasticity_index >= 0.01 && plasticity_index <= 0.07)
		t = CGround::ground_type::SandyLoam;
	else if (plasticity_index > 0.07 && plasticity_index <= 0.17)
		t = CGround::ground_type::Loam;
	else if (plasticity_index > 0.17)
		t = CGround::ground_type::Clay;

	return t;
}

PhysicalLabTrialResults::Consistencia Define_SandyLoam_Consistencia(double fluidity_index)
{
	PhysicalLabTrialResults::Consistencia con = PhysicalLabTrialResults::Consistencia::undefined_cons;
	if (fluidity_index < 0.0)
	{
		con = PhysicalLabTrialResults::Consistencia::tverdaya;
	}
	else if (0.0 <= fluidity_index && fluidity_index <= 1.0)
	{
		con = PhysicalLabTrialResults::Consistencia::plastichnaya;
	}
	else
	{
		con = PhysicalLabTrialResults::Consistencia::tekuchaya;
	}
	return con;
}

PhysicalLabTrialResults::Consistencia Define_ClayAndLoam_Consistencia(double fluidity_index)
{
	PhysicalLabTrialResults::Consistencia con = PhysicalLabTrialResults::Consistencia::undefined_cons;
	if (fluidity_index < 0.0)
	{
		con = PhysicalLabTrialResults::Consistencia::tverdye;
	}
	else if (0.0 <= fluidity_index && fluidity_index <= 0.25)
	{
		con = PhysicalLabTrialResults::Consistencia::polutverdye;
	}	
	else if (0.25 <= fluidity_index && fluidity_index <= 0.50)
	{
		con = PhysicalLabTrialResults::Consistencia::tugoplastichnye;
	}
	else if (0.50 <= fluidity_index && fluidity_index <= 0.75)
	{
		con = PhysicalLabTrialResults::Consistencia::myagkoplastichye;
	}
	else if (0.75 <= fluidity_index && fluidity_index <= 1.0)
	{
		con = PhysicalLabTrialResults::Consistencia::tekucheplastichnye;
	}
	else
	{
		con = PhysicalLabTrialResults::Consistencia::tekuchie;
	}
	return con;
}
const char * PhysicalLabTrialResults::ConsistenciaToString(PhysicalLabTrialResults::Consistencia con)
{
	switch(CGround::s_Quantity)
	{
	case CGround::Quantity::singular:
		{
			switch (CGround::s_Gender)
			{
			case CGround::Gender::male:
				{
					switch (con)
					{
						// Супесь - консистенция
					case PhysicalLabTrialResults::Consistencia::tverdaya:
						return "твёрдая";
					case PhysicalLabTrialResults::Consistencia::plastichnaya:
						return "пластичная";
					case PhysicalLabTrialResults::Consistencia::tekuchaya:
						return "текучая";

						// Суглинок и глина - консистенция
					case PhysicalLabTrialResults::Consistencia::tverdye:
						return "твёрдый";
					case PhysicalLabTrialResults::Consistencia::polutverdye:
						return "полутвёрдый";
					case PhysicalLabTrialResults::Consistencia::tugoplastichnye:
						return "тугопластичный";
					case PhysicalLabTrialResults::Consistencia::myagkoplastichye:
						return "мягкопластичный";
					case PhysicalLabTrialResults::Consistencia::tekucheplastichnye:
						return "текучепластичный";
					case PhysicalLabTrialResults::Consistencia::tekuchie:
						return "текучий";

					default:
						return "";
					}
				}
				break;
			case CGround::Gender::female:
				{
					switch (con)
					{
						// Супесь - консистенция
					case PhysicalLabTrialResults::Consistencia::tverdaya:
						return "твёрдая";
					case PhysicalLabTrialResults::Consistencia::plastichnaya:
						return "пластичная";
					case PhysicalLabTrialResults::Consistencia::tekuchaya:
						return "текучая";

						// Суглинок и глина - консистенция
					case PhysicalLabTrialResults::Consistencia::tverdye:
						return "твёрдая";
					case PhysicalLabTrialResults::Consistencia::polutverdye:
						return "полутвёрдая";
					case PhysicalLabTrialResults::Consistencia::tugoplastichnye:
						return "тугопластичная";
					case PhysicalLabTrialResults::Consistencia::myagkoplastichye:
						return "мягкопластичная";
					case PhysicalLabTrialResults::Consistencia::tekucheplastichnye:
						return "текучепластичная";
					case PhysicalLabTrialResults::Consistencia::tekuchie:
						return "текучая";

					default:
						return "";
					}
				}
				break;
			case CGround::Gender::middle:
				{
					switch (con)
					{
						// Супесь - консистенция
					case PhysicalLabTrialResults::Consistencia::tverdaya:
						return "твёрдое";
					case PhysicalLabTrialResults::Consistencia::plastichnaya:
						return "пластичное";
					case PhysicalLabTrialResults::Consistencia::tekuchaya:
						return "текучее";

						// Суглинок и глина - консистенция
					case PhysicalLabTrialResults::Consistencia::tverdye:
						return "твёрдое";
					case PhysicalLabTrialResults::Consistencia::polutverdye:
						return "полутвёрдое";
					case PhysicalLabTrialResults::Consistencia::tugoplastichnye:
						return "тугопластичное";
					case PhysicalLabTrialResults::Consistencia::myagkoplastichye:
						return "мягкопластичное";
					case PhysicalLabTrialResults::Consistencia::tekucheplastichnye:
						return "текучепластичное";
					case PhysicalLabTrialResults::Consistencia::tekuchie:
						return "текучее";

					default:
						return "";
					}
				}
				break;
			}
		}
		break;
	case CGround::Quantity::plural:
		{
			switch (con)
			{
				// Супесь - консистенция
			case PhysicalLabTrialResults::Consistencia::tverdaya:
				return "твёрдые";
			case PhysicalLabTrialResults::Consistencia::plastichnaya:
				return "пластичные";
			case PhysicalLabTrialResults::Consistencia::tekuchaya:
				return "текучие";

				// Суглинок и глина - консистенция
			case PhysicalLabTrialResults::Consistencia::tverdye:
				return "твёрдые";
			case PhysicalLabTrialResults::Consistencia::polutverdye:
				return "полутвёрдые";
			case PhysicalLabTrialResults::Consistencia::tugoplastichnye:
				return "тугопластичные";
			case PhysicalLabTrialResults::Consistencia::myagkoplastichye:
				return "мягкопластичные";
			case PhysicalLabTrialResults::Consistencia::tekucheplastichnye:
				return "текучепластичные";
			case PhysicalLabTrialResults::Consistencia::tekuchie:
				return "текучие";

			default:
				return "";
			}
		}
		break;
	}
	return "";
}
const char * PhysicalLabTrialResults::ConsistenciaToStringSmall(PhysicalLabTrialResults::Consistencia con)
{
	switch (con)
	{
	case PhysicalLabTrialResults::Consistencia::tverdaya:
		return "твёрд.";
	case PhysicalLabTrialResults::Consistencia::plastichnaya:
		return "пласт.";
	case PhysicalLabTrialResults::Consistencia::tekuchaya:
		return "текуч.";

	case PhysicalLabTrialResults::Consistencia::tverdye:
		return "твёрд.";
	case PhysicalLabTrialResults::Consistencia::polutverdye:
		return "полутв.";
	case PhysicalLabTrialResults::Consistencia::tugoplastichnye:
		return "тугопл.";
	case PhysicalLabTrialResults::Consistencia::myagkoplastichye:
		return "мягкопл.";
	case PhysicalLabTrialResults::Consistencia::tekucheplastichnye:
		return "текучепл.";
	case PhysicalLabTrialResults::Consistencia::tekuchie:
		return "текуч.";

	default:
		return "";
	}
	return "";
}

void PhysicalLabTrialResults::CalcProperties()
{
	this->Init();
	PhysicalLabTrial * phys =  dynamic_cast<PhysicalLabTrial *>(this->lab_trial);

	if (phys &&
		phys->density_of_ground.f && phys->density_of_ground_particles.f
		//влажность природного крупнообмена
		&& phys->moisture_of_nature_large_exchange.f
		)
	{
		//коэффициент пористости					
		e = (1.0 + phys->moisture_of_nature_large_exchange) * (phys->density_of_ground_particles / phys->density_of_ground) - 1.0;

		double density_of_water = 1.0; // плотность воды г/см3
		// Полная влагоёмкость
		water_full_capacity = e * density_of_water / phys->density_of_ground_particles;

		// Влажность водонасыщения
		w_water_saturated = PhysicalLabTrialResults::water_saturated_part_of_full_water_capacity * water_full_capacity;
		if (w_water_saturated < phys->moisture_of_nature_large_exchange)
			w_water_saturated = phys->moisture_of_nature_large_exchange;

		// Недостаток водонасыщения
		lack_of_water_saturating = w_water_saturated - phys->moisture_of_nature_large_exchange;

		// влажность
		/*
		double W = phys->moisture_of_nature_large_exchange;
		*/

		// плотность сухого грунта
		density_of_dry_ground = phys->density_of_ground / (1.0 + phys->moisture_of_nature_large_exchange);


		// плотность водонасыщенного грунта
		density_of_water_saturated_ground = density_of_dry_ground  * (1.0 + w_water_saturated);

		//плотность взвешенного в воде грунта
		density_of_suspended_in_water_ground = (phys->density_of_ground_particles - density_of_water) / (1.0 + e);

		//пористость (объём пор в единице объёма грунта)
		n = 1.0 - density_of_dry_ground / phys->density_of_ground_particles;


		//степень влажности 
		S = phys->moisture_of_nature_large_exchange * phys->density_of_ground_particles
			/ (e * density_of_water);

		if (S < 0.5)
		{
			this->m_sand_vlazhnost = PhysicalLabTrialResults::SandVlazhnost::malovlazhnyj;
		}
		else if (0.5 <= S && S < 0.8 )
		{
			this->m_sand_vlazhnost = PhysicalLabTrialResults::SandVlazhnost::vlazhnyj;
		}
		else
		{
			this->m_sand_vlazhnost = PhysicalLabTrialResults::SandVlazhnost::nasyschennyj_vodoj;
		}

		double g = 9.80665;

		// удельный вес частиц грунта,г/см3                   2.71
		specific_gravity_of_ground_particles = g * phys->density_of_ground_particles;
		// удельный вес грунта,г/см3                          2.00
		specific_gravity_of_ground = g * phys->density_of_ground;
		// удельный вес сухого грунта
		specific_gravity_of_dry_ground = g * this->density_of_dry_ground;
		// удельный вес водонасыщенного грунта
		specific_gravity_of_water_saturated_ground = g * this->density_of_water_saturated_ground;
		// удельный вес взвешенного в воде грунта
		specific_gravity_of_suspended_in_water_ground = g * this->density_of_suspended_in_water_ground;
	}

	if (		
		// влажность на границе текучести (доли ед.)                   .22
		phys->moisture_on_fluidity_border.f
		// влажность на границе раскатывания (пластичности) (доли ед.)                .17
		&& phys->moisture_on_plasticity_border.f)
	{
		// число пластичности						
		plasticity_index = phys->moisture_on_fluidity_border - phys->moisture_on_plasticity_border;
		// определяем тип грунта
		t = DefineGroundType(plasticity_index.v);

		if (
			//влажность природного крупнообмена
			phys->moisture_of_nature_large_exchange.f)
		{
			// показатель текучести fluidity_index
			fluidity_index_nature = 
				(phys->moisture_of_nature_large_exchange - phys->moisture_on_plasticity_border)
				/
				(phys->moisture_on_fluidity_border - phys->moisture_on_plasticity_border);
		}

		if (w_water_saturated.f)
		{
			fluidity_index_water_saturated = 
				(w_water_saturated - phys->moisture_on_plasticity_border)
				/
				(phys->moisture_on_fluidity_border - phys->moisture_on_plasticity_border);
		}

		switch (t)
		{
		case CGround::ground_type::SandyLoam:
			{
				if (fluidity_index_nature.f)
					this->m_Consistencia_nature = 
					Define_SandyLoam_Consistencia(fluidity_index_nature.v);
				if (fluidity_index_water_saturated.f)
					this->m_Consistencia_water_saturated = 
					Define_SandyLoam_Consistencia(fluidity_index_water_saturated.v);
			}
			break;
		case CGround::ground_type::Loam:
		case CGround::ground_type::Clay:
			{
				if (fluidity_index_nature.f)
					this->m_Consistencia_nature = 
					Define_ClayAndLoam_Consistencia(fluidity_index_nature.v);
				if (fluidity_index_water_saturated.f)
					this->m_Consistencia_water_saturated = 
					Define_ClayAndLoam_Consistencia(fluidity_index_water_saturated.v);
			}
			break;
		}
	}
	else
	{
		t = CGround::ground_type::Sand;
	}
	
	this->calculed = true;
}

void PhysicalLabTrialResults::PrintfProperties(vector<fmtstr> & text)
{
	char str[1024]; 
	//string s;		
	PhysicalLabTrial * phys =  dynamic_cast<PhysicalLabTrial *>(this->lab_trial);
	if (phys)
	{
		sprintf(str, "Наименование грунта \0");
		text.push_back(fmtstr(str, NULL, false, true));
		CGround::s_Quantity = CGround::Quantity::singular;
		sprintf(str, "%s\0",  CGround::GrountTypeToStringRus(t));
		text.push_back(fmtstr(str, NULL, true, true));	


		if (density_of_dry_ground.f && density_of_dry_ground.v)
		{
			// плотность сухого грунта
			sprintf(str, "Плотность сухого грунта \0");
			text.push_back(fmtstr(str, NULL, false, true));
			sprintf(str, "%f\0", density_of_dry_ground.v);
			DeleteEndZeros(str);
			text.push_back(fmtstr(str, &density_of_dry_ground.f, true, true));
		}

		if (density_of_water_saturated_ground.f && density_of_water_saturated_ground.v)
		{
			// плотность водонасыщенного грунта
			sprintf(str, "Плотность водонасыщенного грунта \0");
			text.push_back(fmtstr(str, NULL, false, true));
			sprintf(str, "%f\0", density_of_water_saturated_ground.v);
			DeleteEndZeros(str);
			text.push_back(fmtstr(str, &density_of_water_saturated_ground.f, true, true));
		}

		if (density_of_suspended_in_water_ground.f && density_of_suspended_in_water_ground.v)
		{
			//плотность взвешенного в воде грунта
			sprintf(str, "Плотность взвешенного в воде грунта \0");
			text.push_back(fmtstr(str, NULL, false, true));
			sprintf(str, "%f\0", density_of_suspended_in_water_ground.v);
			DeleteEndZeros(str);
			text.push_back(fmtstr(str, &density_of_suspended_in_water_ground.f, true, true));
		}

		if (		
			this->plasticity_index.f && this->plasticity_index.v &&
			// влажность на границе текучести (доли ед.)                   .22
			phys->moisture_on_fluidity_border.f
			// влажность на границе раскатывания (пластичности) (доли ед.)                .17
			&& phys->moisture_on_plasticity_border.f)
		{

			if (plasticity_index.f && plasticity_index.v)
			{
				sprintf(str, "Число пластичности \0");
				text.push_back(fmtstr(str, NULL, false, true));
				sprintf(str, "%f\0", plasticity_index.v);
				DeleteEndZeros(str);
				text.push_back(fmtstr(str, &plasticity_index.f, true, true));
			}

			if (fluidity_index_nature.f && fluidity_index_nature.v)
			{
				// показатель текучести fluidity_index
				sprintf(str, "Показатель текучести в природ. сост. \0");
				text.push_back(fmtstr(str, NULL, false, true));		
				sprintf(str, "%f\0", fluidity_index_nature.v);
				DeleteEndZeros(str);
				text.push_back(fmtstr(str, &fluidity_index_nature.f, true, true));	
			}

			if (fluidity_index_water_saturated.f && fluidity_index_water_saturated.v)
			{
				sprintf(str, "Показатель текучести водонас. \0");
				text.push_back(fmtstr(str, NULL, false, true));		
				sprintf(str, "%f\0", fluidity_index_water_saturated.v);
				DeleteEndZeros(str);
				text.push_back(fmtstr(str, &fluidity_index_water_saturated.f, true, true));		
			}

			switch (t)
			{
			case CGround::ground_type::SandyLoam:
				{
					if (fluidity_index_nature.f)
					{
						sprintf(str, "Консистенция супеси природной влажности \0");
						text.push_back(fmtstr(str, NULL, false, true));		
						sprintf(str, "%s\0", ConsistenciaToString(this->m_Consistencia_nature));
						text.push_back(fmtstr(str, &fluidity_index_nature.f, true, true));	
					}

					if (fluidity_index_water_saturated.f)
					{
						sprintf(str, "Консистенция супеси в водонасыщенном состоянии \0");
						text.push_back(fmtstr(str, NULL, false, true));		
						sprintf(str, "%s\0", ConsistenciaToString(this->m_Consistencia_water_saturated));
						text.push_back(fmtstr(str, &fluidity_index_water_saturated.f, true, true));	
					}
				}
				break;
			case CGround::ground_type::Loam:
			case CGround::ground_type::Clay:
				{
					const char * s;

					switch(t)
					{
					case CGround::ground_type::Loam:
						s = "суглинка";
						break;
					case CGround::ground_type::Clay:
						s = "глины";
						break;
					}

					if (fluidity_index_nature.f)
					{
						sprintf(str, "Консистенция %s природной влажности \0", s);
						text.push_back(fmtstr(str, NULL, false, true));		
						sprintf(str, "%s\0", ConsistenciaToString(this->m_Consistencia_nature));
						text.push_back(fmtstr(str, &fluidity_index_nature.f, true, true));	
					}

					if (fluidity_index_water_saturated.f)
					{
						sprintf(str, "Консистенция %s в водонасыщенном состоянии \0", s);
						text.push_back(fmtstr(str, NULL, false, true));		
						sprintf(str, "%s\0", ConsistenciaToString(this->m_Consistencia_water_saturated));
						text.push_back(fmtstr(str, &fluidity_index_water_saturated.f, true, true));	
					}
				}
				break;
			}

	


		}

		if (n.f && n.v)
		{		
			//пористость					
			sprintf(str, "Пористость \0");
			text.push_back(fmtstr(str, NULL, false, true));
			sprintf(str, "%f\0", n.v);
			DeleteEndZeros(str);
			text.push_back(fmtstr(str, &n.f, true, true));
		}

		if (e.f && e.v)
		{
			//коэффициент пористости					
			sprintf(str, "Коэффициент пористости \0");
			text.push_back(fmtstr(str, NULL, false, true));
			sprintf(str, "%f\0", e.v);
			DeleteEndZeros(str);
			text.push_back(fmtstr(str, &e.f, true, true));
		}

		if (w_water_saturated.f)
		{
			// Влажность водонасыщения
			sprintf(str, "Влажность водонасыщения \0");
			text.push_back(fmtstr(str, NULL, false, true));
			sprintf(str, "%f\0", w_water_saturated.v);
			DeleteEndZeros(str);
			text.push_back(fmtstr(str, &w_water_saturated.f, true, true));
		}

		if (water_full_capacity.f)
		{
			// Полная влагоёмкость
			sprintf(str, "Полная влагоёмкость \0");
			text.push_back(fmtstr(str, NULL, false, true));
			sprintf(str, "%f\0", water_full_capacity.v);
			DeleteEndZeros(str);
			text.push_back(fmtstr(str, &water_full_capacity.f, true, true));
		}

		if (S.f)
		{
			//степень влажности 
			sprintf(str, "Степень влажности \0");
			text.push_back(fmtstr(str, NULL, false, true));
			sprintf(str, "%f\0", S.v);
			DeleteEndZeros(str);
			text.push_back(fmtstr(str, &S.f, true, true));

			//степень влажности 
			sprintf(str, "Влажность \0");
			text.push_back(fmtstr(str, NULL, false, true));
			sprintf(str, "%s\0", PhysicalLabTrialResults::SandVlazhnostToString(this->m_sand_vlazhnost));
			DeleteEndZeros(str);
			text.push_back(fmtstr(str, &S.f, true, true));
		}

		if (lack_of_water_saturating.f)
		{
			// Недостаток водонасыщения
			sprintf(str, "Недостаток водонасыщения \0");
			text.push_back(fmtstr(str, NULL, false, true));
			sprintf(str, "%f\0", lack_of_water_saturating.v);
			DeleteEndZeros(str);
			text.push_back(fmtstr(str, &lack_of_water_saturating.f, true, true));
		}

		if (specific_gravity_of_ground_particles.f && specific_gravity_of_ground_particles.v)
		{
			// Удельный вес частиц грунта
			sprintf(str, "Удельный вес частиц грунта\0");
			text.push_back(fmtstr(str, NULL, false, true));
			sprintf(str, "%f\0", specific_gravity_of_ground_particles.v);
			DeleteEndZeros(str);
			text.push_back(fmtstr(str, &specific_gravity_of_ground_particles.f, true, true));
		}

		if (specific_gravity_of_ground.f && specific_gravity_of_ground.v)
		{		
			// Удельный вес грунта
			sprintf(str, "Удельный вес грунта\0");
			text.push_back(fmtstr(str, NULL, false, true));
			sprintf(str, "%f\0", specific_gravity_of_ground.v);
			DeleteEndZeros(str);
			text.push_back(fmtstr(str, &specific_gravity_of_ground.f, true, true));
		}

		if (specific_gravity_of_dry_ground.f && specific_gravity_of_dry_ground.v)
		{
			// Удельный вес сухого грунта
			sprintf(str, "Удельный вес сухого грунта\0");
			text.push_back(fmtstr(str, NULL, false, true));
			sprintf(str, "%f\0", specific_gravity_of_dry_ground.v);
			DeleteEndZeros(str);
			text.push_back(fmtstr(str, &specific_gravity_of_dry_ground.f, true, true));
		}

		if (specific_gravity_of_water_saturated_ground.f && specific_gravity_of_water_saturated_ground.v)
		{
			// Удельный вес водонасыщенного грунта
			sprintf(str, "Удельный вес водонасыщенного грунта\0");
			text.push_back(fmtstr(str, NULL, false, true));
			sprintf(str, "%f\0", specific_gravity_of_water_saturated_ground.v);
			DeleteEndZeros(str);
			text.push_back(fmtstr(str, &specific_gravity_of_water_saturated_ground.f, true, true));
		}

		if (specific_gravity_of_suspended_in_water_ground.f && specific_gravity_of_suspended_in_water_ground.v)
		{		
			// Удельный вес взвешенного в воде грунта
			sprintf(str, "Удельный вес взвешенного в воде грунта\0");
			text.push_back(fmtstr(str, NULL, false, true));
			sprintf(str, "%f\0", specific_gravity_of_suspended_in_water_ground.v);
			DeleteEndZeros(str);
			text.push_back(fmtstr(str, &specific_gravity_of_suspended_in_water_ground.f, true, true));
		}
	}
}
void PhysicalLabTrialResults::PrintfProperties(vector<LabData> & labdata)
{
	labdata.push_back(LabData());
	this->PrintfProperties(labdata.back().text);
}

void PhysicalLabTrial::Properties(void)
{
	/*printf("PhysicalLabTrial::PrintfProperties()\n");
	// влажность на границе текучести (доли ед.)                   .22
	printf("moisture_on_fluidity_border = %f\n", moisture_on_fluidity_border);
	// влажность на границе раскатывания (пластичности) (доли ед.)                .17
	printf("moisture_on_plasticity_border = %f\n", moisture_on_plasticity_border);
	// влажность природного крупнообмена
	printf("moisture_of_nature_large_exchange = %f\n", moisture_of_nature_large_exchange);
	// влажность пробы заполнителя
	printf("moisture_of_aggregate_sample = %f\n", moisture_of_aggregate_sample);
	// гигроскопическая влажность
	printf("hygroscopic_moisture = %f\n", hygroscopic_moisture);
	// максимальная молекулярная влагоёмкость
	printf("maximal_molecular_moisture_capacity = %f\n", maximal_molecular_moisture_capacity);
	// плотность частиц грунта,г/см3                   2.71
	printf("density_of_ground_particles = %f\n", density_of_ground_particles);
	// плотность грунта,г/см3                          2.00
	printf("density_of_ground = %f\n", density_of_ground);*/
}

bool ChemicalLabTrial::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	v.trial = this;

	ChemicalLabTrial::value_type val_type = vt.vt_ChemicalLabTrial;
	switch(val_type)
	{
	case ChemicalLabTrial::value_type::vt_common_salts_content:
		{
			// общее содержание солей
			v = this->common_salts_content;
			if (*v.pf && v.v) return true;
		}
		break;
	case ChemicalLabTrial::value_type::vt_well_solutable_salts:
		{
			// легкорастворимые соли
			v = this->well_solutable_salts;
			if (*v.pf && v.v) return true;
		}
		break;
	case ChemicalLabTrial::value_type::vt_vegetable_remains_content:
		{
			// содержание растительных остатков
			v = this->vegetable_remains_content;
			if (*v.pf && v.v) return true;
		}
		break;
	case ChemicalLabTrial::value_type::vt_organic_matters:
		{
			// органические вещества
			v = this->organic_matters;
			if (*v.pf && v.v) return true;
		}
		break;
	case ChemicalLabTrial::value_type::vt_pH:
		{
			// водородный показатель
			v = this->pH;
			if (*v.pf && v.v) return true;
		}
		break;
	case ChemicalLabTrial::value_type::vt_steel_mass_loss:
		{
			// потери массы стали
			v = this->steel_mass_loss;
			if (*v.pf && v.v) return true;
		}
		break;
	case ChemicalLabTrial::value_type::vt_nitrogenic_matters:
		{
			// азотистые вещества
			v = this->nitrogenic_matters;
			if (*v.pf && v.v) return true;
		}
		break;
	case ChemicalLabTrial::value_type::vt_Cl_ion:
		{
			// хлор ион
			v = this->Cl_ion;
			if (*v.pf && v.v) return true;
		}
		break;
	case ChemicalLabTrial::value_type::vt_Fe_ion:
		{
			// ион железа
			v = this->Fe_ion;
			if (*v.pf && v.v) return true;
		}
		break;
	case ChemicalLabTrial::value_type::vt_gips:
		{
			// Гипс %
			v = this->gips;
			if (*v.pf && v.v) return true;
		}
		break;
	case ChemicalLabTrial::value_type::vt_carbonats:
		{
			// карбонаты %
			v = this->carbonats;
			if (*v.pf && v.v) return true;
		}
		break;
	case ChemicalLabTrial::value_type::vt_gumus:
		{
			// гумус %
			v = this->gumus;
			if (*v.pf && v.v) return true;
		}
		break;
	}
	return false;
}
const char * ChemicalLabTrial::ValueTypeToString(ChemicalLabTrial::value_type vt)
{
	switch(vt)
	{
	case ChemicalLabTrial::value_type::vt_common_salts_content:
		return "Общее содержание солей";
	case ChemicalLabTrial::value_type::vt_well_solutable_salts:
		return "Легкорастворимые соли";
	case ChemicalLabTrial::value_type::vt_vegetable_remains_content:
		return "Содержание растительных остатков";
	case ChemicalLabTrial::value_type::vt_organic_matters:
		return "Органические вещества";
	case ChemicalLabTrial::value_type::vt_pH:
		return "Водородный показатель";
	case ChemicalLabTrial::value_type::vt_steel_mass_loss:
		return "Потери массы стали";
	case ChemicalLabTrial::value_type::vt_nitrogenic_matters:
		return "Азотистые вещества";
	case ChemicalLabTrial::value_type::vt_Cl_ion:
		return "Хлор ион";
	case ChemicalLabTrial::value_type::vt_Fe_ion:
		return "Ион железа";
	case ChemicalLabTrial::value_type::vt_gips:
		return "Гипс, %";
	case ChemicalLabTrial::value_type::vt_carbonats:
		return "Карбонаты, %";
	case ChemicalLabTrial::value_type::vt_gumus:
		return "Гумус, %";
	default:
		return "";
	}
	return "";
}
int ChemicalLabTrial::GetSignForReliabilityK(ChemicalLabTrial::value_type vt)
{
	switch(vt)
	{
	case ChemicalLabTrial::value_type::vt_common_salts_content:
		return 0;//"Общее содержание солей";
	case ChemicalLabTrial::value_type::vt_well_solutable_salts:
		return 0;//"Легкорастворимые соли";
	case ChemicalLabTrial::value_type::vt_vegetable_remains_content:
		return 0;//"Содержание растительных остатков";
	case ChemicalLabTrial::value_type::vt_organic_matters:
		return 0;//"Органические вещества";
	case ChemicalLabTrial::value_type::vt_pH:
		return 0;//"Водородный показатель";
	case ChemicalLabTrial::value_type::vt_steel_mass_loss:
		return 0;//"Потери массы стали";
	case ChemicalLabTrial::value_type::vt_nitrogenic_matters:
		return 0;//"Азотистые вещества";
	case ChemicalLabTrial::value_type::vt_Cl_ion:
		return 0;//"Хлор ион";
	case ChemicalLabTrial::value_type::vt_Fe_ion:
		return 0;//"Ион железа";
	case ChemicalLabTrial::value_type::vt_gips:
		return 0;//
	case ChemicalLabTrial::value_type::vt_carbonats:
		return 0;//
	case ChemicalLabTrial::value_type::vt_gumus:
		return 0;//
	default:
		return 0;
	}
	return 0;
}
void ChemicalLabTrial::PrintfProperties(void)
{
	printf("ChemicalLabTrial::PrintfProperties()\n");
	// общее содержание солей
	printf("common_salts_content = %f\n", common_salts_content.v);
	// легкорастворимые соли
	printf("well_solutable_salts = %f\n", well_solutable_salts.v);
	// содержание растительных остатков
	printf("vegetable_remains_content = %f\n", vegetable_remains_content.v);
	// органические вещества
	printf("organic_matters = %f\n", organic_matters.v);
	// водородный показатель
	printf("pH = %f\n", pH.v);
	// потери массы стали
	printf("steel_mass_loss = %f\n", steel_mass_loss.v);
	// азотистые вещества
	printf("nitrogenic_matters = %f\n", nitrogenic_matters.v);
	// хлор ион
	printf("Cl_ion = %f\n", Cl_ion.v);
	// ион железа
	printf("Fe_ion = %f\n", Fe_ion.v);

	printf("gips = %f\n", gips.v);
	printf("carbonats = %f\n", carbonats.v);
	printf("gumus = %f\n", gumus.v);
}
void ChemicalLabTrial::PrintfProperties(vector<fmtstr> & text)
{
	char str[4098];
	sprintf(str, "Химические свойства:");
	text.push_back(fmtstr(str, NULL, true, false));

	if (common_salts_content.f && common_salts_content.v)
	{
		// общее содержание солей
		sprintf(str, "общее содержание солей \0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", common_salts_content.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &common_salts_content.f, true, true));
	}
	if (well_solutable_salts.f && well_solutable_salts.v)
	{
		// легкорастворимые соли
		sprintf(str, "легкорастворимые соли \0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", well_solutable_salts.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &well_solutable_salts.f, true, true));
	}
	if (vegetable_remains_content.f && vegetable_remains_content.v)
	{
		// содержание растительных остатков
		sprintf(str, "содержание растительных остатков \0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", vegetable_remains_content.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &vegetable_remains_content.f, true, true));
	}
	if (organic_matters.f && organic_matters.v)
	{
		// органические вещества
		sprintf(str, "органические вещества \0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", organic_matters.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &organic_matters.f, true, true));
	}
	if (pH.f && pH.v)
	{
		// водородный показатель
		sprintf(str, "pH \0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", pH.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &pH.f, true, true));
	}
	if (steel_mass_loss.f && steel_mass_loss.v)
	{
		// потери массы стали
		sprintf(str, "потери массы стали \0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", steel_mass_loss.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &steel_mass_loss.f, true, true));
	}
	if (nitrogenic_matters.f && nitrogenic_matters.v)
	{
		// азотистые вещества
		sprintf(str, "nitrogenic_matters \0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", nitrogenic_matters.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &nitrogenic_matters.f, true, true));
	}
	if (Cl_ion.f && Cl_ion.v)
	{
		// хлор ион
		sprintf(str, "Cl_ion \0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", Cl_ion.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &Cl_ion.f, true, true));
	}
	if (Fe_ion.f && Fe_ion.v)
	{
		// ион железа
		sprintf(str, "Fe_ion \0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", Fe_ion.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &Fe_ion.f, true, true));
	}

	if (gips.f && gips.v)
	{
		// 
		sprintf(str, "Гипс, %\0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", gips.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &gips.f, true, true));
	}
	if (carbonats.f && carbonats.v)
	{
		// 
		sprintf(str, "Карбонаты, %\0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", carbonats.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &carbonats.f, true, true));
	}
	if (gumus.f && gumus.v)
	{
		// 
		sprintf(str, "Гумус, %\0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", gumus.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &gumus.f, true, true));
	}
}
void ChemicalLabTrial::PrintfProperties(vector<LabData> & labdata)
{
	labdata.push_back(LabData());
	PrintfProperties(labdata.back().text);
}

bool ChemicalLabTrialResults::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	v.trial = this;

	return false;
}
/*const char * ChemicalLabTrialResults::ValueTypeToString(ChemicalLabTrialResults::value_type vt)
{
	return "";
}*/

void ChemicalLabTrialResults::CalcProperties()
{
	ChemicalLabTrial * chem_lab_trial = dynamic_cast<ChemicalLabTrial *>(this->lab_trial);
									
	this->m_zatorfovannost = ChemicalLabTrialResults::Zatorfovannost::undefined_zatorfovannost;

	if (chem_lab_trial)
	{
		double v = 
			(chem_lab_trial->vegetable_remains_content.f ? chem_lab_trial->vegetable_remains_content.v : 0.0) + 
			(chem_lab_trial->organic_matters.f ? chem_lab_trial->organic_matters.v : 0.0);
	
		if (v > 0.60)
		{
			this->m_zatorfovannost = ChemicalLabTrialResults::Zatorfovannost::torf;
		}
		else if (v > 0.4 && v <= 0.60)
		{
			this->m_zatorfovannost = ChemicalLabTrialResults::Zatorfovannost::silno_zatorfovanny;
		}
		else if (v > 0.25 && v <= 0.40)
		{
			this->m_zatorfovannost = ChemicalLabTrialResults::Zatorfovannost::sredne_zatorfovanny;
		}
		else if (v > 0.10 && v <= 0.25)
		{
			this->m_zatorfovannost = ChemicalLabTrialResults::Zatorfovannost::slabo_zatorfovanny;
		}
		else
		{
			bool try_physical = true;
			LabTrial * lab_trial = chem_lab_trial->lab_number->FindLabTrial(LabTrial::indication::fractions, -1);
			if (lab_trial)
			{
				FractionsLabTrial * frac_trial = dynamic_cast<FractionsLabTrial *>(lab_trial);
				if (frac_trial)
				{
					FractionsLabTrialResults * frac_lab_trial_res = dynamic_cast<FractionsLabTrialResults *>(frac_trial->results);

					if (frac_lab_trial_res)
					{
						if(!frac_lab_trial_res->calculed)
							frac_lab_trial_res->CalcProperties();	

						if (frac_lab_trial_res->m_sand_soil_class != FractionsLabTrialResults::SandSoilsClass::undefined_sand_soil)
						{
							if (v > 0.03 && v <= 0.10)
								this->m_zatorfovannost = ChemicalLabTrialResults::Zatorfovannost::s_primesju_rastitelnyh_ostatkov;
							else
								this->m_zatorfovannost = ChemicalLabTrialResults::Zatorfovannost::bez_rastitelnyh_ostatkov;

							try_physical = false;
						}				
					}
				}
			}

			if (try_physical)
			{
				LabTrial * lab_trial = chem_lab_trial->lab_number->FindLabTrial(LabTrial::indication::physical, -1);
				if (lab_trial)
				{
					PhysicalLabTrial * phys_trial = dynamic_cast<PhysicalLabTrial *>(lab_trial);
					if (phys_trial)
					{
						PhysicalLabTrialResults * phys_res = dynamic_cast<PhysicalLabTrialResults *>(phys_trial->results);
						if(phys_res)
						{
							if (phys_res->calculed)
								phys_res->CalcProperties();

							switch(phys_res->t)
							{
							case CGround::ground_type::Sand:
								{
									if (v > 0.03 && v <= 0.10)
										this->m_zatorfovannost = ChemicalLabTrialResults::Zatorfovannost::s_primesju_rastitelnyh_ostatkov;
									else
										this->m_zatorfovannost = ChemicalLabTrialResults::Zatorfovannost::bez_rastitelnyh_ostatkov;
								}
								break;
							case CGround::ground_type::Clay:
							case CGround::ground_type::Loam:
							case CGround::ground_type::SandyLoam:
								{
									if (v > 0.05 && v <= 0.10)
										this->m_zatorfovannost = ChemicalLabTrialResults::Zatorfovannost::s_primesju_rastitelnyh_ostatkov;
									else
										this->m_zatorfovannost = ChemicalLabTrialResults::Zatorfovannost::bez_rastitelnyh_ostatkov;
								}
								break;
							default:
								{
									CString s;
									s.Format(
										"Заторфованность в пробе грунта с лабораторным номером %d\n"
										"не определена потому что не хватает данных\n"
										"для определения типа грунта: песчаного или пылевато-глинистого",
										chem_lab_trial->lab_number->lab_n);
									MessageBox(0,s,"ChemicalLabTrialResults::CalcProperties()", 0);
								}
								break;
							}
						}
					}
				}
			}
		}
	}	
}
const char * ChemicalLabTrialResults::ZatorfovannostToString(ChemicalLabTrialResults::Zatorfovannost zat)
{
	switch(CGround::s_Quantity)
	{
	case CGround::Quantity::singular:
		{
			switch (CGround::s_Gender)
			{
			case CGround::Gender::male:
				{
					switch(zat)
					{
					case ChemicalLabTrialResults::Zatorfovannost::undefined_zatorfovannost:
						return "";
					case ChemicalLabTrialResults::Zatorfovannost::bez_rastitelnyh_ostatkov:
						return "Без растительных остатков";
					case ChemicalLabTrialResults::Zatorfovannost::s_primesju_rastitelnyh_ostatkov:
						return "С примесью растительных остатков";
					case ChemicalLabTrialResults::Zatorfovannost::slabo_zatorfovanny:
						return "слабо-заторфованный";
					case ChemicalLabTrialResults::Zatorfovannost::sredne_zatorfovanny:
						return "средне-заторфованный";
					case ChemicalLabTrialResults::Zatorfovannost::silno_zatorfovanny:
						return "сильно-заторфованный";
					case ChemicalLabTrialResults::Zatorfovannost::torf:
						return "торф";
					}
				}
				break;
			case CGround::Gender::female:
				{
					switch(zat)
					{
					case ChemicalLabTrialResults::Zatorfovannost::undefined_zatorfovannost:
						return "";
					case ChemicalLabTrialResults::Zatorfovannost::bez_rastitelnyh_ostatkov:
						return "Без растительных остатков";
					case ChemicalLabTrialResults::Zatorfovannost::s_primesju_rastitelnyh_ostatkov:
						return "С примесью растительных остатков";
					case ChemicalLabTrialResults::Zatorfovannost::slabo_zatorfovanny:
						return "слабо-заторфованная";
					case ChemicalLabTrialResults::Zatorfovannost::sredne_zatorfovanny:
						return "средне-заторфованная";
					case ChemicalLabTrialResults::Zatorfovannost::silno_zatorfovanny:
						return "сильно-заторфованная";
					case ChemicalLabTrialResults::Zatorfovannost::torf:
						return "торф";
					}
				}
				break;
			case CGround::Gender::middle:
				{
					switch(zat)
					{
					case ChemicalLabTrialResults::Zatorfovannost::undefined_zatorfovannost:
						return "";
					case ChemicalLabTrialResults::Zatorfovannost::bez_rastitelnyh_ostatkov:
						return "Без растительных остатков";
					case ChemicalLabTrialResults::Zatorfovannost::s_primesju_rastitelnyh_ostatkov:
						return "С примесью растительных остатков";
					case ChemicalLabTrialResults::Zatorfovannost::slabo_zatorfovanny:
						return "слабо-заторфованное";
					case ChemicalLabTrialResults::Zatorfovannost::sredne_zatorfovanny:
						return "средне-заторфованное";
					case ChemicalLabTrialResults::Zatorfovannost::silno_zatorfovanny:
						return "сильно-заторфованное";
					case ChemicalLabTrialResults::Zatorfovannost::torf:
						return "торф";
					}
				}
				break;
			}
		}
		break;
	case CGround::Quantity::plural:
		{
			switch(zat)
			{
			case ChemicalLabTrialResults::Zatorfovannost::undefined_zatorfovannost:
				return "";
			case ChemicalLabTrialResults::Zatorfovannost::bez_rastitelnyh_ostatkov:
				return "Без растительных остатков";
			case ChemicalLabTrialResults::Zatorfovannost::s_primesju_rastitelnyh_ostatkov:
				return "С примесью растительных остатков";
			case ChemicalLabTrialResults::Zatorfovannost::slabo_zatorfovanny:
				return "слабо-заторфованные";
			case ChemicalLabTrialResults::Zatorfovannost::sredne_zatorfovanny:
				return "средне-заторфованные";
			case ChemicalLabTrialResults::Zatorfovannost::silno_zatorfovanny:
				return "сильно-заторфованные";
			case ChemicalLabTrialResults::Zatorfovannost::torf:
				return "торф";
			}
		}
		break;
	}
}

void ChemicalLabTrialResults::PrintfProperties(vector<fmtstr> & text)
{
}
void ChemicalLabTrialResults::PrintfProperties(vector<LabData> & labdata)
{
}
void ChemicalLabTrial::Properties(void)
{
	/*printf("ChemicalLabTrial::PrintfProperties()\n");
	// общее содержание солей
	printf("common_salts_content = %f\n", common_salts_content);
	// легкорастворимые соли
	printf("well_solutable_salts = %f\n", well_solutable_salts);
	// содержание растительных остатков
	printf("vegetable_remains_content = %f\n", vegetable_remains_content);
	// органические вещества
	printf("organic_matters = %f\n", organic_matters);
	// водородный показатель
	printf("pH = %f\n", pH);
	// потери массы стали
	printf("steel_mass_loss = %f\n", steel_mass_loss);
	// азотистые вещества
	printf("nitrogenic_matters = %f\n", nitrogenic_matters);
	// хлор ион
	printf("Cl_ion = %f\n", Cl_ion);
	// ион железа
	printf("Fe_ion = %f\n", Fe_ion);*/
}

bool FractionsLabTrial::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	v.trial = this;

	FractionsLabTrial::value_type val_type = vt.vt_FractionsLabTrial;
	int i = vt.i_fraction;
	switch(val_type)
	{
	case FractionsLabTrial::value_type::vt_n_fractions:
		{
			v.v = this->n_fractions;
			v.pf = NULL;
			if (v.v) return true;
		}
		break;
#if USE_FRACTION_DIAMETERS_INTERVAL
	case FractionsLabTrial::value_type::vt_fractions_diameter_low:
		{
			if (i >= 0 && i < this->n_fractions)
			{
#if USE_LAB_LAYER_FRACTIONS
				if (this->lab_number)
				{
					LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
					if (lablayer)
					{
						FractionsLabExperiment * fractions = dynamic_cast<FractionsLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::fractions));
						if(fractions)
						{
							// массив содержания фракций
							v.v = fractions->fractions_diameters[i].low;
							v.pf = NULL;
							if (v.v) return true;
						}
					}	
				}
#else
				v.v = this->fractions_diameters[i].high;
				v.pf = NULL;
				if (v.v) return true;
#endif
			}
		}
		break;
	case FractionsLabTrial::value_type::vt_fractions_diameter_high:
		{
			if (i >= 0 && i < this->n_fractions)
			{
#if USE_LAB_LAYER_FRACTIONS
				if (this->lab_number)
				{
					LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
					if (lablayer)
					{
						FractionsLabExperiment * fractions = dynamic_cast<FractionsLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::fractions));
						if(fractions)
						{
							// массив содержания фракций
							v.v = fractions->fractions_diameters[i].high;
							v.pf = NULL;
							if (v.v) return true;
						}
					}	
				}
#else
				v.v = this->fractions_diameters[i].high;
				v.pf = NULL;
				if (v.v) return true;
#endif
			}
		}
		break;
#else
	case FractionsLabTrial::value_type::vt_fractions_diameter:
		{
			if (i >= 0 && i < this->n_fractions)
			{
#if USE_LAB_LAYER_FRACTIONS
				if (this->lab_number)
				{
					LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
					if (lablayer)
					{
						FractionsLabExperiment * fractions = dynamic_cast<FractionsLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::fractions));
						if(fractions)
						{
							// массив содержания фракций
							v.v = fractions->fractions_diameters[i];
							v.pf = NULL;
							if (v.v) return true;
						}
					}	
				}
#else
				v.v = this->fractions_diameters[i];
				v.pf = NULL;
				if (v.v) return true;
#endif
			}
		}
		break;
#endif
	case FractionsLabTrial::value_type::vt_fractions_content:
		{
			if (i >= 0 && i < this->n_fractions)
			{
				v = this->fractions_content[i];
				if (*v.pf) return true;
			}
		}
		break;
	case FractionsLabTrial::value_type::vt_fractions_content_in_aggregate_sample:
		{
			// содержание фракций в пробе заполнителя
			v = fractions_content_in_aggregate_sample;
			if (*v.pf && v.v) return true;
		}
		break;
	case FractionsLabTrial::value_type::vt_particles_content_of_diameter_more_2:
		{
			// содержание честиц ДМ > 2
			v = particles_content_of_diameter_more_2;
			if (*v.pf && v.v) return true;
		}
		break;
	case FractionsLabTrial::value_type::vt_particles_content_of_diameter_less_1:
		{
			// содержание честиц ДМ < 1
			v = particles_content_of_diameter_less_1;
			if (*v.pf && v.v) return true;
		}
		break;
	case FractionsLabTrial::value_type::vt_pourness:
		{
			// окатанность
			v = pourness;
			if (*v.pf && v.v) return true;
		}
		break;
	case FractionsLabTrial::value_type::vt_slope_angle_of_dry_ground:
		{
			// угол откоса сухого грунта
			v = slope_angle_of_dry_ground;
			if (*v.pf && v.v) return true;
		}
		break;
	case FractionsLabTrial::value_type::vt_slope_angle_under_water:
		{
			// угол откоса под водой
			v = slope_angle_under_water;
			if (*v.pf && v.v) return true;
		}
		break;
	}	
	return false;
}
const char * FractionsLabTrial::ValueTypeToString(FractionsLabTrial::value_type vt)
{
	switch(vt)
	{
	case FractionsLabTrial::value_type::vt_fractions_content:
		return "Содержание фракций";
	case FractionsLabTrial::value_type::vt_fractions_content_in_aggregate_sample:
		return "Сод.фрак.в пробе заполнит.";
	case FractionsLabTrial::value_type::vt_particles_content_of_diameter_more_2:
		return "Содержание честиц ДМ > 2";
	case FractionsLabTrial::value_type::vt_particles_content_of_diameter_less_1:
		return "Содержание честиц ДМ < 1";
	case FractionsLabTrial::value_type::vt_pourness:
		return "Окатанность";
	case FractionsLabTrial::value_type::vt_slope_angle_of_dry_ground:
		return "Угол откоса сухого грунта";
	case FractionsLabTrial::value_type::vt_slope_angle_under_water:
		return "Угол откоса под водой";
	default:
		return "";
	}
	return "";
}

int FractionsLabTrial::GetSignForReliabilityK(FractionsLabTrial::value_type vt)
{
	switch(vt)
	{
	case FractionsLabTrial::value_type::vt_fractions_content:
		return 0;//"Содержание фракций";
	case FractionsLabTrial::value_type::vt_fractions_content_in_aggregate_sample:
		return 0;//"Сод.фрак.в пробе заполнит.";
	case FractionsLabTrial::value_type::vt_particles_content_of_diameter_more_2:
		return 0;//"Содержание честиц ДМ > 2";
	case FractionsLabTrial::value_type::vt_particles_content_of_diameter_less_1:
		return 0;//"Содержание честиц ДМ < 1";
	case FractionsLabTrial::value_type::vt_pourness:
		return 0;//"Окатанность";
	case FractionsLabTrial::value_type::vt_slope_angle_of_dry_ground:
		return 0;//"Угол откоса сухого грунта";
	case FractionsLabTrial::value_type::vt_slope_angle_under_water:
		return 0;//"Угол откоса под водой";
	default:
		return 0;
	}
	return 0;
}

void FractionsLabTrial::PrintfProperties(void)
{
	printf("FractionsLabTrial::PrintfProperties()\n");
	// количество фракций, 
	printf("n_fractions = %d\n", n_fractions);
#if USE_LAB_LAYER_FRACTIONS
	if (this->lab_number)
	{
		LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
		if (lablayer)
		{
			FractionsLabExperiment * fractions = dynamic_cast<FractionsLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::fractions));
			if(fractions)
			{
				// массив содержания фракций
				for (int i = 0; i < n_fractions; i++)
				{
					printf("fractions->fractions_diameters[%d] = %f\n", i, fractions->fractions_diameters[i]);
					printf("fractions_content[%d] = %f\n", i, fractions_content[i].v);
				}
			}
		}	
	}
#else
	// массив содержания фракций
	for (int i = 0; i < n_fractions; i++)
	{
		printf("fractions_diameters[%d] = %f\n", i, fractions_diameters[i]);
		printf("fractions_content[%d] = %f\n", i, fractions_content[i].v);
	}
#endif


	// содержание фракций в пробе заполнителя
	printf("fractions_content_in_aggregate_sample = %f\n", fractions_content_in_aggregate_sample.v);
	// содержание честиц ДМ > 2
	printf("particles_content_of_diameter_more_2 = %f\n", particles_content_of_diameter_more_2.v);
	// содержание честиц ДМ < 1
	printf("particles_content_of_diameter_less_1 = %f\n", particles_content_of_diameter_less_1.v);
	// окатанность
	printf("pourness = %f\n", pourness.v);
	// угол откоса сухого грунта
	printf("slope_angle_of_dry_ground = %f\n", slope_angle_of_dry_ground.v);
	// угол откоса под водой
	printf("slope_angle_under_water = %f\n", slope_angle_under_water.v);
}

void FractionsLabTrial::PrintfProperties(vector<fmtstr> & text)
{
	char str[4098];
	if (n_fractions)
	{
		// количество фракций, 
		sprintf(str, "Фракции (количество фракций = %d):", n_fractions);
		text.push_back(fmtstr(str, NULL, true, false));

#if USE_LAB_LAYER_FRACTIONS
		if (this->lab_number)
		{
			LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
			if (lablayer)
			{
				FractionsLabExperiment * fractions = dynamic_cast<FractionsLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::fractions));
				if(fractions)
				{
					int step = STEP;
					string s = "Диам-ры:";
					//     s = "Содерж.:";
					text.push_back(fmtstr(s, NULL, false, true));
					// массив содержания фракций
					for (int i = 0; i < n_fractions; i++)
					{
						//s = "";
						sprintf(str, "%f\0", fractions->fractions_diameters[i]);
						DeleteEndZeros(str);
						//for (int j = 0; j < step-int(strlen(str)); j++)
						//	s += " ";
						//s += str;
						text.push_back(fmtstr(str, NULL, i == n_fractions-1, true));
					}
							s = "Содерж.:";
					text.push_back(fmtstr(s, NULL, false, true));
					// массив содержания фракций
					for (int i = 0; i < n_fractions; i++)
					{
						//s = "";
						sprintf(str, "%f\0", fractions_content[i].v);
						DeleteEndZeros(str);
						///for (int j = 0; j < step-int(strlen(str)); j++)
						//	s += " ";
						//s += str;
						text.push_back(fmtstr(str, &fractions_content[i].f, i == n_fractions-1, true));
					}
				}
			}	
		}
#else
		int step = STEP;
#if USE_FRACTION_DIAMETERS_INTERVAL
		string s = "Диам.min:";
		//     s = "Содерж.:";
		text.push_back(fmtstr(s, NULL, false, true));
		// массив содержания фракций
		for (int i = 0; i < n_fractions; i++)
		{
			//s = "";
			if (fractions_diameters[i].low > -DBL_MAX)
			{
				sprintf(str, "%f\0", fractions_diameters[i].low);
				DeleteEndZeros(str);
			}
			else
			{
				sprintf(str, "");
			}

			//for (int j = 0; j < step-int(strlen(str)); j++)
			//	s += " ";
			//s += str;
			text.push_back(fmtstr(str, NULL, i == n_fractions-1, true));
		}
		
		       s = "Диам.max:";
		//     s = "Содерж.:";
		text.push_back(fmtstr(s, NULL, false, true));
		// массив содержания фракций
		for (int i = 0; i < n_fractions; i++)
		{
			//s = "";
			if (fractions_diameters[i].high < DBL_MAX)
			{
				sprintf(str, "%f\0", fractions_diameters[i].high);
				DeleteEndZeros(str);
			}
			else
			{
				sprintf(str, "");
			}

			//for (int j = 0; j < step-int(strlen(str)); j++)
			//	s += " ";
			//s += str;
			text.push_back(fmtstr(str, NULL, i == n_fractions-1, true));
		}

#else

		string s = "Диам-ры:";
		//     s = "Содерж.:";
		text.push_back(fmtstr(s, NULL, false, true));
		// массив содержания фракций
		for (int i = 0; i < n_fractions; i++)
		{
			//s = "";


			sprintf(str, "%f\0", fractions_diameters[i]);
			DeleteEndZeros(str);
			//for (int j = 0; j < step-int(strlen(str)); j++)
			//	s += " ";
			//s += str;
			text.push_back(fmtstr(str, NULL, i == n_fractions-1, true));
		}

#endif



				s = "Содерж.:";
		text.push_back(fmtstr(s, NULL, false, true));
		// массив содержания фракций
		for (int i = 0; i < n_fractions; i++)
		{
			//s = "";
			sprintf(str, "%f\0", fractions_content[i].v);
			DeleteEndZeros(str);
			///for (int j = 0; j < step-int(strlen(str)); j++)
			//	s += " ";
			//s += str;
			text.push_back(fmtstr(str, &fractions_content[i].f, i == n_fractions-1, true));
		}
#endif
	}

	if (fractions_content_in_aggregate_sample.f && fractions_content_in_aggregate_sample.v)
	{
		// содержание фракций в пробе заполнителя
		sprintf(str, "содержание фракций в пробе заполнителя \0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", fractions_content_in_aggregate_sample.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &fractions_content_in_aggregate_sample.f, true, true));
	}
	if (particles_content_of_diameter_more_2.f && particles_content_of_diameter_more_2.v)
	{
		// содержание честиц ДМ > 2
		sprintf(str, "содержание честиц ДМ > 2 \0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", particles_content_of_diameter_more_2.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &particles_content_of_diameter_more_2.f, true, true));
	}
	if (particles_content_of_diameter_less_1.f && particles_content_of_diameter_less_1.v)
	{
		// содержание честиц ДМ < 1
		sprintf(str, "содержание честиц ДМ < 1 \0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", particles_content_of_diameter_less_1.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &particles_content_of_diameter_less_1.f, true, true));
	}
	if (pourness.f && pourness.v)
	{
		// окатанность
		sprintf(str, "окатанность \0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", pourness.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &pourness.f, true, true));
	}
	if (slope_angle_of_dry_ground.f && slope_angle_of_dry_ground.v)
	{
		// угол откоса сухого грунта
		sprintf(str, "угол откоса сухого грунта \0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", slope_angle_of_dry_ground.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &slope_angle_of_dry_ground.f, true, true));
	}
	if (slope_angle_under_water.f && slope_angle_under_water.v)
	{
		// угол откоса под водой
		sprintf(str, "угол откоса под водой \0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f\0", slope_angle_under_water.v);
		DeleteEndZeros(str); text.push_back(fmtstr(str, &slope_angle_under_water.f, true, true));
	}
}
void FractionsLabTrial::PrintfProperties(vector<LabData> & labdata)
{
	labdata.push_back(LabData());

//#if PLOT_WITH_TEXT
#if 1
	this->PrintfProperties(labdata.back().text);
#else
	char str[4098];
	// количество фракций, 
	sprintf(str, "Фракции (количество фракций = %d):", n_fractions);
	labdata.back().text.push_back(fmtstr(str, NULL, true, false));
#endif

	if (this->lab_number)
	{
		LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
		if (lablayer)
		{
			FractionsLabExperiment * fractions = dynamic_cast<FractionsLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::fractions));
			if(fractions && n_fractions)
			{
				double Y = 0.0;
				short f = 0;

				for (int i = 0; i < n_fractions; i++)
				{
					Y += fractions_content[i].v;
					f += fractions_content[i].f;
				}
				if (f)
				{

					char tit[4098];
					sprintf(tit, "Фракции sum = %f", Y);
					DeleteEndZeros(tit);

					// plot
					labdata.back().plot_data.use_plot = true;
					if (Y == 100.0)
						labdata.back().plot_data.title = "Фракции";
					else
						labdata.back().plot_data.title = tit;
					labdata.back().plot_data.xlabel = "Диам-ры";
					labdata.back().plot_data.ylabel = "Содерж.";
					labdata.back().plot_data.use_sx = true;

					labdata.back().plot_data.plot_lines.push_back(plot_line());
					char sx[4098];
#if 1

					FractionsLabTrialResults * frac_result = dynamic_cast<FractionsLabTrialResults *>(this->results);
					if (frac_result)
					{
						if(!frac_result->calculed)
							frac_result->CalcProperties();

						for(size_t i = 0; i < frac_result->v_diameters.size() && i < frac_result->v_sum_content.size(); i++)
						{							
							sprintf(sx, "%f", frac_result->v_diameters[i]); DeleteEndZeros(sx);
							labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(log10(frac_result->v_diameters[i]), frac_result->v_sum_content[i]));
							labdata.back().plot_data.plot_lines.back().data.back().sx = sx;
						}
					}

#else

					double x,y;
					// массив содержания фракций
					for (int i = 0; i < n_fractions; i++)
					{
						y = fractions_content[i].v;
						Y -= y;
						if (i && fractions->fractions_diameters[i] == fractions->fractions_diameters[i-1])
						{
							/*x = fractions->fractions_diameters[i];
							sprintf(sx, "< %f", x); DeleteEndZeros(sx);
							x /= 5.0;*/
						}
						else
						{
							x = fractions->fractions_diameters[i];
							sprintf(sx, "%f", x); DeleteEndZeros(sx);

							if (true)
								labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(log10(x), Y));
							else
								labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(log10(x), y));
							labdata.back().plot_data.plot_lines.back().data.back().sx = sx;
						}
					}
#endif
				}
			}
		}	
	}
}
bool FractionsLabTrialResults::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	v.trial = this;

	FractionsLabTrialResults::value_type val_type = vt.vt_FractionsLabTrialResults;
	switch(val_type)
	{
	case FractionsLabTrialResults::value_type::vt_clay_soil_class:
		{
			v.v = (double)this->m_clay_soil_class;
			v.pf = NULL;            
			return true;
		}
		break;	
	case FractionsLabTrialResults::value_type::vt_sand_soil_class:
		{
			v.v = (double)this->m_sand_soil_class;
			v.pf = NULL;            
			return true;
		}
		break;	
	case FractionsLabTrialResults::value_type::vt_neodnorodnost:
		{
			v.v = (double)this->m_neodnorodnost;
			v.pf = NULL;            
			return true;
		}
		break;	
	case FractionsLabTrialResults::value_type::vt_d_10:
		{
			v = this->d_10;
			return true;
		}
		break;	
	case FractionsLabTrialResults::value_type::vt_d_60:
		{
			v = this->d_60;
			return true;
		}
		break;	
	case FractionsLabTrialResults::value_type::vt_C_u:
		{
			v = this->C_u;
			return true;
		}
		break;	
	case FractionsLabTrialResults::value_type::vt_clay_frac_content:
		{
			v = this->m_clay_frac_content;
			return true;
		}
		break;	
	case FractionsLabTrialResults::value_type::vt_pyl_frac_content:
		{
			v = this->m_pyl_frac_content;
			return true;
		}
		break;	
	}
	return false;
}
const char * FractionsLabTrialResults::SandSoilsClassToString(FractionsLabTrialResults::SandSoilsClass sand_soil_class)
{
	switch(CGround::s_Quantity)
	{
	case CGround::Quantity::singular:
		{
			switch(sand_soil_class)
			{
			case FractionsLabTrialResults::SandSoilsClass::valunnyj_or_glubovuj:
				return "Крупнообломочный валунный (глыбовый)";
			case FractionsLabTrialResults::SandSoilsClass::galechnikovyj_or_schebenistyj:
				return "Крупнообломочный галечниковый (щебенистый)";
			case FractionsLabTrialResults::SandSoilsClass::gravijnyj_or_dresvyanyj:
				return "Крупнообломочный гравийный (дресвяной)";

			case FractionsLabTrialResults::SandSoilsClass::gravelistyj:
				return "Песок гравелистый";
			case FractionsLabTrialResults::SandSoilsClass::krupnyj:
				return "Песок крупный";
			case FractionsLabTrialResults::SandSoilsClass::srednej_krupnosti:
				return "Песок средней крупности";
			case FractionsLabTrialResults::SandSoilsClass::melkij:
				return "Песок мелкий";
			case FractionsLabTrialResults::SandSoilsClass::pylevatyj:
				return "Песок пылеватый";

			default:
				return "";
			}
		}
		break;
	case CGround::Quantity::plural:
		{
			switch(sand_soil_class)
			{
			case FractionsLabTrialResults::SandSoilsClass::valunnyj_or_glubovuj:
				return "Крупнообломочные валунные (глыбовые)";
			case FractionsLabTrialResults::SandSoilsClass::galechnikovyj_or_schebenistyj:
				return "Крупнообломочные галечниковые (щебенистые)";
			case FractionsLabTrialResults::SandSoilsClass::gravijnyj_or_dresvyanyj:
				return "Крупнообломочные гравийные (дресвяные)";

			case FractionsLabTrialResults::SandSoilsClass::gravelistyj:
				return "Пески гравелистые";
			case FractionsLabTrialResults::SandSoilsClass::krupnyj:
				return "Пески крупные";
			case FractionsLabTrialResults::SandSoilsClass::srednej_krupnosti:
				return "Пески средней крупности";
			case FractionsLabTrialResults::SandSoilsClass::melkij:
				return "Пески мелкие";
			case FractionsLabTrialResults::SandSoilsClass::pylevatyj:
				return "Пески пылеватые";

			default:
				return "";
			}
		}
		break;
	}
	return "";
}
const char * FractionsLabTrialResults::ClaySoilsClassToString(FractionsLabTrialResults::ClaySoilsClass clay_soil_class)
{
	switch(CGround::s_Quantity)
	{
	case CGround::Quantity::singular:
		{
			switch(clay_soil_class)
			{
			case FractionsLabTrialResults::ClaySoilsClass::clay:
				return "Глина";
			case FractionsLabTrialResults::ClaySoilsClass::loam:
				return "Суглинок";
			case FractionsLabTrialResults::ClaySoilsClass::sand:
				return "Песок";
			case FractionsLabTrialResults::ClaySoilsClass::sandyLoam:
				return "Супесь";
			case FractionsLabTrialResults::ClaySoilsClass::undefined_clay_soil:
				return "Не определён";
			default:
				return "";
			}
		}
		break;
	case CGround::Quantity::plural:
		{
			switch(clay_soil_class)
			{
			case FractionsLabTrialResults::ClaySoilsClass::clay:
				return "Глины";
			case FractionsLabTrialResults::ClaySoilsClass::loam:
				return "Суглинки";
			case FractionsLabTrialResults::ClaySoilsClass::sand:
				return "Пески";
			case FractionsLabTrialResults::ClaySoilsClass::sandyLoam:
				return "Супеси";
			case FractionsLabTrialResults::ClaySoilsClass::undefined_clay_soil:
				return "Не определёны";
			default:
				return "";
			}
		}
		break;
	}
	return "";
}
const char * FractionsLabTrialResults::NeodnorodnostToStringSmall(FractionsLabTrialResults::Neodnorodnost no)
{
	switch(no)
	{
	case FractionsLabTrialResults::Neodnorodnost::odnorodnyj:
		return "одн.";

	case FractionsLabTrialResults::Neodnorodnost::neodnorodnyj:
		return "неод.";

	default:
		return "";
	}
	return "";
}
const char * FractionsLabTrialResults::NeodnorodnostToString(FractionsLabTrialResults::Neodnorodnost no)
{
	switch(CGround::s_Quantity)
	{
	case CGround::Quantity::singular:
		{
			switch(no)
			{
			case FractionsLabTrialResults::Neodnorodnost::odnorodnyj:
				return "однородный";

			case FractionsLabTrialResults::Neodnorodnost::neodnorodnyj:
				return "неоднородный";

			default:
				return "";
			}
		}
		break;
	case CGround::Quantity::plural:
		{
			switch(no)
			{
			case FractionsLabTrialResults::Neodnorodnost::odnorodnyj:
				return "однородные";

			case FractionsLabTrialResults::Neodnorodnost::neodnorodnyj:
				return "неоднородные";

			default:
				return "";
			}
		}
		break;
	}
	return "";
}
const char * FractionsLabTrialResults::SandSoilsClassToStringSmall(FractionsLabTrialResults::SandSoilsClass sand_soil_class)
{
	switch(sand_soil_class)
	{
	case FractionsLabTrialResults::SandSoilsClass::valunnyj_or_glubovuj:
		return "валунный (глыбовый)";
	case FractionsLabTrialResults::SandSoilsClass::galechnikovyj_or_schebenistyj:
		return "галечниковый (щебенистый)";
	case FractionsLabTrialResults::SandSoilsClass::gravijnyj_or_dresvyanyj:
		return "гравийный (дресвяной)";

	case FractionsLabTrialResults::SandSoilsClass::gravelistyj:
		return "гравелистый";
	case FractionsLabTrialResults::SandSoilsClass::krupnyj:
		return "крупный";
	case FractionsLabTrialResults::SandSoilsClass::srednej_krupnosti:
		return "средней крупности";
	case FractionsLabTrialResults::SandSoilsClass::melkij:
		return "мелкий";
	case FractionsLabTrialResults::SandSoilsClass::pylevatyj:
		return "пылеватый";

	default:
		return "";
	}
	return "";
}
const char * FractionsLabTrialResults::ClaySoilsClassToStringSmall(FractionsLabTrialResults::ClaySoilsClass clay_soil_class)
{
	switch(clay_soil_class)
	{
	case FractionsLabTrialResults::ClaySoilsClass::clay:
		return "Глина";
	case FractionsLabTrialResults::ClaySoilsClass::loam:
		return "Суглинок";
	case FractionsLabTrialResults::ClaySoilsClass::sand:
		return "Песок";
	case FractionsLabTrialResults::ClaySoilsClass::sandyLoam:
		return "Супесь";
	case FractionsLabTrialResults::ClaySoilsClass::undefined_clay_soil:
		return "Не определён";
	default:
		return "";
	}
	return "";
}
const char * FractionsLabTrialResults::ValueTypeToString(FractionsLabTrialResults::value_type vt)
{
	switch(vt)
	{
	case FractionsLabTrialResults::value_type::vt_sand_soil_class:
		return "Класс крупнообломочно-песчаного грунта";

	case FractionsLabTrialResults::value_type::vt_clay_soil_class:
		return "Класс глин.грунта по сод.глинист.част.";

	case FractionsLabTrialResults::value_type::vt_clay_frac_content:
		return "Содержание глинистой фракции";

	case FractionsLabTrialResults::value_type::vt_pyl_frac_content:
		return "Содержание пылеватой фракции";

	case FractionsLabTrialResults::value_type::vt_neodnorodnost:
		return "Степень неоднородности";

	case FractionsLabTrialResults::value_type::vt_C_u:
		return "Коэффициент неоднородности";

	case FractionsLabTrialResults::value_type::vt_d_60:
		return "Диаметр частиц, < кот. сод. 60%% ч-ц";

	case FractionsLabTrialResults::value_type::vt_d_10:
		return "Диаметр частиц, < кот. сод. 10%% ч-ц";

	default:
		return "";
	}
	return "";
}
bool GetSandSoilsClass(double x, double Y, FractionsLabTrialResults::SandSoilsClass& sand_soil_class)
{
	//x - current fraction diameter		
	//Y - sum of content with diameter more than x
	if (x >= 200.)
	{
		if (Y > 50.)
		{
			sand_soil_class = FractionsLabTrialResults::SandSoilsClass::valunnyj_or_glubovuj;
			return true;
		}
		else
			return false;
	}
	if (x >= 10)
	{
		if (Y > 50.)
		{
			sand_soil_class = FractionsLabTrialResults::SandSoilsClass::galechnikovyj_or_schebenistyj;
			return true;
		}
		else
			return false;
	}
	if (x >= 2.)
	{
		if (Y > 50.)
		{
			sand_soil_class = FractionsLabTrialResults::SandSoilsClass::gravijnyj_or_dresvyanyj;
			return true;
		}
		else if (Y > 25.)
		{
			sand_soil_class = FractionsLabTrialResults::SandSoilsClass::gravelistyj;
			return true;
		}		
		else
			return false;
	}

	if (x >= 0.5)
	{
		if (Y > 50.)
		{
			sand_soil_class = FractionsLabTrialResults::SandSoilsClass::krupnyj;
			return true;
		}
		else
			return false;
	}
	if (x >= 0.25)
	{
		if (Y > 50.)
		{
			sand_soil_class = FractionsLabTrialResults::SandSoilsClass::srednej_krupnosti;
			return true;
		}
		else
			return false;
	}
	if (x >= 0.1)
	{
		if (Y >= 75.)
		{
			sand_soil_class = FractionsLabTrialResults::SandSoilsClass::melkij;
			return true;
		}
		else if (Y < 75.)
		{
			sand_soil_class = FractionsLabTrialResults::SandSoilsClass::pylevatyj;
			return true;
		}
	}
	return false;
}

bool GetClaySoilsClass(double y, FractionsLabTrialResults::ClaySoilsClass& clay_soil_class)
{
	//y - содержанию глинистых частиц (<0.005)
	if (y > 30.)
	{
		clay_soil_class = FractionsLabTrialResults::ClaySoilsClass::clay;
		return true;
	}
	else if (y <= 30. && y > 10.)
	{

		clay_soil_class = FractionsLabTrialResults::ClaySoilsClass::loam;
		return true;
	}
	else if (y <= 10. && y > 3.)
	{

		clay_soil_class = FractionsLabTrialResults::ClaySoilsClass::sandyLoam;
		return true;
	}
	else if (y <= 3.)
	{

		clay_soil_class = FractionsLabTrialResults::ClaySoilsClass::sand;
		return true;
	}

	return false;
}

void FractionsLabTrialResults::CalcProperties()
{
	m_neodnorodnost = Neodnorodnost::undefined_neodnorodnost;					
	m_sand_soil_class = FractionsLabTrialResults::SandSoilsClass::undefined_sand_soil;
	m_minimum_krupnosti_chastic = 0.0; m_soderzhanie_chastic = 100.0;

	m_clay_soil_class = FractionsLabTrialResults::ClaySoilsClass::undefined_clay_soil;
	//m_soderzhanie_glinistyh_chastic = 0.0; // (<0.005mm)
	this->m_clay_frac_content = 0.0;
	this->m_pyl_frac_content  = 0.0;



	this->v_diameters.clear();
	this->v_sum_content.clear();

	FractionsLabTrial * frac =  dynamic_cast<FractionsLabTrial *>(this->lab_trial);
	if (frac)
	{
		if(frac->n_fractions)
		{
			double Y = 0.0;
			double x;
			// массив содержания фракций
			for (int i = 0; i < frac->n_fractions; i++)
			{
				Y += frac->fractions_content[i].v;
#if USE_FRACTION_DIAMETERS_INTERVAL
				x = frac->fractions_diameters[i].low;
				if (x > -DBL_MAX)
				{
					m_minimum_krupnosti_chastic = x; m_soderzhanie_chastic = Y;// if GetSandSoilsClass never true
					if (GetSandSoilsClass(x, Y, m_sand_soil_class))
					{
						m_minimum_krupnosti_chastic = x; m_soderzhanie_chastic = Y;
						break;
					}
				}
#else
				if (i && frac->fractions_diameters[i] == frac->fractions_diameters[i-1])
				{
					x = frac->fractions_diameters[i];
				}
				else
				{
					x = frac->fractions_diameters[i];
					m_minimum_krupnosti_chastic = x; m_soderzhanie_chastic = Y;// if GetSandSoilsClass never true
					if (GetSandSoilsClass(x, Y, m_sand_soil_class))
					{
						m_minimum_krupnosti_chastic = x; m_soderzhanie_chastic = Y;
						break;
					}
				}
#endif
			}

		}

		if(frac->n_fractions)
		{
			double y, x_low, x_high;
			// массив содержания фракций
			for (int i = 0; i < frac->n_fractions; i++)
			{
				y = frac->fractions_content[i].v;

				x_low = frac->fractions_diameters[i].low;
				x_high = frac->fractions_diameters[i].high;
				if (x_low == -DBL_MAX && x_high == 0.005)
				{
					this->m_clay_frac_content = y;
					if (GetClaySoilsClass(y, m_clay_soil_class))
					{
					}
				}
				if (x_low > -DBL_MAX && x_high < DBL_MAX)
				{
					if (x_low >= 0.005 && x_high <= 0.1)
					{
						this->m_pyl_frac_content.v += y;				
					}
				}
			}
		}

		if(frac->n_fractions)
		{
			double Y = 0.0;
			short f = 0;
			for (int i = 0; i < frac->n_fractions; i++)
			{
				Y += frac->fractions_content[i].v;
				f += frac->fractions_content[i].f;
			}
			//вставить проверку Y == 100
			if (fabs(Y - 100.0) >  1e-6)
			{
				CString s;
				s.Format("В лабораторном номере %d\n"
					"Сумма содержания фракций %f не равна 100%%",
					this->lab_trial->GetLabNumber()->lab_n,	Y);
				AfxMessageBox(s);
			}

			if (f)
			{
				double x_low, x_high, y;
				double Y_pre = Y;
				double part_10 = 0.0;
				double part_60 = 0.0;

				bool d_10_calculed = false;
				bool d_60_calculed = false;

				// массив содержания фракций
#if USE_FRACTION_DIAMETERS_INTERVAL

				for (int i = 0; i < frac->n_fractions; i++)
				{
					y = frac->fractions_content[i].v;
					x_low = frac->fractions_diameters[i].low;
					x_high = frac->fractions_diameters[i].high;

					if (x_high < DBL_MAX)
					{
						this->v_diameters.push_back(x_high);
						this->v_sum_content.push_back(Y);
					}

					Y -= y;

					if (i == frac->n_fractions - 1 && x_low > 0)
					{
						this->v_diameters.push_back(x_high);
						this->v_sum_content.push_back(Y);
					}

					char str[4098];
/*					sprintf(str,  "pre\n"
						"i = %d frac->n_fractions = %d\n"
						"y = %f Y = %f Y_pre = %f\n"
						"x_low = %f x_high = %f\n"
						"part_10 = %f\n"
						"part_60 = %f\n"
						"d_10 = %f"
						, i, frac->n_fractions,
						y, Y, Y_pre,
						x_low, x_high,
						part_10,
						part_60,
						d_10.v
						);
					AfxMessageBox(str);
*/
					if (Y <= 60. &&  60. <= Y_pre)
					{
						if (x_low != -DBL_MAX && x_high != DBL_MAX)
						{
							part_60 = (60. - Y) / (Y_pre - Y);
							d_60 = x_low + part_60 * (x_high - x_low);
							d_60_calculed = true;
						}
						else if (!d_60_calculed && x_low != -DBL_MAX && x_high == DBL_MAX)
						{
						}
					}
					if (Y <= 10. &&  10. <= Y_pre)
					{
						if (x_low != -DBL_MAX && x_high != DBL_MAX)
						{
							part_10 = (10. - Y) / (Y_pre - Y);
							d_10 = x_low + part_10 * (x_high - x_low);
							d_10_calculed = true;
						}
						else if (!d_10_calculed && x_low == -DBL_MAX && x_high != DBL_MAX)
						{
							part_10 = (10. - Y) / (Y_pre - Y);
							d_10 = 0.0 + part_10 * (x_high - 0.0);
						}
					}
/*
					sprintf(str, "post\n"
						"i = %d frac->n_fractions = %d\n"
						"y = %f Y = %f Y_pre = %f\n"
						"x_low = %f x_high = %f\n"
						"part_10 = %f\n"
						"part_60 = %f\n"
						"d_10 = %f\n"
						"d_60 = %f"
						, i, frac->n_fractions,
						y, Y, Y_pre,
						x_low, x_high,
						part_10,
						part_60
						,d_10.v
						,d_60.v
						);
					AfxMessageBox(str);	
					
*/
					Y_pre = Y;


				}

#else
				for (int i = 0; i < frac->n_fractions; i++)
				{
					y = frac->fractions_content[i].v;
					Y -= y;

					/*char str[4098];
					sprintf(str,  "pre\n"
						"i = %d frac->n_fractions = %d\n"
						"y = %f Y = %f Y_pre = %f\n"
						"x = %f x_pre = %f\n"
						"part_10 = %f\n"
						"part_60 = %f\n"
						"d_10_calculed = %d d_10 = %f"
						, i, frac->n_fractions,
						y, Y, Y_pre,
						x, x_pre,
						part_10,
						part_60,
						d_10_calculed, d_10.v
						);
					AfxMessageBox(str);*/

					if (i && frac->fractions_diameters[i] == frac->fractions_diameters[i-1])
					{
						if (i == frac->n_fractions - 1 && !d_10_calculed)
						{
							part_10 = (10. - Y) / (Y_pre - Y);
							d_10 = 0.0 + part_10 * (x - 0.0);
						}
					}
					else
					{
						x = frac->fractions_diameters[i];

						this->v_diameters.push_back(x);
						this->v_sum_content.push_back(Y);

						if (i)
						{
							if (Y <= 60. &&  60. <= Y_pre)
							{
								part_60 = (60. - Y) / (Y_pre - Y);
								d_60 = x + part_60 * (x_pre - x);
							}
							if (Y <= 10. &&  10. <= Y_pre)
							{
								part_10 = (10. - Y) / (Y_pre - Y);
								d_10 = x + part_10 * (x_pre - x);
								d_10_calculed = true;
							}
							if (i == frac->n_fractions - 1 && !d_10_calculed)
							{
								part_10 = (10. - Y) / (Y_pre - Y);
								d_10 = 0.0 + part_10 * (x - 0.0);
							}
						}
						/*else
						{
							if (Y >= 60. &&  60. <= Y_pre)
							{
								part_60 = (60. - Y) / (Y_pre - Y);
								d_60 = x + part_60 * (x_pre - x);
							}
						}*/
					}
					/*sprintf(str, "post\n"
						"i = %d frac->n_fractions = %d\n"
						"y = %f Y = %f Y_pre = %f\n"
						"x = %f x_pre = %f\n"
						"part_10 = %f\n"
						"part_60 = %f\n"
						"d_10_calculed = %d d_10 = %f"
						, i, frac->n_fractions,
						y, Y, Y_pre,
						x, x_pre,
						part_10,
						part_60,
						d_10_calculed, d_10.v
						);
					AfxMessageBox(str);	*/
					

					Y_pre = Y;
					x_pre = x;


				}
#endif
				this->C_u = d_60 / d_10;

				if (this->C_u < 3.0)
				{
					this->m_neodnorodnost = Neodnorodnost::odnorodnyj;
				}
				else
				{
					this->m_neodnorodnost = Neodnorodnost::neodnorodnyj;
				}
			}
		}
	}
}
void FractionsLabTrialResults::PrintfProperties(vector<fmtstr> & text)
{
	FractionsLabTrial * frac = dynamic_cast<FractionsLabTrial *>(this->lab_trial);
	if (frac && frac->n_fractions)
	{
		char str[4098];
		sprintf(str, "%s\0", FractionsLabTrialResults::ValueTypeToString(FractionsLabTrialResults::value_type::vt_sand_soil_class));
		text.push_back(fmtstr(str, NULL, false, true));

		sprintf(str, "%s\0", FractionsLabTrialResults::SandSoilsClassToString(this->m_sand_soil_class));
		text.push_back(fmtstr(str, NULL, true, true));

		char sx[128];
		sprintf(sx, "%f", m_minimum_krupnosti_chastic);
		DeleteEndZeros(sx);

		char sy[128];
		sprintf(sy, "%f", m_soderzhanie_chastic);
		DeleteEndZeros(sy);

		sprintf(str, "Содержание частиц крупностью > %s мм\0", sx);
		text.push_back(fmtstr(str, NULL, false, true));

		sprintf(str, "%s %%\0", sy);
		text.push_back(fmtstr(str, NULL, true, true));



		sprintf(str, "%s\0", FractionsLabTrialResults::ValueTypeToString(FractionsLabTrialResults::value_type::vt_clay_soil_class));
		text.push_back(fmtstr(str, NULL, false, true));

		sprintf(str, "%s\0", FractionsLabTrialResults::ClaySoilsClassToString(this->m_clay_soil_class));
		text.push_back(fmtstr(str, NULL, true, true));



		sprintf(sy, "%f", this->m_clay_frac_content.v);
		DeleteEndZeros(sy);

		sprintf(str, "Содержание глинистой фракции");
		text.push_back(fmtstr(str, NULL, false, true));

		sprintf(str, "%s %%\0", sy);
		text.push_back(fmtstr(str, NULL, true, true));



		sprintf(sy, "%f", this->m_pyl_frac_content.v);
		DeleteEndZeros(sy);

		sprintf(str, "Содержание пылеватой фракции");
		text.push_back(fmtstr(str, NULL, false, true));

		sprintf(str, "%s %%\0", sy);
		text.push_back(fmtstr(str, NULL, true, true));


		char s[128];
		sprintf(str, "Диаметр частиц, < которого сод. 60%% ч-ц\0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(s, "%f", d_60.v); DeleteEndZeros(s);
		if (strlen(s) > max_str_len_val_printf_fmtstr)
			sprintf(s, "%e", d_60.v);
		sprintf(str, "%s мм\0", s);
		text.push_back(fmtstr(str, &d_60.f, true, true));

		sprintf(str, "Диаметр частиц, < которого сод. 10%% ч-ц\0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(s, "%f", d_10.v); DeleteEndZeros(s);
		if (strlen(s) > max_str_len_val_printf_fmtstr)
			sprintf(s, "%e", d_10.v);
		sprintf(str, "%s мм\0", s);
		text.push_back(fmtstr(str, &d_10.f, true, true));

		sprintf(str, "Коэффициент неоднородности\0");
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%f", C_u.v); DeleteEndZeros(str);
		if (strlen(str) > max_str_len_val_printf_fmtstr)
			sprintf(str, "%e", C_u.v);
		text.push_back(fmtstr(str, &C_u.f, true, true));

		sprintf(str, "Степень неоднородности\0", sx);
		text.push_back(fmtstr(str, NULL, false, true));
		sprintf(str, "%s", FractionsLabTrialResults::NeodnorodnostToString(this->m_neodnorodnost)); 
		text.push_back(fmtstr(str, &C_u.f, true, true));
	}
}
void FractionsLabTrialResults::PrintfProperties(vector<LabData> & labdata)
{
	labdata.push_back(LabData());
	this->PrintfProperties(labdata.back().text);
}
void FractionsLabTrial::Properties(void)
{
#if LABORATORY_WITH_SURFDOC
	printf("FractionsLabTrial::PrintfProperties()\n");

	// количество фракций, 
	printf("n_fractions = %d\n", n_fractions);
	if (this->lab_number)
	{
		LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
		if (lablayer)
		{
			FractionsLabExperiment * fractions = dynamic_cast<FractionsLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::fractions));
			if(fractions)
			{
				Laboratory * lab = (Laboratory *)lablayer->GetLaboratory();
				if (lab)
				{

					SurfDoc * doc = (SurfDoc *)lab->GetDoc();
					project * prj = dynamic_cast<project *>(doc);
					if (prj)
					{
						char tit[1024]; sprintf(tit, "Фракции (лаб. номер %s)", this->lab_number->ID.c_str()); 
						const char * s1 = "Диаметры"; const char * sv = "Содержание";
						plot1d_view * plot = prj->AddPlot1DView(PLOT_USERDATA_STRUCTURE, tit, s1, sv, true);
						// массив содержания фракций
						// массив содержания фракций
						for (int i = 0; i < n_fractions; i++)
						{
							double x = fractions->fractions_diameters[i];
							double y = fractions_content[i].v;
						
							//printf("x = %f y = %f\n", x,y);
							void * udata = NULL;
							plot->AddData(x, y, udata);
						}		
						plot->SetCenterAndScale();
						plot->Update();
					}
				}
			}
		}	
	}


	// содержание фракций в пробе заполнителя
	printf("fractions_content_in_aggregate_sample = %f\n", fractions_content_in_aggregate_sample.v);
	// содержание честиц ДМ > 2
	printf("particles_content_of_diameter_more_2 = %f\n", particles_content_of_diameter_more_2.v);
	// содержание честиц ДМ < 1
	printf("particles_content_of_diameter_less_1 = %f\n", particles_content_of_diameter_less_1.v);
	// окатанность
	printf("pourness = %f\n", pourness.v);
	// угол откоса сухого грунта
	printf("slope_angle_of_dry_ground = %f\n", slope_angle_of_dry_ground.v);
	// угол откоса под водой
	printf("slope_angle_under_water = %f\n", slope_angle_under_water.v);
#endif
}

const char * CompressionLabTrial::CompressionLabTrialTypeToString(CompressionLabTrial::type comtype)
{
	switch(comtype)				
	{
	case CompressionLabTrial::type::undefined:
		return "undefined";
	case CompressionLabTrial::type::nature_condition:
		return "nature_condition";
	case CompressionLabTrial::type::task_condition:
		return "task_condition";
	case CompressionLabTrial::type::shrinkage:
		return "shrinkage";
	default:
		return "";
	}
}
const char * CompressionLabTrial::CompressionLabTrialTypeToStringRus(CompressionLabTrial::type comtype)
{
	switch(comtype)				
	{
	case CompressionLabTrial::type::undefined:
		return "undefined";
	case CompressionLabTrial::type::nature_condition:
		return "в природном состоянии";
	case CompressionLabTrial::type::task_condition:
		return "в заданном состоянии";
	case CompressionLabTrial::type::shrinkage:
		return "на усадку";
	default:
		return "";
	}
}
const char * CompressionLabTrial::CompressionLabTrialTypeToStringRusSmall(CompressionLabTrial::type comtype)
{
	switch(comtype)				
	{
	case CompressionLabTrial::type::undefined:
		return "undefined";
	case CompressionLabTrial::type::nature_condition:
		return "в природ. сост.";
	case CompressionLabTrial::type::task_condition:
		return "в задан. сост.";
	case CompressionLabTrial::type::shrinkage:
		return "на усадку";
	default:
		return "";
	}
}
const char * CompressionLabTrial::ValueTypeToString(CompressionLabTrial::value_type vt)
{
	switch(vt)
	{
	case CompressionLabTrial::value_type::vt_absolute_deformation:
		return "Абсолютная деформация";
	case CompressionLabTrial::value_type::vt_apparatus_type:
		return "Тип прибора";
	case CompressionLabTrial::value_type::vt_hoop_diameter:
		return "Диаметр кольца";
	case CompressionLabTrial::value_type::vt_hoop_height:
		return "Высота кольца";
	case CompressionLabTrial::value_type::vt_trial_method:
		return "Метод испытания";
	case CompressionLabTrial::value_type::vt_task_moisture:
		return "Заданная влажность";
	case CompressionLabTrial::value_type::vt_task_moisture_v:
		return "Заданная влажность";
	case CompressionLabTrial::value_type::vt_task_density:
		return "Заданная плотность";
	default:
		return "";
	}
	return "";
}


const char * CompressionLabTrialResults3::ValueTypeToString(CompressionLabTrialResults3::value_type vt)
{
	switch(vt)
	{
	case CompressionLabTrialResults3::value_type::vt_davlenie_nabuhania:
		return "Давление набухания";
	case CompressionLabTrialResults3::value_type::vt_dejstvit_polnaja_osadka:
		return "Действительная полная осадка";
	case CompressionLabTrialResults3::value_type::vt_gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_dvum_krivym:
		return "Начальное просадочное давление по 2-м кривым (прогн. штампа по Гурвичу), МПа";
	case CompressionLabTrialResults3::value_type::vt_gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj:
		return "Начальное просадочное давление по 1-ой кривой (прогн. штампа по Гурвичу), МПа";
	case CompressionLabTrialResults3::value_type::vt_gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_peregibu_vtoroj_krivoj:
		return "Нач. просад. давл. по перегибу второй кривой (прогн. штампа по Гурвичу), МПа";
	case CompressionLabTrialResults3::value_type::vt_h0:
		return "высота образца грунта при прир. влаж. и прир. давл. (на глубине отбора образца)";
	case CompressionLabTrialResults3::value_type::vt_m_otzhatoj_vody:
		return "Масса отжатой воды";
	case CompressionLabTrialResults3::value_type::vt_nachalnoe_prosadochnoe_davlenie_po_dvum_krivym:
		return "Начальное просадочное давление по 2-м кривым, МПа";
	case CompressionLabTrialResults3::value_type::vt_nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj:
		return "Начальное просадочное давление по 1-ой кривой, МПа";
	case CompressionLabTrialResults3::value_type::vt_popravochnyj_koefficient_alpha:
		return "Поправочный коэффициент альфа";
	case CompressionLabTrialResults3::value_type::vt_svobodnoe_otnositelnoe_nabuhanie:
		return "Свободное относительное набухание";
	default:
		return "";
	}
	return "";
}
int CompressionLabTrialResults3::GetSignForReliabilityK(CompressionLabTrialResults3::value_type vt)
{
	switch(vt)
	{
	case CompressionLabTrialResults3::value_type::vt_davlenie_nabuhania:
		return 0;//"Давление набухания";
	case CompressionLabTrialResults3::value_type::vt_dejstvit_polnaja_osadka:
		return 0;//"Действительная полная осадка";
	case CompressionLabTrialResults3::value_type::vt_gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_dvum_krivym:
		return 0;//"Начальное просадочное давление по 2-м кривым (прогноз штампа по Гурвичу)";
	case CompressionLabTrialResults3::value_type::vt_gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj:
		return 0;//"Начальное просадочное давление по 1-ой кривой (прогноз штампа по Гурвичу)";
	case CompressionLabTrialResults3::value_type::vt_gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_peregibu_vtoroj_krivoj:
		return 0;//"Начальное просадочное давление по перегибу второй кривой (прогноз штампа по Гурвичу)";
	case CompressionLabTrialResults3::value_type::vt_h0:
		return 0;//"высота образца грунта при природной влажности и природном давлении (на глубине отбора образца)";
	case CompressionLabTrialResults3::value_type::vt_m_otzhatoj_vody:
		return 0;//"Масса отжатой воды";
	case CompressionLabTrialResults3::value_type::vt_nachalnoe_prosadochnoe_davlenie_po_dvum_krivym:
		return 0;//"Начальное просадочное давление по 2-м кривым";
	case CompressionLabTrialResults3::value_type::vt_nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj:
		return 0;//"Начальное просадочное давление по 1-ой кривой";
	case CompressionLabTrialResults3::value_type::vt_popravochnyj_koefficient_alpha:
		return 0;//"Поправочный коэффициент альфа";
	case CompressionLabTrialResults3::value_type::vt_svobodnoe_otnositelnoe_nabuhanie:
		return 0;//"Свободное относительное набухание";
	default:
		return 0;//"";
	}
	return 0;
}
int CompressionLabTrial::GetSignForReliabilityK(CompressionLabTrial::value_type vt)
{
	switch(vt)
	{
	case CompressionLabTrial::value_type::vt_absolute_deformation:
		return 0;//"Абсолютная деформация";
	case CompressionLabTrial::value_type::vt_apparatus_type:
		return 0;//"Тип прибора";
	case CompressionLabTrial::value_type::vt_hoop_diameter:
		return 0;//"Диаметр кольца";
	case CompressionLabTrial::value_type::vt_hoop_height:
		return 0;//"Высота кольца";
	case CompressionLabTrial::value_type::vt_trial_method:
		return 0;//"Метод испытания";
	case CompressionLabTrial::value_type::vt_task_moisture:
		return 0;//"Заданная влажность";
	case CompressionLabTrial::value_type::vt_task_moisture_v:
		return 0;//"Заданная влажность";
	case CompressionLabTrial::value_type::vt_task_density:
		return 0;//"Заданная плотность";
	default:
		return 0;
	}
	return 0;
}


bool CompressionLabTrial::GetValue(CompressionValueType & vt, trial_got_value & v)
{
	v.trial = this;

	CompressionLabTrial::value_type val_type = vt.vt_CompressionLabTrial;
	int i = vt.i_compression_pressure;
	switch(val_type)
	{
	case CompressionLabTrial::value_type::vt_n_pressures:
		{
			v.v = this->n_pressures;
			v.pf = NULL;
			if (v.v) return true;
		}
		break;
	case CompressionLabTrial::value_type::vt_pressure:
		{
			if (i >= 0 && i < this->n_pressures)
			{
#if USE_LAB_LAYER_PRESSURES
				if (this->lab_number)
				{
					LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
					if (lablayer)
					{
						CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
						if(compression)
						{
							switch (this->com_type)
							{
							case CompressionLabTrial::type::nature_condition:
								{
									// массив pressures
									v.v = compression->pressures_in_nature_condition[i];
									v.pf = NULL;
									if (v.v) return true;
								}
								break;
							case CompressionLabTrial::type::task_condition:
								{
									// массив pressures
									v.v = compression->pressures_in_task_condition[i];
									v.pf = NULL;
									if (v.v) return true;
								}
								break;
							case CompressionLabTrial::type::shrinkage:
								{
									// массив pressures
									v.v = compression->pressures_on_shrinkage[i];
									v.pf = NULL;
									if (v.v) return true;
								}
								break;
							}
						}
					}	
				}
#else
				v.v = this->pressures[i];
				v.pf = NULL;
				if (v.v) return true;
#endif
			}
		}
		break;
	case CompressionLabTrial::value_type::vt_absolute_deformation:
		{
			if (i >= 0 && i < this->n_pressures)
			{
				v = this->absolute_deformations[i];
				if (*v.pf) return true;
			}
		}
		break;
	case CompressionLabTrial::value_type::vt_hoop_diameter:
		{
			// диаметр кольца
#if USE_LAB_LAYER_HOOP
			if (this->lab_number)
			{
				LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
				if (lablayer)
				{
					CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
					if(compression)
					{
						v.v = compression->hoop_diameter;
						v.pf = NULL;
						if (v.v) return true;
					}
				}
			}
#else
			v.v = this->hoop_diameter;
			v.pf = NULL;
			if (v.v) return true;
#endif
		}
		break;
	case CompressionLabTrial::value_type::vt_hoop_height:
		{
			// высота кольца
#if USE_LAB_LAYER_HOOP
			if (this->lab_number)
			{
				LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
				if (lablayer)
				{
					CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
					if(compression)
					{
						v.v = compression->hoop_height;
						v.pf = NULL;
						if (v.v) return true;
					}
				}
			}
#else
			v.v = this->hoop_height;
			v.pf = NULL;
			if (v.v) return true;
#endif

		}
		break;
		/*
	case CompressionLabTrial::value_type::vt_trial_method:
		{
			// метод испытания
			if (this->lab_number)
			{
				LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
				if (lablayer)
				{
					CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
					if(compression)
					{
						v.v = compression->trial_method;
						v.pf = NULL;
						if (v.v) return true;
					}
				}
			}
		}
		break;*/
	}	
	return false;
}

bool CompressionLabTrial::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	return this->GetValue(vt.vt_Compression, v);
}

bool CompressionLabTrial3::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	v.trial = this;

	switch(vt.vt_Compression_3.com_type)
	{
	case CompressionLabTrial::type::nature_condition:
		{
			if (this->p_trial_1)
			{			
				this->p_trial_1->GetValue(vt.vt_Compression_3.vt_Compression_nature, v);
			}
		}
		break;
	case CompressionLabTrial::type::task_condition:
		{
			if (this->p_trial_2)
			{			
				this->p_trial_2->GetValue(vt.vt_Compression_3.vt_Compression_task, v);
			}
		}
		break;
	case CompressionLabTrial::type::shrinkage:
		{
			if (this->p_trial_3)
			{			
				this->p_trial_3->GetValue(vt.vt_Compression_3.vt_Compression_shrinkage, v);
			}
		}
		break;
	}

	return false;	
}



void CompressionLabTrial::PrintfProperties(void)
{
	printf("CompressionLabTrial::PrintfProperties()\n");
	printf("CompressionLabTrial  type = %s\n", CompressionLabTrial::CompressionLabTrialTypeToString(com_type));

	if (this->lab_number)
	{
		LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
		if (lablayer)
		{
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
			if(compression)
			{
				// массив
				for (int i = 0; i < n_pressures; i++)
				{
#if USE_LAB_LAYER_PRESSURES
					switch(com_type)				
					{
					case CompressionLabTrial::type::nature_condition:
						{
							printf("compression->pressures_in_nature_condition[%d] = %f\n", i, compression->pressures_in_nature_condition[i]);
						}
						break;
					case CompressionLabTrial::type::task_condition:
						{
							printf("compression->pressures_in_task_condition[%d] = %f\n", i, compression->pressures_in_task_condition[i]);
						}
						break;
					case CompressionLabTrial::type::shrinkage:
						{
							printf("compression->pressures_on_shrinkage[%d] = %f\n", i, compression->pressures_on_shrinkage[i]);
						}
						break;
					}
#else
					printf("compression->pressures[%d] = %f\n", i, this->pressures[i]);
#endif

					printf("absolute_deformations[%d] = %f\n", i, absolute_deformations[i].v);
				}
			}
		}	
	}
}
void CompressionLabTrial3::PrintfProperties(void)
{
	printf("CompressionLabTrial3::PrintfProperties()\n");

	if (this->p_trial_1)
		this->p_trial_1->PrintfProperties();
	if (this->p_trial_2)
		this->p_trial_2->PrintfProperties();
	if (this->p_trial_3)
		this->p_trial_3->PrintfProperties();
}


double GetPuasson_shtamp(CGround::ground_type t)
{
	// коэффициент Пуассона
	double mju = 1.0;
	switch(t)
	{
	case CGround::ground_type::Sand:
		mju = 0.30;
		break;
	case CGround::ground_type::SandyLoam://супесь
		mju = 0.30;
		break;
	case CGround::ground_type::Loam://суглинок
		mju = 0.35;
		break;
	case CGround::ground_type::Clay://Глина
		mju = 0.42;
		break;
	}
	return mju;
}

double GetPuasson_interpolation(CGround::ground_type t, double IL, double Ip, double Wp)
{
	// коэффициент Пуассона
	double mju = 1.0;
	switch(t)
	{
		// для песков и супесей 0,30 - 0,35
	case CGround::ground_type::Sand:
		mju = 0.325;
		break;
	case CGround::ground_type::SandyLoam://супесь
		mju = 0.325;
		break;
	case CGround::ground_type::Loam://суглинок
		//для суглинков 0,35-0,37
		mju = 0.36;
		break;
	case CGround::ground_type::Clay://Глина
		{
			double IL_min = - Wp / Ip;
			double vIL[] = {IL_min, 0.0,  0.25,  1.0};
			double vmj[] = {0.2,    0.3,  0.38,  0.45};
			linterp(5, vIL, vmj, IL, mju);
			if (mju < 0.2) mju = 0.2;
			if (mju > 0.45) mju = 0.45;
		}
		break;
	}
	// меньшие значения mju принмают при большей плотности
 
	return mju;
}

double GetBeta_compress_obych(CGround::ground_type t)
{
	// коэффициент Beta
	double beta = 1.0;
	switch(t)
	{
	case CGround::ground_type::Sand:
		beta = 0.80;
		break;
	case CGround::ground_type::SandyLoam://супесь
		beta = 0.70;
		break;
	case CGround::ground_type::Loam://суглинок
		beta = 0.50;
		break;
	case CGround::ground_type::Clay://Глина
		beta = 0.4;
		break;
	}
	return beta;
}

double GetBeta_compress_prosad(CGround::ground_type t)
{
	// коэффициент Beta
	double beta = 1.0;
	switch(t)
	{
	case CGround::ground_type::SandyLoam://супесь
		beta = 0.74;
		break;
	case CGround::ground_type::Loam://суглинок
		beta = 0.63;
		break;
	case CGround::ground_type::Clay://Глина
		beta = 0.4;
		break;
	}
	return beta;
}

double GetBeta(double mju)
{
	double beta = 1.0 - 2.0 * mju * mju / (1.0 - mju);
	return beta;
}
double GetBetaMavrodi(CGround::ground_type t, double Jp)
{
	switch(t)
	{
	case CGround::ground_type::Sand:
		{
			// коэффициент Пуассона
			double mju = 0.30;
			double beta = 1.0 - 2.0 * mju * mju / (1.0 - mju);
			return beta;
		}
		break;
	case CGround::ground_type::SandyLoam://супесь
	case CGround::ground_type::Loam://суглинок
	case CGround::ground_type::Clay://Глина
		{
			double beta = 2.0 * (0.37 - Jp);
			return beta;
		}
		break;
	}
	return 0.0;
}
double GetMk(CGround::ground_type t, double e)
{
	// коэффициент 
	double mk = 1.0;

	//супеси
	double ve0[] = { 0.45,  0.55,  0.65,  0.75,  0.85};
	double vm0[] = {  4.0,   4.0,   3.5,   3.0,   2.0};

	// суглинки
	double ve1[] = { 0.45,  0.55,  0.65,  0.75,  0.85,  0.95,  1.05};
	double vm1[] = {  5.0,   5.0,   4.5,   4.0,   3.0,   2.5,   2.0};
	
	//глины
	double ve2[] = {0.65,  0.75,  0.85,  0.95,  1.05};
	double vm2[] = { 6.0,   6.0,   5.5,   5.0,   4.5};


	switch(t)
	{
	case CGround::ground_type::Sand:
		break;
	case CGround::ground_type::SandyLoam://супесь
		linterp(5, ve0, vm0, e, mk);
		break;
	case CGround::ground_type::Loam://суглинок
		linterp(7, ve1, vm1, e, mk);
		break;
	case CGround::ground_type::Clay://Глина
		linterp(5, ve2, vm2, e, mk);
		break;
	}
	return mk;
}
double GetKp(double depth, double D)
{
	double r = depth/D;

	if (r >= 5.0)
		return 0.7;

	// коэффициент 
	double Kp = 1.0;

	double vr [] = { 0.0,   1.0,  2.0,  3.0,  4.0,  5.0 };
	double vkp[] = { 1.0,  0.90, 0.82, 0.77, 0.73,  0.70};
	linterp(6, vr, vkp, r, Kp);
	return Kp;
}
double GetHdef(double p, double D)
{
	//величина деформируемой зоны грунта по вертикали
	//давления
	double vp [] = { 0.05,  0.1,  0.2,  0.3,  0.4};
	// доля от диаметра штампа
	double vt [] = { 0.4,  0.7,  1.2,  1.7,  2.0};
	double t = 0.0;
	linterp(6, vp, vt, p, t);
	return t * D;
}
void PrintfGurvichShtamp(Gurvich * res, vector<fmtstr> * text)
{
	char str[1024]; 
		
/*		sprintf(str, "a0 = %f\0", shtamp_lin_interp_a0.v);
		DeleteEndZeros(str);
		if (text) text->push_back(fmtstr(str, NULL, true, true));
		
		sprintf(str, "a1 = %f\0", shtamp_lin_interp_a1.v);
		DeleteEndZeros(str);
		if (text) text->push_back(fmtstr(str, NULL, true, true));
*/
		char s1[1024];
		char s2[1024];
		char sE[1024];

		sprintf(s1, "%f", res->shtamp_deformation_module_01_02_pressure_interval[0]);
		sprintf(s2, "%f", res->shtamp_deformation_module_01_02_pressure_interval[1]);
		sprintf(sE, "%f", res->shtamp_deformation_module_in_01_02_interval.v);
		DeleteEndZeros(s1);
		DeleteEndZeros(s2);
		DeleteEndZeros(sE);
		if (strlen(sE) > max_str_len_val_printf_fmtstr)
			sprintf(sE, "%e", res->shtamp_deformation_module_in_01_02_interval.v);
		sprintf(str, "Модуль деформации (под штампом) [%s - %s] = %s МПа\0", s1, s2, sE);
		if (text) text->push_back(fmtstr(str, &res->shtamp_deformation_module_in_01_02_interval.f, true, true));

		sprintf(sE, "%f", res->Sy_shtamp_lin_in_01_02_interval.v);
		DeleteEndZeros(sE);
		if (strlen(sE) > max_str_len_val_printf_fmtstr)
			sprintf(sE, "%e", res->Sy_shtamp_lin_in_01_02_interval.v);
		sprintf(str, "Ср.кв.откл.усадки(штамп).от лин.ф-ции [%s - %s] = %s, мм", s1, s2, sE);
		if (text) text->push_back(fmtstr(str, &res->Sy_shtamp_lin_in_01_02_interval.f, true, true));
		
		sprintf(s1, "%f", res->shtamp_deformation_module_defined_pressure_interval[0]);
		sprintf(s2, "%f", res->shtamp_deformation_module_defined_pressure_interval[1]);
		sprintf(sE, "%f", res->shtamp_deformation_module_in_defined_interval.v);
		DeleteEndZeros(s1);
		DeleteEndZeros(s2);
		DeleteEndZeros(sE);
		if (strlen(sE) > max_str_len_val_printf_fmtstr)
			sprintf(sE, "%e", res->shtamp_deformation_module_in_defined_interval.v);
		sprintf(str, "Модуль деформации (под штампом) [%s - %s] = %s МПа\0", s1, s2, sE);
		if (text) text->push_back(fmtstr(str, &res->shtamp_deformation_module_in_defined_interval.f, true, true));

		sprintf(sE, "%f", res->Sy_shtamp_lin_in_defined_interval.v);
		DeleteEndZeros(sE);
		if (strlen(sE) > max_str_len_val_printf_fmtstr)
			sprintf(sE, "%e", res->Sy_shtamp_lin_in_defined_interval.v);
		sprintf(str, "Ср.кв.откл.усадки(штамп).от лин.ф-ции [%s - %s] = %s, мм", s1, s2, sE);
		if (text) text->push_back(fmtstr(str, &res->Sy_shtamp_lin_in_defined_interval.f, true, true));
		
		sprintf(str, "Kp = %f\0", res->Kp.v);
		DeleteEndZeros(str);
		if (text) text->push_back(fmtstr(str, &res->Kp.f, true, true));

		sprintf(s1, "%f", res->shtamp_deformation_module_01_02_pressure_interval[0]);
		sprintf(s2, "%f", res->shtamp_deformation_module_01_02_pressure_interval[1]);
		sprintf(sE, "%f", res->shtamp_deformation_module_in_01_02_interval_Kp.v);
		DeleteEndZeros(s1);
		DeleteEndZeros(s2);
		DeleteEndZeros(sE);
		if (strlen(sE) > max_str_len_val_printf_fmtstr)
			sprintf(sE, "%e", res->shtamp_deformation_module_in_01_02_interval_Kp.v);
		sprintf(str, "Модуль деформации (под штампом) [%s - %s] * Kp = %s МПа\0", s1, s2, sE);
		if (text) text->push_back(fmtstr(str, &res->shtamp_deformation_module_in_01_02_interval_Kp.f, true, true));

		sprintf(s1, "%f", res->shtamp_deformation_module_defined_pressure_interval[0]);
		sprintf(s2, "%f", res->shtamp_deformation_module_defined_pressure_interval[1]);
		sprintf(sE, "%f", res->shtamp_deformation_module_in_defined_interval_Kp.v);
		DeleteEndZeros(s1);
		DeleteEndZeros(s2);
		DeleteEndZeros(sE);
		if (strlen(sE) > max_str_len_val_printf_fmtstr)
			sprintf(sE, "%e", res->shtamp_deformation_module_in_defined_interval_Kp.v);
		sprintf(str, "Модуль деформации (под штампом) [%s - %s] * Kp = %s МПа\0", s1, s2, sE);
		if (text) text->push_back(fmtstr(str, &res->shtamp_deformation_module_in_defined_interval_Kp.f, true, true));
}

// диаметр штампа в прогнозе по Гурвичу
double Gurvich::shtamp_diameter = 79.788; //см

double Gurvich::y_SecondDerivativeLimit = 25;

void Gurvich::CalcDeformationModuleOnShtampPrediction(const char * name,
							int n,
							CompressionLabExperiment * compression,
							// влажность
							double w,
							// влажность водонасыщения
							double W_sat,
							//коэффициент пористости
							double e,
							// число пластичности
							double Ip)
{		
	if (this->m_res && compression)
	{
		this->m_res->zamachivanie = false;

		LabNumber * labnumber = this->m_res->lab_trial ? (LabNumber *)this->m_res->lab_trial->GetLabNumber() : NULL;
		if (!labnumber) return;

		LabLayer * lablayer = (LabLayer *)labnumber->GetLabLayer();
		if (!lablayer) return;

		vector<x_compression>		* p_shtamp_vx = NULL;
		vector<trial_value>			* p_shtamp_vy = NULL;

		p_shtamp_vx = &shtamp_vx;
		p_shtamp_vy = &shtamp_vy;

		p_shtamp_vx->clear();
		p_shtamp_vy->clear();

		bool defined_interval_started = false;
		bool defined_interval_finished = false;
		vector<size_t> defined_interval_indexes;

		bool interval_01_02_started = false;
		bool interval_01_02_finished = false;
		vector<size_t> interval_01_02_indexes;

		defined_interval_indexes.clear();
		interval_01_02_indexes.clear();

		CompressionLabTrial * com_lab_trial = dynamic_cast<CompressionLabTrial *>(this->m_res->lab_trial);
		if (com_lab_trial)
		{
			//bool first_pressure_determined = false;
			char str[4098];
			string s = name;			
			for (int i = 0; i < com_lab_trial->n_pressures; i++)
			{
#if USE_LAB_LAYER_PRESSURES
				double pressure;
				switch(m_res->com_type)				
				{
				case CompressionLabTrial::type::nature_condition:
					{
						pressure = compression->pressures_in_nature_condition[i];

						if (i > 0 && compression->pressures_in_nature_condition[i-1] == compression->pressures_in_nature_condition[i])
						{
							m_res->zamachivanie = true;
						}
					}
					break;
				case CompressionLabTrial::type::task_condition:
					{
						pressure = compression->pressures_in_task_condition[i];
					}
					break;
				case CompressionLabTrial::type::shrinkage:
					{
						pressure = compression->pressures_on_shrinkage[i];
					}
					break;
				}

#else
				double pressure = com_lab_trial->pressures[i];;
				if (m_res->com_type == CompressionLabTrial::type::nature_condition)			
				{
					if (i > 0 && com_lab_trial->pressures[i-1] == com_lab_trial->pressures[i])
					{
						m_res->zamachivanie = true;
					}
				}
#endif
				double W;
				if (m_res->zamachivanie)
					W = W_sat;
				else
					W = w;
				
				double Em = 0.0;
				double Ecp = 0.0;
				double Wm = 0.0;
				double Wcp = 0.0;


				bool calc = true;

				double Sk = 0.0;

				if (pressure == 0.05
					||
					pressure == 0.10
					||
					pressure == 0.15
					||
					pressure == 0.20
					||
					pressure == 0.25)
				{
#if USE_LAB_LAYER_HOOP
					Sk = com_lab_trial->absolute_deformations[i].v * (20.0 / compression->hoop_height);
#else
					Sk = com_lab_trial->absolute_deformations[i].v * (20.0 / com_lab_trial->hoop_height);
#endif
				}

				double Ssh = 0.0;

				if (pressure == 0.05)
				{								
					Em = 0.98 * e;
					Ecp = (Em + e)/2.0;
					Wm = 0.99 * W;
					Wcp = (Wm + W)/2.0;
					Ssh = 0.044 * Sk + 0.54*Ecp + 5.75 * Wcp - 6.0*Ip + 0.86;
				}
				else if (pressure == 0.10)
				{
					Em = 0.96 * e;
					Ecp = (Em + e)/2.0;
					Wm = 0.97 * W;
					Wcp = (Wm + W)/2.0;
					Ssh = 0.78 * Sk + 0.82*Ecp + 11.3 * Wcp - 8.2*Ip + 1.25;
				}
				else if (pressure == 0.15)
				{
					Em = 0.93 * e;
					Ecp = (Em + e)/2.0;
					Wm = 0.95 * W;
					Wcp = (Wm + W)/2.0;
					Ssh = 1.50 * Sk + 1.58*Ecp + 14.1 * Wcp - 12.0*Ip + 1.87;
				}
				else if (pressure == 0.20)
				{
					Em = 0.88 * e;
					Ecp = (Em + e)/2.0;
					Wm = 0.93 * W;
					Wcp = (Wm + W)/2.0;
					Ssh = 1.52 * Sk + 2.71*Ecp + 17.6 * Wcp - 15.1*Ip + 2.40;
				}
				else if (pressure == 0.25)
				{
					Em = 0.85 * e;
					Ecp = (Em + e)/2.0;
					Wm = 0.90 * W;
					Wcp = (Wm + W)/2.0;
					Ssh = 0.81 * Sk + 3.70*Ecp + 37.7 * Wcp - 29.8*Ip + 2.80;
				}
				else
				{
					calc = false;
				}

				double y;

				if (calc)
				{
					switch (n)
					{
					case 1:
						y = Em;
						break;
					case 2:
						y = Ecp;
						break;
					case 3:
						y = Wm;
						break;
					case 4:
						y = Wcp;
						break;
					case 5:
						y = Ssh;
						break;
					}
					sprintf(str, "%f\0", y);
					DeleteEndZeros(str);
				}
				else
				{
					sprintf(str, "***\0");
				}
				
				if (calc/* && !m_res->zamachivanie*/)
				{
					p_shtamp_vx->push_back(x_compression(pressure, m_res->zamachivanie));
					p_shtamp_vy->push_back(trial_value(y));
				}
				if ( ! defined_interval_started )
				{
					if (pressure >= lablayer->deformation_module_defined_pressure_interval[0])
					{
						defined_interval_started = true;
					}
				}
				if ( ! defined_interval_finished )
				{
					if (pressure > lablayer->deformation_module_defined_pressure_interval[1])
					{
						defined_interval_finished = true;
					}
				}
				if (calc && !m_res->zamachivanie && defined_interval_started && !defined_interval_finished )
				{
					defined_interval_indexes.push_back(p_shtamp_vy->size()-1);
				}


				if ( ! interval_01_02_started )
				{
					if (pressure >= CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0])
					{
						interval_01_02_started = true;
					}
				}
				if ( ! interval_01_02_finished )
				{
					if (pressure > CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1])
					{
						interval_01_02_finished = true;
					}
				}
				if (calc && !m_res->zamachivanie && interval_01_02_started && !interval_01_02_finished )
				{
					interval_01_02_indexes.push_back(p_shtamp_vy->size()-1);
				}
			}
		}


		PhysicalLabTrial * phys =  dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
		if (!phys) return;

		PhysicalLabTrialResults * phys_res =  dynamic_cast<PhysicalLabTrialResults *>(phys->results);
		if (!phys_res) return;
		if (!phys_res->calculed)
			phys_res->CalcProperties();

		// коэффициент Пуассона
		double mju = GetPuasson_shtamp(phys_res->t);
		switch(m_res->com_type)				
		{
		case CompressionLabTrial::type::nature_condition:
			{
				mju = m_res->nju_tab.v;
			}
			break;
		case CompressionLabTrial::type::task_condition:
			{
				mju = m_res->nju_tab_ws.v;
			}
			break;
		}

		vector<x_compression> vx_01_02_interval;
		vector<trial_got_value> vy_in_01_02_interval;

		for (size_t j = 0; j < interval_01_02_indexes.size(); j++)
		{
			size_t i = interval_01_02_indexes[j];

			double pressure = p_shtamp_vx->operator [](i).x;

			vx_01_02_interval.push_back(pressure);

			trial_got_value tgvy = p_shtamp_vy->operator [](i);
			tgvy.lab_number = this->m_res->lab_trial ? this->m_res->lab_trial->lab_number : NULL;
			tgvy.trial = NULL;

			vy_in_01_02_interval.push_back(tgvy);

			if(j == 0) shtamp_deformation_module_01_02_pressure_interval[0] = pressure;
			shtamp_deformation_module_01_02_pressure_interval[1] = pressure;

		}

		if (MinSqLinear(2, vx_01_02_interval, vy_in_01_02_interval, 0, 0, true, shtamp_lin_interp_a0_in_01_02_interval, shtamp_lin_interp_a1_in_01_02_interval, m_shtamp_lin_in_01_02_interval, Sy_shtamp_lin_in_01_02_interval))
		{
			shtamp_deformation_module_in_01_02_interval = 10. * (1.0 - mju * mju) * 0.79 * Gurvich::shtamp_diameter / shtamp_lin_interp_a1_in_01_02_interval.v;
		}



		vector<x_compression> vx_defined_interval;
		vector<trial_got_value> vy_in_defined_interval;

		for (size_t j = 0; j < defined_interval_indexes.size(); j++)
		{
			size_t i = defined_interval_indexes[j];

			double pressure = p_shtamp_vx->operator [](i).x;

			vx_defined_interval.push_back(pressure);

			trial_got_value tgvy = p_shtamp_vy->operator [](i);
			tgvy.lab_number = this->m_res->lab_trial ? this->m_res->lab_trial->lab_number : NULL;
			tgvy.trial = NULL;

			vy_in_defined_interval.push_back(tgvy);

			if(j == 0) shtamp_deformation_module_defined_pressure_interval[0] = pressure;
			shtamp_deformation_module_defined_pressure_interval[1] = pressure;

		}

		if (MinSqLinear(2, vx_defined_interval, vy_in_defined_interval, 0, 0, true, shtamp_lin_interp_a0_in_defined_interval, shtamp_lin_interp_a1_in_defined_interval, m_shtamp_lin_in_defined_interval, Sy_shtamp_lin_in_defined_interval))
		{
			shtamp_deformation_module_in_defined_interval = 10. * (1.0 - mju * mju) * 0.79 * Gurvich::shtamp_diameter / shtamp_lin_interp_a1_in_defined_interval.v;
	/*
			printf("shtamp_deformation_module_in_defined_interval [%f %f] = %f\n",
				shtamp_deformation_module_defined_pressure_interval[0],
				shtamp_deformation_module_defined_pressure_interval[1],
				shtamp_deformation_module_in_defined_interval.v);*/
		}

		CompressionLabTrial * comp = dynamic_cast<CompressionLabTrial *>(this->m_res->lab_trial);

		if (comp && comp->lab_number)
		{
			Kp = GetKp(comp->lab_number->depth, 0.01 * Gurvich::shtamp_diameter);
			this->shtamp_deformation_module_in_01_02_interval_Kp = this->shtamp_deformation_module_in_01_02_interval * Kp;
			this->shtamp_deformation_module_in_defined_interval_Kp = this->shtamp_deformation_module_in_defined_interval * Kp;
		}


	}
}


void Gurvich::CalcDeformationModuleOnShtampPrediction(
	CompressionLabExperiment * compression)
{
	if (this->m_res)
	{
		LabNumber * labnumber = this->m_res->lab_trial ? (LabNumber *)this->m_res->lab_trial->GetLabNumber() : NULL;
		if (!labnumber) return;
		PhysicalLabTrial * phys =  dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
		if (!phys) return;
		PhysicalLabTrialResults * phys_res =  dynamic_cast<PhysicalLabTrialResults *>(phys->results);
		if (!phys_res) return;
		if (!phys_res->calculed)
			phys_res->CalcProperties();

		if ( 
			(phys_res->t == CGround::ground_type::SandyLoam || phys_res->t == CGround::ground_type::Loam || phys_res->t == CGround::ground_type::Clay)
			)
		{
			// Влажность водонасыщения

			double W_sat = phys_res->w_water_saturated.v;
			/*sprintf(str, "Влажность водонасыщения = %f\0", Wnas);
			DeleteEndZeros(str);
			s = str;
			if (text) text->push_back(s);*/

			// влажность
			double W = 0.0;


			switch(m_res->com_type)				
			{
			case CompressionLabTrial::type::nature_condition:
				{
					W = phys->moisture_of_nature_large_exchange.v;
				}
				break;
			case CompressionLabTrial::type::task_condition:
				{

					char szBuff[128];
					strcpy(szBuff, compression->task_moisture.c_str());
					OemToChar(szBuff, szBuff);
						
					if (strlen(szBuff))
					{
						setlocale( LC_ALL, "Russian" );
						char * buff = _strlwr( _strdup( szBuff ) );
						setlocale( LC_ALL, "English" );

						if (0 == strcmp(buff, "водонас."))
							W = W_sat;

						if (0 == strcmp(buff, "        "))
							W = W_sat;

						if (buff) free(buff);
					}
				}
				break;
			case CompressionLabTrial::type::shrinkage:
				{
					W = W_sat;
				}
				break;
			}

			// число пластичности						
			double Ip = phys_res->plasticity_index.v;
			double e = phys_res->e.v;

			this->CalcDeformationModuleOnShtampPrediction("Под штамп:",		5, compression, W, W_sat, e, Ip);		
		}
	}
}

void Gurvich::PrintShtampDeformationPrediction(const char * name,
							vector<fmtstr> * text,
							PlotData * plot_data)
{						
	if (plot_data)
		plot_data->plot_lines.push_back(plot_line());

	char str[4098];
	string s = name;			
	if (text) text->push_back(fmtstr(s, NULL, false, true));

	for (size_t i = 0; i < this->shtamp_vx.size(); i++)
	{
		double pressure = this->shtamp_vx[i].x;
		double y = this->shtamp_vy[i].v;	

		if (text) text->push_back(fmtstr(str, NULL, i == this->shtamp_vx.size() - 1, true));

		if (plot_data)
			plot_data->plot_lines.back().data.push_back(plot_data_2d(pressure, y));
	}
}
void Gurvich::PrintGurvichShtamp(CompressionLabExperiment * compression, PhysicalLabTrial * phys, vector<fmtstr> * text, double W_sat, double & W)
{
	char str[1024]; 
	if (this->m_res)
	{
		string s = "";		

		switch(this->m_res->com_type)				
		{
		case CompressionLabTrial::type::nature_condition:
			{
				W = phys->moisture_of_nature_large_exchange.v;
				char sw[1024];
				sprintf(sw, "%f", W);
				DeleteEndZeros(sw);
				sprintf(str, "Под штампом в природном состоянии (влажн. = %s)\0", sw);	
				s += str;	
			}
			break;
		case CompressionLabTrial::type::task_condition:
			{

				char szBuff[128];
				strcpy(szBuff, compression->task_moisture.c_str());
				OemToChar(szBuff, szBuff);
					
				if (strlen(szBuff))
				{
					setlocale( LC_ALL, "Russian" );
					char * buff = _strlwr( _strdup( szBuff ) );
					setlocale( LC_ALL, "English" );

					if (0 == strcmp(buff, "водонас."))
						W = W_sat;

					if (0 == strcmp(buff, "        "))
						W = W_sat;

					if (buff) free(buff);
				}

				char sw[1024];
				char sd[1024];

				sprintf(sw, "%f", W);
				DeleteEndZeros(sw);

				sprintf(sd, "%f", compression->task_density);
				DeleteEndZeros(sd);

				sprintf(str, "Под штампом с задан. влажн. \"%s\" = %s и плотн. %s\0", szBuff, sw, sd);	
				s += str;
			}
			break;
		case CompressionLabTrial::type::shrinkage:
			{
				W = W_sat;
			}
			break;
		}
		if (text) text->push_back(fmtstr(s, NULL, true, false));
	}
}
void CompressionLabTrialResults3::PrintGurvichShtampProsadka_po_dvum_krivym(
	PlotData * plot_data)
{		
	if (this->p_result_1)
	{
		if (plot_data)
			plot_data->plot_lines.push_back(plot_line());

		for (size_t i = 0; i < this->p_result_1->m_gurvich.shtamp_vx.size(); i++)
		{
			double pressure = this->p_result_1->m_gurvich.shtamp_vx[i].x;
			double y = this->gurvich_shtamp_prosadka_po_dvum_krivym[i].v;	

			if (plot_data)
				plot_data->plot_lines.back().data.push_back(plot_data_2d(pressure, y));
		}
	}
}
void CompressionLabTrialResults3::PrintGurvichShtampProsadka_po_odnoj_krivoj(
	PlotData * plot_data)
{		
	if (this->p_result_1)
	{
		if (plot_data)
			plot_data->plot_lines.push_back(plot_line());

		for (size_t i = 0; i < this->p_result_1->m_gurvich.shtamp_vx.size(); i++)
		{
			double pressure = this->p_result_1->m_gurvich.shtamp_vx[i].x;
			double y = this->gurvich_shtamp_prosadka_po_odnoj_krivoj[i].v;	

			if (plot_data)
				plot_data->plot_lines.back().data.push_back(plot_data_2d(pressure, y));
		}
	}
}
bool CompressionLabTrialResults3::PrintDeformationModuleOnShtamp(
	CompressionLabExperiment * compression,
	vector<fmtstr> * text,
	vector<LabData> * labdata)
{
	string s;
	char str[4098]; 
	char sv[128];

	LabNumber * labnumber = this->lab_trial ? (LabNumber *)this->lab_trial->GetLabNumber() : NULL;
	if (!labnumber) return false;
	PhysicalLabTrial * phys =  dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
	if (!phys) return false;

	PhysicalLabTrialResults * phys_res =  dynamic_cast<PhysicalLabTrialResults *>(phys->results);
	if (!phys_res) return false;
	if (!phys_res->calculed)
		phys_res->CalcProperties();


	LabLayer * lablayer = (LabLayer *) labnumber->GetLabLayer();
	if (!lablayer)
	{
		return false;
	}
	CompressionLabTrial3 * comp_lab_trial = dynamic_cast<CompressionLabTrial3 *>(this->lab_trial);
	if (!comp_lab_trial)
	{
		return false;
	}
			
	LabParameters * lab_params = lablayer->FindLabParameters(comp_lab_trial->trial_indication);
	CompressionLabParameters3 * com_lab_params = dynamic_cast<CompressionLabParameters3 *>(lab_params);

	if ( 
		(phys_res->t == CGround::ground_type::SandyLoam || phys_res->t == CGround::ground_type::Loam || phys_res->t == CGround::ground_type::Clay)
		)
	{
		// Влажность водонасыщения
		double W_sat = phys_res->w_water_saturated.v;

		// число пластичности						
		double Ip = phys_res->plasticity_index.v;
		double e = phys_res->e.v;			

		if(labdata)
		{
			labdata->back().plot_data.use_plot = true;
			labdata->back().plot_data.y_dir = -1;
			labdata->back().plot_data.title = "Расчётн. осадка под штампом";
			labdata->back().plot_data.xlabel = "Давления, МПа";
			labdata->back().plot_data.ylabel = "Абс.Деф., мм";	
			labdata->back().plot_data.x_ax_not_dubl = true;	

			if (com_lab_params && com_lab_params->params_nature.GetCheckedLabParam() &&
				com_lab_params->params_nature.parameters_results3_every &&
				com_lab_params->params_nature.parameters_results3_every->GetCheckedLabParam())
			{
				if (this->p_result_1 && this->p_result_1->calculed)
				{
					// влажность
					double W = 0.0;
					this->p_result_1->m_gurvich.PrintGurvichShtamp(compression, phys, text, W_sat, W);
					this->p_result_1->m_gurvich.PrintShtampDeformationPrediction("Под штамп:", NULL, &labdata->back().plot_data);			
					
					if (this->p_result_1->m_gurvich.shtamp_lin_interp_a0_in_01_02_interval.f)
					{
						labdata->back().plot_data.lin_interp.push_back(LinInterp());
						labdata->back().plot_data.lin_interp.back().m_a0 = this->p_result_1->m_gurvich.shtamp_lin_interp_a0_in_01_02_interval.v;	
						labdata->back().plot_data.lin_interp.back().m_a1 = this->p_result_1->m_gurvich.shtamp_lin_interp_a1_in_01_02_interval.v;
						labdata->back().plot_data.lin_interp.back().xmin = this->p_result_1->m_gurvich.shtamp_deformation_module_01_02_pressure_interval[0];
						labdata->back().plot_data.lin_interp.back().xmax = this->p_result_1->m_gurvich.shtamp_deformation_module_01_02_pressure_interval[1];

						labdata->back().plot_data.lin_interp.push_back(LinInterp());
						labdata->back().plot_data.lin_interp.back().m_a0 = this->p_result_1->m_gurvich.shtamp_lin_interp_a0_in_defined_interval.v;	
						labdata->back().plot_data.lin_interp.back().m_a1 = this->p_result_1->m_gurvich.shtamp_lin_interp_a1_in_defined_interval.v;
						labdata->back().plot_data.lin_interp.back().xmin = this->p_result_1->m_gurvich.shtamp_deformation_module_defined_pressure_interval[0];
						labdata->back().plot_data.lin_interp.back().xmax = this->p_result_1->m_gurvich.shtamp_deformation_module_defined_pressure_interval[1];
						labdata->back().plot_data.lin_interp.back().line_color = RGB(0,0,200);	
					}
				}
			}
			if (com_lab_params && com_lab_params->params_task.GetCheckedLabParam() &&
				com_lab_params->params_task.parameters_results3_every &&
				com_lab_params->params_task.parameters_results3_every->GetCheckedLabParam())
			{
				if (this->p_result_2 && this->p_result_2->calculed)
				{
					// влажность
					double W = 0.0;
					this->p_result_2->m_gurvich.PrintGurvichShtamp(compression, phys, text, W_sat, W);
					this->p_result_2->m_gurvich.PrintShtampDeformationPrediction("Под штамп:", NULL, &labdata->back().plot_data);			
					
					if (this->p_result_2->m_gurvich.shtamp_lin_interp_a0_in_01_02_interval.f)
					{
						labdata->back().plot_data.lin_interp.push_back(LinInterp());
						labdata->back().plot_data.lin_interp.back().m_a0 = this->p_result_2->m_gurvich.shtamp_lin_interp_a0_in_01_02_interval.v;	
						labdata->back().plot_data.lin_interp.back().m_a1 = this->p_result_2->m_gurvich.shtamp_lin_interp_a1_in_01_02_interval.v;
						labdata->back().plot_data.lin_interp.back().xmin = this->p_result_2->m_gurvich.shtamp_deformation_module_01_02_pressure_interval[0];
						labdata->back().plot_data.lin_interp.back().xmax = this->p_result_2->m_gurvich.shtamp_deformation_module_01_02_pressure_interval[1];

						labdata->back().plot_data.lin_interp.push_back(LinInterp());
						labdata->back().plot_data.lin_interp.back().m_a0 = this->p_result_2->m_gurvich.shtamp_lin_interp_a0_in_defined_interval.v;	
						labdata->back().plot_data.lin_interp.back().m_a1 = this->p_result_2->m_gurvich.shtamp_lin_interp_a1_in_defined_interval.v;
						labdata->back().plot_data.lin_interp.back().xmin = this->p_result_2->m_gurvich.shtamp_deformation_module_defined_pressure_interval[0];
						labdata->back().plot_data.lin_interp.back().xmax = this->p_result_2->m_gurvich.shtamp_deformation_module_defined_pressure_interval[1];
						labdata->back().plot_data.lin_interp.back().line_color = RGB(0,0,200);	
					}
				}
			}
			if (com_lab_params && com_lab_params->params_shrinkage.GetCheckedLabParam() &&
				com_lab_params->params_shrinkage.parameters_results3_every &&
				com_lab_params->params_shrinkage.parameters_results3_every->GetCheckedLabParam())
			{
				if (this->p_result_3 && this->p_result_3->calculed)
				{
					// влажность
					double W = 0.0;
					this->p_result_3->m_gurvich.PrintGurvichShtamp(compression, phys, text, W_sat, W);
					this->p_result_3->m_gurvich.PrintShtampDeformationPrediction("Под штамп:",  NULL, &labdata->back().plot_data);			
					
					if (this->p_result_3->m_gurvich.shtamp_lin_interp_a0_in_01_02_interval.f)
					{
						labdata->back().plot_data.lin_interp.push_back(LinInterp());
						labdata->back().plot_data.lin_interp.back().m_a0 = this->p_result_3->m_gurvich.shtamp_lin_interp_a0_in_01_02_interval.v;	
						labdata->back().plot_data.lin_interp.back().m_a1 = this->p_result_3->m_gurvich.shtamp_lin_interp_a1_in_01_02_interval.v;
						labdata->back().plot_data.lin_interp.back().xmin = this->p_result_3->m_gurvich.shtamp_deformation_module_01_02_pressure_interval[0];
						labdata->back().plot_data.lin_interp.back().xmax = this->p_result_3->m_gurvich.shtamp_deformation_module_01_02_pressure_interval[1];

						labdata->back().plot_data.lin_interp.push_back(LinInterp());
						labdata->back().plot_data.lin_interp.back().m_a0 = this->p_result_3->m_gurvich.shtamp_lin_interp_a0_in_defined_interval.v;	
						labdata->back().plot_data.lin_interp.back().m_a1 = this->p_result_3->m_gurvich.shtamp_lin_interp_a1_in_defined_interval.v;
						labdata->back().plot_data.lin_interp.back().xmin = this->p_result_3->m_gurvich.shtamp_deformation_module_defined_pressure_interval[0];
						labdata->back().plot_data.lin_interp.back().xmax = this->p_result_3->m_gurvich.shtamp_deformation_module_defined_pressure_interval[1];
						labdata->back().plot_data.lin_interp.back().line_color = RGB(0,0,200);	
					}
				}
			}

			if(this->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_peregibu_vtoroj_krivoj_calculed)
			{
				if (this->p_result_1)
				{
					labdata->back().plot_data.lin_vertical.push_back(LinVertical());
					labdata->back().plot_data.lin_vertical.back().m_x = this->p_result_1->ocenka_bytovogo_davlenia.v;
					labdata->back().plot_data.lin_vertical.back().line_color = RGB(0,200,0);
					labdata->back().plot_data.lin_vertical.back().line_style = PS_DOT;
				}

				labdata->back().plot_data.lin_vertical.push_back(LinVertical());
				labdata->back().plot_data.lin_vertical.back().m_x = this->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_peregibu_vtoroj_krivoj.v;
				labdata->back().plot_data.lin_vertical.back().line_color = RGB(0,0,200);
				labdata->back().plot_data.lin_vertical.back().line_style = PS_DOT;

				labdata->push_back(LabData());
				sprintf(sv, "%f", this->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_peregibu_vtoroj_krivoj.v); DeleteEndZeros(sv);
				sprintf(str, "Нач. просад. давление в прогн. штампе (по точке перегиба) = %s МПа", sv);
				labdata->back().text.push_back(fmtstr(str, NULL, true, false));
			}

			if (D2yDx2_calculed)
			{
				labdata->push_back(LabData());
				// plot
				labdata->back().plot_data.use_plot = true;
				labdata->back().plot_data.y_dir = +1;
				labdata->back().plot_data.title = "Вторая производная осадки после замачивания";
				labdata->back().plot_data.xlabel = "Давления, МПа";
				labdata->back().plot_data.ylabel = "D2yDx2";
				labdata->back().plot_data.zero_min_y = false;
				labdata->back().plot_data.plot_lines.push_back(plot_line());

				if (this->p_result_2 && this->p_result_2->m_gurvich.shtamp_vx.size())
				{
					labdata->back().plot_data.set_max_x = true;
					labdata->back().plot_data.max_x_to_set = this->p_result_2->m_gurvich.shtamp_vx.back().x;
				}

				// массив
				for (size_t i = 0; i < m2X.size(); i++)
				{
					labdata->back().plot_data.plot_lines.back().data.push_back(plot_data_2d(m2X[i], D2yDx2[i].v));
				}
			}

			if (gurvich_shtamp_prosadka_calculed_po_dvum_krivym)
			{
				if (labdata)
				{
					labdata->push_back(LabData());
					text = &labdata->back().text;
				}				
				
				labdata->back().plot_data.use_plot = true;
				labdata->back().plot_data.y_dir = +1;
				labdata->back().plot_data.title = "Просадка в прогнозн. штампе по Гурвичу (по дв.кр.)";
				labdata->back().plot_data.xlabel = "Давления, МПа";
				labdata->back().plot_data.ylabel = "Просадка, мм";	
				labdata->back().plot_data.x_ax_not_dubl = true;	

				labdata->back().plot_data.plot_lines.push_back(plot_line());
				labdata->back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
				for (size_t i = 0; i < this->x_gurvich_shtamp_prosadka_po_dvum_krivym.size(); i++)
				{
					double x = this->x_gurvich_shtamp_prosadka_po_dvum_krivym[i];
					double y = this->gurvich_shtamp_prosadka_po_dvum_krivym[i].v;
					labdata->back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
				}
			}			
			if (gurvich_shtamp_prosadka_calculed_po_dvum_krivym)
			{
				if (labdata)
				{
					labdata->push_back(LabData());
					text = &labdata->back().text;
				}				
				
				labdata->back().plot_data.use_plot = true;
				labdata->back().plot_data.y_dir = +1;
				labdata->back().plot_data.title = "Относит. просадоч. в прогнозн. штампе по Гурвичу (по дв.кр.)";
				labdata->back().plot_data.xlabel = "Давления, МПа";
				labdata->back().plot_data.ylabel = "Отн.просад., д.е.";	
				labdata->back().plot_data.x_ax_not_dubl = true;	

				labdata->back().plot_data.plot_lines.push_back(plot_line());
				labdata->back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
				for (size_t i = 0; i < this->x_gurvich_shtamp_prosadka_po_dvum_krivym.size(); i++)
				{
					double x = this->x_gurvich_shtamp_prosadka_po_dvum_krivym[i];
					double y = this->gurvich_shtamp_otnosit_prosadochnost_po_dvum_krivym[i].v;
					labdata->back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
				}

				if (this->p_result_1)
				{
					labdata->back().plot_data.lin_vertical.push_back(LinVertical());
					labdata->back().plot_data.lin_vertical.back().m_x = this->p_result_1->ocenka_bytovogo_davlenia.v;
					labdata->back().plot_data.lin_vertical.back().line_color = RGB(0,200,0);
					labdata->back().plot_data.lin_vertical.back().line_style = PS_DOT;
				}

				labdata->back().plot_data.lin_vertical.push_back(LinVertical());
				labdata->back().plot_data.lin_vertical.back().m_x = this->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_dvum_krivym.v;
				labdata->back().plot_data.lin_vertical.back().line_color = RGB(0,0,200);
				labdata->back().plot_data.lin_vertical.back().line_style = PS_DOT;


				/*labdata->back().plot_data.plot_lines.push_back(plot_line());
				labdata->back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
				for (int i = 0; i < this->x_gurvich_shtamp_prosadka_po_dvum_krivym.size(); i++)
				{
					double x = this->x_gurvich_shtamp_prosadka_po_dvum_krivym[i];
					double y = this->gurvich_shtamp_hdef_po_dvum_krivym[i].v;
					labdata->back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
				}*/

				if(this->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_dvum_krivym.f)
				{
					labdata->push_back(LabData());
					sprintf(sv, "%f", this->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_dvum_krivym.v); DeleteEndZeros(sv);
					sprintf(str, "Нач. просад. давление в прогн. штампе (по дв.кр.) = %s МПа", sv);
					labdata->back().text.push_back(fmtstr(str, NULL, true, false));
				}

			}			
			
			if (gurvich_shtamp_prosadka_calculed_po_odnoj_krivoj)
			{
				if (labdata)
				{
					labdata->push_back(LabData());
					text = &labdata->back().text;
				}				

				labdata->back().plot_data.use_plot = true;
				labdata->back().plot_data.y_dir = +1;
				labdata->back().plot_data.title = "Просадка в прогнозн. штампе по Гурвичу (по од.кр.)";
				labdata->back().plot_data.xlabel = "Давления, МПа";
				labdata->back().plot_data.ylabel = "Просадка, мм";	
				labdata->back().plot_data.x_ax_not_dubl = true;	

				labdata->back().plot_data.plot_lines.push_back(plot_line());
				labdata->back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
				for (size_t i = 0; i < this->x_gurvich_shtamp_prosadka_po_odnoj_krivoj.size(); i++)
				{
					double x = this->x_gurvich_shtamp_prosadka_po_odnoj_krivoj[i];
					double y = this->gurvich_shtamp_prosadka_po_odnoj_krivoj[i].v;
					labdata->back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
				}
			}

			if (gurvich_shtamp_prosadka_calculed_po_odnoj_krivoj)
			{
				if (labdata)
				{
					labdata->push_back(LabData());
					text = &labdata->back().text;
				}				

				labdata->back().plot_data.use_plot = true;
				labdata->back().plot_data.y_dir = +1;
				labdata->back().plot_data.title = "Относит. просадоч. в прогнозн. штампе по Гурвичу (по од.кр.)";
				labdata->back().plot_data.xlabel = "Давления, МПа";
				labdata->back().plot_data.ylabel = "Отн.просад., д.е.";	
				labdata->back().plot_data.x_ax_not_dubl = true;	

				labdata->back().plot_data.plot_lines.push_back(plot_line());
				labdata->back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
				for (size_t i = 0; i < this->x_gurvich_shtamp_prosadka_po_odnoj_krivoj.size(); i++)
				{
					double x = this->x_gurvich_shtamp_prosadka_po_odnoj_krivoj[i];
					double y = this->gurvich_shtamp_otnosit_prosadochnost_po_odnoj_krivoj[i].v;
					labdata->back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
				}

				if (this->p_result_1)
				{
					labdata->back().plot_data.lin_vertical.push_back(LinVertical());
					labdata->back().plot_data.lin_vertical.back().m_x = this->p_result_1->ocenka_bytovogo_davlenia.v;
					labdata->back().plot_data.lin_vertical.back().line_color = RGB(0,200,0);
					labdata->back().plot_data.lin_vertical.back().line_style = PS_DOT;
				}

				labdata->back().plot_data.lin_vertical.push_back(LinVertical());
				labdata->back().plot_data.lin_vertical.back().m_x = this->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj.v;
				labdata->back().plot_data.lin_vertical.back().line_color = RGB(0,0,200);
				labdata->back().plot_data.lin_vertical.back().line_style = PS_DOT;

				if(this->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj.f)
				{
					labdata->push_back(LabData());
					sprintf(sv, "%f", this->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj.v); DeleteEndZeros(sv);
					sprintf(str, "Нач. просад. давление в прогн. штампе (по од.кр.) = %s МПа", sv);
					labdata->back().text.push_back(fmtstr(str, NULL, true, false));
				}

			}
		}

		if (labdata)
		{
			labdata->push_back(LabData());
			text = &labdata->back().text;
		}					

		if (com_lab_params && com_lab_params->params_nature.GetCheckedLabParam() &&
			com_lab_params->params_nature.parameters_results3_every &&
			com_lab_params->params_nature.parameters_results3_every->GetCheckedLabParam())
		{
			if (this->p_result_1 && this->p_result_1->calculed)
			{
				if (text) text->push_back(fmtstr("В природном состоянии", NULL, true, false));
				if (this->p_result_1 && this->p_result_1->zamachivanie)
				{
					char sw[1024];
					sprintf(sw, "%f", W_sat);
					DeleteEndZeros(sw);
					sprintf(str, "При замачивании влажность = %s\0", sw);	
					if (text) text->push_back(fmtstr(str, NULL, true, true));
				}
				PrintfGurvichShtamp(&this->p_result_1->m_gurvich, text);
			}
		}

		if (com_lab_params && com_lab_params->params_task.GetCheckedLabParam() &&
			com_lab_params->params_task.parameters_results3_every &&
			com_lab_params->params_task.parameters_results3_every->GetCheckedLabParam())
		{
			if (this->p_result_2 && this->p_result_2->calculed)
			{
				if (text) text->push_back(fmtstr("В заданном состоянии", NULL, true, false));
				PrintfGurvichShtamp(&this->p_result_2->m_gurvich, text);
			}
		}

		if (com_lab_params && com_lab_params->params_shrinkage.GetCheckedLabParam() &&
			com_lab_params->params_shrinkage.parameters_results3_every &&
			com_lab_params->params_shrinkage.parameters_results3_every->GetCheckedLabParam())
		{
			if (this->p_result_3 && this->p_result_3->calculed)
			{
				if (text) text->push_back(fmtstr("На усадку", NULL, true, false));
				PrintfGurvichShtamp(&this->p_result_3->m_gurvich, text);
			}
		}
		return true;
	}
	return false;
}

bool Gurvich::PrintShtampDeformationPrediction(
	CompressionLabExperiment * compression,
	vector<fmtstr> * text,
	vector<LabData> * labdata)
{
	string s;
	char str[1024]; 
	if (this->m_res)
	{
		LabNumber * labnumber = this->m_res->lab_trial ? (LabNumber *)this->m_res->lab_trial->GetLabNumber() : NULL;
		if (!labnumber) return false;
		PhysicalLabTrial * phys =  dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
		if (!phys) return false;

		PhysicalLabTrialResults * phys_res =  dynamic_cast<PhysicalLabTrialResults *>(phys->results);
		if (!phys_res) return false;
		if (!phys_res->calculed)
			phys_res->CalcProperties();

		if ( 
			(phys_res->t == CGround::ground_type::SandyLoam || phys_res->t == CGround::ground_type::Loam || phys_res->t == CGround::ground_type::Clay)
			)
		{
			// Влажность водонасыщения
			double W_sat = phys_res->w_water_saturated.v;

			// число пластичности						
			double Ip = phys_res->plasticity_index.v;
			double e = phys_res->e.v;					

			// влажность
			double W = 0.0;

			PrintGurvichShtamp(compression, phys, text, W_sat, W);


			if(labdata)
			{
				this->PrintShtampDeformationPrediction("Под штамп:",	NULL, &labdata->back().plot_data);			

				labdata->back().plot_data.use_plot = true;
				labdata->back().plot_data.y_dir = -1;
				labdata->back().plot_data.title = "Расчётн. осадка под штампом";
				labdata->back().plot_data.xlabel = "Давления, МПа";
				labdata->back().plot_data.ylabel = "Абс.Деф., мм";	

				labdata->back().plot_data.lin_interp.push_back(LinInterp());
				labdata->back().plot_data.lin_interp.back().m_a0 = shtamp_lin_interp_a0_in_01_02_interval.v;	
				labdata->back().plot_data.lin_interp.back().m_a1 = shtamp_lin_interp_a1_in_01_02_interval.v;
				labdata->back().plot_data.lin_interp.back().xmin = shtamp_deformation_module_01_02_pressure_interval[0];
				labdata->back().plot_data.lin_interp.back().xmax = shtamp_deformation_module_01_02_pressure_interval[1];

				labdata->back().plot_data.lin_interp.push_back(LinInterp());
				labdata->back().plot_data.lin_interp.back().m_a0 = shtamp_lin_interp_a0_in_defined_interval.v;	
				labdata->back().plot_data.lin_interp.back().m_a1 = shtamp_lin_interp_a1_in_defined_interval.v;
				labdata->back().plot_data.lin_interp.back().xmin = shtamp_deformation_module_defined_pressure_interval[0];
				labdata->back().plot_data.lin_interp.back().xmax = shtamp_deformation_module_defined_pressure_interval[1];
				labdata->back().plot_data.lin_interp.back().line_color = RGB(0,0,200);	
			}

			if (labdata)
			{
				labdata->push_back(LabData());
				text = &labdata->back().text;
			}


			if (this->m_res->zamachivanie)
			{
				char sw[1024];
				sprintf(sw, "%f", W_sat);
				DeleteEndZeros(sw);
				sprintf(str, "При замачивании влажность = %s\0", sw);	
				if (text) text->push_back(fmtstr(str, NULL, true, true));
			}
						

			::PrintfGurvichShtamp(this, text);

			return true;
		}
	}
	return false;
}


void CompressionLabTrial::PrintfProperties(vector<fmtstr> & text)
{
	char str[4098];
	sprintf(str, "Компрессия: Число давлений %s = %d"
		, CompressionLabTrial::CompressionLabTrialTypeToStringRus(com_type)
		, n_pressures
		);
	text.push_back(fmtstr(str, NULL, true, false));

	if (this->lab_number)
	{
		LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
		if (lablayer)
		{
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
			if(compression)
			{
				int step = STEP;
				string s = "Давления, МПа:";
				//     s = "Абс.Деф.:";		

				text.push_back(fmtstr(s, NULL, false, true));

				for (int i = 0; i < n_pressures; i++)
				{
					//s = "";
#if USE_LAB_LAYER_PRESSURES
					switch(com_type)				
					{
					case CompressionLabTrial::type::nature_condition:
						{
							sprintf(str, "%f\0", compression->pressures_in_nature_condition[i]);
						}
						break;
					case CompressionLabTrial::type::task_condition:
						{
							sprintf(str, "%f\0", compression->pressures_in_task_condition[i]);
						}
						break;
					case CompressionLabTrial::type::shrinkage:
						{
							sprintf(str, "%f\0", compression->pressures_on_shrinkage[i]);
						}
						break;
					}
#else
					sprintf(str, "%f\0", pressures[i]);
#endif
					DeleteEndZeros(str);
					//for (int j = 0; j < step-int(strlen(str)); j++)
					//	s += " ";
					//s += str;
					text.push_back(fmtstr(str, &absolute_deformations[i].f, i == n_pressures-1, true));
				}
				       s = "Абс.Деф., мм:";			
				text.push_back(fmtstr(s, NULL, false, true));
				for (int i = 0; i < n_pressures; i++)
				{
					//s = "";
					sprintf(str, "%f\0", absolute_deformations[i].v);
					DeleteEndZeros(str);
					//for (int j = 0; j < step-int(strlen(str)); j++)
					//	s += " ";
					//s += str;
					text.push_back(fmtstr(str, &absolute_deformations[i].f, i == n_pressures-1, true));
				}
			}
		}	
	}
}

void CompressionLabTrial3::PrintfProperties(vector<fmtstr> & text)
{
	if (p_trial_1 && p_trial_2 && p_trial_3)
	{
		char str[4098];
		sprintf(str, "Компрессия 3: Число давлений [%d %d %d]"
			, this->p_trial_1->n_pressures
			, this->p_trial_2->n_pressures
			, this->p_trial_3->n_pressures
			);
		text.push_back(fmtstr(str, NULL, true, false));

		p_trial_1->PrintfProperties(text);
		p_trial_2->PrintfProperties(text);
		p_trial_3->PrintfProperties(text);

	}
}

void CompressionLabTrial3::PrintfProperties(vector<LabData> & labdata)
{
	labdata.push_back(LabData());

#if PLOT_WITH_TEXT
	PrintfProperties(labdata.back().text);
#else
	if (p_trial_1 && p_trial_2 && p_trial_3)
	{
		char str[4098];
		sprintf(str, "Компрессия 3: Число давлений [%d %d %d]"
			, this->p_trial_1->n_pressures
			, this->p_trial_2->n_pressures
			, this->p_trial_3->n_pressures
			);
		labdata.back().text.push_back(fmtstr(str, NULL, true, false));

		char s1[128];
		char s2[128];
		char s3[128];

		sprintf(s1, "%f ", this->p_trial_1->n_pressures ? this->p_trial_1->hoop_height : 0.0);
		sprintf(s2, "%f ", this->p_trial_2->n_pressures ? this->p_trial_2->hoop_height : 0.0);
		sprintf(s3, "%f", this->p_trial_3->n_pressures ? this->p_trial_3->hoop_height : 0.0);

		DeleteEndZeros(s1);
		DeleteEndZeros(s2);
		DeleteEndZeros(s3);

		sprintf(str, "Высота кольца [%s%s%s]"
			, this->p_trial_1->n_pressures ? s1 : ""
			, this->p_trial_2->n_pressures ? s2 : ""
			, this->p_trial_3->n_pressures ? s3 : ""
			);

		labdata.back().text.push_back(fmtstr(str, NULL, true, false));
	}
#endif
}

void CompressionLabTrial::PrintfProperties(vector<LabData> & labdata)
{
	labdata.push_back(LabData());

#if PLOT_WITH_TEXT
	PrintfProperties(labdata.back().text);
#else
	char str[4098];
	sprintf(str, "Компрессия: Число давлений %s = %d"
		, CompressionLabTrial::CompressionLabTrialTypeToStringRus(com_type)
		, n_pressures
		);
	labdata.back().text.push_back(fmtstr(str, NULL, true, false));
#endif
}

bool CompressionLabTrialResults::IncludeConnected()
{
	bool result = false;
#if USE_COMPR_PO_OTN_DEF	
	if (this->S_lin_y_in_01_02_interval.f == TRIAL_VALUE_INCLUDED)
	{
		 if (this->compression_module_y_in_01_02_interval.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->compression_module_y_in_01_02_interval.f = TRIAL_VALUE_DEFINED;

		 if (this->deformation_module_y_in_01_02_interval.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->deformation_module_y_in_01_02_interval.f = TRIAL_VALUE_DEFINED;

		 if (this->deformation_module_y_in_01_02_interval_mk.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->deformation_module_y_in_01_02_interval_mk.f = TRIAL_VALUE_DEFINED;

		 result = true;
	}
	if (this->S_lin_y_in_defined_interval.f == TRIAL_VALUE_INCLUDED)
	{
		 if (this->compression_module_y_in_defined_interval.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->compression_module_y_in_defined_interval.f = TRIAL_VALUE_DEFINED;

		 if (this->deformation_module_y_in_defined_interval.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->deformation_module_y_in_defined_interval.f = TRIAL_VALUE_DEFINED;

		 result = true;
	}
#endif


	if (this->S_lin_e_in_01_02_interval.f == TRIAL_VALUE_INCLUDED)
	{
		 if (this->compression_module_e_in_01_02_interval.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->compression_module_e_in_01_02_interval.f = TRIAL_VALUE_DEFINED;

		 if (this->deformation_module_e_in_01_02_interval.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->deformation_module_e_in_01_02_interval.f = TRIAL_VALUE_DEFINED;

		 if (this->deformation_module_e_in_01_02_interval_mk.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->deformation_module_e_in_01_02_interval_mk.f = TRIAL_VALUE_DEFINED;

		 result = true;
	}
	if (this->S_lin_e_in_defined_interval.f == TRIAL_VALUE_INCLUDED)
	{
		 if (this->compression_module_e_in_defined_interval.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->compression_module_e_in_defined_interval.f = TRIAL_VALUE_DEFINED;

		 if (this->deformation_module_e_in_defined_interval.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->deformation_module_e_in_defined_interval.f = TRIAL_VALUE_DEFINED;

		 result = true;
	}

	if (this->m_gurvich.Sy_shtamp_lin_in_01_02_interval.f == TRIAL_VALUE_INCLUDED)
	{
		 if (this->m_gurvich.shtamp_deformation_module_in_01_02_interval.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->m_gurvich.shtamp_deformation_module_in_01_02_interval.f = TRIAL_VALUE_DEFINED;

		 if (this->m_gurvich.shtamp_deformation_module_in_01_02_interval_Kp.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->m_gurvich.shtamp_deformation_module_in_01_02_interval_Kp.f = TRIAL_VALUE_DEFINED;

		 result = true;
	}

	if (this->m_gurvich.Sy_shtamp_lin_in_defined_interval.f == TRIAL_VALUE_INCLUDED)
	{
		 if (this->m_gurvich.shtamp_deformation_module_in_defined_interval.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->m_gurvich.shtamp_deformation_module_in_defined_interval.f = TRIAL_VALUE_DEFINED;

		 if (this->m_gurvich.shtamp_deformation_module_in_defined_interval_Kp.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->m_gurvich.shtamp_deformation_module_in_defined_interval_Kp.f = TRIAL_VALUE_DEFINED;

		 result = true;
	}




	return result;
}

bool CompressionLabTrialResults::ExcludeConnected()
{
	bool result = false;
#if USE_COMPR_PO_OTN_DEF
	if (this->S_lin_y_in_01_02_interval.f == TRIAL_VALUE_EXCLUDED)
	{
		 if (this->compression_module_y_in_01_02_interval.f == TRIAL_VALUE_DEFINED)
			 this->compression_module_y_in_01_02_interval.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 if (this->deformation_module_y_in_01_02_interval.f == TRIAL_VALUE_DEFINED)
			 this->deformation_module_y_in_01_02_interval.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 if (this->deformation_module_y_in_01_02_interval_mk.f == TRIAL_VALUE_DEFINED)
			 this->deformation_module_y_in_01_02_interval_mk.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 result = true;
	}
	if (this->S_lin_y_in_defined_interval.f == TRIAL_VALUE_EXCLUDED)
	{
		 if (this->compression_module_y_in_defined_interval.f == TRIAL_VALUE_DEFINED)
			 this->compression_module_y_in_defined_interval.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 if (this->deformation_module_y_in_defined_interval.f == TRIAL_VALUE_DEFINED)
			 this->deformation_module_y_in_defined_interval.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 result = true;
	}
#endif
	
	if (this->S_lin_e_in_01_02_interval.f == TRIAL_VALUE_EXCLUDED)
	{
		 if (this->compression_module_e_in_01_02_interval.f == TRIAL_VALUE_DEFINED)
			 this->compression_module_e_in_01_02_interval.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 if (this->deformation_module_e_in_01_02_interval.f == TRIAL_VALUE_DEFINED)
			 this->deformation_module_e_in_01_02_interval.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 if (this->deformation_module_e_in_01_02_interval_mk.f == TRIAL_VALUE_DEFINED)
			 this->deformation_module_e_in_01_02_interval_mk.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 result = true;
	}
	if (this->S_lin_e_in_defined_interval.f == TRIAL_VALUE_EXCLUDED)
	{
		 if (this->compression_module_e_in_defined_interval.f == TRIAL_VALUE_DEFINED)
			 this->compression_module_e_in_defined_interval.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 if (this->deformation_module_e_in_defined_interval.f == TRIAL_VALUE_DEFINED)
			 this->deformation_module_e_in_defined_interval.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 result = true;
	}

	if (this->m_gurvich.Sy_shtamp_lin_in_01_02_interval.f == TRIAL_VALUE_EXCLUDED)
	{
		 if (this->m_gurvich.shtamp_deformation_module_in_01_02_interval.f == TRIAL_VALUE_DEFINED)
			 this->m_gurvich.shtamp_deformation_module_in_01_02_interval.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 if (this->m_gurvich.shtamp_deformation_module_in_01_02_interval_Kp.f == TRIAL_VALUE_DEFINED)
			 this->m_gurvich.shtamp_deformation_module_in_01_02_interval_Kp.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 result = true;
	}

	if (this->m_gurvich.Sy_shtamp_lin_in_defined_interval.f == TRIAL_VALUE_EXCLUDED)
	{
		 if (this->m_gurvich.shtamp_deformation_module_in_defined_interval.f == TRIAL_VALUE_DEFINED)
			 this->m_gurvich.shtamp_deformation_module_in_defined_interval.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 if (this->m_gurvich.shtamp_deformation_module_in_defined_interval_Kp.f == TRIAL_VALUE_DEFINED)
			 this->m_gurvich.shtamp_deformation_module_in_defined_interval_Kp.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 result = true;
	}
	return result;
}



bool CompressionLabTrialResults3::IncludeConnected()
{
	bool result = false;
	if (this->p_result_1 && this->p_result_1->IncludeConnected())
		result = true;
	if (this->p_result_2 && this->p_result_2->IncludeConnected())
		result = true;
	if (this->p_result_3 && this->p_result_3->IncludeConnected())
		result = true;
	return result;
}

bool CompressionLabTrialResults3::ExcludeConnected()
{
	bool result = false;
	if (this->p_result_1 && this->p_result_1->ExcludeConnected())
		result = true;
	if (this->p_result_2 && this->p_result_2->ExcludeConnected())
		result = true;
	if (this->p_result_3 && this->p_result_3->ExcludeConnected())
		result = true;
	return result;
}

bool CompressionLabTrialResults3::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	switch(vt.vt_Compression_3.com_type)
	{
	case CompressionLabTrial::type::nature_condition:
		{
			if (this->p_result_1)
			{
				return this->p_result_1->GetValue(vt.vt_Compression_3.vt_Compression_nature, v);
			}
		}
		break;
	case CompressionLabTrial::type::task_condition:
		{
			if (this->p_result_2)
			{			
				return this->p_result_2->GetValue(vt.vt_Compression_3.vt_Compression_task, v);
			}
		}
		break;
	case CompressionLabTrial::type::shrinkage:
		{
			if (this->p_result_3)
			{			
				return this->p_result_3->GetValue(vt.vt_Compression_3.vt_Compression_shrinkage, v);
			}
		}
		break;
	case CompressionLabTrial::type::tri:
		{
			return this->GetValue(vt.vt_Compression_3.vt_CompressionLabTrialResults3, v);
		}
		break;
	}

	return false;
}

bool CompressionLabTrialResults3::GetValue(CompressionLabTrialResults3::value_type vt, trial_got_value & v)
{
	v.trial = this;
	switch(vt)
	{
	case CompressionLabTrialResults3::value_type::vt_davlenie_nabuhania:
		{
			v = this->davlenie_nabuhania;
			if (*v.pf) return true;
		}
		break;
	case CompressionLabTrialResults3::value_type::vt_dejstvit_polnaja_osadka:
		{
			v = this->dejstvit_polnaja_osadka;
			if (*v.pf) return true;
		}
		break;
	case CompressionLabTrialResults3::value_type::vt_gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_dvum_krivym:
		{
			if (gurvich_shtamp_prosadka_calculed_po_dvum_krivym)
			{
				v = this->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_dvum_krivym;
				if (*v.pf) return true;
			}
		}
		break;
	case CompressionLabTrialResults3::value_type::vt_gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj:
		{
			if (gurvich_shtamp_prosadka_calculed_po_odnoj_krivoj)
			{
				v = this->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj;
				if (*v.pf) return true;
			}
		}
		break;
	case CompressionLabTrialResults3::value_type::vt_gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_peregibu_vtoroj_krivoj:
		{
			if (gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_peregibu_vtoroj_krivoj_calculed)
			{
				v = this->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_peregibu_vtoroj_krivoj;
				if (*v.pf) return true;
			}
		}
		break;
	case CompressionLabTrialResults3::value_type::vt_h0:
		{
			v = this->h0;
			if (*v.pf) return true;
		}
		break;
	case CompressionLabTrialResults3::value_type::vt_m_otzhatoj_vody:
		{
			v = this->m_otzhatoj_vody;
			if (*v.pf) return true;
		}
		break;
	case CompressionLabTrialResults3::value_type::vt_nachalnoe_prosadochnoe_davlenie_po_dvum_krivym:
		{
			if (prosadka_calculed_po_dvum_krivym)
			{
				v = this->nachalnoe_prosadochnoe_davlenie_po_dvum_krivym;
				if (*v.pf) return true;
			}
		}
		break;
	case CompressionLabTrialResults3::value_type::vt_nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj:
		{
			if (prosadka_calculed_po_odnoj_krivoj)
			{
				v = this->nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj;
				if (*v.pf) return true;
			}
		}
		break;
	case CompressionLabTrialResults3::value_type::vt_popravochnyj_koefficient_alpha:
		{
			v = this->popravochnyj_koefficient_alpha;
			if (*v.pf) return true;
		}
		break;
	case CompressionLabTrialResults3::value_type::vt_svobodnoe_otnositelnoe_nabuhanie:
		{
			v = this->svobodnoe_otnositelnoe_nabuhanie;
			if (*v.pf) return true;
		}
		break;
	}
	return false;
}


bool CompressionLabTrialResults::GetValue(CompressionValueType & vt, trial_got_value & v)
{	
	v.trial = this;

	switch(vt.n_compression_value_type)
	{
	case 0:
		{
			CompressionLabTrialResults::value_type_0 val_type_0 = vt.vt_CompressionLabTrialResults_0;
			switch(val_type_0)
			{
			case CompressionLabTrialResults::value_type_0::vt_ocenka_bytovogo_davlenia:
				{
					v = this->ocenka_bytovogo_davlenia;
					if (*v.pf) return true;
				}
				break;	
			/*case CompressionLabTrialResults::value_type_0::vt_beta_int:
				{
					v = this->beta_int;
					if (*v.pf) return true;
				}
				break;	*/	
			case CompressionLabTrialResults::value_type_0::vt_nju_tab_ws:
				{
					v = this->nju_tab_ws;
					if (*v.pf) return true;
				}
				break;		
			case CompressionLabTrialResults::value_type_0::vt_nju_tab:
				{
					v = this->nju_tab;
					if (*v.pf) return true;
				}
				break;		
			case CompressionLabTrialResults::value_type_0::vt_beta_tab_ws:
				{
					v = this->beta_tab_ws;
					if (*v.pf) return true;
				}
				break;		
			case CompressionLabTrialResults::value_type_0::vt_beta_tab:
				{
					v = this->beta_tab;
					if (*v.pf) return true;
				}
				break;		
			/*case CompressionLabTrialResults::value_type_0::vt_beta_mavrodi:
				{
					v = this->beta_mavrodi;
					if (*v.pf) return true;
				}
				break;*/		
			case CompressionLabTrialResults::value_type_0::vt_mk:
				{
					v = this->mk;
					if (*v.pf) return true;
				}
				break;
			}
		}
		break;
#if USE_COMPR_PO_OTN_DEF	

	case 1:
		{
			CompressionLabTrialResults::value_type_1 val_type_1 = vt.vt_CompressionLabTrialResults_1;
			switch(val_type_1)
			{	

			case CompressionLabTrialResults::value_type_1::vt_S_lin_y_in_01_02_interval:
				{
					v = this->S_lin_y_in_01_02_interval;
					if (*v.pf) return true;
				}
				break;	

			case CompressionLabTrialResults::value_type_1::vt_S_lin_y_in_defined_interval:
				{
					v = this->S_lin_y_in_defined_interval;
					if (*v.pf) return true;
				}
				break;	

			case CompressionLabTrialResults::value_type_1::vt_compression_module_y_in_01_02_interval:
				{
					v = this->compression_module_y_in_01_02_interval;
					if (*v.pf) return true;
				}
				break;	

			case CompressionLabTrialResults::value_type_1::vt_compression_module_y_in_defined_interval:
				{
					v = this->compression_module_y_in_defined_interval;
					if (*v.pf) return true;
				}
				break;

			case CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_01_02_interval:
				{
					v = this->deformation_module_y_in_01_02_interval;
					if (*v.pf) return true;
				}
				break;	


			case CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_defined_interval:
				{
					v = this->deformation_module_y_in_defined_interval;
					if (*v.pf) return true;
				}
				break;

			case CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_01_02_interval_mk:
				{
					v = this->deformation_module_y_in_01_02_interval_mk;
					if (*v.pf) return true;
				}
				break;	
			}
		}
		break;
#endif
	case 2:
		{
			CompressionLabTrialResults::value_type_2 val_type_2 = vt.vt_CompressionLabTrialResults_2;
			switch(val_type_2)
			{

			case CompressionLabTrialResults::value_type_2::vt_a_in_01_02_interval:
				{
					v = this->a_in_01_02_interval;
					if (*v.pf) return true;
				}
				break;	

			case CompressionLabTrialResults::value_type_2::vt_a_in_defined_interval:
				{
					v = this->a_in_defined_interval;
					if (*v.pf) return true;
				}
				break;


			case CompressionLabTrialResults::value_type_2::vt_compression_module_e_in_01_02_interval:
				{
					v = this->compression_module_e_in_01_02_interval;
					if (*v.pf) return true;
				}
				break;	

			case CompressionLabTrialResults::value_type_2::vt_compression_module_e_in_defined_interval:
				{
					v = this->compression_module_e_in_defined_interval;
					if (*v.pf) return true;
				}
				break;


			case CompressionLabTrialResults::value_type_2::vt_deformation_module_e_in_01_02_interval:
				{
					v = this->deformation_module_e_in_01_02_interval;
					if (*v.pf) return true;
				}
				break;

			case CompressionLabTrialResults::value_type_2::vt_deformation_module_e_in_defined_interval:
				{
					v = this->deformation_module_e_in_defined_interval;
					if (*v.pf) return true;
				}
				break;


			case CompressionLabTrialResults::value_type_2::vt_deformation_module_e_in_01_02_interval_mk:
				{
					v = this->deformation_module_e_in_01_02_interval_mk;
					if (*v.pf) return true;
				}
				break;	
			}
		}
		break;
	case 3:
		{
			CompressionLabTrialResults::value_type_3 val_type_3 = vt.vt_CompressionLabTrialResults_3;
			switch(val_type_3)
			{

			case CompressionLabTrialResults::value_type_3::vt_Kp:
				{
					v = this->m_gurvich.Kp;
					if (*v.pf) return true;
				}
				break;	

			case CompressionLabTrialResults::value_type_3::vt_shtamp_Sy_lin_in_01_02_interval:
				{
					v = this->m_gurvich.Sy_shtamp_lin_in_01_02_interval;
					if (*v.pf) return true;
				}
				break;	

			case CompressionLabTrialResults::value_type_3::vt_shtamp_Sy_lin_in_defined_interval:
				{
					v = this->m_gurvich.Sy_shtamp_lin_in_defined_interval;
					if (*v.pf) return true;
				}
				break;	

			case CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_01_02_interval:
				{
					v = this->m_gurvich.shtamp_deformation_module_in_01_02_interval;
					if (*v.pf) return true;
				}
				break;
			case CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_01_02_interval_Kp:
				{
					v = this->m_gurvich.shtamp_deformation_module_in_01_02_interval_Kp;
					if (*v.pf) return true;
				}
				break;

			case CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_defined_interval:
				{
					v = this->m_gurvich.shtamp_deformation_module_in_defined_interval;
					if (*v.pf) return true;
				}
				break;
			case CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_defined_interval_Kp:
				{
					v = this->m_gurvich.shtamp_deformation_module_in_defined_interval_Kp;
					if (*v.pf) return true;
				}
				break;
			}
		}
		break;
	default:
		return false;
	}
	return false;
}

bool CompressionLabTrialResults::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	v.trial = this;
	return this->GetValue(vt.vt_Compression, v);
}
const char * CompressionLabTrialResults::ValueTypeToString(CompressionLabTrialResults::value_type_0 vt, LabLayer * lablayer)
{
//	char str[4096];
	char s1[1024];
	char s2[1024];

	sprintf(s1, "\0");
	sprintf(s2, "\0");

	switch(vt)
	{
	case CompressionLabTrialResults::value_type_0::vt_ocenka_bytovogo_davlenia:
		{
			return "Оценка бытового давления, МПа";
		}
		break;
	/*case CompressionLabTrialResults::value_type_0::vt_beta_int:
		{
			return "Kоэффициент beta из интерполяционного к-та Пуассона";
		}
		break;	*/

	case CompressionLabTrialResults::value_type_0::vt_nju_tab_ws:
		{
			return "Kоэффициент Пуассона (водонас)";
		}
		break;	
	case CompressionLabTrialResults::value_type_0::vt_nju_tab:
		{
			return "Kоэффициент Пуассона";
		}
		break;	

	case CompressionLabTrialResults::value_type_0::vt_beta_tab_ws:
		{
			return "Kоэффициент beta (водонас) из табличного к-та Пуассона";
		}
		break;	
	case CompressionLabTrialResults::value_type_0::vt_beta_tab:
		{
			return "Kоэффициент beta из табличного к-та Пуассона";
		}
		break;	
	/*case CompressionLabTrialResults::value_type_0::vt_beta_mavrodi:
		{
			return "Kоэффициент beta по Мавроди";
		}
		break;*/	
	case CompressionLabTrialResults::value_type_0::vt_mk:
		{
			return "Kоэффициент  mk";
		}
		break;	

	default:
		return "";
	}
	return "";
}
#if USE_COMPR_PO_OTN_DEF	
const char * CompressionLabTrialResults::ValueTypeToString(CompressionLabTrialResults::value_type_1 vt, LabLayer * lablayer, bool every)
{
	char str[4096];
	char s1[1024];
	char s2[1024];

	sprintf(s1, "\0");
	sprintf(s2, "\0");

	char severy[1024];
	if (every)
		sprintf(severy, "\0");
	else
		sprintf(severy, " (по общ.сов.оп)");

	switch(vt)
	{


	case CompressionLabTrialResults::value_type_1::vt_S_lin_y_in_01_02_interval:
		{
			sprintf(s1, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0]);
			sprintf(s2, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Ср.кв.откл.отн.деф.от лин.ф-ции [%s - %s]%s", s1, s2, severy);
			return _strdup( str );
		}
		break;	


	case CompressionLabTrialResults::value_type_1::vt_S_lin_y_in_defined_interval:
		{
			if (lablayer) sprintf(s1, "%f", lablayer->deformation_module_defined_pressure_interval[0]);
			if (lablayer) sprintf(s2, "%f", lablayer->deformation_module_defined_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Ср.кв.откл.отн.деф.от лин.ф-ции [%s - %s]%s", s1, s2, severy);
			return _strdup( str );
		}
		break;	

	case CompressionLabTrialResults::value_type_1::vt_compression_module_y_in_01_02_interval:
		{
			//return "Модуль деф. в задан.инт.давл., МПа";
			sprintf(s1, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0]);
			sprintf(s2, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Компрессионый модуль (по отн.деф) [%s - %s]%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;



	case CompressionLabTrialResults::value_type_1::vt_compression_module_y_in_defined_interval:
		{
			//return "Модуль деф. в задан.инт.давл., МПа";
			if (lablayer) sprintf(s1, "%f", lablayer->deformation_module_defined_pressure_interval[0]);
			if (lablayer) sprintf(s2, "%f", lablayer->deformation_module_defined_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Компрессионый модуль (по отн.деф) [%s - %s]%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;



	case CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_01_02_interval:
		{
			//return "Модуль деф. в задан.инт.давл., МПа";
			sprintf(s1, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0]);
			sprintf(s2, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Модуль деформации (по отн.деф) [%s - %s]%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;

	case CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_defined_interval:
		{
			//return "Модуль деф. в задан.инт.давл., МПа";
			if (lablayer) sprintf(s1, "%f", lablayer->deformation_module_defined_pressure_interval[0]);
			if (lablayer) sprintf(s2, "%f", lablayer->deformation_module_defined_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Модуль деформации (по отн.деф) [%s - %s]%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;

	case CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_01_02_interval_mk:
		{
			//return "Модуль деф. в задан.инт.давл., МПа";
			sprintf(s1, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0]);
			sprintf(s2, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Модуль деформации (по отн.деф) [%s - %s] * mk%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;

	default:
		return "";
	}
	return "";
}
#endif
const char * CompressionLabTrialResults::ValueTypeToString(CompressionLabTrialResults::value_type_2 vt, LabLayer * lablayer, bool every)
{
	char str[4096];
	char s1[1024];
	char s2[1024];

	sprintf(s1, "\0");
	sprintf(s2, "\0");

	char severy[1024];
	if (every)
		sprintf(severy, "\0");
	else
		sprintf(severy, " (по общ.сов.оп)");

	switch(vt)
	{

	case CompressionLabTrialResults::value_type_2::vt_S_lin_e_in_01_02_interval:
		{
			sprintf(s1, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0]);
			sprintf(s2, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Ср.кв.откл.компр.крив.от лин.ф-ции [%s - %s]%s", s1, s2, severy);
			return _strdup( str );
		}
		break;	

	case CompressionLabTrialResults::value_type_2::vt_S_lin_e_in_defined_interval:
		{
			if (lablayer) sprintf(s1, "%f", lablayer->deformation_module_defined_pressure_interval[0]);
			if (lablayer) sprintf(s2, "%f", lablayer->deformation_module_defined_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Ср.кв.откл.компр.крив.от лин.ф-ции [%s - %s]%s", s1, s2, severy);
			return _strdup( str );
		}
		break;	

	case CompressionLabTrialResults::value_type_2::vt_a_in_01_02_interval:
		{
			//return "Модуль деф. в задан.инт.давл., МПа";
			sprintf(s1, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0]);
			sprintf(s2, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Коэффициент уплотнения (сжимаемости) [%s - %s]%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;

	case CompressionLabTrialResults::value_type_2::vt_a_in_defined_interval:
		{
			//return "Модуль деф. в задан.инт.давл., МПа";
			if (lablayer) sprintf(s1, "%f", lablayer->deformation_module_defined_pressure_interval[0]);
			if (lablayer) sprintf(s2, "%f", lablayer->deformation_module_defined_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Коэффициент уплотнения (сжимаемости) [%s - %s]%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;

	case CompressionLabTrialResults::value_type_2::vt_compression_module_e_in_01_02_interval:
		{
			//return "Модуль деф. в задан.инт.давл., МПа";
			sprintf(s1, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0]);
			sprintf(s2, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			//sprintf(str, "Компрессионый модуль (по компр.крив) [%s - %s]%s, МПа\0", s1, s2, severy);
			sprintf(str, "Компрессионый модуль (без бета) [%s - %s]%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;

	case CompressionLabTrialResults::value_type_2::vt_compression_module_e_in_defined_interval:
		{
			//return "Модуль деф. в задан.инт.давл., МПа";
			if (lablayer) sprintf(s1, "%f", lablayer->deformation_module_defined_pressure_interval[0]);
			if (lablayer) sprintf(s2, "%f", lablayer->deformation_module_defined_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			//sprintf(str, "Компрессионый модуль (по компр.крив) [%s - %s]%s, МПа\0", s1, s2, severy);
			sprintf(str, "Компрессионый модуль (без бета) [%s - %s]%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;

	case CompressionLabTrialResults::value_type_2::vt_deformation_module_e_in_01_02_interval:
		{
			//return "Модуль деф. в задан.инт.давл., МПа";
			sprintf(s1, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0]);
			sprintf(s2, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			//sprintf(str, "Модуль деформации (по компр.крив) [%s - %s]%s, МПа\0", s1, s2, severy);
			sprintf(str, "Модуль деформации (с бета) [%s - %s]%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;

	case CompressionLabTrialResults::value_type_2::vt_deformation_module_e_in_defined_interval:
		{
			//return "Модуль деф. в задан.инт.давл., МПа";
			if (lablayer) sprintf(s1, "%f", lablayer->deformation_module_defined_pressure_interval[0]);
			if (lablayer) sprintf(s2, "%f", lablayer->deformation_module_defined_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			//sprintf(str, "Модуль деформации (по компр.крив) [%s - %s]%s, МПа\0", s1, s2, severy);
			sprintf(str, "Модуль деформации (с бета) [%s - %s]%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;

	case CompressionLabTrialResults::value_type_2::vt_deformation_module_e_in_01_02_interval_mk:
		{
			//return "Модуль деф. в задан.инт.давл., МПа";
			sprintf(s1, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0]);
			sprintf(s2, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			//sprintf(str, "Модуль деформации (по компр.крив) [%s - %s] * mk%s, МПа\0", s1, s2, severy);
			sprintf(str, "Модуль деформации (с бета) [%s - %s] * mk%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;

	default:
		return "";
	}
	return "";
}
const char * CompressionLabTrialResults::ValueTypeToString(CompressionLabTrialResults::value_type_3 vt, LabLayer * lablayer, bool every)
{
	char str[4096];
	char s1[1024];
	char s2[1024];

	sprintf(s1, "\0");
	sprintf(s2, "\0");

	char severy[1024];
	if (every)
		sprintf(severy, "\0");
	else
		sprintf(severy, " (по общ.сов.оп)");

	switch(vt)
	{

	case CompressionLabTrialResults::value_type_3::vt_Kp:
		{
			sprintf(str, "Kоэффициент  Kp%s", severy);
			return _strdup( str );
		}
		break;	

	case CompressionLabTrialResults::value_type_3::vt_shtamp_Sy_lin_in_01_02_interval:
		{
			sprintf(s1, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0]);
			sprintf(s2, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Ср.кв.откл.усадки(штамп).от лин.ф-ции [%s - %s]%s, мм", s1, s2, severy);
			return _strdup( str );
		}
		break;	

	case CompressionLabTrialResults::value_type_3::vt_shtamp_Sy_lin_in_defined_interval:
		{
			if (lablayer) sprintf(s1, "%f", lablayer->deformation_module_defined_pressure_interval[0]);
			if (lablayer) sprintf(s2, "%f", lablayer->deformation_module_defined_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Ср.кв.откл.усадки(штамп).от лин.ф-ции [%s - %s]%s, мм", s1, s2, severy);
			return _strdup( str );
		}
		break;	

	case CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_01_02_interval:		
		{
			//return "Мод.деф.под штамп.в зад.инт.давл., МПа";
			sprintf(s1, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0]);
			sprintf(s2, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Мод.деф.под штампом [%s - %s]%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;

	case CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_defined_interval:		
		{
			//return "Мод.деф.под штамп.в зад.инт.давл., МПа";
			if (lablayer) sprintf(s1, "%f", lablayer->deformation_module_defined_pressure_interval[0]);
			if (lablayer) sprintf(s2, "%f", lablayer->deformation_module_defined_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Мод.деф.под штампом [%s - %s]%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;


	case CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_01_02_interval_Kp:		
		{
			//return "Мод.деф.под штамп.в зад.инт.давл., МПа";
			sprintf(s1, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0]);
			sprintf(s2, "%f", CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Мод.деф.под штампом [%s - %s] * Kp%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;


	case CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_defined_interval_Kp:		
		{
			//return "Мод.деф.под штамп.в зад.инт.давл., МПа";
			if (lablayer) sprintf(s1, "%f", lablayer->deformation_module_defined_pressure_interval[0]);
			if (lablayer) sprintf(s2, "%f", lablayer->deformation_module_defined_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			sprintf(str, "Мод.деф.под штампом [%s - %s] * Kp%s, МПа\0", s1, s2, severy);
			return _strdup( str );
		}
		break;

	default:
		return "";
	}
	return "";
}
int CompressionLabTrialResults::GetSignForReliabilityK(CompressionLabTrialResults::value_type_0 vt)
{
	/*switch(vt)
	{
	default:
		return 0;
	}*/
	return 0;
}

#if USE_COMPR_PO_OTN_DEF	
int CompressionLabTrialResults::GetSignForReliabilityK(CompressionLabTrialResults::value_type_1 vt)
{
	switch(vt)
	{

	case CompressionLabTrialResults::value_type_1::vt_compression_module_y_in_01_02_interval:
		return -1;//"Модуль деформации под штампом, МПа";
	case CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_01_02_interval:
		return -1;//"Модуль деформации под штампом, МПа";
	case CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_01_02_interval_mk:
		return -1;//"Модуль деформации под штампом, МПа";

	case CompressionLabTrialResults::value_type_1::vt_compression_module_y_in_defined_interval:
		return -1;//"Модуль деформации под штампом, МПа";
	case CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_defined_interval:
		return -1;//"Модуль деформации под штампом, МПа";

	default:
		return 0;
	}
	return 0;
}

#endif
int CompressionLabTrialResults::GetSignForReliabilityK(CompressionLabTrialResults::value_type_2 vt)
{
	switch(vt)
	{

	case CompressionLabTrialResults::value_type_2::vt_a_in_01_02_interval:
		return +1;
	case CompressionLabTrialResults::value_type_2::vt_a_in_defined_interval:
		return +1;

	case CompressionLabTrialResults::value_type_2::vt_compression_module_e_in_01_02_interval:
		return -1;
	case CompressionLabTrialResults::value_type_2::vt_deformation_module_e_in_01_02_interval:
		return -1;//"Модуль деформации под штампом, МПа";
	case CompressionLabTrialResults::value_type_2::vt_deformation_module_e_in_01_02_interval_mk:
		return -1;//"Модуль деформации под штампом, МПа";

	case CompressionLabTrialResults::value_type_2::vt_compression_module_e_in_defined_interval:
		return -1;//"Модуль деформации под штампом, МПа";
	case CompressionLabTrialResults::value_type_2::vt_deformation_module_e_in_defined_interval:
		return -1;//"Модуль деформации под штампом, МПа";




	default:
		return 0;
	}
	return 0;
}

int CompressionLabTrialResults::GetSignForReliabilityK(CompressionLabTrialResults::value_type_3 vt)
{
	switch(vt)
	{


	case CompressionLabTrialResults::value_type_3::vt_Kp:
		return -1;//"Модуль деформации под штампом, МПа";
	


	case CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_01_02_interval:
		return -1;//"Модуль деформации под штампом, МПа";
	case CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_01_02_interval_Kp:
		return -1;//"Модуль деформации под штампом, МПа";


	case CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_defined_interval:
		return -1;//"Модуль деформации под штампом, МПа";
	case CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_defined_interval_Kp:
		return -1;//"Модуль деформации под штампом, МПа";

	default:
		return 0;
	}
	return 0;
}


bool CompressionLabTrialResults::compression_module_e_with_min_sq = false;
//bool CompressionLabTrialResults::use_mavrodi_beta = false;

void LogInterpOfCompression(double init_x0, size_t i1, size_t i2, 
							vector<x_compression> & vx, vector<trial_got_value> & ve, 
							trial_value & minus_A, double & x_0, trial_value & m_C,
							int & m_log, trial_value & Sy_log)
{

	vector<x_compression> vlogx;
	vlogx.resize(vx.size());

	x_0 = init_x0;

	double delta = 0.0;

	int iteracion = 0;

	double dS_dx0 = 0.0;
	double d2S_dx0 = 0.0;

	while (iteracion++ < 10000)
	{
		for (size_t ii = 0; ii < vx.size(); ii++)
		{							 
			vlogx[ii] = log(vx[ii].x + x_0);
		}
		
		MinSqLinear(3, vlogx, ve, int(i1), int(i2), true, m_C, minus_A, m_log, Sy_log);
		
		dS_dx0 = 0.0;
		d2S_dx0 = 0.0;
		for (size_t ii = i1; ii < i2; ii++)
		{	
			/*
			maple ('s := (C + minus_A * ln(x + x0) - Y);')
			dSdx0 = maple ('simplify(diff(s^2, x0));')
			dSd2x0 = maple ('simplify(diff(s^2, x0$2));')
			dsdx = maple ('simplify(diff(s, x));')
			*/
			// dSdx0 = -2*(-C-minus_A*log(x+x0)+Y)*minus_A/(x+x0)
			dS_dx0 += 2*(m_C.v + minus_A.v * vlogx[ii].x - ve[ii].v) * minus_A.v / (vx[ii].x + x_0);
			//dSd2x0 = 2*minus_A*(minus_A-C-minus_A*log(x+x0)+Y)/(x+x0)^2
			d2S_dx0 += 2*minus_A.v*(minus_A.v - m_C.v - minus_A.v * vlogx[ii].x + ve[ii].v) / ((vx[ii].x + x_0)*(vx[ii].x + x_0));

		}
		delta = dS_dx0 / d2S_dx0;

		if (fabs(delta) < 1.0e-8)
			break;
#if 0
		// ограничение по максимальному e0
		if (m_C.v + minus_A.v * log(x_0 - 1.0 * delta) > 2.0)
			break;


		if ((x_0 - 1.0 * delta) < 0.01)
			break;
#endif
		x_0 -= 1.0 * delta;
	}
	printf("iteracion = %d Sy_log = %f m_log = %d dS_dx0 = %e d2S_dx0 = %e delta = %e x_0 = %f\n", iteracion, Sy_log.v, m_log, dS_dx0, d2S_dx0, delta, x_0);
}

double CompressionLabTrialResults::e_SecondDerivativeLimit = - 0.045;

void CompressionLabTrialResults::CalcProperties()
{
	zamachivanie = false;

	CompressionLabTrial * comp = dynamic_cast<CompressionLabTrial *>(this->lab_trial);

	if (comp && comp->lab_number && comp->n_pressures)
	{
		//PhysicalLabTrial * phys_lab_trial = dynamic_cast<PhysicalLabTrial *>(comp->lab_number->FindLabTrial(LabTrial::indication::physical));

		LabLayer * lablayer = (LabLayer *) comp->lab_number->GetLabLayer();

		if (lablayer)
		{
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
			if(compression)
			{
				PhysicalLabTrial * phys = dynamic_cast<PhysicalLabTrial *>(comp->lab_number->FindLabTrial(LabTrial::indication::physical, comp->id_phys_vyprob));
				if (!phys)
					phys = dynamic_cast<PhysicalLabTrial *>(comp->lab_number->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
				if (phys)
				{
					PhysicalLabTrialResults * phys_res =  dynamic_cast<PhysicalLabTrialResults *>(phys->results);
					if (phys_res)
					{
						if (!phys_res->calculed)
							phys_res->CalcProperties();



						
							

						double e0 = phys_res->e.v;
#if !USE_e0_IN_E_CALCULATION 
						double e1_in_01_02_pressure_interval;
						double e1_in_defined_pressure_interval;

						bool e1_in_01_02_pressure_interval_defined = false;
						bool e1_in_defined_pressure_interval_defined = false;
#endif

						// массив
						double x;
						trial_got_value y;
						trial_got_value e;

						vx.clear();
						va.clear();
						vy.clear();
						ve.clear();

						bool interval_01_02_started = false;
						bool interval_01_02_finished = false;
						vector<x_compression> vx_01_02_interval;
						vector<trial_got_value> vy_in_01_02_interval;
						vector<trial_got_value> ve_in_01_02_interval;

						bool defined_interval_started = false;
						bool defined_interval_finished = false;
						vector<x_compression> vx_defined_interval;
						vector<trial_got_value> vy_in_defined_interval;
						vector<trial_got_value> ve_in_defined_interval;

						x = 0.0;

						y.pf = NULL;
						y.v = 0.0;
						y.lab_number = comp->lab_number;
						
						e = y;
						e.v = e0;
						e.lab_number = comp->lab_number;

						bool first_zero_pressure = 
							comp->n_pressures && comp->pressures[0] == 0.0;
						
						if (!zamachivanie && !first_zero_pressure)
						{
							vx.push_back(x);
							va.push_back(0.0);
							vy.push_back(y);
							ve.push_back(e);
						}



						for (int i = 0; i < comp->n_pressures; i++)
						{
#if USE_LAB_LAYER_PRESSURES
							switch(com_type)				
							{
							case CompressionLabTrial::type::nature_condition:
								{
									x = compression->pressures_in_nature_condition[i];
									if (i > 0 && compression->pressures_in_nature_condition[i-1] == compression->pressures_in_nature_condition[i])
									{
										zamachivanie = true;
									}
								}
								break;
							case CompressionLabTrial::type::task_condition:
								{
									x = compression->pressures_in_task_condition[i];
								}
								break;
							case CompressionLabTrial::type::shrinkage:
								{
									x = compression->pressures_on_shrinkage[i];
								}
								break;
							}
#else
							x = comp->pressures[i];
							if (com_type == CompressionLabTrial::type::nature_condition)			
							{
								if (i > 0 && comp->pressures[i-1] == comp->pressures[i])
								{
									zamachivanie = true;
								}
							}

#endif



							/*if (i == 0)
							{
								deformation_module_pressure_interval[0] = x;
							}*/

							y = comp->absolute_deformations[i];
#if USE_LAB_LAYER_HOOP
							y.v /= compression->hoop_height;
#else
							y.v /= comp->hoop_height;
#endif
							y.lab_number = comp->lab_number;

							e = y;
							e.v = e0 - (1.0 + e0) * y.v;
							e.lab_number = comp->lab_number;

							if (!zamachivanie)
							{
								va.push_back(comp->absolute_deformations[i].v);
								vx.push_back(x);
								vy.push_back(y);
								ve.push_back(e);
							}

							if ( ! interval_01_02_started )
							{
								if (x >= CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0])
								{
									interval_01_02_started = true;
								}
							}
							if ( ! interval_01_02_finished )
							{
								if (x > CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1])
								{
									interval_01_02_finished = true;
								}
							}
							if (!zamachivanie && interval_01_02_started && !interval_01_02_finished )
							{
								vx_01_02_interval.push_back(x);
								vy_in_01_02_interval.push_back(y);
								ve_in_01_02_interval.push_back(e);

								if (vx_01_02_interval.size() == 1)
								{
									def_module_01_02_pressure_interval[0] = x;
#if !USE_e0_IN_E_CALCULATION 
									e1_in_01_02_pressure_interval = e.v;
									e1_in_01_02_pressure_interval_defined = true;
#endif
								}
								def_module_01_02_pressure_interval[1] = x;
							}
							else
							{
								if (vx_01_02_interval.size() == 0)
								{
									if (first_zero_pressure)
									{
										if (i == 1 && interval_01_02_finished )
										{
											def_module_01_02_pressure_interval[0] = 0.0;
											vx_01_02_interval.push_back(0.0);
											trial_got_value y_0 = y; y_0.v = 0.0;
											trial_got_value e_0 = e; e_0.v = e0;

											vy_in_01_02_interval.push_back(y_0);
											ve_in_01_02_interval.push_back(e_0);

											def_module_01_02_pressure_interval[1] = comp->pressures[1];
											vx_01_02_interval.push_back(x);
											vy_in_01_02_interval.push_back(y);
											ve_in_01_02_interval.push_back(e);
										}
									}
									else
									{
										if (i == 0 && interval_01_02_finished )
										{
											def_module_01_02_pressure_interval[0] = 0.0;
											vx_01_02_interval.push_back(0.0);
											trial_got_value y_0 = y; y_0.v = 0.0;
											trial_got_value e_0 = e; e_0.v = e0;

											vy_in_01_02_interval.push_back(y_0);
											ve_in_01_02_interval.push_back(e_0);

											def_module_01_02_pressure_interval[1] = comp->pressures[0];
											vx_01_02_interval.push_back(x);
											vy_in_01_02_interval.push_back(y);
											ve_in_01_02_interval.push_back(e);
										}
									}
								}
								if (vx_01_02_interval.size() == 1)
								{
								}
							}


							if ( ! defined_interval_started )
							{
								if (x >= lablayer->deformation_module_defined_pressure_interval[0])
								{
									defined_interval_started = true;
								}
							}
							if ( ! defined_interval_finished )
							{
								if (x > lablayer->deformation_module_defined_pressure_interval[1])
								{
									defined_interval_finished = true;
								}
							}
							if (!zamachivanie && defined_interval_started && !defined_interval_finished )
							{
								vx_defined_interval.push_back(x);
								vy_in_defined_interval.push_back(y);
								ve_in_defined_interval.push_back(e);

								if (vx_defined_interval.size() == 1)
								{
									def_module_defined_pressure_interval[0] = x;
#if !USE_e0_IN_E_CALCULATION 
									e1_in_defined_pressure_interval = e.v;
									e1_in_defined_pressure_interval_defined = true;
#endif
								}
								def_module_defined_pressure_interval[1] = x;
							}
							else
							{
								if (vx_defined_interval.size() == 0)
								{
									if (first_zero_pressure)
									{
										if (i == 1 && defined_interval_finished )
										{
											def_module_defined_pressure_interval[0] = 0.0;
											vx_defined_interval.push_back(0.0);
											trial_got_value y_0 = y; y_0.v = 0.0;
											trial_got_value e_0 = e; e_0.v = e0;

											vy_in_defined_interval.push_back(y_0);
											ve_in_defined_interval.push_back(e_0);

											def_module_defined_pressure_interval[1] = comp->pressures[1];
											vx_defined_interval.push_back(x);
											vy_in_defined_interval.push_back(y);
											ve_in_defined_interval.push_back(e);
										}
									}
									else
									{
										if (i == 0 && defined_interval_finished )
										{
											def_module_defined_pressure_interval[0] = 0.0;
											vx_defined_interval.push_back(0.0);
											trial_got_value y_0 = y; y_0.v = 0.0;
											trial_got_value e_0 = e; e_0.v = e0;

											vy_in_defined_interval.push_back(y_0);
											ve_in_defined_interval.push_back(e_0);

											def_module_defined_pressure_interval[1] = comp->pressures[0];
											vx_defined_interval.push_back(x);
											vy_in_defined_interval.push_back(y);
											ve_in_defined_interval.push_back(e);
										}
									}
								}
								if (vx_defined_interval.size() == 1)
								{
								}
							}


						}
#if USE_COMPR_PO_OTN_DEF

						MinSqLinear(
							2, 
							vx_01_02_interval, 
							vy_in_01_02_interval, 
							0, 0, true, 
							lin_interp_y_a0_in_01_02_interval, 
							lin_interp_y_a1_in_01_02_interval, 
							m_lin_y_in_01_02_interval, 
							S_lin_y_in_01_02_interval);

						MinSqLinear(
							2, 
							vx_defined_interval, 
							vy_in_defined_interval, 
							0, 0, true, 
							lin_interp_y_a0_in_defined_interval, 
							lin_interp_y_a1_in_defined_interval, 
							m_lin_y_in_defined_interval, 
							S_lin_y_in_defined_interval);						
#endif
						MinSqLinear(
							2, 
							vx_01_02_interval, 
							ve_in_01_02_interval, 
							0, 0, true, 
							lin_interp_e_a0_in_01_02_interval, 
							lin_interp_e_a1_in_01_02_interval, 
							m_lin_e_in_01_02_interval, 
							S_lin_e_in_01_02_interval);


						MinSqLinear(
							2, 
							vx_defined_interval, 
							ve_in_defined_interval, 
							0, 0, true, 
							lin_interp_e_a0_in_defined_interval, 
							lin_interp_e_a1_in_defined_interval, 
							m_lin_e_in_defined_interval, 
							S_lin_e_in_defined_interval);


						this->m_gurvich.CalcDeformationModuleOnShtampPrediction(compression);

						double g = 9.80665;

						// коэффициент Пуассона
						//double mju = GetPuasson(phys_res->t);
						double IL = phys_res->fluidity_index_nature.v;
						double IL_ws = phys_res->fluidity_index_water_saturated.v;
						double Ip = phys_res->plasticity_index.v;
						double Wp = phys->moisture_on_plasticity_border.v;
						nju_tab = GetPuasson_interpolation(phys_res->t, IL, Ip, Wp);
						nju_tab_ws = GetPuasson_interpolation(phys_res->t, IL_ws, Ip, Wp);

						mk = GetMk(phys_res->t, phys_res->e.v);
						
						beta_tab = GetBeta(nju_tab.v);
						beta_tab_ws = GetBeta(nju_tab_ws.v);
//						beta_mavrodi = GetBetaMavrodi(phys_res->t, phys_res->plasticity_index.v);

						//ocenka_bytovogo_davlenia = 1000.0 * g * phys->density_of_ground * comp->lab_number->depth;// Па
						if (phys_res->density_of_water_saturated_ground.f)
						{
							ocenka_bytovogo_davlenia = 1000.0 * g * phys_res->density_of_water_saturated_ground.v * comp->lab_number->depth;// Па
							ocenka_bytovogo_davlenia.v *= 0.000001; //МПа
						}


			
#if USE_COMPR_PO_OTN_DEF
						compression_module_y_in_01_02_interval = 1.0 / this->lin_interp_y_a1_in_01_02_interval.v;
						compression_module_y_in_defined_interval = 1.0 / this->lin_interp_y_a1_in_defined_interval.v;
/*						if (CompressionLabTrialResults::use_mavrodi_beta)
						{
							deformation_module_y_in_01_02_interval = beta_mavrodi / this->lin_interp_y_a1_in_01_02_interval.v;
							deformation_module_y_in_defined_interval = beta_mavrodi / this->lin_interp_y_a1_in_defined_interval.v;
						}
						else
						{*/
							if (this->lab_trial->trial_indication == LabTrial::indication::compression_task_condition_absolute_deformation)
							{
								deformation_module_y_in_01_02_interval = beta_tab_ws / this->lin_interp_y_a1_in_01_02_interval.v;
								deformation_module_y_in_defined_interval = beta_tab_ws / this->lin_interp_y_a1_in_defined_interval.v;
							}
							else
							{
								deformation_module_y_in_01_02_interval = beta_tab / this->lin_interp_y_a1_in_01_02_interval.v;
								deformation_module_y_in_defined_interval = beta_tab / this->lin_interp_y_a1_in_defined_interval.v;
							}
						//}
#endif
						if (CompressionLabTrialResults::compression_module_e_with_min_sq)
						{
#if !USE_e0_IN_E_CALCULATION 
							if (e1_in_01_02_pressure_interval_defined)
								compression_module_e_in_01_02_interval = - (1.0 + e1_in_01_02_pressure_interval) / this->lin_interp_e_a1_in_01_02_interval.v;
							if(e1_in_defined_pressure_interval_defined)
								compression_module_e_in_defined_interval = - (1.0 + e1_in_defined_pressure_interval) / this->lin_interp_e_a1_in_defined_interval.v;
#else
							compression_module_e_in_01_02_interval = - (1.0 + e0) / this->lin_interp_e_a1_in_01_02_interval.v;
							compression_module_e_in_defined_interval = - (1.0 + e0) / this->lin_interp_e_a1_in_defined_interval.v;
#endif

							a_in_01_02_interval = - this->lin_interp_e_a1_in_01_02_interval.v;
							a_in_defined_interval = - this->lin_interp_e_a1_in_defined_interval.v;
						}
						else
						{
							if(vx_01_02_interval.size() > 1 && ve_in_01_02_interval.size() > 1 && vx_01_02_interval.size() == ve_in_01_02_interval.size())
							{
								size_t n = vx_01_02_interval.size(); 
								compression_module_e_in_01_02_interval = 
#if !USE_e0_IN_E_CALCULATION 
									(1.0 + ve_in_01_02_interval[0].v) 
#else
									(1.0 + e0) 
#endif
									* 
									(vx_01_02_interval[n-1].x - vx_01_02_interval[0].x) 
									/ 
									(ve_in_01_02_interval[0].v - ve_in_01_02_interval[n-1].v)
									;

								a_in_01_02_interval = 
									(ve_in_01_02_interval[0].v - ve_in_01_02_interval[n-1].v)
									/
									(vx_01_02_interval[n-1].x - vx_01_02_interval[0].x);
							}

							if(vx_defined_interval.size() > 1 && ve_in_defined_interval.size() > 1 && vx_defined_interval.size() == ve_in_defined_interval.size())
							{
								size_t n = vx_defined_interval.size(); 
								compression_module_e_in_defined_interval = 
#if !USE_e0_IN_E_CALCULATION 
									(1.0 + ve_in_defined_interval[0].v) 
#else
									(1.0 + e0) 
#endif
									* 
									(vx_defined_interval[n-1].x - vx_defined_interval[0].x) 
									/ 
									(ve_in_defined_interval[0].v - ve_in_defined_interval[n-1].v)
									;

								a_in_defined_interval = 
									(ve_in_defined_interval[0].v - ve_in_defined_interval[n-1].v)
									/
									(vx_defined_interval[n-1].x - vx_defined_interval[0].x);
							}
						}

/*						if (CompressionLabTrialResults::use_mavrodi_beta)
						{
							deformation_module_e_in_01_02_interval = beta_mavrodi * compression_module_e_in_01_02_interval;
							deformation_module_e_in_defined_interval = beta_mavrodi * compression_module_e_in_defined_interval;
						}
						else
						{*/
							if (this->lab_trial->trial_indication == LabTrial::indication::compression_task_condition_absolute_deformation)
							{
								deformation_module_e_in_01_02_interval = beta_tab_ws * compression_module_e_in_01_02_interval;
								deformation_module_e_in_defined_interval = beta_tab_ws * compression_module_e_in_defined_interval;
							}
							else
							{
								deformation_module_e_in_01_02_interval = beta_tab * compression_module_e_in_01_02_interval;
								deformation_module_e_in_defined_interval = beta_tab * compression_module_e_in_defined_interval;
							}
						//}
							
#if USE_COMPR_PO_OTN_DEF
						deformation_module_y_in_01_02_interval_mk = deformation_module_y_in_01_02_interval * mk;
#endif
						deformation_module_e_in_01_02_interval_mk = deformation_module_e_in_01_02_interval * mk;
						
						if (calc_e_log_interp)
						{
							if (vx.size() > 1 && ve.size() > 1)
							{
								/// Ищем уравнение компрессионной кривой в виде логарифмической зависимости
								/// e = - A * ln(sigma + sigma_0) + C
			
								this->v_e_log_interp.clear();

								//Вычисляем обращённую производную компрессионной кривой
								meanX.resize(vx.size()-1);
								minusDxDe.resize(ve.size()-1);;

								for (size_t i = 0; i < vx.size()-1; i++)
								{
									minusDxDe[i] = ve[i];

									meanX[i] = 0.5 * (vx[i].x + vx[i+1].x);
									minusDxDe[i].v = (vx[i+1].x - vx[i].x) / (ve[i].v - ve[i+1].v);
								}

								//вычисляем вторую производную компрессионной кривой
								m2X.resize(vx.size()-2);
								D2eDx2.resize(ve.size()-2);;

								for (size_t i = 1; i < vx.size()-1; i++)
								{
									D2eDx2[i-1] = ve[i];

									m2X[i-1] = vx[i].x;
									D2eDx2[i-1].v = (ve[i+1].v - ve[i].v) / (vx[i+1].x - vx[i].x) - (ve[i].v - ve[i-1].v) / (vx[i].x - vx[i-1].x);
								}

								trial_value S_lin_minusDxDe;
								int m_lin_minusDxDe;
								trial_value lin_interp_minusDxDe_a0;
								trial_value lin_interp_minusDxDe_a1;

								size_t m_i1, m_i2;
								size_t i1 = 0, i2;

								int interval = 0;

								while (i1 < vx.size()-1)
								{
									//printf("i1 = %d vx.size() = %u\n", i1, vx.size());

									bool flag = true;
									for (i2 = i1+1; i2 < vx.size() && flag; i2++)
									{

										flag = i2-1 < D2eDx2.size() ? D2eDx2[i2-1].v > e_SecondDerivativeLimit : true;

										//printf("i2 = %d D2eDx2.size() = %u D2eDx2[%d].v = %f flag = %d\n", i2, D2eDx2.size(), i2-1, D2eDx2[i2-1].v, flag);

										m_i1 = i1;
										m_i2 = i2;
									}

									//printf("m_i1 = %d\n", m_i1);
									//printf("m_i2 = %d\n", m_i2);

									this->v_e_log_interp.push_back(CompressionLogInterpolation());
									
									this->v_e_log_interp.back().i1 = m_i1;
									this->v_e_log_interp.back().i2 = m_i2;

									this->v_e_log_interp.back().p1 = vx[m_i1].x;
									this->v_e_log_interp.back().p2 = vx[m_i2].x;

									this->v_e_log_interp.back().e1 = ve[m_i1].v;
									this->v_e_log_interp.back().e2 = ve[m_i2].v;

									if (m_i2 - m_i1 > 1)
									{
										this->v_e_log_interp.back().is_log = true;
										this->v_e_log_interp.back().interval = interval;

										MinSqLinear(
											2, 
											meanX, 
											minusDxDe, 
											m_i1, m_i2-1, true, 
											lin_interp_minusDxDe_a0, 
											lin_interp_minusDxDe_a1, 
											m_lin_minusDxDe, 
											S_lin_minusDxDe);

										double x0 = lin_interp_minusDxDe_a0.v / lin_interp_minusDxDe_a1.v;
										printf("initial x0 = %f\n", x0);
										if (x0 < 0.0 || x0 > 100.)
										{
											x0 = 0.3;
											printf("initial x0 corrected = %f\n", x0);
										}                    
											

										LogInterpOfCompression(x0, m_i1, m_i2+1, vx, ve, this->v_e_log_interp.back().minus_A, this->v_e_log_interp.back().x_0, this->v_e_log_interp.back().m_C, this->v_e_log_interp.back().m_log, this->v_e_log_interp.back().Sy_log);


										if (lablayer->deformation_module_defined_pressure >= vx[m_i1].x 
											&& lablayer->deformation_module_defined_pressure < vx[m_i2].x)
										{
											e_p = this->v_e_log_interp.back().minus_A.v*log(lablayer->deformation_module_defined_pressure + this->v_e_log_interp.back().x_0) + this->v_e_log_interp.back().m_C.v;
											
											// double a = dedp = A/(p+x0);
											// dsdx = minus_A/(x+x0)
											a_p = - this->v_e_log_interp.back().minus_A.v / (lablayer->deformation_module_defined_pressure + this->v_e_log_interp.back().x_0);

#if !USE_e0_IN_E_CALCULATION 
//											if (CompressionLabTrialResults::use_mavrodi_beta)
//												E_p = beta_mavrodi.v * (1.0 + e_p) / a_p;
//											else
											{
												if (this->lab_trial->trial_indication == LabTrial::indication::compression_task_condition_absolute_deformation)
													E_p = beta_tab_ws.v * (1.0 + e_p) / a_p;
												else
													E_p = beta_tab.v * (1.0 + e_p) / a_p;
											}
#else
//											if (CompressionLabTrialResults::use_mavrodi_beta)
//												E_p = beta_mavrodi.v * (1.0 + e0) / a_p;
//											else
											{
												if (this->lab_trial->trial_indication == LabTrial::indication::compression_task_condition_absolute_deformation)
													E_p = beta_tab_ws.v * (1.0 + e0) / a_p;
												else
													E_p = beta_tab.v * (1.0 + e0) / a_p;
											}
#endif

											p_interval = interval;
										}
									}
									else
									{
										this->v_e_log_interp.back().is_log = false;
										this->v_e_log_interp.back().interval = interval;

										//линейная интерполяция между двумя точками
										double p1 = vx[m_i1].x;
										double p2 = vx[m_i2].x;

										double e1 = ve[m_i1].v;
										double e2 = ve[m_i2].v;

										double part = (lablayer->deformation_module_defined_pressure - p1) / (p2 - p1);

										e_p = e1 + part * (e2 - e1);
								
										// double a = dedp
										a_p = (e1 - e2) / (p2 - p1);
											
#if !USE_e0_IN_E_CALCULATION 
//										if (CompressionLabTrialResults::use_mavrodi_beta)
//											E_p = beta_mavrodi.v * (1.0 + e_p) / a_p;
//										else
										{
											if (this->lab_trial->trial_indication == LabTrial::indication::compression_task_condition_absolute_deformation)
												E_p = beta_tab_ws.v * (1.0 + e_p) / a_p;
											else
												E_p = beta_tab.v * (1.0 + e_p) / a_p;
										}
#else
//										if (CompressionLabTrialResults::use_mavrodi_beta)
//											E_p = beta_mavrodi.v * (1.0 + e0) / a_p;
//										else
										{
											if (this->lab_trial->trial_indication == LabTrial::indication::compression_task_condition_absolute_deformation)
												E_p = beta_tab_ws.v * (1.0 + e0) / a_p;
											else
												E_p = beta_tab.v * (1.0 + e0) / a_p;
										}
#endif
											
										p_interval = interval;
									}
									i1 = m_i2;
									interval++;
								}
								calc_e_log_interp = false;
							}
						}
						else
						{
							int interval = 0;
							for (vector<CompressionLogInterpolation>::iterator it = this->v_e_log_interp.begin();
								it != this->v_e_log_interp.end(); it++)
							{
								if (lablayer->deformation_module_defined_pressure >= (*it).p1 
									/*&& lablayer->deformation_module_defined_pressure < (*it).p2*/)
								{								
									if ((*it).is_log)
									{
										e_p = (*it).minus_A.v*log(lablayer->deformation_module_defined_pressure + (*it).x_0) + (*it).m_C.v;
										
										// double a = dedp = A/(p+x0);
										// dsdx = minus_A/(x+x0)
										a_p = - (*it).minus_A.v / (lablayer->deformation_module_defined_pressure + (*it).x_0);

#if !USE_e0_IN_E_CALCULATION 
//										if (CompressionLabTrialResults::use_mavrodi_beta)
//											E_p = beta_mavrodi.v * (1.0 + e_p) / a_p;
//										else
										{
											if (this->lab_trial->trial_indication == LabTrial::indication::compression_task_condition_absolute_deformation)
												E_p = beta_tab_ws.v * (1.0 + e_p) / a_p;
											else
												E_p = beta_tab.v * (1.0 + e_p) / a_p;
										}
#else
//										if (CompressionLabTrialResults::use_mavrodi_beta)
//											E_p = beta_mavrodi.v * (1.0 + e0) / a_p;
//										else
										{
											if (this->lab_trial->trial_indication == LabTrial::indication::compression_task_condition_absolute_deformation)
												E_p = beta_tab_ws.v * (1.0 + e0) / a_p;
											else
												E_p = beta_tab.v * (1.0 + e0) / a_p;
										}
#endif

										p_interval = interval;
									}		
									else
									{
										//линейная интерполяция между двумя точками
										double p1 = (*it).p1;
										double p2 = (*it).p2;

										double e1 = (*it).e1;
										double e2 = (*it).e2;

										double part = (lablayer->deformation_module_defined_pressure - p1) / (p2 - p1);

										e_p = e1 + part * (e2 - e1);
								
										// double a = dedp
										a_p = (e1 - e2) / (p2 - p1);

#if !USE_e0_IN_E_CALCULATION 
//										if (CompressionLabTrialResults::use_mavrodi_beta)
//											E_p = beta_mavrodi.v * (1.0 + e_p) / a_p;
//										else
										{
											if (this->lab_trial->trial_indication == LabTrial::indication::compression_task_condition_absolute_deformation)
												E_p = beta_tab_ws.v * (1.0 + e_p) / a_p;
											else
												E_p = beta_tab.v * (1.0 + e_p) / a_p;
										}
#else
//										if (CompressionLabTrialResults::use_mavrodi_beta)
//											E_p = beta_mavrodi.v * (1.0 + e0) / a_p;
//										else
										{
											if (this->lab_trial->trial_indication == LabTrial::indication::compression_task_condition_absolute_deformation)
												E_p = beta_tab_ws.v * (1.0 + e0) / a_p;
											else
												E_p = beta_tab.v * (1.0 + e0) / a_p;
										}
#endif


										p_interval = interval;
									}
								}

								interval++;
							}
						}

						this->calculed = true;
					}
				}
			}
		}	
	}
}

void CompressionLabTrialResults3::CalcProperties()
{
	gurvich_shtamp_prosadka_calculed_po_dvum_krivym = false;
	gurvich_shtamp_prosadka_calculed_po_odnoj_krivoj = false;
	prosadka_calculed_po_dvum_krivym = false;
	prosadka_calculed_po_odnoj_krivoj = false;

	D2yDx2_calculed = false;
	gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_peregibu_vtoroj_krivoj_calculed = false;

	if (this->p_result_1) this->p_result_1->CalcProperties();
	if (this->p_result_2) this->p_result_2->CalcProperties();
	if (this->p_result_3) this->p_result_3->CalcProperties();
			
	if (this->p_result_1 && this->p_result_1->calculed)
	{
		this->p_result_1->ocenka_bytovogo_davlenia;

		size_t ny = 
			this->p_result_1->va.size();

		size_t nx = 
			this->p_result_1->vx.size();

		size_t n = min(nx, ny);

		double a = 0.0;//абсолютная деформация при бытовом давлении

		for (size_t i = 0; i < n; i++)
		{
			if (this->p_result_1->ocenka_bytovogo_davlenia <= this->p_result_1->vx[i].x || i == n - 1)
			{
				if (i)
				{
					double part = 
						(this->p_result_1->ocenka_bytovogo_davlenia.v - this->p_result_1->vx[i-1].x)
						/
						(this->p_result_1->vx[i].x - this->p_result_1->vx[i-1].x);

					a = this->p_result_1->va[i-1] + part * (this->p_result_1->va[i] - this->p_result_1->va[i-1]);

				}
				else
				{
					double part = 
						(this->p_result_1->ocenka_bytovogo_davlenia.v - 0.0)
						/
						(this->p_result_1->vx[i].x - 0.0);

					a = 0.0 + part * (this->p_result_1->va[i] - 0.0);
				}

				break;
			}
		}

		double hh = 0.0;//высота кольца

		CompressionLabTrial * com_lab_trial = dynamic_cast<CompressionLabTrial *>(this->p_result_1->lab_trial);
		if (com_lab_trial)
		{
			hh = com_lab_trial->hoop_height;
		}

		if (hh)
		{
			//высота образца грунта при природной влажности и природном давлении (на глубине отбора образца)
			h0 = hh - a;
		}
	}

	if (this->p_result_1 && this->p_result_1->calculed && this->p_result_2 && this->p_result_2->calculed)
	{
		size_t ny = min(
			this->p_result_1->va.size(),
			this->p_result_2->va.size());
		size_t nx = min(
			this->p_result_1->vx.size(),
			this->p_result_2->vx.size());
		size_t n = min(nx, ny);

		x_prosadka_po_dvum_krivym.resize(n);
		prosadka_po_dvum_krivym.resize(n);
		otnosit_prosadochnost_po_dvum_krivym.resize(n);
				
		for (size_t i = 0; i < n; i++)
		{
			if (this->p_result_1->vx[i].x == this->p_result_2->vx[i].x)
			{
				x_prosadka_po_dvum_krivym[i] = this->p_result_1->vx[i].x;
				prosadka_po_dvum_krivym[i] = 
					this->p_result_2->va[i] -
					this->p_result_1->va[i];

				if (h0.f)
				{
					otnosit_prosadochnost_po_dvum_krivym[i] = prosadka_po_dvum_krivym[i] / h0;
				}
			}
		}
		for (size_t i = 0; i < n; i++)
		{
			double znamenatel = i ? (otnosit_prosadochnost_po_dvum_krivym[i].v - otnosit_prosadochnost_po_dvum_krivym[i-1].v)
				: (otnosit_prosadochnost_po_dvum_krivym[i].v - 0.0);

			if (0.01 <= otnosit_prosadochnost_po_dvum_krivym[i].v || i == n - 1)
			{
				if (znamenatel > 0)
				{
					if (i)
					{
						double part = 
							(0.01 - otnosit_prosadochnost_po_dvum_krivym[i-1].v)
							/
							znamenatel;

						nachalnoe_prosadochnoe_davlenie_po_dvum_krivym = x_prosadka_po_dvum_krivym[i-1] + part * (x_prosadka_po_dvum_krivym[i] - x_prosadka_po_dvum_krivym[i-1]);
					}
					else
					{
						double part = 
							0.01
							/
							znamenatel;

						nachalnoe_prosadochnoe_davlenie_po_dvum_krivym = 0.0 + part * (x_prosadka_po_dvum_krivym[i] - 0.0);
					}
					break;
				}
				
			}
		}

		prosadka_calculed_po_dvum_krivym = true;
	}

	if (this->p_result_2 && this->p_result_2->calculed)
	{
		size_t ny =	this->p_result_2->va.size();
		size_t nx =	this->p_result_2->vx.size();
		size_t n = min(nx, ny);

		double hh = 0.0;//высота кольца
		CompressionLabTrial * com_lab_trial = 
			dynamic_cast<CompressionLabTrial *>(this->p_result_2->lab_trial);

		if (com_lab_trial)
		{
			hh = com_lab_trial->hoop_height;
		}

		if (n && this->p_result_2->va[0] < 0.0 && hh)
		{
			svobodnoe_otnositelnoe_nabuhanie = - this->p_result_2->va[0] / hh;

			if (svobodnoe_otnositelnoe_nabuhanie.v >= 0.04)
				m_nabuhanie = CompressionLabTrialResults3::Nabuhanie::nabuhajuschie;
			else 
				m_nabuhanie = CompressionLabTrialResults3::Nabuhanie::nenabuhajuschie;
					
			for (size_t i = 0; i < n; i++)
			{
				this->p_result_2->vx[i].x;
				this->p_result_2->va[i];
			}
			for (size_t i = 1; i < n; i++)
			{
				if (0.0 <= this->p_result_2->va[i] || i == n - 1)
				{
					double part = 
						(0.0 - this->p_result_2->va[i-1])
						/
						(this->p_result_2->va[i] - this->p_result_2->va[i-1]);

					davlenie_nabuhania = 
						this->p_result_2->vx[i-1].x + 
						part * (this->p_result_2->vx[i].x - this->p_result_2->vx[i-1].x);

					break;
				}
			}
		}
	}

    // вычисляем просадочность по одной кривой
	if (this->p_result_1 && this->p_result_1->calculed)
	{
		CompressionLabTrial * com_lab_trial = dynamic_cast<CompressionLabTrial *>(this->p_result_1->lab_trial);
		if (com_lab_trial)
		{
			// компрессия грунта в природном состоянии
			CompressionLabTrial * comp = dynamic_cast<CompressionLabTrial *>(this->p_result_1->lab_trial);
			if(comp)
			{
				bool zamach = false;	
				int n = 0;
				double y_posle_zamachivania = 0.0;
				double dy_zamachivania = 0.0;
				double x_zamachivania = 0.0;

				bool first_zero_pressure = comp->n_pressures && comp->pressures[0] == 0.0;

				for (int i = 0; i < comp->n_pressures; i++)
				{
					//comp->pressures[i];
					if (i > 0 && comp->pressures[i-1] == comp->pressures[i])
					{
						zamach = true;
						n = i;
						y_posle_zamachivania = comp->absolute_deformations[i].v;
						dy_zamachivania = comp->absolute_deformations[i].v - comp->absolute_deformations[i-1].v;
						x_zamachivania = comp->pressures[i];
					}
				}

				if (zamach && n)
				{
					int i0 = !first_zero_pressure;

					x_prosadka_po_odnoj_krivoj.resize(n+i0);
					prosadka_po_odnoj_krivoj.resize(n+i0);
					otnosit_prosadochnost_po_odnoj_krivoj.resize(n+i0);

					if (!first_zero_pressure)
					{
						x_prosadka_po_odnoj_krivoj[0] = 0.0;
						prosadka_po_odnoj_krivoj[0] = 0.0;
						otnosit_prosadochnost_po_odnoj_krivoj[0] = 0.0;
					}

					for (int i = 0; i < n; i++)
					{
						double part = 
							comp->pressures[i]
							/
							x_zamachivania;
#define PROSADOCHOST_LINEAR_INTERPOLATION 1
#if !PROSADOCHOST_LINEAR_INTERPOLATION
						// алгоритм плохо работает
							// линейная интерполяция компрессионной кривой 
							// начиная от замоченного состояния до нуля
							// часто пересекает компрессионную кривую 
							// в природном состоянии
							// из-за чего получаются нелепые отрицательные значения 
							// относительной просадочности
						double yi = part * y_posle_zamachivania;

						prosadka_po_odnoj_krivoj[i+i0] = 
							yi - comp->absolute_deformations[i].v;

#else
							// поэтому в первом приближении целесообразно проводить
							// линейную интерполяцию не компрессионной кривой,
							// а просадки

						double dyi = part * dy_zamachivania;
						prosadka_po_odnoj_krivoj[i+i0] = dyi;


							// в более серьёзном приближении надо будет производить 
							// нелинейную (логарифмическую, например) интерполяцию
							// компрессионной кривой в природном состоянии,
							// затем "вытягивать" её вниз
							// до точки замачивания
#endif
						x_prosadka_po_odnoj_krivoj[i+i0] = comp->pressures[i];
						if (h0.f)
						{
							otnosit_prosadochnost_po_odnoj_krivoj[i+i0] = prosadka_po_odnoj_krivoj[i+i0] / h0;
						}

					}

					for (int i = 0; i < n + i0; i++)
					{
						if (0.01 <= otnosit_prosadochnost_po_odnoj_krivoj[i].v || i == n + i0 - 1)
						{
							double znamenatel = i ? (otnosit_prosadochnost_po_odnoj_krivoj[i].v - otnosit_prosadochnost_po_odnoj_krivoj[i-1].v)
								: (otnosit_prosadochnost_po_odnoj_krivoj[i].v - 0.0);
							if (znamenatel > 0.0)
							{
								if (i)
								{
									double part = 
										(0.01 - otnosit_prosadochnost_po_odnoj_krivoj[i-1].v)
										/
										znamenatel;

									nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj = x_prosadka_po_odnoj_krivoj[i-1] + part * (x_prosadka_po_odnoj_krivoj[i] - x_prosadka_po_odnoj_krivoj[i-1]);
								}
								else
								{
									double part = 
										(0.01 - 0.0)
										/
										znamenatel;

									nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj = 0.0 + part * (x_prosadka_po_odnoj_krivoj[i] - 0.0);
								}
								break;
							}
							
						}
					}

					prosadka_calculed_po_odnoj_krivoj = true;							
				}
			}
		}
	}

	if (this->p_result_1 && this->p_result_1->calculed && this->p_result_2 && this->p_result_2->calculed)
	{
		size_t ny = min(
			this->p_result_1->m_gurvich.shtamp_vy.size(),
			this->p_result_2->m_gurvich.shtamp_vy.size());
		size_t nx = min(
			this->p_result_1->m_gurvich.shtamp_vx.size(),
			this->p_result_2->m_gurvich.shtamp_vx.size());
		size_t n = min(nx, ny);




		if (this->p_result_2 && this->p_result_2->calculed 
			&& this->p_result_2->m_gurvich.shtamp_vx.size() > 2
			&& this->p_result_2->m_gurvich.shtamp_vy.size() > 2
			)
		{
			//вычисляем вторую производную осадки после замачивания
			m2X.resize(this->p_result_2->m_gurvich.shtamp_vx.size()-2);
			D2yDx2.resize(this->p_result_2->m_gurvich.shtamp_vy.size()-2);;

			for (size_t i = 1; i < this->p_result_2->m_gurvich.shtamp_vx.size()-1; i++)
			{
				D2yDx2[i-1] = this->p_result_2->m_gurvich.shtamp_vy[i];

				m2X[i-1] = this->p_result_2->m_gurvich.shtamp_vx[i].x;
				D2yDx2[i-1].v = 
					(this->p_result_2->m_gurvich.shtamp_vy[i+1].v - this->p_result_2->m_gurvich.shtamp_vy[i].v) / 
					(this->p_result_2->m_gurvich.shtamp_vx[i+1].x - this->p_result_2->m_gurvich.shtamp_vx[i].x) 
					- 
					(this->p_result_2->m_gurvich.shtamp_vy[i].v - this->p_result_2->m_gurvich.shtamp_vy[i-1].v) / 
					(this->p_result_2->m_gurvich.shtamp_vx[i].x - this->p_result_2->m_gurvich.shtamp_vx[i-1].x);
			}


			// ищем максимум второй производной для выявления перегиба
			size_t i_max_D2yDx2 = 0;
			double max_D2yDx2 = D2yDx2[i_max_D2yDx2].v;

			for (size_t i = 1; i < D2yDx2.size(); i++)
			{
				if (max_D2yDx2 < D2yDx2[i].v)
				{
					i_max_D2yDx2 = i;
					max_D2yDx2 = D2yDx2[i_max_D2yDx2].v;
				}
			}

			if (max_D2yDx2 > Gurvich::y_SecondDerivativeLimit)
			{
				gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_peregibu_vtoroj_krivoj = 
					this->p_result_2->m_gurvich.shtamp_vx[i_max_D2yDx2+1].x;

				gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_peregibu_vtoroj_krivoj_calculed = true;

			}




			D2yDx2_calculed = true;
		}




		x_gurvich_shtamp_prosadka_po_dvum_krivym.resize(n);
		gurvich_shtamp_prosadka_po_dvum_krivym.resize(n);
		gurvich_shtamp_hdef_po_dvum_krivym.resize(n);
		gurvich_shtamp_otnosit_prosadochnost_po_dvum_krivym.resize(n);


		for (size_t i = 0; i < n; i++)
		{
			if (this->p_result_1->m_gurvich.shtamp_vx[i].x == this->p_result_2->m_gurvich.shtamp_vx[i].x)
			{
				x_gurvich_shtamp_prosadka_po_dvum_krivym[i] = this->p_result_1->m_gurvich.shtamp_vx[i].x;
				gurvich_shtamp_prosadka_po_dvum_krivym[i] = 
					this->p_result_2->m_gurvich.shtamp_vy[i].v -
					this->p_result_1->m_gurvich.shtamp_vy[i].v;

				gurvich_shtamp_hdef_po_dvum_krivym[i] = 
					GetHdef(this->p_result_1->m_gurvich.shtamp_vx[i].x, 
					10.0 * Gurvich::shtamp_diameter);

				gurvich_shtamp_otnosit_prosadochnost_po_dvum_krivym[i] = 
					gurvich_shtamp_prosadka_po_dvum_krivym[i] /
					gurvich_shtamp_hdef_po_dvum_krivym[i];

			}
		}
		for (size_t i = 0; i < n; i++)
		{
			double znamenatel = i ? 
				(gurvich_shtamp_otnosit_prosadochnost_po_dvum_krivym[i].v - gurvich_shtamp_otnosit_prosadochnost_po_dvum_krivym[i-1].v)
				:
				(gurvich_shtamp_otnosit_prosadochnost_po_dvum_krivym[i].v - 0.0);

			if (0.005 <= gurvich_shtamp_otnosit_prosadochnost_po_dvum_krivym[i].v || i == n - 1)
			{
				if (znamenatel > 0.0)
				{	
					if (i)
					{
						double part = 
							(0.005 - gurvich_shtamp_otnosit_prosadochnost_po_dvum_krivym[i-1].v)
							/
							znamenatel;

						gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_dvum_krivym = 
							x_gurvich_shtamp_prosadka_po_dvum_krivym[i-1] + 
							part * 
							(x_gurvich_shtamp_prosadka_po_dvum_krivym[i] - x_gurvich_shtamp_prosadka_po_dvum_krivym[i-1]);
					}
					else
					{
						double part = 
							(0.005 - 0.0)
							/
							(gurvich_shtamp_otnosit_prosadochnost_po_dvum_krivym[i].v - 0.0);

						gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_dvum_krivym = 0.0 + part * (x_gurvich_shtamp_prosadka_po_dvum_krivym[i] - 0.0);
					}
					break;
				}				
			}
		}

		gurvich_shtamp_prosadka_calculed_po_dvum_krivym = true;
	}
	if (this->p_result_1 && this->p_result_1->calculed)
	{	

		size_t ny = this->p_result_1->m_gurvich.shtamp_vy.size();
		size_t nx =	this->p_result_1->m_gurvich.shtamp_vx.size();
		size_t nxy = min(nx, ny);
		size_t n = 0;

		double y_posle_zamachivania = 0.0;
		double dy_zamachivania = 0.0;
		double x_zamachivania = 0.0;

		for (size_t i = 1; i < nxy; i++)
		{
			if (this->p_result_1->m_gurvich.shtamp_vx[i].x == this->p_result_1->m_gurvich.shtamp_vx[i-1].x)
			{
				n = i;
				y_posle_zamachivania = this->p_result_1->m_gurvich.shtamp_vy[i].v;
				dy_zamachivania = this->p_result_1->m_gurvich.shtamp_vy[i].v - this->p_result_1->m_gurvich.shtamp_vy[i-1].v;
				x_zamachivania = this->p_result_1->m_gurvich.shtamp_vx[i].x;
				break;
			}
		}

		if (n)
		{
			x_gurvich_shtamp_prosadka_po_odnoj_krivoj.resize(n);
			gurvich_shtamp_prosadka_po_odnoj_krivoj.resize(n);
			gurvich_shtamp_hdef_po_odnoj_krivoj.resize(n);
			gurvich_shtamp_otnosit_prosadochnost_po_odnoj_krivoj.resize(n);

			for (size_t i = 0; i < n; i++)
			{
				double part = 
					(this->p_result_1->m_gurvich.shtamp_vx[i].x - 0.0)
					/
					(x_zamachivania - 0.0);


				x_gurvich_shtamp_prosadka_po_odnoj_krivoj[i] = this->p_result_1->m_gurvich.shtamp_vx[i].x;
#if !PROSADOCHOST_LINEAR_INTERPOLATION
				double yi = 0.0 + part * (y_posle_zamachivania - 0.0);
				gurvich_shtamp_prosadka_po_odnoj_krivoj[i] = 
					yi - this->p_result_1->m_gurvich.shtamp_vy[i].v;
#else
				double dyi = part * dy_zamachivania;
				gurvich_shtamp_prosadka_po_odnoj_krivoj[i] = dyi;
#endif
				gurvich_shtamp_hdef_po_odnoj_krivoj[i] = 
					GetHdef(this->p_result_1->m_gurvich.shtamp_vx[i].x, 
					10.0 * Gurvich::shtamp_diameter);

				gurvich_shtamp_otnosit_prosadochnost_po_odnoj_krivoj[i] = 
					gurvich_shtamp_prosadka_po_odnoj_krivoj[i] /
					gurvich_shtamp_hdef_po_odnoj_krivoj[i];

			}
			for (size_t i = 0; i < n; i++)
			{
				if (0.005 <= gurvich_shtamp_otnosit_prosadochnost_po_odnoj_krivoj[i].v || i == n - 1)
				{
					double znamenatel = i ? 
						(gurvich_shtamp_otnosit_prosadochnost_po_odnoj_krivoj[i].v - gurvich_shtamp_otnosit_prosadochnost_po_odnoj_krivoj[i-1].v)
						:
						(gurvich_shtamp_otnosit_prosadochnost_po_odnoj_krivoj[i].v - 0.0);
					if (znamenatel > 0.0)
					{
						if (i)
						{
							double part = 
								(0.005 - gurvich_shtamp_otnosit_prosadochnost_po_odnoj_krivoj[i-1].v)
								/
								znamenatel ;

							gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj = x_gurvich_shtamp_prosadka_po_odnoj_krivoj[i-1] + part * (x_gurvich_shtamp_prosadka_po_odnoj_krivoj[i] - x_gurvich_shtamp_prosadka_po_odnoj_krivoj[i-1]);
						}
						else
						{
							double part = 
								(0.005 - 0.0)
								/
								znamenatel ;

							gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj = 0.0 + part * (x_gurvich_shtamp_prosadka_po_odnoj_krivoj[i] - 0.0);
						}
						break;
					}
					
				}
			}

			gurvich_shtamp_prosadka_calculed_po_odnoj_krivoj = true;
		}
	}


	if (this->p_result_1)
	{
		if (prosadka_calculed_po_dvum_krivym)
		{
			if (nachalnoe_prosadochnoe_davlenie_po_dvum_krivym.f)
			{
				if(nachalnoe_prosadochnoe_davlenie_po_dvum_krivym.v < this->p_result_1->ocenka_bytovogo_davlenia.v)
					m_prosadochnost = CompressionLabTrialResults3::Prosadochnost::prosadochnye;
				else
					m_prosadochnost = CompressionLabTrialResults3::Prosadochnost::neprosadochnye;
			}
			else
			{
				if (x_prosadka_po_dvum_krivym.size() && x_prosadka_po_dvum_krivym.back() >= this->p_result_1->ocenka_bytovogo_davlenia.v)
				{
					m_prosadochnost = CompressionLabTrialResults3::Prosadochnost::neprosadochnye;
				}
			}
		}
		else if (prosadka_calculed_po_odnoj_krivoj)
		{
			if (nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj.f)
			{
				if(nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj.v < this->p_result_1->ocenka_bytovogo_davlenia.v)
					m_prosadochnost = CompressionLabTrialResults3::Prosadochnost::prosadochnye;
				else
					m_prosadochnost = CompressionLabTrialResults3::Prosadochnost::neprosadochnye;
			}
			else
			{
				if (x_prosadka_po_odnoj_krivoj.size() && x_prosadka_po_odnoj_krivoj.back() >= this->p_result_1->ocenka_bytovogo_davlenia.v)
				{
					m_prosadochnost = CompressionLabTrialResults3::Prosadochnost::neprosadochnye;
				}
			}
		}
	}

	if (this->p_result_2 && this->p_result_2->calculed)
	{
		CompressionLabTrial * comp_trial_2 = dynamic_cast<CompressionLabTrial *>(p_result_2->lab_trial);
		if (comp_trial_2)
		{
			if (comp_trial_2->m_grunta_posle.f && comp_trial_2->m_grunta_zamoch.f)
			{
				double d_kolca = comp_trial_2->hoop_diameter;
				double s_kolca = 0.01 * 0.25 * PI * d_kolca * d_kolca;
				double osadka_po_indikatory = comp_trial_2->absolute_deformations[comp_trial_2->n_pressures-1].v;

				m_otzhatoj_vody = comp_trial_2->m_grunta_zamoch.v - comp_trial_2->m_grunta_posle.v;
				dejstvit_polnaja_osadka = 10.0 * m_otzhatoj_vody.v / s_kolca;
				popravochnyj_koefficient_alpha = dejstvit_polnaja_osadka.v / osadka_po_indikatory;
			}		
		}
	}
}

const char * CompressionLabTrialResults3::ProsadochnostToString(CompressionLabTrialResults3::Prosadochnost pros)
{
	switch(CGround::s_Quantity)
	{
	case CGround::Quantity::singular:
		{
			switch (CGround::s_Gender)
			{
			case CGround::Gender::male:
				{
					switch(pros)
					{
					case CompressionLabTrialResults3::Prosadochnost::neprosadochnye:
						return "непросадочный";
					case CompressionLabTrialResults3::Prosadochnost::prosadochnye:
						return "просадочный";
					}
				}
				break;
			case CGround::Gender::female:
				{
					switch(pros)
					{
					case CompressionLabTrialResults3::Prosadochnost::neprosadochnye:
						return "непросадочная";
					case CompressionLabTrialResults3::Prosadochnost::prosadochnye:
						return "просадочная";
					}
				}
				break;
			case CGround::Gender::middle:
				{
					switch(pros)
					{
					case CompressionLabTrialResults3::Prosadochnost::neprosadochnye:
						return "непросадочное";
					case CompressionLabTrialResults3::Prosadochnost::prosadochnye:
						return "просадочное";
					}
				}
				break;
			}
		}
		break;
	case CGround::Quantity::plural:
		{
			switch(pros)
			{
			case CompressionLabTrialResults3::Prosadochnost::neprosadochnye:
				return "непросадочные";
			case CompressionLabTrialResults3::Prosadochnost::prosadochnye:
				return "просадочные";
			}
		}
		break;
	}
	return "";
}
const char * CompressionLabTrialResults3::NabuhanieToString(CompressionLabTrialResults3::Nabuhanie nab)
{
	switch(CGround::s_Quantity)
	{
	case CGround::Quantity::singular:
		{
			switch (CGround::s_Gender)
			{
			case CGround::Gender::male:
				{
					switch(nab)
					{
					case CompressionLabTrialResults3::Nabuhanie::nenabuhajuschie:
						return "ненабухающий";
					case CompressionLabTrialResults3::Nabuhanie::nabuhajuschie:
						return "набухающий";
					}
				}
				break;
			case CGround::Gender::female:
				{
					switch(nab)
					{
					case CompressionLabTrialResults3::Nabuhanie::nenabuhajuschie:
						return "ненабухающая";
					case CompressionLabTrialResults3::Nabuhanie::nabuhajuschie:
						return "набухающая";
					}
				}
				break;
			case CGround::Gender::middle:
				{
					switch(nab)
					{
					case CompressionLabTrialResults3::Nabuhanie::nenabuhajuschie:
						return "ненабухающее";
					case CompressionLabTrialResults3::Nabuhanie::nabuhajuschie:
						return "набухающее";
					}
				}
				break;
			}
		}
		break;
	case CGround::Quantity::plural:
		{
			switch(nab)
			{
			case CompressionLabTrialResults3::Nabuhanie::nenabuhajuschie:
				return "ненабухающие";
			case CompressionLabTrialResults3::Nabuhanie::nabuhajuschie:
				return "набухающие";
			}
		}
		break;
	}
	return "";
}


void PrintfProp1(CompressionLabTrialResults * res, vector<fmtstr> & text)
{
	char str[1024];

	sprintf(str, "ocenka_bytovogo_davlenia = %0.3f МПа", res->ocenka_bytovogo_davlenia.v);
	text.push_back(fmtstr(str, NULL, true, false));

	sprintf(str, "Коэффициент Пуассона = %f", res->nju_tab.v);
	text.push_back(fmtstr(str, NULL, true, false));

	sprintf(str, "Коэффициент Пуассона (водонас) = %f", res->nju_tab_ws.v);
	text.push_back(fmtstr(str, NULL, true, false));


	sprintf(str, "beta = %f", res->beta_tab.v);
	text.push_back(fmtstr(str, NULL, true, false));

	sprintf(str, "beta_ws = %f", res->beta_tab_ws.v);
	text.push_back(fmtstr(str, NULL, true, false));

//	sprintf(str, "beta_mavrodi = %f", res->beta_mavrodi.v);
//	text.push_back(fmtstr(str, NULL, true, false));

	sprintf(str, "mk = %f", res->mk.v);
	text.push_back(fmtstr(str, NULL, true, false));
}
#if USE_COMPR_PO_OTN_DEF
void PrintfPropY(CompressionLabTrialResults * res, vector<fmtstr> & text)
{
	char str[1024];
/*
	sprintf(str, "log_interp_a0 = %f", res->log_interp_a0.v);
	text.push_back(fmtstr(str, &res->log_interp_a0.f, true, false));

	sprintf(str, "log_interp_a1 = %f", res->log_interp_a1.v);
	text.push_back(fmtstr(str, &res->log_interp_a1.f, true, false));

	sprintf(str, "m_log = %d", res->m_log);
	text.push_back(fmtstr(str, &res->log_interp_a0.f, true, false));

	sprintf(str, "S_log = %f", res->Sy_log);
	text.push_back(fmtstr(str, &res->log_interp_a0.f, true, false));


	sprintf(str, "lin_interp_a0 = %f", res->lin_interp_a0.v);
	text.push_back(fmtstr(str, &res->lin_interp_a0.f, true, false));

	sprintf(str, "lin_interp_a1 = %f", res->lin_interp_a1.v);
	text.push_back(fmtstr(str, &res->lin_interp_a1.f, true, false));

	sprintf(str, "m_lin = %d", res->m_lin);
	text.push_back(fmtstr(str, &res->lin_interp_a0.f, true, false));

	sprintf(str, "S_lin = %f", res->Sy_lin);
	text.push_back(fmtstr(str, &res->lin_interp_a0.f, true, false));
*/
	char s1[1024];
	char s2[1024];

/*	sprintf(s1, "%f", res->deformation_module_pressure_interval[0]);
	sprintf(s2, "%f", res->deformation_module_pressure_interval[1]);
	DeleteEndZeros(s1);
	DeleteEndZeros(s2);	

	sprintf(str, "Модуль деформации во всём интервале [%s - %s] = %f", s1, s2, res->deformation_module.v);
	text.push_back(fmtstr(str, &res->deformation_module.f, true, false));





	sprintf(str, "lin_interp_a0_in_defined_interval = %f", res->lin_interp_a0_in_defined_interval.v);
	text.push_back(fmtstr(str, &res->lin_interp_a0_in_defined_interval.f, true, false));

	sprintf(str, "lin_interp_a1_in_defined_interval = %f", res->lin_interp_a1_in_defined_interval.v);
	text.push_back(fmtstr(str, &res->lin_interp_a1_in_defined_interval.f, true, false));

	sprintf(str, "m_lin_in_defined_interval = %d", res->m_lin_in_defined_interval);
	text.push_back(fmtstr(str, &res->lin_interp_a0_in_defined_interval.f, true, false));

*/
	sprintf(s1, "%f", res->def_module_01_02_pressure_interval[0]);
	sprintf(s2, "%f", res->def_module_01_02_pressure_interval[1]);
	DeleteEndZeros(s1);
	DeleteEndZeros(s2);	

	sprintf(str, "Компрессионный модуль (по отн.деф) [%s - %s] = %f МПа", s1, s2, res->compression_module_y_in_01_02_interval.v);
	text.push_back(fmtstr(str, &res->deformation_module_y_in_01_02_interval.f, true, false));
	
	sprintf(str, "Ср.кв.откл.отн.деф.от лин.ф-ции [%s - %s] = %f", s1, s2, res->S_lin_y_in_01_02_interval.v);
	text.push_back(fmtstr(str, &res->S_lin_y_in_01_02_interval.f, true, false));

	sprintf(str, "Модуль деформации (по отн.деф) [%s - %s] = %f МПа", s1, s2, res->deformation_module_y_in_01_02_interval.v);
	text.push_back(fmtstr(str, &res->deformation_module_y_in_01_02_interval.f, true, false));

	sprintf(str, "Модуль деформации (по отн.деф) [%s - %s] * mk = %f МПа", s1, s2, res->deformation_module_y_in_01_02_interval_mk.v);
	text.push_back(fmtstr(str, &res->deformation_module_y_in_01_02_interval_mk.f, true, false));

	sprintf(s1, "%f", res->def_module_defined_pressure_interval[0]);
	sprintf(s2, "%f", res->def_module_defined_pressure_interval[1]);
	DeleteEndZeros(s1);
	DeleteEndZeros(s2);	

	sprintf(str, "Компрессионный модуль (по отн.деф) [%s - %s] = %f МПа", s1, s2, res->compression_module_y_in_defined_interval.v);
	text.push_back(fmtstr(str, &res->deformation_module_y_in_defined_interval.f, true, false));

	sprintf(str, "Ср.кв.откл.отн.деф.от лин.ф-ции [%s - %s] = %f", s1, s2, res->S_lin_y_in_defined_interval.v);
	text.push_back(fmtstr(str, &res->S_lin_y_in_defined_interval.f, true, false));

	sprintf(str, "Модуль деформации (по отн.деф) [%s - %s] = %f МПа", s1, s2, res->deformation_module_y_in_defined_interval.v);
	text.push_back(fmtstr(str, &res->deformation_module_y_in_defined_interval.f, true, false));
}
#endif
void PrintfPropE(CompressionLabTrialResults * res, vector<fmtstr> & text)
{
	char str[1024];

	char sp[1024];
	sprintf(sp, "%f", res->lab_trial->lab_number->lab_layer->deformation_module_defined_pressure);
	DeleteEndZeros(sp);

		char sp1[128];
		char sp2[128];

	for (vector<CompressionLogInterpolation>::iterator it = res->v_e_log_interp.begin();
		it != res->v_e_log_interp.end(); it++)
	{
		if((*it).is_log)
		{
			sprintf(sp1, "%f", (*it).p1);
			DeleteEndZeros(sp1);
			sprintf(sp2, "%f", (*it).p2);
			DeleteEndZeros(sp2);

			sprintf(str, "e[%s - %s] = %f*ln(p+%f)+%f      (интервал № %d)", sp1, sp2, (*it).minus_A.v, (*it).x_0, (*it).m_C.v, (*it).interval);
			text.push_back(fmtstr(str, &(*it).m_C.f, true, false));

			//sprintf(str, "Sy_log = %f m_log = %d", (*it).Sy_log.v, (*it).m_log);
			//text.push_back(fmtstr(str, &(*it).m_C.f, true, false));

			//sprintf(str, "i1 = %d i2 = %d", (*it).i1, (*it).i2);
			//text.push_back(fmtstr(str, &(*it).m_C.f, true, false));
		}
	}

	sprintf(str, "e(%s) = %f", sp, res->e_p);
	text.push_back(fmtstr(str, NULL, true, false));

	
	sprintf(str, "a(%s) = %f", sp, res->a_p);
	text.push_back(fmtstr(str, NULL, true, false));


	sprintf(str, "E(%s) = %f", sp, res->E_p);
	text.push_back(fmtstr(str, NULL, true, false));


	sprintf(str, "интервал № %d", res->p_interval);
	text.push_back(fmtstr(str, NULL, true, false));


							
/*
	sprintf(str, "log_interp_a0 = %f", res->log_interp_a0.v);
	text.push_back(fmtstr(str, &res->log_interp_a0.f, true, false));

	sprintf(str, "log_interp_a1 = %f", res->log_interp_a1.v);
	text.push_back(fmtstr(str, &res->log_interp_a1.f, true, false));

	sprintf(str, "m_log = %d", res->m_log);
	text.push_back(fmtstr(str, &res->log_interp_a0.f, true, false));

	sprintf(str, "S_log = %f", res->Sy_log);
	text.push_back(fmtstr(str, &res->log_interp_a0.f, true, false));


	sprintf(str, "lin_interp_a0 = %f", res->lin_interp_a0.v);
	text.push_back(fmtstr(str, &res->lin_interp_a0.f, true, false));

	sprintf(str, "lin_interp_a1 = %f", res->lin_interp_a1.v);
	text.push_back(fmtstr(str, &res->lin_interp_a1.f, true, false));

	sprintf(str, "m_lin = %d", res->m_lin);
	text.push_back(fmtstr(str, &res->lin_interp_a0.f, true, false));

	sprintf(str, "S_lin = %f", res->Sy_lin);
	text.push_back(fmtstr(str, &res->lin_interp_a0.f, true, false));
*/
	char s1[1024];
	char s2[1024];

/*	sprintf(s1, "%f", res->deformation_module_pressure_interval[0]);
	sprintf(s2, "%f", res->deformation_module_pressure_interval[1]);
	DeleteEndZeros(s1);
	DeleteEndZeros(s2);	

	sprintf(str, "Модуль деформации во всём интервале [%s - %s] = %f", s1, s2, res->deformation_module.v);
	text.push_back(fmtstr(str, &res->deformation_module.f, true, false));





	sprintf(str, "lin_interp_a0_in_defined_interval = %f", res->lin_interp_a0_in_defined_interval.v);
	text.push_back(fmtstr(str, &res->lin_interp_a0_in_defined_interval.f, true, false));

	sprintf(str, "lin_interp_a1_in_defined_interval = %f", res->lin_interp_a1_in_defined_interval.v);
	text.push_back(fmtstr(str, &res->lin_interp_a1_in_defined_interval.f, true, false));

	sprintf(str, "m_lin_in_defined_interval = %d", res->m_lin_in_defined_interval);
	text.push_back(fmtstr(str, &res->lin_interp_a0_in_defined_interval.f, true, false));

*/

	sprintf(s1, "%f", res->def_module_01_02_pressure_interval[0]);
	sprintf(s2, "%f", res->def_module_01_02_pressure_interval[1]);
	DeleteEndZeros(s1);
	DeleteEndZeros(s2);	

	const char * method;

	if (CompressionLabTrialResults::compression_module_e_with_min_sq)
		method = "(по м-ду наим.кв.) ";
	else
		method = "";

	sprintf(str, "Коэффициент уплотнения %s[%s - %s] = %f МПа-1", method, s1, s2, res->a_in_01_02_interval.v);
	text.push_back(fmtstr(str, &res->a_in_01_02_interval.f, true, false));
	
	sprintf(str, "Компрессионный модуль (без бета)[%s - %s] = %f МПа", s1, s2, res->compression_module_e_in_01_02_interval.v);
	text.push_back(fmtstr(str, &res->compression_module_e_in_01_02_interval.f, true, false));

	sprintf(str, "Ср.кв.откл.компр.крив.от лин.ф-ции [%s - %s] = %f", s1, s2, res->S_lin_e_in_01_02_interval.v);
	text.push_back(fmtstr(str, &res->S_lin_e_in_01_02_interval.f, true, false));

	sprintf(str, "Модуль деформации (c бета) [%s - %s] = %f МПа", s1, s2, res->deformation_module_e_in_01_02_interval.v);
	text.push_back(fmtstr(str, &res->deformation_module_e_in_01_02_interval.f, true, false));

	sprintf(str, "Модуль деформации (c бета) [%s - %s] * mk = %f МПа", s1, s2, res->deformation_module_e_in_01_02_interval_mk.v);
	text.push_back(fmtstr(str, &res->deformation_module_e_in_01_02_interval_mk.f, true, false));

	sprintf(s1, "%f", res->def_module_defined_pressure_interval[0]);
	sprintf(s2, "%f", res->def_module_defined_pressure_interval[1]);
	DeleteEndZeros(s1);
	DeleteEndZeros(s2);	





	sprintf(str, "Коэффициент уплотнения %s[%s - %s] = %f МПа-1", method, s1, s2, res->a_in_defined_interval.v);
	text.push_back(fmtstr(str, &res->a_in_defined_interval.f, true, false));



	sprintf(str, "Компрессионный модуль (по компр.крив. - E без бета)[%s - %s] = %f МПа", s1, s2, res->compression_module_e_in_defined_interval.v);
	text.push_back(fmtstr(str, &res->deformation_module_e_in_defined_interval.f, true, false));

	sprintf(str, "Ср.кв.откл.компр.крив.от лин.ф-ции [%s - %s] = %f", s1, s2, res->S_lin_e_in_defined_interval.v);
	text.push_back(fmtstr(str, &res->S_lin_e_in_defined_interval.f, true, false));

	sprintf(str, "Модуль деформации (по компр.крив.)[%s - %s] = %f МПа", s1, s2, res->deformation_module_e_in_defined_interval.v);
	text.push_back(fmtstr(str, &res->deformation_module_e_in_defined_interval.f, true, false));
}
void CompressionLabTrialResults::PrintfProperties(vector<fmtstr> & text)
{
#if USE_COMPR_PO_OTN_DEF
	PrintfPropY(this, text);
#endif
	PrintfPropE(this, text);

	LabNumber * labnumber = this->lab_trial ? (LabNumber *)this->lab_trial->GetLabNumber() : NULL;
	if (labnumber)
	{
		LabLayer * lablayer = (LabLayer *) labnumber->GetLabLayer();
		if (lablayer)
		{
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
			if(compression)
			{
				this->m_gurvich.PrintShtampDeformationPrediction(compression, &text, NULL);
			}
		}
	}
}
void CompressionLabTrialResults3::PrintfProperties(vector<fmtstr> & text)
{
	if (this->p_result_1) this->p_result_1->PrintfProperties(text);
	if (this->p_result_2) this->p_result_2->PrintfProperties(text);
	if (this->p_result_3) this->p_result_3->PrintfProperties(text);
	this->PrintfProperties_self(text);
}
void CompressionLabTrialResults3::PrintfProperties_self(vector<fmtstr> & text)
{
	//TODO realise this
}
void CompressionLabTrialResults3::PrintfProperties_self(vector<LabData> & labdata)
{
	//TODO realise this
}
void CompressionLabTrialResults::PrintfProperties(vector<LabData> & labdata)
{

	zamachivanie = false;

	LabNumber * labnumber = this->lab_trial ? (LabNumber *)this->lab_trial->GetLabNumber() : NULL;
	if (labnumber)
	{
		LabLayer * lablayer = (LabLayer *) labnumber->GetLabLayer();
		CompressionLabTrial * comp_lab_trial = dynamic_cast<CompressionLabTrial *>(this->lab_trial);
		if (lablayer && comp_lab_trial)
		{		
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
			LabParameters * lab_params = lablayer->FindLabParameters(comp_lab_trial->trial_indication);
			CompressionLabParameters * com_lab_params = dynamic_cast<CompressionLabParameters *>(lab_params);
			
			if(compression && com_lab_params && com_lab_params->GetCheckedLabParam())
			{
				if (com_lab_params->parameters_initial && com_lab_params->parameters_initial->GetCheckedLabParam())
				{
					labdata.push_back(LabData());
					{
						// plot
						labdata.back().plot_data.use_plot = true;
						labdata.back().plot_data.y_dir = -1;
						labdata.back().plot_data.title = "Компрессия - зависимость абсолютной деформации от нагрузки";
						labdata.back().plot_data.xlabel = "Давления, МПа";
						labdata.back().plot_data.ylabel = "Абс.Деф., мм";
						labdata.back().plot_data.plot_lines.push_back(plot_line());

						// массив
						double x,y;
						for (int i = 0; i < comp_lab_trial->n_pressures; i++)
						{
#if USE_LAB_LAYER_PRESSURES
							switch(com_type)				
							{
							case CompressionLabTrial::type::nature_condition:
								{
									x = compression->pressures_in_nature_condition[i];
									if (i > 0 && compression->pressures_in_nature_condition[i-1] == compression->pressures_in_nature_condition[i])
									{
										zamachivanie = true;
									}
								}
								break;
							case CompressionLabTrial::type::task_condition:
								{
									x = compression->pressures_in_task_condition[i];
								}
								break;
							case CompressionLabTrial::type::shrinkage:
								{
									x = compression->pressures_on_shrinkage[i];
								}
								break;
							}
#else
							x = comp_lab_trial->pressures[i];
							if (com_type == CompressionLabTrial::type::nature_condition)			
							{
								if (i > 0 && comp_lab_trial->pressures[i-1] == comp_lab_trial->pressures[i])
								{
									zamachivanie = true;
								}
							}

#endif

							y = comp_lab_trial->absolute_deformations[i].v;
							labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
						}
					}
				}

				if (com_lab_params->parameters_results && com_lab_params->parameters_results->GetCheckedLabParam())
				{					
					labdata.push_back(LabData());
					PrintfProp1(this, labdata.back().text);
				}

#if USE_COMPR_PO_OTN_DEF
				if (com_lab_params->parameters_results1_every && com_lab_params->parameters_results1_every->GetCheckedLabParam())
				{					
					labdata.push_back(LabData());
					if (1)
					{
						// plot
						labdata.back().plot_data.use_plot = true;
						labdata.back().plot_data.y_dir = -1;
						labdata.back().plot_data.title = "Компрессия - зависимость относительной Деформации от нагрузки";
						labdata.back().plot_data.xlabel = "Давления, МПа";
						labdata.back().plot_data.ylabel = "Отн.Деф.";
						labdata.back().plot_data.plot_lines.push_back(plot_line());

						// массив
						double x,y;
						for (int i = 0; i < comp_lab_trial->n_pressures; i++)
						{
#if USE_LAB_LAYER_PRESSURES
							switch(com_type)				
							{
							case CompressionLabTrial::type::nature_condition:
								{
									x = compression->pressures_in_nature_condition[i];
									if (i > 0 && compression->pressures_in_nature_condition[i-1] == compression->pressures_in_nature_condition[i])
									{
										zamachivanie = true;
									}
								}
								break;
							case CompressionLabTrial::type::task_condition:
								{
									x = compression->pressures_in_task_condition[i];
								}
								break;
							case CompressionLabTrial::type::shrinkage:
								{
									x = compression->pressures_on_shrinkage[i];
								}
								break;
							}
#else
							x = comp_lab_trial->pressures[i];
							if (com_type == CompressionLabTrial::type::nature_condition)			
							{
								if (i > 0 && comp_lab_trial->pressures[i-1] == comp_lab_trial->pressures[i])
								{
									zamachivanie = true;
								}
							}

#endif

#if USE_LAB_LAYER_HOOP
							y = comp_lab_trial->absolute_deformations[i].v / compression->hoop_height;
#else
							y = comp_lab_trial->absolute_deformations[i].v / comp_lab_trial->hoop_height;
#endif
							labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
						}


						if (!calculed)
							CalcProperties();

						labdata.back().plot_data.lin_interp.push_back(LinInterp());
						labdata.back().plot_data.lin_interp.back().m_a0 = lin_interp_y_a0_in_01_02_interval.v;
						labdata.back().plot_data.lin_interp.back().m_a1 = lin_interp_y_a1_in_01_02_interval.v;
						labdata.back().plot_data.lin_interp.back().xmin = def_module_01_02_pressure_interval[0];
						labdata.back().plot_data.lin_interp.back().xmax = def_module_01_02_pressure_interval[1];

						labdata.back().plot_data.lin_interp.push_back(LinInterp());
						labdata.back().plot_data.lin_interp.back().m_a0 = lin_interp_y_a0_in_defined_interval.v;
						labdata.back().plot_data.lin_interp.back().m_a1 = lin_interp_y_a1_in_defined_interval.v;
						labdata.back().plot_data.lin_interp.back().xmin = def_module_defined_pressure_interval[0];
						labdata.back().plot_data.lin_interp.back().xmax = def_module_defined_pressure_interval[1];
						labdata.back().plot_data.lin_interp.back().line_color = RGB(0,0,200);

		//					labdata.back().plot_data.use_log_interp = true;
		//					labdata.back().plot_data.log_interp_a0 = comp_rezults->log_interp_a0.v;
		//					labdata.back().plot_data.log_interp_a1 = comp_rezults->log_interp_a1.v;


					}
					labdata.push_back(LabData());
					PrintfPropY(this, labdata.back().text);
				}

#endif	
				if (com_lab_params->parameters_results2_every && com_lab_params->parameters_results2_every->GetCheckedLabParam())
				{
					labdata.push_back(LabData());

					double max_x_to_set = 0.0;
					
					//PhysicalLabTrial * phys =  dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical));
					PhysicalLabTrial * phys = dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical, comp_lab_trial->id_phys_vyprob));
					if (!phys)
						phys = dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
					if (phys)
					{
						PhysicalLabTrialResults * phys_res =  dynamic_cast<PhysicalLabTrialResults *>(phys->results);
						if (phys_res)
						{
							if (!phys_res->calculed)
								phys_res->CalcProperties();

							double e0 = phys_res->e.v;
							
							CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
							if(compression)
							{
								if (!calculed)
									CalcProperties();
								// plot
								labdata.back().plot_data.use_plot = true;
								labdata.back().plot_data.y_dir = +1;
								labdata.back().plot_data.title = "Компрессионная кривая";
								labdata.back().plot_data.xlabel = "Давления, МПа";
								labdata.back().plot_data.ylabel = "Коэф.порист. e, д.е.";
								labdata.back().plot_data.zero_min_y = false;
								labdata.back().plot_data.plot_lines.push_back(plot_line());
								// массив
								double x = 0, y, e=e0;								
#if 1
								for (size_t i = 0; i < vx.size(); i++)
								{
									x = vx[i].x;
									y = vy[i].v;
									e = ve[i].v;
									labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, e));
									max_x_to_set = x;	
								}
#else
								labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, e));
								for (int i = 0; i < comp_lab_trial->n_pressures; i++)
								{
#if USE_LAB_LAYER_PRESSURES
									switch(com_type)				
									{
									case CompressionLabTrial::type::nature_condition:
										{
											x = compression->pressures_in_nature_condition[i];
											if (i > 0 && compression->pressures_in_nature_condition[i-1] == compression->pressures_in_nature_condition[i])
											{
												zamachivanie = true;
											}
										}
										break;
									case CompressionLabTrial::type::task_condition:
										{
											x = compression->pressures_in_task_condition[i];
										}
										break;
									case CompressionLabTrial::type::shrinkage:
										{
											x = compression->pressures_on_shrinkage[i];
										}
										break;
									}
#else
									x = comp_lab_trial->pressures[i];
									if (com_type == CompressionLabTrial::type::nature_condition)			
									{
										if (i > 0 && comp_lab_trial->pressures[i-1] == comp_lab_trial->pressures[i])
										{
											zamachivanie = true;
										}
									}

#endif

#if USE_LAB_LAYER_HOOP
									y = comp_lab_trial->absolute_deformations[i].v / compression->hoop_height;
#else
									y = comp_lab_trial->absolute_deformations[i].v / comp_lab_trial->hoop_height;
#endif
									e = e0 - (1.0 + e0) * y;
									labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, e));
									max_x_to_set = x;
								}
#endif


								labdata.back().plot_data.lin_interp.push_back(LinInterp());
								labdata.back().plot_data.lin_interp.back().m_a0 = lin_interp_e_a0_in_01_02_interval.v;
								labdata.back().plot_data.lin_interp.back().m_a1 = lin_interp_e_a1_in_01_02_interval.v;
								labdata.back().plot_data.lin_interp.back().xmin = def_module_01_02_pressure_interval[0];
								labdata.back().plot_data.lin_interp.back().xmax = def_module_01_02_pressure_interval[1];

								labdata.back().plot_data.lin_interp.push_back(LinInterp());
								labdata.back().plot_data.lin_interp.back().m_a0 = lin_interp_e_a0_in_defined_interval.v;
								labdata.back().plot_data.lin_interp.back().m_a1 = lin_interp_e_a1_in_defined_interval.v;
								labdata.back().plot_data.lin_interp.back().xmin = def_module_defined_pressure_interval[0];
								labdata.back().plot_data.lin_interp.back().xmax = def_module_defined_pressure_interval[1];
								labdata.back().plot_data.lin_interp.back().line_color = RGB(0,0,200);
								labdata.back().plot_data.lin_interp.back().line_width = 0;

								labdata.back().plot_data.lin_vertical.push_back(LinVertical());
								labdata.back().plot_data.lin_vertical.back().m_x = ocenka_bytovogo_davlenia.v;
								labdata.back().plot_data.lin_vertical.back().line_color = RGB(0,200,0);
								labdata.back().plot_data.lin_vertical.back().line_style = PS_DOT;

#if 0
								labdata.back().plot_data.log_interp.push_back(LogInterp());
								labdata.back().plot_data.log_interp.back().m_C = -C.v;
								labdata.back().plot_data.log_interp.back().m_A = minus_A.v;
								labdata.back().plot_data.log_interp.back().m_x0 = - sigma_0.v;
								//labdata.back().plot_data.log_interp.back().xmin = def_module_defined_pressure_interval[0];
								//labdata.back().plot_data.log_interp.back().xmax = def_module_defined_pressure_interval[1];
								labdata.back().plot_data.log_interp.back().line_color = RGB(0,0,200);
								labdata.back().plot_data.log_interp.back().line_width = 3;
#endif

								for (vector<CompressionLogInterpolation>::iterator it = this->v_e_log_interp.begin();
									it != this->v_e_log_interp.end(); it++)
								{
									if ((*it).is_log)
									{
										labdata.back().plot_data.log_interp.push_back(LogInterp());
										labdata.back().plot_data.log_interp.back().m_C = (*it).m_C.v;
										labdata.back().plot_data.log_interp.back().m_A = -(*it).minus_A.v;
										labdata.back().plot_data.log_interp.back().m_x0 = (*it).x_0;
										labdata.back().plot_data.log_interp.back().xmin = (*it).p1;
										labdata.back().plot_data.log_interp.back().xmax = (*it).p2;
										labdata.back().plot_data.log_interp.back().line_color = RGB(0,0,200);
										labdata.back().plot_data.log_interp.back().line_width = 3;	
									}
								}
							}
							if(compression)
							{
								labdata.push_back(LabData());
								// plot
								labdata.back().plot_data.use_plot = true;
								labdata.back().plot_data.y_dir = +1;
								labdata.back().plot_data.title = "Коэффициент уплотнения";
								labdata.back().plot_data.xlabel = "Давления, МПа";
								labdata.back().plot_data.ylabel = "Коэф.уплот. a, МПа-1";
								labdata.back().plot_data.zero_min_y = false;
								labdata.back().plot_data.plot_lines.push_back(plot_line());
								// массив
								double x = 0, y, e=e0, a;								
								for (size_t i = 0; i < vx.size(); i++)
								{
									a = (e - ve[i].v)/(vx[i].x - x);

									x = vx[i].x;
									y = vy[i].v;
									e = ve[i].v;

									if (i)
										labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, a));
									max_x_to_set = x;	
								}

								for (vector<CompressionLogInterpolation>::iterator it = this->v_e_log_interp.begin();
									it != this->v_e_log_interp.end(); it++)
								{
									if ((*it).is_log)
									{
										labdata.back().plot_data.hyp_interp.push_back(HypInterp());
										labdata.back().plot_data.hyp_interp.back().m_A = -(*it).minus_A.v;
										labdata.back().plot_data.hyp_interp.back().m_x0 = (*it).x_0;
										labdata.back().plot_data.hyp_interp.back().xmin = (*it).p1;
										labdata.back().plot_data.hyp_interp.back().xmax = (*it).p2;
										labdata.back().plot_data.hyp_interp.back().line_color = RGB(0,0,200);
										labdata.back().plot_data.hyp_interp.back().line_width = 3;	

										labdata.back().plot_data.additional_y_for_scale.push_back( - (*it).minus_A.v / ((*it).p1 + (*it).x_0) );
										labdata.back().plot_data.additional_y_for_scale.push_back( - (*it).minus_A.v / ((*it).p2 + (*it).x_0) );


									}
								}
							}

#if 0
							labdata.push_back(LabData());
							if (1)
							{
								// plot
								labdata.back().plot_data.use_plot = true;
								labdata.back().plot_data.y_dir = +1;
								labdata.back().plot_data.title = "Обращённая производная компрессионной кривой";
								labdata.back().plot_data.xlabel = "Давления, МПа";
								labdata.back().plot_data.ylabel = "-DxDe";
								labdata.back().plot_data.zero_min_y = false;
								labdata.back().plot_data.plot_lines.push_back(plot_line());

								labdata.back().plot_data.set_max_x = true;
								labdata.back().plot_data.max_x_to_set = max_x_to_set;
								// массив

								for (size_t i = 0; i < meanX.size(); i++)
								{
									labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(meanX[i], minusDxDe[i].v));
								}
							}
#endif
							labdata.push_back(LabData());
							if (1)
							{
								// plot
								labdata.back().plot_data.use_plot = true;
								labdata.back().plot_data.y_dir = +1;
								labdata.back().plot_data.title = "Вторая производная компрессионной кривой";
								labdata.back().plot_data.xlabel = "Давления, МПа";
								labdata.back().plot_data.ylabel = "D2eDx2";
								labdata.back().plot_data.zero_min_y = false;
								labdata.back().plot_data.plot_lines.push_back(plot_line());

								labdata.back().plot_data.set_max_x = true;
								labdata.back().plot_data.max_x_to_set = max_x_to_set;
								// массив

								for (size_t i = 0; i < m2X.size(); i++)
								{
									labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(m2X[i], D2eDx2[i].v));
								}
							}
							labdata.push_back(LabData());
							PrintfPropE(this, labdata.back().text);
						}
					}
				}

				if (com_lab_params->parameters_results3_every && com_lab_params->parameters_results3_every->GetCheckedLabParam())
				{
					labdata.push_back(LabData());

					if (this->m_gurvich.PrintShtampDeformationPrediction(compression, &labdata.back().text, &labdata))
					{
					}

				}
			}
		}
	}
}

void CompressionLabTrialResults3::PrintfProperties(vector<LabData> & labdata)
{

	if (this->p_result_1) this->p_result_1->zamachivanie = false;

	LabNumber * labnumber = this->lab_trial ? (LabNumber *)this->lab_trial->GetLabNumber() : NULL;
	if (labnumber)
	{
		LabLayer * lablayer = (LabLayer *) labnumber->GetLabLayer();
		CompressionLabTrial3 * comp_lab_trial = dynamic_cast<CompressionLabTrial3 *>(this->lab_trial);
		if (lablayer && comp_lab_trial)
		{		
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
			LabParameters * lab_params = lablayer->FindLabParameters(comp_lab_trial->trial_indication);
			CompressionLabParameters3 * com_lab_params = dynamic_cast<CompressionLabParameters3 *>(lab_params);
			
			if(compression && com_lab_params && com_lab_params->GetCheckedLabParam())
			{
				if (com_lab_params->GetInitialCheckedLabParam())
				{
					labdata.push_back(LabData());
					{
						// plot
						labdata.back().plot_data.use_plot = true;
						labdata.back().plot_data.y_dir = -1;
						labdata.back().plot_data.title = "Компрессия - зависимость абсолютной деформации от нагрузки";
						labdata.back().plot_data.xlabel = "Давления, МПа";
						labdata.back().plot_data.ylabel = "Абс.Деф., мм";

						labdata.back().plot_data.x_ax_not_dubl = true;

						if (com_lab_params->params_nature.GetCheckedLabParam() 
							&& com_lab_params->params_nature.parameters_initial
							&& com_lab_params->params_nature.parameters_initial->GetCheckedLabParam()
							&& comp_lab_trial->p_trial_1)
						{
							// массив
							double x1,y1;
							labdata.back().plot_data.plot_lines.push_back(plot_line());
							labdata.back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
							for (int i = 0; i < comp_lab_trial->p_trial_1->n_pressures; i++)
							{
#if USE_LAB_LAYER_PRESSURES
								x1 = compression->pressures_in_nature_condition[i];
								if (i > 0 && compression->pressures_in_nature_condition[i-1] == compression->pressures_in_nature_condition[i])
								{
									if (this->p_result_1) this->p_result_1->zamachivanie = true;
								}
#else
								x1 = comp_lab_trial->p_trial_1->pressures[i];
								if (i > 0 && comp_lab_trial->p_trial_1->pressures[i-1] == comp_lab_trial->p_trial_1->pressures[i])
								{
									if (this->p_result_1) this->p_result_1->zamachivanie = true;
								}
#endif

								y1 = comp_lab_trial->p_trial_1->absolute_deformations[i].v;
								labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x1, y1));
							}
						}

						if (com_lab_params->params_task.GetCheckedLabParam() 
							&& com_lab_params->params_task.parameters_initial
							&& com_lab_params->params_task.parameters_initial->GetCheckedLabParam()
							&& comp_lab_trial->p_trial_2)
						{
							double x2,y2;
							labdata.back().plot_data.plot_lines.push_back(plot_line());
							for (int i = 0; i < comp_lab_trial->p_trial_2->n_pressures; i++)
							{
#if USE_LAB_LAYER_PRESSURES
								x2 = compression->pressures_in_task_condition[i];	
#else
								x2 = comp_lab_trial->p_trial_2->pressures[i];	
#endif
								y2 = comp_lab_trial->p_trial_2->absolute_deformations[i].v;
								labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x2, y2));
							}
						}

						if (com_lab_params->params_shrinkage.GetCheckedLabParam() 
							&& com_lab_params->params_shrinkage.parameters_initial
							&& com_lab_params->params_shrinkage.parameters_initial->GetCheckedLabParam()
							&& comp_lab_trial->p_trial_3)
						{
							double x3,y3;
							labdata.back().plot_data.plot_lines.push_back(plot_line());
							for (int i = 0; i < comp_lab_trial->p_trial_3->n_pressures; i++)
							{
#if USE_LAB_LAYER_PRESSURES
								x3 = compression->pressures_on_shrinkage[i];
#else
								x3 = comp_lab_trial->p_trial_3->pressures[i];
#endif
								y3 = comp_lab_trial->p_trial_3->absolute_deformations[i].v;
								labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x3, y3));
							}
						}
					}
				}

				if (com_lab_params->GetResultsCheckedLabParam())
				{	
					if (com_lab_params->params_nature.GetCheckedLabParam() 
						&& com_lab_params->params_nature.parameters_results
						&& com_lab_params->params_nature.parameters_results->GetCheckedLabParam()
						)
					{
						if (this->p_result_1 && this->p_result_1->calculed)
						{
							labdata.push_back(LabData());
							labdata.back().text.push_back(fmtstr("В природном состоянии", NULL, true, false));
							PrintfProp1(this->p_result_1, labdata.back().text);
						}
					}

					if (com_lab_params->params_task.GetCheckedLabParam() 
						&& com_lab_params->params_task.parameters_results
						&& com_lab_params->params_task.parameters_results->GetCheckedLabParam()
						)
					{
						if (this->p_result_2 && this->p_result_2->calculed)
						{
							labdata.push_back(LabData());
							labdata.back().text.push_back(fmtstr("В заданном состоянии", NULL, true, false));
							PrintfProp1(this->p_result_2, labdata.back().text);
						}
					}

					if (com_lab_params->params_shrinkage.GetCheckedLabParam() 
						&& com_lab_params->params_shrinkage.parameters_results
						&& com_lab_params->params_shrinkage.parameters_results->GetCheckedLabParam()
						)
					{
						if (this->p_result_3 && this->p_result_3->calculed)
						{
							labdata.push_back(LabData());
							labdata.back().text.push_back(fmtstr("На усадку", NULL, true, false));
							PrintfProp1(this->p_result_3, labdata.back().text);
						}
					}
				}
#if USE_COMPR_PO_OTN_DEF
				if (com_lab_params->GetResult1EveryCheckedLabParam())
				{					
					labdata.push_back(LabData());
					if (1)
					{
						// plot
						labdata.back().plot_data.use_plot = true;
						labdata.back().plot_data.y_dir = -1;
						labdata.back().plot_data.title = "Компрессия - зависимость относительной деформации от нагрузки";
						labdata.back().plot_data.xlabel = "Давления, МПа";
						labdata.back().plot_data.ylabel = "Отн.Деф.";
						labdata.back().plot_data.x_ax_not_dubl = true;

						double x,y;
						if (com_lab_params->params_nature.GetCheckedLabParam() 
							&& com_lab_params->params_nature.parameters_results1_every
							&& com_lab_params->params_nature.parameters_results1_every->GetCheckedLabParam()
							&& comp_lab_trial->p_trial_1)
						{
							// массив
							int n_press_1 = comp_lab_trial->p_trial_1->n_pressures;
							if (n_press_1)
							{
								labdata.back().plot_data.plot_lines.push_back(plot_line());
								labdata.back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
								for (int i = 0; i < n_press_1; i++)
								{
#if USE_LAB_LAYER_PRESSURES
									x = compression->pressures_in_nature_condition[i];
									if (i > 0 && compression->pressures_in_nature_condition[i-1] == compression->pressures_in_nature_condition[i])
									{
										if (this->p_result_1) this->p_result_1->zamachivanie = true;
									}
#else
									x = comp_lab_trial->p_trial_1->pressures[i];
									if (i > 0 && comp_lab_trial->p_trial_1->pressures[i-1] == comp_lab_trial->p_trial_1->pressures[i])
									{
										if (this->p_result_1) this->p_result_1->zamachivanie = true;
									}
#endif

#if USE_LAB_LAYER_HOOP
									y = comp_lab_trial->p_trial_1->absolute_deformations[i].v / compression->hoop_height;
#else
									y = comp_lab_trial->p_trial_1->absolute_deformations[i].v / comp_lab_trial->p_trial_1->hoop_height;
#endif
									labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
								}
							}
						}


						if (com_lab_params->params_task.GetCheckedLabParam() 
							&& com_lab_params->params_task.parameters_results1_every
							&& com_lab_params->params_task.parameters_results1_every->GetCheckedLabParam()
							&& comp_lab_trial->p_trial_2)
						{
							int n_press_2 = comp_lab_trial->p_trial_2->n_pressures;
							if (n_press_2)
							{
								labdata.back().plot_data.plot_lines.push_back(plot_line());
								labdata.back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
								for (int i = 0; i < n_press_2; i++)
								{
#if USE_LAB_LAYER_PRESSURES
									x = compression->pressures_in_task_condition[i];
#else
									x = comp_lab_trial->p_trial_2->pressures[i];
#endif
#if USE_LAB_LAYER_HOOP
									y = comp_lab_trial->p_trial_2->absolute_deformations[i].v / compression->hoop_height;
#else
									y = comp_lab_trial->p_trial_2->absolute_deformations[i].v / comp_lab_trial->p_trial_2->hoop_height;
#endif
									labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
								}
							}
						}


						if (com_lab_params->params_shrinkage.GetCheckedLabParam() 
							&& com_lab_params->params_shrinkage.parameters_results1_every
							&& com_lab_params->params_shrinkage.parameters_results1_every->GetCheckedLabParam()
							&& comp_lab_trial->p_trial_3)
						{
							int n_press_3 = comp_lab_trial->p_trial_3->n_pressures;
							if (n_press_3)
							{
								labdata.back().plot_data.plot_lines.push_back(plot_line());
								for (int i = 0; i < n_press_3; i++)
								{
#if USE_LAB_LAYER_PRESSURES
									x = compression->pressures_on_shrinkage[i];
#else
									x = comp_lab_trial->p_trial_3->pressures[i];
#endif

#if USE_LAB_LAYER_HOOP
									y = comp_lab_trial->p_trial_3->absolute_deformations[i].v / compression->hoop_height;
#else
									y = comp_lab_trial->p_trial_3->absolute_deformations[i].v / comp_lab_trial->p_trial_3->hoop_height;
#endif
									labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
								}
							}
						}


						if (!calculed)
							CalcProperties();

						if (com_lab_params->params_nature.GetCheckedLabParam() 
							&& com_lab_params->params_nature.parameters_results1_every
							&& com_lab_params->params_nature.parameters_results1_every->GetCheckedLabParam()
							)
						{
							if (this->p_result_1 && this->p_result_1->lin_interp_y_a0_in_01_02_interval.f && this->p_result_1->lin_interp_y_a0_in_defined_interval.f)
							{
								labdata.back().plot_data.lin_interp.push_back(LinInterp());
								labdata.back().plot_data.lin_interp.back().m_a0 = this->p_result_1->lin_interp_y_a0_in_01_02_interval.v;
								labdata.back().plot_data.lin_interp.back().m_a1 = this->p_result_1->lin_interp_y_a1_in_01_02_interval.v;
								labdata.back().plot_data.lin_interp.back().xmin = this->p_result_1->def_module_01_02_pressure_interval[0];
								labdata.back().plot_data.lin_interp.back().xmax = this->p_result_1->def_module_01_02_pressure_interval[1];

								labdata.back().plot_data.lin_interp.push_back(LinInterp());
								labdata.back().plot_data.lin_interp.back().m_a0 = this->p_result_1->lin_interp_y_a0_in_defined_interval.v;
								labdata.back().plot_data.lin_interp.back().m_a1 = this->p_result_1->lin_interp_y_a1_in_defined_interval.v;
								labdata.back().plot_data.lin_interp.back().xmin = this->p_result_1->def_module_defined_pressure_interval[0];
								labdata.back().plot_data.lin_interp.back().xmax = this->p_result_1->def_module_defined_pressure_interval[1];
								labdata.back().plot_data.lin_interp.back().line_color = RGB(0,0,200);
							}

						}
						if (com_lab_params->params_task.GetCheckedLabParam() 
							&& com_lab_params->params_task.parameters_results1_every
							&& com_lab_params->params_task.parameters_results1_every->GetCheckedLabParam()
							)
						{
							if (this->p_result_2 && this->p_result_2->lin_interp_y_a0_in_01_02_interval.f && this->p_result_2->lin_interp_y_a0_in_defined_interval.f)
							{
								labdata.back().plot_data.lin_interp.push_back(LinInterp());
								labdata.back().plot_data.lin_interp.back().m_a0 = this->p_result_2->lin_interp_y_a0_in_01_02_interval.v;
								labdata.back().plot_data.lin_interp.back().m_a1 = this->p_result_2->lin_interp_y_a1_in_01_02_interval.v;
								labdata.back().plot_data.lin_interp.back().xmin = this->p_result_2->def_module_01_02_pressure_interval[0];
								labdata.back().plot_data.lin_interp.back().xmax = this->p_result_2->def_module_01_02_pressure_interval[1];

								labdata.back().plot_data.lin_interp.push_back(LinInterp());
								labdata.back().plot_data.lin_interp.back().m_a0 = this->p_result_2->lin_interp_y_a0_in_defined_interval.v;
								labdata.back().plot_data.lin_interp.back().m_a1 = this->p_result_2->lin_interp_y_a1_in_defined_interval.v;
								labdata.back().plot_data.lin_interp.back().xmin = this->p_result_2->def_module_defined_pressure_interval[0];
								labdata.back().plot_data.lin_interp.back().xmax = this->p_result_2->def_module_defined_pressure_interval[1];
								labdata.back().plot_data.lin_interp.back().line_color = RGB(0,0,200);
							}
						}

						if (com_lab_params->params_shrinkage.GetCheckedLabParam() 
							&& com_lab_params->params_shrinkage.parameters_results1_every
							&& com_lab_params->params_shrinkage.parameters_results1_every->GetCheckedLabParam()
							)
						{
							if (this->p_result_3 && this->p_result_3->lin_interp_y_a0_in_01_02_interval.f && this->p_result_3->lin_interp_y_a0_in_defined_interval.f)
							{
								labdata.back().plot_data.lin_interp.push_back(LinInterp());
								labdata.back().plot_data.lin_interp.back().m_a0 = this->p_result_3->lin_interp_y_a0_in_01_02_interval.v;
								labdata.back().plot_data.lin_interp.back().m_a1 = this->p_result_3->lin_interp_y_a1_in_01_02_interval.v;
								labdata.back().plot_data.lin_interp.back().xmin = this->p_result_3->def_module_01_02_pressure_interval[0];
								labdata.back().plot_data.lin_interp.back().xmax = this->p_result_3->def_module_01_02_pressure_interval[1];

								labdata.back().plot_data.lin_interp.push_back(LinInterp());
								labdata.back().plot_data.lin_interp.back().m_a0 = this->p_result_3->lin_interp_y_a0_in_defined_interval.v;
								labdata.back().plot_data.lin_interp.back().m_a1 = this->p_result_3->lin_interp_y_a1_in_defined_interval.v;
								labdata.back().plot_data.lin_interp.back().xmin = this->p_result_3->def_module_defined_pressure_interval[0];
								labdata.back().plot_data.lin_interp.back().xmax = this->p_result_3->def_module_defined_pressure_interval[1];
								labdata.back().plot_data.lin_interp.back().line_color = RGB(0,0,200);
							}
						}

					}



#if USE_COMPR_PO_OTN_DEF

					if (com_lab_params->params_nature.GetCheckedLabParam() 
						&& com_lab_params->params_nature.parameters_results1_every
						&& com_lab_params->params_nature.parameters_results1_every->GetCheckedLabParam()
						)
					{
						if (this->p_result_1 && this->p_result_1->calculed)
						{
							labdata.push_back(LabData());
							labdata.back().text.push_back(fmtstr("В природном состоянии", NULL, true, false));
							PrintfPropY(this->p_result_1, labdata.back().text);
						}
					}
#endif
					if (com_lab_params->params_task.GetCheckedLabParam() 
						&& com_lab_params->params_task.parameters_results1_every
						&& com_lab_params->params_task.parameters_results1_every->GetCheckedLabParam()
						)
					{	
						if (this->p_result_2 && this->p_result_2->calculed)
						{
							labdata.push_back(LabData());
							labdata.back().text.push_back(fmtstr("В заданном состоянии", NULL, true, false));
							PrintfPropY(this->p_result_2, labdata.back().text);
						}
					}

					if (com_lab_params->params_shrinkage.GetCheckedLabParam() 
						&& com_lab_params->params_shrinkage.parameters_results1_every
						&& com_lab_params->params_shrinkage.parameters_results1_every->GetCheckedLabParam()
						)
					{
						if (this->p_result_3 && this->p_result_3->calculed)
						{
							labdata.push_back(LabData());
							labdata.back().text.push_back(fmtstr("На усадку", NULL, true, false));
							PrintfPropY(this->p_result_3, labdata.back().text);
						}
					}
				}

				if (com_lab_params->GetResult1EveryCheckedLabParam())
				{					
					char str[4098];
					char sv[128];

					labdata.push_back(LabData());
					if (prosadka_calculed_po_dvum_krivym)
					{
						// plot
						labdata.back().plot_data.use_plot = true;
						labdata.back().plot_data.y_dir = -1;
						labdata.back().plot_data.title = "Компрессия - зависимость относительного сжатия от нагрузки";
						labdata.back().plot_data.xlabel = "Давления, МПа";
						labdata.back().plot_data.ylabel = "Отн.Сжат.";
						labdata.back().plot_data.x_ax_not_dubl = true;

						double x,y;
						if (com_lab_params->params_nature.GetCheckedLabParam() 
							&& com_lab_params->params_nature.parameters_results1_every
							&& com_lab_params->params_nature.parameters_results1_every->GetCheckedLabParam()
							&& comp_lab_trial->p_trial_1)
						{
							// массив
							int n_press_1 = comp_lab_trial->p_trial_1->n_pressures;
							if (n_press_1)
							{
								labdata.back().plot_data.plot_lines.push_back(plot_line());
								labdata.back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
								labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(0.0, 0.0));
								for (int i = 0; i < n_press_1; i++)
								{
#if USE_LAB_LAYER_PRESSURES
									x = compression->pressures_in_nature_condition[i];
									if (i > 0 && compression->pressures_in_nature_condition[i-1] == compression->pressures_in_nature_condition[i])
									{
										if (this->p_result_1) this->p_result_1->zamachivanie = true;
									}
#else
									x = comp_lab_trial->p_trial_1->pressures[i];
									if (i > 0 && comp_lab_trial->p_trial_1->pressures[i-1] == comp_lab_trial->p_trial_1->pressures[i])
									{
										if (this->p_result_1) this->p_result_1->zamachivanie = true;
									}
#endif
									y = comp_lab_trial->p_trial_1->absolute_deformations[i].v / this->h0.v;
									labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
								}
							}
						}


						if (com_lab_params->params_task.GetCheckedLabParam() 
							&& com_lab_params->params_task.parameters_results1_every
							&& com_lab_params->params_task.parameters_results1_every->GetCheckedLabParam()
							&& comp_lab_trial->p_trial_2)
						{
							int n_press_2 = comp_lab_trial->p_trial_2->n_pressures;
							if (n_press_2)
							{
								labdata.back().plot_data.plot_lines.push_back(plot_line());
								labdata.back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
								labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(0.0, 0.0));
								for (int i = 0; i < n_press_2; i++)
								{
#if USE_LAB_LAYER_PRESSURES
									x = compression->pressures_in_task_condition[i];
#else
									x = comp_lab_trial->p_trial_2->pressures[i];
#endif
									y = comp_lab_trial->p_trial_2->absolute_deformations[i].v / this->h0.v;
									labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
								}
							}
						}


						if (com_lab_params->params_shrinkage.GetCheckedLabParam() 
							&& com_lab_params->params_shrinkage.parameters_results1_every
							&& com_lab_params->params_shrinkage.parameters_results1_every->GetCheckedLabParam()
							&& comp_lab_trial->p_trial_3)
						{
							int n_press_3 = comp_lab_trial->p_trial_3->n_pressures;
							if (n_press_3)
							{
								labdata.back().plot_data.plot_lines.push_back(plot_line());
								for (int i = 0; i < n_press_3; i++)
								{
#if USE_LAB_LAYER_PRESSURES
									x = compression->pressures_on_shrinkage[i];
#else
									x = comp_lab_trial->p_trial_3->pressures[i];
#endif
									y = comp_lab_trial->p_trial_3->absolute_deformations[i].v / this->h0.v;
									labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
								}
							}
						}

						if (prosadka_calculed_po_dvum_krivym)
						{
							labdata.back().plot_data.plot_lines.push_back(plot_line());
							labdata.back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
							for (size_t i = 0; i < this->otnosit_prosadochnost_po_dvum_krivym.size(); i++)
							{
								x = this->x_prosadka_po_dvum_krivym[i];
								y = this->otnosit_prosadochnost_po_dvum_krivym[i].v;
								labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
							}

							if (this->p_result_1)
							{
								labdata.back().plot_data.lin_vertical.push_back(LinVertical());
								labdata.back().plot_data.lin_vertical.back().m_x = this->p_result_1->ocenka_bytovogo_davlenia.v;
								labdata.back().plot_data.lin_vertical.back().line_color = RGB(0,200,0);
								labdata.back().plot_data.lin_vertical.back().line_style = PS_DOT;
							}

							labdata.back().plot_data.lin_vertical.push_back(LinVertical());
							labdata.back().plot_data.lin_vertical.back().m_x = this->nachalnoe_prosadochnoe_davlenie_po_dvum_krivym.v;
							labdata.back().plot_data.lin_vertical.back().line_color = RGB(0,0,200);
							labdata.back().plot_data.lin_vertical.back().line_style = PS_DOT;
						}
						if(this->nachalnoe_prosadochnoe_davlenie_po_dvum_krivym.f)
						{
							labdata.push_back(LabData());
							sprintf(sv, "%f", this->nachalnoe_prosadochnoe_davlenie_po_dvum_krivym.v); DeleteEndZeros(sv);
							sprintf(str, "Начальное просадочное давление (по двум кривым) = %s МПа", sv);
							labdata.back().text.push_back(fmtstr(str, NULL, true, false));
						}
					}

					
					
					labdata.push_back(LabData());
					if (prosadka_calculed_po_odnoj_krivoj)
					{
						// plot
						labdata.back().plot_data.use_plot = true;
						labdata.back().plot_data.y_dir = -1;
						labdata.back().plot_data.title = "Компрессия - зависимость относительного сжатия от нагрузки";
						labdata.back().plot_data.xlabel = "Давления, МПа";
						labdata.back().plot_data.ylabel = "Отн.Сжат.";
						labdata.back().plot_data.x_ax_not_dubl = true;

						double x,y;
						if (com_lab_params->params_nature.GetCheckedLabParam() 
							&& com_lab_params->params_nature.parameters_results1_every
							&& com_lab_params->params_nature.parameters_results1_every->GetCheckedLabParam()
							&& comp_lab_trial->p_trial_1)
						{
							// массив
							int n_press_1 = comp_lab_trial->p_trial_1->n_pressures;
							if (n_press_1)
							{
								labdata.back().plot_data.plot_lines.push_back(plot_line());
								labdata.back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
								labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(0.0, 0.0));

								int i, i_zamach = 0;
								for (i = 0; i < n_press_1; i++)
								{

#if USE_LAB_LAYER_PRESSURES
									x = compression->pressures_in_nature_condition[i];
									if (i > 0 && compression->pressures_in_nature_condition[i-1] == compression->pressures_in_nature_condition[i])
									{
										if (this->p_result_1) this->p_result_1->zamachivanie = true;
										i_zamach = i;
									}
#else
									x = comp_lab_trial->p_trial_1->pressures[i];
									if (i > 0 && comp_lab_trial->p_trial_1->pressures[i-1] == comp_lab_trial->p_trial_1->pressures[i])
									{
										if (this->p_result_1) this->p_result_1->zamachivanie = true;
										i_zamach = i;
									}
#endif
									y = comp_lab_trial->p_trial_1->absolute_deformations[i].v / this->h0.v;
									labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
								}

								i = i_zamach;

								labdata.back().plot_data.plot_lines.push_back(plot_line());
								labdata.back().plot_data.plot_lines.back().prec = plot_line::label_precision::no;
								labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(0.0, 0.0));
#if USE_LAB_LAYER_PRESSURES
								x = compression->pressures_in_nature_condition[i];
#else
								x = comp_lab_trial->p_trial_1->pressures[i];
#endif
								y = comp_lab_trial->p_trial_1->absolute_deformations[i].v / this->h0.v;
								labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));

								labdata.back().plot_data.plot_lines.back().line_color = RGB(200,0,0);
								labdata.back().plot_data.plot_lines.back().line_style = PS_DOT;
							}
						}



						if (prosadka_calculed_po_odnoj_krivoj)
						{
							labdata.back().plot_data.plot_lines.push_back(plot_line());
							labdata.back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
							for (size_t i = 0; i < this->otnosit_prosadochnost_po_odnoj_krivoj.size(); i++)
							{
								x = this->x_prosadka_po_odnoj_krivoj[i];
								y = this->otnosit_prosadochnost_po_odnoj_krivoj[i].v;
								labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
							}

							if (this->p_result_1)
							{
								labdata.back().plot_data.lin_vertical.push_back(LinVertical());
								labdata.back().plot_data.lin_vertical.back().m_x = this->p_result_1->ocenka_bytovogo_davlenia.v;
								labdata.back().plot_data.lin_vertical.back().line_color = RGB(0,200,0);
								labdata.back().plot_data.lin_vertical.back().line_style = PS_DOT;
							}

							labdata.back().plot_data.lin_vertical.push_back(LinVertical());
							labdata.back().plot_data.lin_vertical.back().m_x = this->nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj.v;
							labdata.back().plot_data.lin_vertical.back().line_color = RGB(0,0,200);
							labdata.back().plot_data.lin_vertical.back().line_style = PS_DOT;
						}
						if(this->nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj.f)
						{
							labdata.push_back(LabData());
							sprintf(sv, "%f", this->nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj.v); DeleteEndZeros(sv);
							sprintf(str, "Начальное просадочное давление (по одной кривой) = %s МПа", sv);
							labdata.back().text.push_back(fmtstr(str, NULL, true, false));
						}
					}


					labdata.push_back(LabData());
					labdata.back().text.push_back(fmtstr("высота образца грунта при природной влажности", NULL, true, false));
					labdata.back().text.push_back(fmtstr("и природном давлении (на глубине отбора образца)", NULL, true, false));
					

					sprintf(sv, "%f", h0.v); DeleteEndZeros(sv);
					sprintf(str, "h0 = %s мм", sv);
					labdata.back().text.push_back(fmtstr(str, NULL, true, false));



					if(this->svobodnoe_otnositelnoe_nabuhanie.f)
					{
						labdata.push_back(LabData());
						sprintf(sv, "%f", this->svobodnoe_otnositelnoe_nabuhanie.v); DeleteEndZeros(sv);
						sprintf(str, "Свободное относительное набухание = %s д.е.", sv);
						labdata.back().text.push_back(fmtstr(str, NULL, true, false));
					}

					if(this->davlenie_nabuhania.f)
					{
						labdata.push_back(LabData());
						sprintf(sv, "%f", this->davlenie_nabuhania.v); DeleteEndZeros(sv);
						sprintf(str, "Давление набухания = %s МПа", sv);
						labdata.back().text.push_back(fmtstr(str, NULL, true, false));
					}

					
					if (this->m_otzhatoj_vody.f)
					{
						labdata.push_back(LabData());
						sprintf(sv, "%f", this->m_otzhatoj_vody.v); DeleteEndZeros(sv);
						sprintf(str, "Масса отжатой из второго кольца воды = %s г", sv);
						labdata.back().text.push_back(fmtstr(str, NULL, true, false));						
					}
					if (this->dejstvit_polnaja_osadka.f)
					{
						labdata.push_back(LabData());
						sprintf(sv, "%f", this->dejstvit_polnaja_osadka.v); DeleteEndZeros(sv);
						sprintf(str, "Действительная полная осадка = %s мм", sv);
						labdata.back().text.push_back(fmtstr(str, NULL, true, false));
					}
					if (this->popravochnyj_koefficient_alpha.f)
					{
						labdata.push_back(LabData());
						sprintf(sv, "%f", this->popravochnyj_koefficient_alpha.v); DeleteEndZeros(sv);
						sprintf(str, "Поправочный коэффициент альфа = %s", sv);
						labdata.back().text.push_back(fmtstr(str, NULL, true, false));								
					}

				}

#endif
				if (com_lab_params->GetResult2EveryCheckedLabParam())
				{
					labdata.push_back(LabData());

					double max_x_to_set = 0.0;
					
					//PhysicalLabTrial * phys = dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical));
					PhysicalLabTrial * phys1 = dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical, comp_lab_trial->p_trial_1->id_phys_vyprob));
					if (!phys1)
						phys1 = dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
					PhysicalLabTrial * phys2 = dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical, comp_lab_trial->p_trial_2->id_phys_vyprob));
					if (!phys2)
						phys2 = dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
					PhysicalLabTrial * phys3 = dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical, comp_lab_trial->p_trial_3->id_phys_vyprob));
					if (!phys3)
						phys3 = dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
					if (phys1 && phys2 && phys3)
					{
						PhysicalLabTrialResults * phys_res1 =  dynamic_cast<PhysicalLabTrialResults *>(phys1->results);
						PhysicalLabTrialResults * phys_res2 =  dynamic_cast<PhysicalLabTrialResults *>(phys2->results);
						PhysicalLabTrialResults * phys_res3 =  dynamic_cast<PhysicalLabTrialResults *>(phys3->results);
						if (phys_res1 && phys_res2 && phys_res3)
						{
							if (!phys_res1->calculed)
								phys_res1->CalcProperties();

							if (!phys_res2->calculed)
								phys_res2->CalcProperties();

							if (!phys_res3->calculed)
								phys_res3->CalcProperties();

							double e0_1 = phys_res1->e.v;
							double e0_2 = phys_res2->e.v;
							double e0_3 = phys_res3->e.v;
							
							CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
							if(compression)
							{
								if (!calculed)
									CalcProperties();
								// plot
								labdata.back().plot_data.use_plot = true;
								labdata.back().plot_data.y_dir = +1;
								labdata.back().plot_data.title = "Компрессионная кривая";
								labdata.back().plot_data.xlabel = "Давления, МПа";
								labdata.back().plot_data.ylabel = "Коэф.порист. e, д.е.";
								labdata.back().plot_data.zero_min_y = false;
								labdata.back().plot_data.x_ax_not_dubl = true;

								// массив
								double x = 0, y, e//=e0
									;	

								if (com_lab_params->params_nature.GetCheckedLabParam() 
									&& com_lab_params->params_nature.parameters_results2_every
									&& com_lab_params->params_nature.parameters_results2_every->GetCheckedLabParam()
									)
								{
									if (this->p_result_1)
									{	
										int nx = this->p_result_1->vx.size();
										if (nx)
										{
											labdata.back().plot_data.plot_lines.push_back(plot_line());
											labdata.back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
											for (int i = 0; i < nx; i++)
											{
												x = this->p_result_1->vx[i].x;
												y = this->p_result_1->vy[i].v;
												e = this->p_result_1->ve[i].v;
												labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, e));
												if (max_x_to_set < x) max_x_to_set = x;	
											}
										}
									}
								}
								if (com_lab_params->params_task.GetCheckedLabParam() 
									&& com_lab_params->params_task.parameters_results2_every
									&& com_lab_params->params_task.parameters_results2_every->GetCheckedLabParam()
									)
								{
									if (this->p_result_2)
									{									
										int nx = this->p_result_2->vx.size();
										if (nx)
										{
											labdata.back().plot_data.plot_lines.push_back(plot_line());
											labdata.back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
											for (int i = 0; i < nx; i++)
											{
												x = this->p_result_2->vx[i].x;
												y = this->p_result_2->vy[i].v;
												e = this->p_result_2->ve[i].v;
												labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, e));
												if (max_x_to_set < x) max_x_to_set = x;	
											}
										}
									}
								}
								if (com_lab_params->params_shrinkage.GetCheckedLabParam() 
									&& com_lab_params->params_shrinkage.parameters_results2_every
									&& com_lab_params->params_shrinkage.parameters_results2_every->GetCheckedLabParam()
									)
								{
									if (this->p_result_3)
									{									
										int nx = this->p_result_3->vx.size();
										if (nx)
										{
											labdata.back().plot_data.plot_lines.push_back(plot_line());
											for (int i = 0; i < nx; i++)
											{
												x = this->p_result_3->vx[i].x;
												y = this->p_result_3->vy[i].v;
												e = this->p_result_3->ve[i].v;
												labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, e));
												if (max_x_to_set < x) max_x_to_set = x;	
											}
										}
									}
								}

								if (com_lab_params->params_nature.GetCheckedLabParam() 
									&& com_lab_params->params_nature.parameters_results2_every
									&& com_lab_params->params_nature.parameters_results2_every->GetCheckedLabParam()
									)
								{
									if (this->p_result_1 && this->p_result_1->lin_interp_e_a0_in_01_02_interval.f && this->p_result_1->lin_interp_e_a0_in_defined_interval.f)
									{
										labdata.back().plot_data.lin_interp.push_back(LinInterp());
										labdata.back().plot_data.lin_interp.back().m_a0 = this->p_result_1->lin_interp_e_a0_in_01_02_interval.v;
										labdata.back().plot_data.lin_interp.back().m_a1 = this->p_result_1->lin_interp_e_a1_in_01_02_interval.v;
										labdata.back().plot_data.lin_interp.back().xmin = this->p_result_1->def_module_01_02_pressure_interval[0];
										labdata.back().plot_data.lin_interp.back().xmax = this->p_result_1->def_module_01_02_pressure_interval[1];

										labdata.back().plot_data.lin_interp.push_back(LinInterp());
										labdata.back().plot_data.lin_interp.back().m_a0 = this->p_result_1->lin_interp_e_a0_in_defined_interval.v;
										labdata.back().plot_data.lin_interp.back().m_a1 = this->p_result_1->lin_interp_e_a1_in_defined_interval.v;
										labdata.back().plot_data.lin_interp.back().xmin = this->p_result_1->def_module_defined_pressure_interval[0];
										labdata.back().plot_data.lin_interp.back().xmax = this->p_result_1->def_module_defined_pressure_interval[1];
										labdata.back().plot_data.lin_interp.back().line_color = RGB(0,0,200);
										labdata.back().plot_data.lin_interp.back().line_width = 0;
									}
								}

								if (com_lab_params->params_task.GetCheckedLabParam() 
									&& com_lab_params->params_task.parameters_results2_every
									&& com_lab_params->params_task.parameters_results2_every->GetCheckedLabParam()
									)
								{
									if (this->p_result_2 && this->p_result_2->lin_interp_e_a0_in_01_02_interval.f && this->p_result_2->lin_interp_e_a0_in_defined_interval.f)
									{
										labdata.back().plot_data.lin_interp.push_back(LinInterp());
										labdata.back().plot_data.lin_interp.back().m_a0 = this->p_result_2->lin_interp_e_a0_in_01_02_interval.v;
										labdata.back().plot_data.lin_interp.back().m_a1 = this->p_result_2->lin_interp_e_a1_in_01_02_interval.v;
										labdata.back().plot_data.lin_interp.back().xmin = this->p_result_2->def_module_01_02_pressure_interval[0];
										labdata.back().plot_data.lin_interp.back().xmax = this->p_result_2->def_module_01_02_pressure_interval[1];

										labdata.back().plot_data.lin_interp.push_back(LinInterp());
										labdata.back().plot_data.lin_interp.back().m_a0 = this->p_result_2->lin_interp_e_a0_in_defined_interval.v;
										labdata.back().plot_data.lin_interp.back().m_a1 = this->p_result_2->lin_interp_e_a1_in_defined_interval.v;
										labdata.back().plot_data.lin_interp.back().xmin = this->p_result_2->def_module_defined_pressure_interval[0];
										labdata.back().plot_data.lin_interp.back().xmax = this->p_result_2->def_module_defined_pressure_interval[1];
										labdata.back().plot_data.lin_interp.back().line_color = RGB(0,0,200);
										labdata.back().plot_data.lin_interp.back().line_width = 0;
									}
								}

								if (com_lab_params->params_shrinkage.GetCheckedLabParam() 
									&& com_lab_params->params_shrinkage.parameters_results2_every
									&& com_lab_params->params_shrinkage.parameters_results2_every->GetCheckedLabParam()
									)
								{
									if (this->p_result_3 && this->p_result_3->lin_interp_e_a0_in_01_02_interval.f && this->p_result_3->lin_interp_e_a0_in_defined_interval.f)
									{
										labdata.back().plot_data.lin_interp.push_back(LinInterp());
										labdata.back().plot_data.lin_interp.back().m_a0 = this->p_result_3->lin_interp_e_a0_in_01_02_interval.v;
										labdata.back().plot_data.lin_interp.back().m_a1 = this->p_result_3->lin_interp_e_a1_in_01_02_interval.v;
										labdata.back().plot_data.lin_interp.back().xmin = this->p_result_3->def_module_01_02_pressure_interval[0];
										labdata.back().plot_data.lin_interp.back().xmax = this->p_result_3->def_module_01_02_pressure_interval[1];

										labdata.back().plot_data.lin_interp.push_back(LinInterp());
										labdata.back().plot_data.lin_interp.back().m_a0 = this->p_result_3->lin_interp_e_a0_in_defined_interval.v;
										labdata.back().plot_data.lin_interp.back().m_a1 = this->p_result_3->lin_interp_e_a1_in_defined_interval.v;
										labdata.back().plot_data.lin_interp.back().xmin = this->p_result_3->def_module_defined_pressure_interval[0];
										labdata.back().plot_data.lin_interp.back().xmax = this->p_result_3->def_module_defined_pressure_interval[1];
										labdata.back().plot_data.lin_interp.back().line_color = RGB(0,0,200);
										labdata.back().plot_data.lin_interp.back().line_width = 0;
									}
								}

								if (this->p_result_1 && this->p_result_1->ocenka_bytovogo_davlenia.f)
								{
									labdata.back().plot_data.lin_vertical.push_back(LinVertical());
									labdata.back().plot_data.lin_vertical.back().m_x = this->p_result_1->ocenka_bytovogo_davlenia.v;
									labdata.back().plot_data.lin_vertical.back().line_color = RGB(0,200,0);
									labdata.back().plot_data.lin_vertical.back().line_style = PS_DOT;
								}
								else
								{
									if (this->p_result_2 && this->p_result_2->ocenka_bytovogo_davlenia.f)
									{
										labdata.back().plot_data.lin_vertical.push_back(LinVertical());
										labdata.back().plot_data.lin_vertical.back().m_x = this->p_result_2->ocenka_bytovogo_davlenia.v;
										labdata.back().plot_data.lin_vertical.back().line_color = RGB(0,200,0);
										labdata.back().plot_data.lin_vertical.back().line_style = PS_DOT;
									}
								}

#if 0
								labdata.back().plot_data.log_interp.push_back(LogInterp());
								labdata.back().plot_data.log_interp.back().m_C = -C.v;
								labdata.back().plot_data.log_interp.back().m_A = minus_A.v;
								labdata.back().plot_data.log_interp.back().m_x0 = - sigma_0.v;
								//labdata.back().plot_data.log_interp.back().xmin = def_module_defined_pressure_interval[0];
								//labdata.back().plot_data.log_interp.back().xmax = def_module_defined_pressure_interval[1];
								labdata.back().plot_data.log_interp.back().line_color = RGB(0,0,200);
								labdata.back().plot_data.log_interp.back().line_width = 3;
#endif

								if (com_lab_params->params_nature.GetCheckedLabParam() 
									&& com_lab_params->params_nature.parameters_results2_every
									&& com_lab_params->params_nature.parameters_results2_every->GetCheckedLabParam()
									)
								{								
									if (this->p_result_1)
									{
										for (vector<CompressionLogInterpolation>::iterator it = this->p_result_1->v_e_log_interp.begin();
											it != this->p_result_1->v_e_log_interp.end(); it++)
										{
											if ((*it).is_log)
											{
												labdata.back().plot_data.log_interp.push_back(LogInterp());
												labdata.back().plot_data.log_interp.back().m_C = (*it).m_C.v;
												labdata.back().plot_data.log_interp.back().m_A = -(*it).minus_A.v;
												labdata.back().plot_data.log_interp.back().m_x0 = (*it).x_0;
												labdata.back().plot_data.log_interp.back().xmin = (*it).p1;
												labdata.back().plot_data.log_interp.back().xmax = (*it).p2;
												labdata.back().plot_data.log_interp.back().line_color = RGB(0,0,200);
												labdata.back().plot_data.log_interp.back().line_width = 3;	
											}
										}
									}
								}
								if (com_lab_params->params_task.GetCheckedLabParam() 
									&& com_lab_params->params_task.parameters_results2_every
									&& com_lab_params->params_task.parameters_results2_every->GetCheckedLabParam()
									)
								{
									if (this->p_result_2)
									{
										for (vector<CompressionLogInterpolation>::iterator it = this->p_result_2->v_e_log_interp.begin();
											it != this->p_result_2->v_e_log_interp.end(); it++)
										{
											if ((*it).is_log)
											{
												labdata.back().plot_data.log_interp.push_back(LogInterp());
												labdata.back().plot_data.log_interp.back().m_C = (*it).m_C.v;
												labdata.back().plot_data.log_interp.back().m_A = -(*it).minus_A.v;
												labdata.back().plot_data.log_interp.back().m_x0 = (*it).x_0;
												labdata.back().plot_data.log_interp.back().xmin = (*it).p1;
												labdata.back().plot_data.log_interp.back().xmax = (*it).p2;
												labdata.back().plot_data.log_interp.back().line_color = RGB(0,0,200);
												labdata.back().plot_data.log_interp.back().line_width = 3;	
											}
										}
									}
								}
								if (com_lab_params->params_shrinkage.GetCheckedLabParam() 
									&& com_lab_params->params_shrinkage.parameters_results2_every
									&& com_lab_params->params_shrinkage.parameters_results2_every->GetCheckedLabParam()
									)
								{																
									if (this->p_result_3)
									{
										for (vector<CompressionLogInterpolation>::iterator it = this->p_result_3->v_e_log_interp.begin();
											it != this->p_result_3->v_e_log_interp.end(); it++)
										{
											if ((*it).is_log)
											{
												labdata.back().plot_data.log_interp.push_back(LogInterp());
												labdata.back().plot_data.log_interp.back().m_C = (*it).m_C.v;
												labdata.back().plot_data.log_interp.back().m_A = -(*it).minus_A.v;
												labdata.back().plot_data.log_interp.back().m_x0 = (*it).x_0;
												labdata.back().plot_data.log_interp.back().xmin = (*it).p1;
												labdata.back().plot_data.log_interp.back().xmax = (*it).p2;
												labdata.back().plot_data.log_interp.back().line_color = RGB(0,0,200);
												labdata.back().plot_data.log_interp.back().line_width = 3;	
											}
										}
									}
								}
							}
							if(compression)
							{
								labdata.push_back(LabData());
								// plot
								labdata.back().plot_data.use_plot = true;
								labdata.back().plot_data.y_dir = +1;
								labdata.back().plot_data.title = "Коэффициент уплотнения";
								labdata.back().plot_data.xlabel = "Давления, МПа";
								labdata.back().plot_data.ylabel = "Коэф.уплот. a, МПа-1";
								labdata.back().plot_data.zero_min_y = false;
								labdata.back().plot_data.x_ax_not_dubl = true;

								if (com_lab_params->params_nature.GetCheckedLabParam() 
									&& com_lab_params->params_nature.parameters_results2_every
									&& com_lab_params->params_nature.parameters_results2_every->GetCheckedLabParam()
									)
								{	
									if (this->p_result_1)
									{
										int nx = this->p_result_1->vx.size();
										if (nx)
										{
											labdata.back().plot_data.plot_lines.push_back(plot_line());
											labdata.back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
											double x = 0, y, e=e0_1, a;								
											for (int i = 0; i < nx; i++)
											{
												a = (e - this->p_result_1->ve[i].v)/(this->p_result_1->vx[i].x - x);

												x = this->p_result_1->vx[i].x;
												y = this->p_result_1->vy[i].v;
												e = this->p_result_1->ve[i].v;

												if (i)
													labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, a));
												if (max_x_to_set < x) max_x_to_set = x;	
											}
										}

										for (vector<CompressionLogInterpolation>::iterator it = this->p_result_1->v_e_log_interp.begin();
											it != this->p_result_1->v_e_log_interp.end(); it++)
										{
											if ((*it).is_log)
											{
												labdata.back().plot_data.hyp_interp.push_back(HypInterp());
												labdata.back().plot_data.hyp_interp.back().m_A = -(*it).minus_A.v;
												labdata.back().plot_data.hyp_interp.back().m_x0 = (*it).x_0;
												labdata.back().plot_data.hyp_interp.back().xmin = (*it).p1;
												labdata.back().plot_data.hyp_interp.back().xmax = (*it).p2;
												labdata.back().plot_data.hyp_interp.back().line_color = RGB(0,0,200);
												labdata.back().plot_data.hyp_interp.back().line_width = 3;	
												
												
												labdata.back().plot_data.additional_y_for_scale.push_back( - (*it).minus_A.v / ((*it).p1 + (*it).x_0) );
												labdata.back().plot_data.additional_y_for_scale.push_back( - (*it).minus_A.v / ((*it).p2 + (*it).x_0) );

											}
										}
									}
								}

								if (com_lab_params->params_task.GetCheckedLabParam() 
									&& com_lab_params->params_task.parameters_results2_every
									&& com_lab_params->params_task.parameters_results2_every->GetCheckedLabParam()
									)
								{	
									if (this->p_result_2)
									{
										int nx = this->p_result_2->vx.size();
										if (nx)
										{
											labdata.back().plot_data.plot_lines.push_back(plot_line());
											labdata.back().plot_data.plot_lines.back().prec = plot_line::label_precision::seven;
											double x = 0, y, e=e0_2, a;								
											for (int i = 0; i < nx; i++)
											{
												a = (e - this->p_result_2->ve[i].v)/(this->p_result_2->vx[i].x - x);

												x = this->p_result_2->vx[i].x;
												y = this->p_result_2->vy[i].v;
												e = this->p_result_2->ve[i].v;

												if (i)
													labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, a));
												if (max_x_to_set < x) max_x_to_set = x;	
											}
										}

										for (vector<CompressionLogInterpolation>::iterator it = this->p_result_2->v_e_log_interp.begin();
											it != this->p_result_2->v_e_log_interp.end(); it++)
										{
											if ((*it).is_log)
											{
												labdata.back().plot_data.hyp_interp.push_back(HypInterp());
												labdata.back().plot_data.hyp_interp.back().m_A = -(*it).minus_A.v;
												labdata.back().plot_data.hyp_interp.back().m_x0 = (*it).x_0;
												labdata.back().plot_data.hyp_interp.back().xmin = (*it).p1;
												labdata.back().plot_data.hyp_interp.back().xmax = (*it).p2;
												labdata.back().plot_data.hyp_interp.back().line_color = RGB(0,0,200);
												labdata.back().plot_data.hyp_interp.back().line_width = 3;	

												labdata.back().plot_data.additional_y_for_scale.push_back( - (*it).minus_A.v / ((*it).p1 + (*it).x_0) );
												labdata.back().plot_data.additional_y_for_scale.push_back( - (*it).minus_A.v / ((*it).p2 + (*it).x_0) );
											}
										}
									}
								}
								if (com_lab_params->params_shrinkage.GetCheckedLabParam() 
									&& com_lab_params->params_shrinkage.parameters_results2_every
									&& com_lab_params->params_shrinkage.parameters_results2_every->GetCheckedLabParam()
									)
								{	
									if (this->p_result_3)
									{
										int nx = this->p_result_3->vx.size();
										if (nx)
										{
											labdata.back().plot_data.plot_lines.push_back(plot_line());
											double x = 0, y, e=e0_3, a;								
											for (int i = 0; i < nx; i++)
											{
												a = (e - this->p_result_3->ve[i].v)/(this->p_result_3->vx[i].x - x);

												x = this->p_result_3->vx[i].x;
												y = this->p_result_3->vy[i].v;
												e = this->p_result_3->ve[i].v;

												if (i)
													labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, a));
												if (max_x_to_set < x) max_x_to_set = x;	
											}
										}

										for (vector<CompressionLogInterpolation>::iterator it = this->p_result_3->v_e_log_interp.begin();
											it != this->p_result_3->v_e_log_interp.end(); it++)
										{
											if ((*it).is_log)
											{
												labdata.back().plot_data.hyp_interp.push_back(HypInterp());
												labdata.back().plot_data.hyp_interp.back().m_A = -(*it).minus_A.v;
												labdata.back().plot_data.hyp_interp.back().m_x0 = (*it).x_0;
												labdata.back().plot_data.hyp_interp.back().xmin = (*it).p1;
												labdata.back().plot_data.hyp_interp.back().xmax = (*it).p2;
												labdata.back().plot_data.hyp_interp.back().line_color = RGB(0,0,200);
												labdata.back().plot_data.hyp_interp.back().line_width = 3;	

												labdata.back().plot_data.additional_y_for_scale.push_back( - (*it).minus_A.v / ((*it).p1 + (*it).x_0) );
												labdata.back().plot_data.additional_y_for_scale.push_back( - (*it).minus_A.v / ((*it).p2 + (*it).x_0) );
											}
										}
									}
								}
							}

#if 0
							labdata.push_back(LabData());
							if (1)
							{
								// plot
								labdata.back().plot_data.use_plot = true;
								labdata.back().plot_data.y_dir = +1;
								labdata.back().plot_data.title = "Обращённая производная компрессионной кривой";
								labdata.back().plot_data.xlabel = "Давления, МПа";
								labdata.back().plot_data.ylabel = "-DxDe";
								labdata.back().plot_data.zero_min_y = false;
								labdata.back().plot_data.plot_lines.push_back(plot_line());

								labdata.back().plot_data.set_max_x = true;
								labdata.back().plot_data.max_x_to_set = max_x_to_set;
								// массив

								for (size_t i = 0; i < meanX.size(); i++)
								{
									labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(meanX[i], minusDxDe[i].v));
								}
							}
#endif
							labdata.push_back(LabData());
							if (1)
							{
								// plot
								labdata.back().plot_data.use_plot = true;
								labdata.back().plot_data.y_dir = +1;
								labdata.back().plot_data.title = "Вторая производная компрессионной кривой";
								labdata.back().plot_data.xlabel = "Давления, МПа";
								labdata.back().plot_data.ylabel = "D2eDx2";
								labdata.back().plot_data.zero_min_y = false;

								labdata.back().plot_data.set_max_x = true;
								labdata.back().plot_data.max_x_to_set = max_x_to_set;
								labdata.back().plot_data.x_ax_not_dubl = true;
								// массив

								if (com_lab_params->params_nature.GetCheckedLabParam() 
									&& com_lab_params->params_nature.parameters_results2_every
									&& com_lab_params->params_nature.parameters_results2_every->GetCheckedLabParam()
									)
								{								
									if (this->p_result_1)
									{
										labdata.back().plot_data.plot_lines.push_back(plot_line());
										for (size_t i = 0; i < this->p_result_1->m2X.size(); i++)
										{
											labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(this->p_result_1->m2X[i], this->p_result_1->D2eDx2[i].v));
										}
									}
								}
								if (com_lab_params->params_task.GetCheckedLabParam() 
									&& com_lab_params->params_task.parameters_results2_every
									&& com_lab_params->params_task.parameters_results2_every->GetCheckedLabParam()
									)
								{	
									if (this->p_result_2)
									{
										labdata.back().plot_data.plot_lines.push_back(plot_line());
										for (size_t i = 0; i < this->p_result_2->m2X.size(); i++)
										{
											labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(this->p_result_2->m2X[i], this->p_result_2->D2eDx2[i].v));
										}
									}
								}
								if (com_lab_params->params_shrinkage.GetCheckedLabParam() 
									&& com_lab_params->params_shrinkage.parameters_results2_every
									&& com_lab_params->params_shrinkage.parameters_results2_every->GetCheckedLabParam()
									)
								{	
									if (this->p_result_3)
									{
										labdata.back().plot_data.plot_lines.push_back(plot_line());
										for (size_t i = 0; i < this->p_result_3->m2X.size(); i++)
										{
											labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(this->p_result_3->m2X[i], this->p_result_3->D2eDx2[i].v));
										}
									}
								}
							}

							if (com_lab_params->params_nature.GetCheckedLabParam() 
								&& com_lab_params->params_nature.parameters_results2_every
								&& com_lab_params->params_nature.parameters_results2_every->GetCheckedLabParam()
								)
							{
								if (this->p_result_1 && this->p_result_1->calculed)
								{
									labdata.push_back(LabData());
									labdata.back().text.push_back(fmtstr("В природном состоянии", NULL, true, false));
									PrintfPropE(this->p_result_1, labdata.back().text);
								}
							}

							if (com_lab_params->params_task.GetCheckedLabParam() 
								&& com_lab_params->params_task.parameters_results2_every
								&& com_lab_params->params_task.parameters_results2_every->GetCheckedLabParam()
								)
							{
								if (this->p_result_2 && this->p_result_2->calculed)
								{
									labdata.push_back(LabData());
									labdata.back().text.push_back(fmtstr("В заданном состоянии", NULL, true, false));
									PrintfPropE(this->p_result_2, labdata.back().text);
								}
							}

							if (com_lab_params->params_shrinkage.GetCheckedLabParam() 
								&& com_lab_params->params_shrinkage.parameters_results2_every
								&& com_lab_params->params_shrinkage.parameters_results2_every->GetCheckedLabParam()
								)
							{	
								if (this->p_result_3 && this->p_result_3->calculed)
								{
									labdata.push_back(LabData());
									labdata.back().text.push_back(fmtstr("На усадку", NULL, true, false));
									PrintfPropE(this->p_result_3, labdata.back().text);
								}
							}
						}
					}
				}
				if (com_lab_params->GetResult3EveryCheckedLabParam())
				{
					labdata.push_back(LabData());

					if (this->PrintDeformationModuleOnShtamp(compression, &labdata.back().text, &labdata))
					{
					}

				}
			}
		}
	}

	this->PrintfProperties_self(labdata);
}


void CompressionLabTrial::Properties(void)
{
#if LABORATORY_WITH_SURFDOC
	//printf("CompressionLabTrial::Properties()\n");

	if (this->lab_number)
	{
		LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
		if (lablayer)
		{
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
			if(compression)
			{
				Laboratory * lab = (Laboratory *)lablayer->GetLaboratory();
				if (lab)
				{

					SurfDoc * doc = (SurfDoc *)lab->GetDoc();
					project * prj = dynamic_cast<project *>(doc);
					if (prj)
					{
						char tit[1024]; sprintf(tit, "Компрессия (лаб. номер %s)", this->lab_number->ID.c_str()); 
						const char * s1 = "Давления, МПа"; const char * sv = "Абс.деф., мм";
						plot1d_view * plot = prj->AddPlot1DView(PLOT_USERDATA_STRUCTURE, tit, s1, sv, true);
						// массив содержания фракций
						for (int i = 0; i < n_pressures; i++)
						{
							double x;
							switch(com_type)				
							{
							case CompressionLabTrial::type::nature_condition:
								{
									x = compression->pressures_in_nature_condition[i];
								}
								break;
							case CompressionLabTrial::type::task_condition:
								{
									x = compression->pressures_in_task_condition[i];
								}
								break;
							case CompressionLabTrial::type::shrinkage:
								{
									x = compression->pressures_on_shrinkage[i];
								}
								break;
							}
							double y = absolute_deformations[i].v;
							//printf("x = %f y = %f\n", x,y);
							void * udata = NULL;
							plot->AddData(x, y, udata);
						}		
						plot->SetCenterAndScale();
						plot->Update();
					}
				}
			}
		}	
	}
#endif
}
void CompressionLabTrial3::Properties(void)
{
}
const char * CutLabTrial::CutLabTrialTypeToString(CutLabTrial::type cuttype)
{
	switch(cuttype)				
	{
	case CutLabTrial::type::undefined:
		return "undefined";
	case CutLabTrial::type::nature_condition:
		return "nature_condition";
	case CutLabTrial::type::task_condition:
		return "task_condition";
	default:
		return "";
	}
}

const char * CutLabTrial::CutLabTrialTypeToStringRusSmall(CutLabTrial::type cuttype)
{
	switch(cuttype)				
	{
	case CutLabTrial::type::undefined:
		return "undefined";
	case CutLabTrial::type::nature_condition:
		return "в прир. сост.";
	case CutLabTrial::type::task_condition:
		return "в задан. сост.";
	default:
		return "";
	}
}

const char * CutLabTrial::CutLabTrialTypeToStringRus(CutLabTrial::type cuttype)
{
	switch(cuttype)				
	{
	case CutLabTrial::type::undefined:
		return "undefined";
	case CutLabTrial::type::nature_condition:
		return "в природном состоянии";
	case CutLabTrial::type::task_condition:
		return "в заданном состоянии";
	default:
		return "";
	}
}
int CutLabTrial::GetSignForReliabilityK(CutLabTrial::value_type vt)
{
	switch(vt)
	{
	case CutLabTrial::value_type::vt_cut_resistance:
		return 0;//"Сопротивление срезу";
	case CutLabTrial::value_type::vt_apparatus_type:
		return 0;//"Тип прибора";
	case CutLabTrial::value_type::vt_hoop_diameter:
		return 0;//"Диаметр кольца";
	case CutLabTrial::value_type::vt_hoop_height:
		return 0;//"Высота кольца";
	case CutLabTrial::value_type::vt_trial_method:
		return 0;//"Метод испытания";
	case CutLabTrial::value_type::vt_task_moisture:
		return 0;//"Заданная влажность";
	case CutLabTrial::value_type::vt_task_moisture_v:
		return 0;//"Заданная влажность";
	case CutLabTrial::value_type::vt_task_density:
		return 0;//"Заданная плотность";
	default:
		return 0;
	}
	return 0;
}


const char * CutLabTrial::ValueTypeToString(CutLabTrial::value_type vt)
{
	switch(vt)
	{
	case CutLabTrial::value_type::vt_cut_resistance:
		return "Сопротивление срезу, МПа";
	case CutLabTrial::value_type::vt_apparatus_type:
		return "Тип прибора";
	case CutLabTrial::value_type::vt_hoop_diameter:
		return "Диаметр кольца";
	case CutLabTrial::value_type::vt_hoop_height:
		return "Высота кольца";
	case CutLabTrial::value_type::vt_trial_method:
		return "Метод испытания";
	case CutLabTrial::value_type::vt_task_moisture:
		return "Заданная влажность";
	case CutLabTrial::value_type::vt_task_moisture_v:
		return "Заданная влажность";
	case CutLabTrial::value_type::vt_task_density:
		return "Заданная плотность";

	case CutLabTrial::value_type::vt_hid:
		return "Ход испытаний";
	case CutLabTrial::value_type::vt_shema:
		return "Схема испытаний";
	case CutLabTrial::value_type::vt_stan:
		return "Состояние грунта";
	default:
		return "";
	}
	return "";
}


bool CutLabTrial::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	v.trial = this;

	CutLabTrial::value_type val_type = vt.vt_CutLabTrial;
	int i = vt.i_cut_pressure;
	switch(val_type)
	{
	case CutLabTrial::value_type::vt_n_pressures:
		{
			v.v = this->n_pressures;
			v.pf = NULL;
			if (v.v) return true;
		}
		break;
	case CutLabTrial::value_type::vt_pressure:
		{
			if (i >= 0 && i < this->n_pressures)
			{
#if USE_LAB_LAYER_CUT_PRESSURES
				if (this->lab_number)
				{
					LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
					if (lablayer)
					{
						CutLabExperiment * cut = dynamic_cast<CutLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::cut));
						if(cut)
						{
							switch (this->cut_type)
							{
							case CutLabTrial::type::nature_condition:
								{
									// массив pressures
									v.v = cut->pressures_in_nature_condition[i];
									v.pf = NULL;
									if (v.v) return true;
								}
								break;
							case CutLabTrial::type::task_condition:
								{
									// массив pressures
									v.v = cut->pressures_in_task_condition[i];
									v.pf = NULL;
									if (v.v) return true;
								}
								break;
							}
						}
					}	
				}
#else
				v.v = this->pressures[i];
				v.pf = NULL;
				if (v.v) return true;
#endif
			}
		}
		break;
	case CutLabTrial::value_type::vt_cut_resistance:
		{
			if (i >= 0 && i < this->n_pressures)
			{
				v = this->cut_resistances[i];
				if (*v.pf) return true;
			}
		}
		break;
	case CutLabTrial::value_type::vt_hoop_diameter:
		{
			// диаметр кольца
			if (this->lab_number)
			{
				LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
				if (lablayer)
				{
					CutLabExperiment * cut = dynamic_cast<CutLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::cut));
					if(cut)
					{
						v.v = cut->hoop_diameter;
						v.pf = NULL;
						if (v.v) return true;
					}
				}
			}
		}
		break;
	case CutLabTrial::value_type::vt_hoop_height:
		{
			// высота кольца
			if (this->lab_number)
			{
				LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
				if (lablayer)
				{
					CutLabExperiment * cut = dynamic_cast<CutLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::cut));
					if(cut)
					{
						v.v = cut->hoop_height;
						v.pf = NULL;
						if (v.v) return true;
					}
				}
			}
		}
		break;
	case CutLabTrial::value_type::vt_hid:
		{
			// Ход испытаний
			v.v = this->id_hid;
			v.pf = NULL;
			if (v.v) return true;
		}
		break;
	case CutLabTrial::value_type::vt_shema:
		{
			// Схема испытаний
			v.v = this->id_shema;
			v.pf = NULL;
			if (v.v) return true;
		}
		break;
	case CutLabTrial::value_type::vt_stan:
		{
			// Состояние грунта
			v.v = this->id_stan;
			v.pf = NULL;
			if (v.v) return true;
		}
		break;
		/*
	case CutLabTrial::value_type::vt_trial_method:
		{
			// метод испытания
			if (this->lab_number)
			{
				LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
				if (lablayer)
				{
					CutLabExperiment * cut = dynamic_cast<CutLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::cut));
					if(cutn)
					{
						v.v = cut->trial_method;
						v.pf = NULL;
						if (v.v) return true;
					}
				}
			}
		}
		break;*/
	}	
	return false;
}
void CutLabTrial::PrintfProperties(void)
{
	printf("CutLabTrial::PrintfProperties()\n");
	printf("CutLabTrial  type = %s\n", CutLabTrial::CutLabTrialTypeToString(cut_type));


	for (int i = 0; i < n_pressures; i++)
	{
		printf("pressures[%d] = %f\n", i,pressures[i]);
		printf("cut_resistances[%d] = %f\n", i, cut_resistances[i].v);
	}

}

void CutLabTrial::PrintfProperties(vector<fmtstr> & text)
{
	char str[4098];
	sprintf(str, "Срез: Число давлений %s = %d"
		, CutLabTrial::CutLabTrialTypeToStringRus(cut_type)
		, n_pressures
		);
	text.push_back(fmtstr(str, NULL, true, false));


	int step = STEP;
	string s = "Давления, МПа:";
	//     s = "Соп.срез:";				
	text.push_back(fmtstr(s, NULL, false, true));

	for (int i = 0; i < n_pressures; i++)
	{
		s = "";
		sprintf(str, "%f\0", pressures[i]);
		DeleteEndZeros(str);
		text.push_back(fmtstr(str, &cut_resistances[i].f, i==n_pressures-1, true));
	}
			s = "Соп.срез, МПа:";			
	text.push_back(fmtstr(s, NULL, false, true));
	for (int i = 0; i < n_pressures; i++)
	{
		sprintf(str, "%f\0", cut_resistances[i].v);
		DeleteEndZeros(str);
		text.push_back(fmtstr(str, &cut_resistances[i].f, i==n_pressures-1, true));
	}
}
bool GetNju_0_95(int n, double &nju)
{
	if (n >= 3)
	{
		switch(n)
		{
		case 3:
			nju = 1.41;
			break;
		case 4:
			nju = 1.71;
			break;
		case 5:
			nju = 1.92;
			break;
		case 6:
			nju = 2.07;
			break;
		case 7:
			nju = 2.18;
			break;
		case 8:
			nju = 2.27;
			break;
		case 9:
			nju = 2.35;
			break;
		case 10:
			nju = 2.41;
			break;
		case 11:
			nju = 2.47;
			break;
		case 12:
			nju = 2.52;
			break;
		case 13:
			nju = 2.56;
			break;
		case 14:
			nju = 2.60;
			break;
		case 15:
			nju = 2.64;
			break;
		case 16:
			nju = 2.67;
			break;
		case 17:
			nju = 2.70;
			break;
		case 18:
			nju = 2.73;
			break;
		case 19:
			nju = 2.75;
			break;
		case 20:
			nju = 2.78;
			break;
		case 21:
			nju = 2.80;
			break;
		case 22:
			nju = 2.82;
			break;
		case 23:
			nju = 2.84;
			break;
		case 24:
			nju = 2.86;
			break;
		case 25:
			nju = 2.88;
			break;
		case 26:
			nju = 2.90;
			break;
		case 27:
			nju = 2.91;
			break;
		case 28:
			nju = 2.93;
			break;
		case 29:
			nju = 2.94;
			break;
		case 30:
			nju = 2.96;
			break;
		case 31:
			nju = 2.97;
			break;
		case 32:
			nju = 2.98;
			break;
		case 33:
			nju = 3.00;
			break;
		case 34:
			nju = 3.01;
			break;
		case 35:
			nju = 3.02;
			break;
		case 36:
			nju = 3.03;
			break;
		case 37:
			nju = 3.04;
			break;
		case 38:
			nju = 3.05;
			break;
		case 39:
			nju = 3.06;
			break;
		case 40:
			nju = 3.07;
			break;
		case 41:
			nju = 3.08;
			break;
		case 42:
			nju = 3.09;
			break;
		case 43:
			nju = 3.10;
			break;
		case 44:
			nju = 3.11;
			break;
		case 45:
			nju = 3.12;
			break;
		case 46:
			nju = 3.13;
			break;
		case 47:
			nju = 3.14;
			break;
		case 48:
			nju = 3.14;
			break;
		case 49:
			nju = 3.15;
			break;
		case 50:
			nju = 3.16;
			break;
		default:
			nju = 3.16;
			break;
		}
		return true;
	}
	return false;
}

bool MinSqLinear(int n, double * x, double * y, double & a0, double & a1, double & Sy, bool to_printf)
{
	double sum_x = 0.0;
	double sum_y = 0.0;
	double sum_xy = 0.0;
	double sum_xx = 0.0;



	for (int i = 0; i < n; i ++)
	{
		sum_x += x[i];
		sum_y += y[i];
		sum_xy += x[i] * y[i];
		sum_xx += x[i] * x[i];
	}

if(to_printf) printf("sum_x = %f\n", sum_x);
if(to_printf) printf("sum_y = %f\n", sum_y);
if(to_printf) printf("sum_xy = %f\n", sum_xy);
if(to_printf) printf("sum_xx = %f\n", sum_xx);

	// тангенс угла
	a1 = 
		(n*sum_xy - sum_y*sum_x) 
		/
		(n*sum_xx - sum_x*sum_x);

if(to_printf) printf("a1 = %f\n", a1);

	// смещение
	a0 = (1.0 / double(n)) * (sum_y - a1 * sum_x);

if(to_printf) printf("a0 = %f\n", a0);

	// среднеквадратическое отклонение
	double sy = 0.0;

	for (int i = 0; i < n; i ++)
	{
		double delta_y = x[i] * a1 + a0 - y[i];
		sy += delta_y * delta_y;
	}
		
	if (n - 2 > 0)
		sy /= n - 2;

	Sy = sqrt(sy);
	return true;
}

bool MinSqLinear(int min_n, vector<x_compression> & x, vector<trial_got_value> & y, int i0, int n, bool donot_shift, trial_value & a0, trial_value & a1, int & m, trial_value & Sy, bool to_printf)
{
	if (!n) n = int(y.size());
if(to_printf) printf("MinSqLinear n = %d\n", n);
	double sum_x = 0.0;
	double sum_y = 0.0;
	double sum_xy = 0.0;
	double sum_xx = 0.0;

	m = 0;

	for (int i = i0; i < n; i ++)
	{
		if (!y[i].pf || (y[i].pf && (*y[i].pf == TRIAL_VALUE_DEFINED || *y[i].pf == TRIAL_VALUE_INCLUDED || *y[i].pf == TRIAL_VALUE_DEFINED_CANNOT_EXCLUDED || *y[i].pf == TRIAL_VALUE_DEFINED_CAN_EXCLUDED_ONLY_BY_MINSQLIN || *y[i].pf == TRIAL_VALUE_INCLUDED_TO_MINSQLIN)))
			m++;
	}

if(to_printf) printf("MinSqLinear m = %d\n", m);

	if (m < min_n)
	{
		return false;
	}


	for (int i = i0; i < n; i ++)
	{
		if (!y[i].pf || (y[i].pf && (*y[i].pf == TRIAL_VALUE_DEFINED || *y[i].pf == TRIAL_VALUE_INCLUDED || *y[i].pf == TRIAL_VALUE_DEFINED_CANNOT_EXCLUDED || *y[i].pf == TRIAL_VALUE_DEFINED_CAN_EXCLUDED_ONLY_BY_MINSQLIN || *y[i].pf == TRIAL_VALUE_INCLUDED_TO_MINSQLIN)))
		{

			sum_x += x[i].x;
//if(to_printf) printf("x[%d] = %f sum_x = %f\n", i , x[i], sum_x);
			sum_y += y[i].v;
			sum_xy += x[i].x * y[i].v;
			sum_xx += x[i].x * x[i].x;
		}
	}

if(to_printf) printf("sum_x = %f\n", sum_x);
if(to_printf) printf("sum_y = %f\n", sum_y);
if(to_printf) printf("sum_xy = %f\n", sum_xy);
if(to_printf) printf("sum_xx = %f\n", sum_xx);

	// тангенс угла
	a1 = 
		(m*sum_xy - sum_y*sum_x) 
		/
		(m*sum_xx - sum_x*sum_x);

if(to_printf) printf("a1 = %f\n", a1.v);

	// смещение
	a0 = (1.0 / double(m)) * (sum_y - a1 * sum_x);

if(to_printf) printf("a0 = %f\n", a0.v);


	if (a0.v >= 0.0 || donot_shift)
	{
	}
	else
	{
		a1 = sum_xy	/ sum_xx;
		a0 = 0.0;
	}

	// среднеквадратическое отклонение
	double sy = 0.0;

	for (int i = i0; i < n; i ++)
	{
		if (!y[i].pf || (y[i].pf && (*y[i].pf == TRIAL_VALUE_DEFINED || *y[i].pf == TRIAL_VALUE_INCLUDED || *y[i].pf == TRIAL_VALUE_DEFINED_CANNOT_EXCLUDED || *y[i].pf == TRIAL_VALUE_DEFINED_CAN_EXCLUDED_ONLY_BY_MINSQLIN || *y[i].pf == TRIAL_VALUE_INCLUDED_TO_MINSQLIN)))
		{
			double delta_y = x[i].x * a1.v + a0.v - y[i].v;
			sy += delta_y * delta_y;
		}
	}
		
	if (a0.v >= 0.0 || donot_shift)
	{
		if (m - 2 > 0)
			sy /= m - 2;
	}
	else
	{
		sy /= m - 1;
	}

	Sy = sqrt(sy);

	return true;

}

bool LabLayer::MinSqLinearStat(LabTrialValueType & vt, vector<x_compression> & x, vector<trial_got_value> & y, bool donot_shift, trial_value & a0, trial_value & a1, int & m, trial_value & Sy, MinSqLinearStatParameters & param)
{

	int n = int(y.size());
	m = n;	

	while (m >= 6)
	{
		if (MinSqLinear(6, x, y, 0, 0, donot_shift, a0, a1, m, Sy))
		{
		}

		double nju;// статистический критерий исключения возможных ошибок
		if(!GetNju_0_95(m, nju))
		{
			return false;
		}

		bool excluded = false;

		for (int i = 0; i < n; i ++)
		{
			if (fabs(y[i].v - (a0.v + a1.v * x[i].x)) > nju * Sy)
				// если выполняется условие исключения
			{	
				if (y[i].pf)
				{		
					if (*y[i].pf == TRIAL_VALUE_DEFINED_CAN_EXCLUDED_ONLY_BY_MINSQLIN)  // если значение ранее не исключено
					{
						// исключаем
						*y[i].pf = TRIAL_VALUE_EXCLUDED_BY_MINSQLIN;
						excluded = true;

						if (!this->excluded_list_filled)
						{
							excluded_lab_trial exlt;

							char s[128];
							sprintf(s, "%s\0", this->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
							OemToChar(s, s);						
#endif

							exlt.lab_layer_number = s;
							exlt.labnumer_ID = y[i].lab_number ? y[i].lab_number->ID : "undefined";
							exlt.depth = y[i].lab_number ? y[i].lab_number->depth : 0.0;
							exlt.m_mine_working_type = y[i].lab_number ? y[i].lab_number->m_mine_working_type : LabNumber::mine_working_type::undefined;
							exlt.mine_working_number = y[i].lab_number ? y[i].lab_number->mine_working_number : "undefined";

							exlt.pf = y[i].pf;
							exlt.v = y[i].v;
							exlt.vt = vt;

							exlt.vt.cut_pressure = x[i].x;

							exlt.trial = y[i].trial;

							Laboratory::excluded_trials.push_back(exlt);
						}
					}

				}
			}
		}

		// заново рассчитываем количество неисключённых значений
		m = 0;
		param.x_mean = 0.0;
		param.x_min = DBL_MAX;
		param.x_max = -DBL_MAX;
		for (int i = 0; i < n; i ++)
		{
			if (y[i].pf)
				if (*y[i].pf == TRIAL_VALUE_DEFINED || *y[i].pf == TRIAL_VALUE_INCLUDED || *y[i].pf == TRIAL_VALUE_DEFINED_CANNOT_EXCLUDED || *y[i].pf == TRIAL_VALUE_DEFINED_CAN_EXCLUDED_ONLY_BY_MINSQLIN || *y[i].pf == TRIAL_VALUE_INCLUDED_TO_MINSQLIN)
				{
					m++;
					param.x_mean += x[i].x;

					if (param.x_min > x[i].x)
						param.x_min = x[i].x;

					if (param.x_max < x[i].x)
						param.x_max = x[i].x;
				}
		}
		param.x_mean /= m;
		param.SumCentralSqX = 0.0;
		for (int i = 0; i < n; i ++)
		{
			if (y[i].pf)
				if (*y[i].pf == TRIAL_VALUE_DEFINED || *y[i].pf == TRIAL_VALUE_INCLUDED || *y[i].pf == TRIAL_VALUE_DEFINED_CANNOT_EXCLUDED || *y[i].pf == TRIAL_VALUE_DEFINED_CAN_EXCLUDED_ONLY_BY_MINSQLIN || *y[i].pf == TRIAL_VALUE_INCLUDED_TO_MINSQLIN)
				{
					param.SumCentralSqX += (x[i].x - param.x_mean)*(x[i].x - param.x_mean);
				}
		}
		param.G = (param.x_min - param.x_mean) / sqrt(param.SumCentralSqX);
		param.D = (param.x_max - param.x_mean) / sqrt(param.SumCentralSqX);
		param.lambda = 
			sqrt
			(
				0.5 * 
				(
					1.0 - 
						(1.0 + m * param.G * param.D) 
						/ 
						(
							sqrt(
								(1.0 + m * param.G * param.G) * (1.0 + m * param.D * param.D)
							)
						)
				)
			);

		param.Kx_min = sqrt(1.0 + 
				m * (param.x_min - param.x_mean) * (param.x_min - param.x_mean)
				/
				param.SumCentralSqX
			);

		param.Kx_max = sqrt(1.0 + 
				m * (param.x_max - param.x_mean) * (param.x_max - param.x_mean)
				/
				param.SumCentralSqX
			);

		if (!excluded)
		{
//			vn = vmean;
//			S = sigma;
//			V = S / vn;			
			return true;
		}
	}
	return false;

}

void CutLabTrial::PrintfProperties(vector<LabData> & labdata)
{
	labdata.push_back(LabData());

#if PLOT_WITH_TEXT
	this->PrintfProperties(labdata.back().text);
#else
	char str[4098];
	sprintf(str, "Срез: Число давлений %s = %d"
		, CutLabTrial::CutLabTrialTypeToStringRus(cut_type)
		, n_pressures
		);
	labdata.back().text.push_back(fmtstr(str, NULL, true, false));
#endif


	//plot
	labdata.back().plot_data.use_plot = true;
	labdata.back().plot_data.title = "Срез";
	labdata.back().plot_data.xlabel = "Давления, МПа";
	labdata.back().plot_data.ylabel = "Сопр.срезу, МПа";
	labdata.back().plot_data.plot_lines.push_back(plot_line());

	double x,y;
	for (int i = 0; i < n_pressures; i++)
	{
		x = pressures[i];
		y = cut_resistances[i].v;
		labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(x, y));
	}
}

bool CutLabTrialResults::IncludeConnected()
{
	bool have_excluded = this->c.f == TRIAL_VALUE_EXCLUDED || this->tgfi.f == TRIAL_VALUE_EXCLUDED;

	bool have_included = this->c.f == TRIAL_VALUE_INCLUDED || this->tgfi.f == TRIAL_VALUE_INCLUDED;
	
	if (have_included && !have_excluded)
	{
		 if (this->tgfi.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->tgfi.f = TRIAL_VALUE_DEFINED;

		 if (this->c.f == TRIAL_VALUE_EXCLUDED_AS_CONNECTED)
			 this->c.f = TRIAL_VALUE_DEFINED;

		 return true;
	}
	return false;
}

bool CutLabTrialResults::ExcludeConnected()
{
	if (this->c.f == TRIAL_VALUE_EXCLUDED || this->tgfi.f == TRIAL_VALUE_EXCLUDED)
	{
		 if (this->tgfi.f == TRIAL_VALUE_DEFINED)
			 this->tgfi.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 if (this->c.f == TRIAL_VALUE_DEFINED)
			 this->c.f = TRIAL_VALUE_EXCLUDED_AS_CONNECTED;

		 return true;
	}
	return false;
}
bool CutLabTrialResults::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	v.trial = this;

	CutLabTrialResults::value_type val_type = vt.vt_CutLabTrialResults;
	switch(val_type)
	{
	case CutLabTrialResults::value_type::vt_c:
		{
			v = this->c;
			if (*v.pf) return true;
		}
		break;
	case CutLabTrialResults::value_type::vt_fi:
		{
			v.v = this->fi;
			v.pf = NULL;
			
			return true;
		}
		break;
	case CutLabTrialResults::value_type::vt_tgfi:
		{
			v = this->tgfi;
			if (*v.pf) return true;
		}
		break;
	case CutLabTrialResults::value_type::vt_Stau:
		{
			v = this->Stau;
			if (*v.pf) return true;
		}
		break;
	}	
	return false;
}
const char * CutLabTrialResults::ValueTypeToString(CutLabTrialResults::value_type vt, bool every)
{
	if (every)
	{
		switch(vt)
		{
		case CutLabTrialResults::value_type::vt_c:
			return "Удельное сцепление, МПа";
		case CutLabTrialResults::value_type::vt_tgfi:
			return "Тангенс угла вн. трения";
		case CutLabTrialResults::value_type::vt_fi:
			return "Угол внутреннего трения, град";
		case CutLabTrialResults::value_type::vt_Stau:
			return "Среднекв.откл.сопр.срезу";

		default:
			return "";
		}
	}
	else
	{
		switch(vt)
		{
		case CutLabTrialResults::value_type::vt_c:
			return "Удельное сцепление (по ед.сов.оп.), МПа ";
		case CutLabTrialResults::value_type::vt_tgfi:
			return "Тангенс угла вн. трения (по ед.сов.оп.)";
		case CutLabTrialResults::value_type::vt_fi:
			return "Угол внутреннего трения (по ед.сов.оп.), град";
		case CutLabTrialResults::value_type::vt_Stau:
			return "Среднекв.откл.сопр.срезу (по ед.сов.оп.)";

		default:
			return "";
		}
	}
	return "";
}
int CutLabTrialResults::GetSignForReliabilityK(CutLabTrialResults::value_type vt)
{
	switch(vt)
	{
	case CutLabTrialResults::value_type::vt_c:
		return -1;//"Удельное сцепление";
	case CutLabTrialResults::value_type::vt_tgfi:
		return -1;//"Тангенс угла вн. трения";
	case CutLabTrialResults::value_type::vt_fi:
		return -1;//"Угол внутреннего трения";
	case CutLabTrialResults::value_type::vt_Stau:
		return 0;//"Среднекв.откл.сопр.срезу";

	default:
		return 0;
	}
	return 0;
}
void CutLabTrialResults::CalcProperties()
{
	CutLabTrial * cut_lab_trial = dynamic_cast<CutLabTrial *>(this->lab_trial);
	if (cut_lab_trial)
	{
		LabNumber * labnumber = (LabNumber *)cut_lab_trial->GetLabNumber();

		vector<x_compression> vx;
		vector<trial_got_value> vy;
		vx.clear();
		vy.clear();

		for(int i = 0; i < cut_lab_trial->n_pressures; i++)                                
			vx.push_back(cut_lab_trial->pressures[i]);

		for(int i = 0; i < cut_lab_trial->n_pressures; i++)   
		{
			trial_got_value y;
			y = cut_lab_trial->cut_resistances[i];
			y.lab_number = labnumber;
			y.trial = NULL;
			vy.push_back(y);
		}

		int m;


		if (MinSqLinear(3, vx, vy, 0, 0, false, c, tgfi, m, Stau))
		{
			fi = atan(tgfi.v)/PI*180.;
			this->calculed = true;
		}
		else
		{
		}
	}
}
void CutLabTrialResults::PrintfProperties(vector<fmtstr> & text)
{
	if (this->calculed)
	{
		char str[1024];
		sprintf(str, "c = %f", c.v);
		text.push_back(fmtstr(str,&c.f,true, false));

		sprintf(str, "tgfi = %f", tgfi.v);
		text.push_back(fmtstr(str,&tgfi.f,true, false));	

		sprintf(str, "fi = %f", fi);
		text.push_back(fmtstr(str,&tgfi.f,true, false));

		sprintf(str, "Stau = %f", Stau.v);
		text.push_back(fmtstr(str,&tgfi.f,true, false));	
	}
}
void CutLabTrialResults::PrintfProperties(vector<LabData> & labdata)
{
	if (this->calculed)
	{					
		labdata.back().plot_data.lin_interp.push_back(LinInterp());
		labdata.back().plot_data.lin_interp.back().m_a0 = c.v;
		labdata.back().plot_data.lin_interp.back().m_a1 = tgfi.v;
	}

	labdata.push_back(LabData());
	this->PrintfProperties(labdata.back().text);
}
void CutLabTrial::Properties(void)
{
#if LABORATORY_WITH_SURFDOC
	printf("CutLabTrial::PrintfProperties()\n");
	printf("CutLabTrial  type = %s\n", CutLabTrial::CutLabTrialTypeToString(cut_type));

	if (this->lab_number)
	{
		LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
		if (lablayer)
		{
			CutLabExperiment * cut = dynamic_cast<CutLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::cut));
			if(cut)
			{
				Laboratory * lab = (Laboratory *)lablayer->GetLaboratory();
				if (lab)
				{

					SurfDoc * doc = (SurfDoc *)lab->GetDoc();
					project * prj = dynamic_cast<project *>(doc);
					if (prj)
					{
						char tit[1024]; sprintf(tit, "Срез (лаб. номер %s)", this->lab_number->ID.c_str()); 
						const char * s1 = "Давления, МПа"; const char * sv = "Сопр. срезу, МПа";
						plot1d_view * plot = prj->AddPlot1DView(PLOT_USERDATA_STRUCTURE, tit, s1, sv, true);
						// массив содержания фракций
						for (int i = 0; i < n_pressures; i++)
						{
							double x;
							switch(cut_type)				
							{
							case CutLabTrial::type::nature_condition:
								{
									x = cut->pressures_in_nature_condition[i];
								}
								break;
							case CutLabTrial::type::task_condition:
								{
									x = cut->pressures_in_task_condition[i];
								}
								break;
							}

							double y = cut_resistances[i].v;
	
							//printf("x = %f y = %f\n", x,y);
							void * udata = NULL;
							plot->AddData(x, y, udata);
						}		
						plot->SetCenterAndScale();
						plot->Update();
					}
				}
			}
		}	
	}
#endif
}

bool PressingLabTrial::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	v.trial = this;

	return false;
}

void PressingLabTrial::PrintfProperties(void)
{
	printf("PressingLabTrial::PrintfProperties()\n");

	for (int i = 0; i < 3; i++)
	{
		// нагрузки
		printf("loads[%d] = %f\n", loads[i]);
		// сечения
		printf("sections[%d] = %f\n", sections[i]);
	}
}
void PressingLabTrial::PrintfProperties(vector<fmtstr> & text)
{
	
	char str[4098];
	sprintf(str, "Одноосное сжатие (число нагрузок = 3):");
	text.push_back(fmtstr(str, NULL, true, false));


	int step = STEP;
	string s = "Нагрузки:";
	//     s = "Сечения :";			
	text.push_back(fmtstr(s, NULL, false, true));
	for (int i = 0; i < 3; i++)
	{
		//s = "";
		sprintf(str, "%f\0", loads[i]);
		DeleteEndZeros(str);
		//for (int j = 0; j < step-int(strlen(str)); j++)
		//	s += " ";
		//s += str;
		text.push_back(fmtstr(str, NULL, i==2, true));
		//text.push_back(fmtstr(s, loads[i].f, i==2));
	}
			s = "Сечения :";			
	text.push_back(fmtstr(s, NULL, false, true));
	for (int i = 0; i < 3; i++)
	{
		//s = "";
		sprintf(str, "%f\0", sections[i]);
		DeleteEndZeros(str);
		//for (int j = 0; j < step-int(strlen(str)); j++)
		//	s += " ";
		//s += str;
		text.push_back(fmtstr(str, NULL, i==2, true));
		//text.push_back(fmtstr(s, loads[i].f, i==2));
	}

}
void PressingLabTrial::PrintfProperties(vector<LabData> & labdata)
{
	labdata.push_back(LabData());
	
#if PLOT_WITH_TEXT
	this->PrintfProperties(labdata.back().text);
#else
	char str[4098];
	sprintf(str, "Одноосное сжатие (число нагрузок = 3):");
	labdata.back().text.push_back(fmtstr(str, NULL, true, false));
#endif

	labdata.back().plot_data.use_plot = true;
	labdata.back().plot_data.title = "Одноосное сжатие";
	labdata.back().plot_data.xlabel = "нагрузки";
	labdata.back().plot_data.ylabel = "сечения";
				
	labdata.back().plot_data.plot_lines.push_back(plot_line());

	for (int i = 0; i < 3; i++)
	{
		// нагрузки
		//printf("loads[%d] = %f\n", loads[i]);
		// сечения
		//printf("sections[%d] = %f\n", sections[i]);
		labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(loads[i], sections[i]));
	}
}
bool PressingLabTrialResults::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	v.trial = this;

	return false;
}
void PressingLabTrialResults::CalcProperties()
{
}
void PressingLabTrialResults::PrintfProperties(vector<fmtstr> & text)
{
}
void PressingLabTrialResults::PrintfProperties(vector<LabData> & labdata)
{
}
void PressingLabTrial::Properties(void)
{
#if LABORATORY_WITH_SURFDOC

	if (this->lab_number)
	{
		LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
		if (lablayer)
		{
			Laboratory * lab = (Laboratory *)lablayer->GetLaboratory();
			if (lab)
			{
				SurfDoc * doc = (SurfDoc *)lab->GetDoc();
				project * prj = dynamic_cast<project *>(doc);
				if (prj)
				{
					char tit[1024]; sprintf(tit, "Одноосное сжатие (лаб. номер %s)", this->lab_number->ID.c_str()); 
					const char * s1 = "нагрузки"; const char * sv = "сечения";
					plot1d_view * plot = prj->AddPlot1DView(PLOT_USERDATA_STRUCTURE, tit, s1, sv, true);
					// массив содержания фракций
					for (int i = 0; i < 3; i++)
					{
						// нагрузки
						double x = loads[i];
						// сечения
						double y = sections[i];

						//printf("x = %f y = %f\n", x,y);
						void * udata = NULL;
						plot->AddData(x, y, udata);
					}		
					plot->SetCenterAndScale();
					plot->Update();
				}
			}
		}	
	}
#endif
}

const char * FiltrationLabTrial::FiltrationLabTrialTypeToString(FiltrationLabTrial::type filtrtype)
{
	switch(filtrtype)				
	{
	case FiltrationLabTrial::type::undefined:
		return "undefined";
	case FiltrationLabTrial::type::with_pressures:
		return "with_pressures";
	case FiltrationLabTrial::type::with_densities:
		return "with_densities";
	default:
		return "";
	}
}
const char * FiltrationLabTrial::FiltrationLabTrialTypeToStringRus(FiltrationLabTrial::type filtrtype)
{
	switch(filtrtype)				
	{
	case FiltrationLabTrial::type::undefined:
		return "undefined";
	case FiltrationLabTrial::type::with_pressures:
		return "with_pressures";
	case FiltrationLabTrial::type::with_densities:
		return "with_densities";
	default:
		return "";
	}
}

bool FiltrationLabTrial::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	v.trial = this;

	return false;
}
void FiltrationLabTrial::PrintfProperties(void)
{
	printf("FiltrationLabTrial::PrintfProperties()\n");
	printf("FiltrationLabTrialType = %s\n", FiltrationLabTrial::FiltrationLabTrialTypeToString(filtr_type));
	filtr_type;

	for (int i = 0; i < 3; i++)
	{
		// расход
		printf("expenditures[%d] = %f\n", expenditures[i]);
		// плотности
		printf("densities[%d] = %f\n", densities[i]);
	}
}

void FiltrationLabTrial::PrintfProperties(vector<fmtstr> & text)
{
	char str[4098];
	sprintf(str, "Фильтрация: Число давлений = 3 тип = %s"
		, FiltrationLabTrial::FiltrationLabTrialTypeToStringRus(filtr_type)
		);
	text.push_back(fmtstr(str, NULL, true, false));

	int step = STEP;
	string s = "Расходы:";
	//     s = "Плот-ти:";			
	text.push_back(fmtstr(s, NULL, false, true));
	for (int i = 0; i < 3; i++)
	{
		//s = "";
		sprintf(str, "%f\0", expenditures[i]);
		DeleteEndZeros(str);
		//for (int j = 0; j < step-int(strlen(str)); j++)
		//	s += " ";
		//s += str;
		text.push_back(fmtstr(str, NULL, i==2, true));
		//text.push_back(fmtstr(s, expenditures[i].f, i==2));
	}
			s = "Плот-ти:";			
	text.push_back(fmtstr(s, NULL, false, true));
	for (int i = 0; i < 3; i++)
	{
		//s = "";
		sprintf(str, "%f\0", densities[i]);
		DeleteEndZeros(str);
		//for (int j = 0; j < step-int(strlen(str)); j++)
		//	s += " ";
		//s += str;
		text.push_back(fmtstr(str, NULL, i==2, true));
		//text.push_back(fmtstr(s, expenditures[i].f, i==2));
	}
}

void FiltrationLabTrial::PrintfProperties(vector<LabData> & labdata)
{
	labdata.push_back(LabData());

#if PLOT_WITH_TEXT
	this->PrintfProperties(labdata.back().text);
#else
	char str[4098];
	sprintf(str, "Фильтрация: Число давлений = 3 тип = %s"
		, FiltrationLabTrial::FiltrationLabTrialTypeToStringRus(filtr_type)
		);
	labdata.back().text.push_back(fmtstr(str, NULL, true, false));
#endif

	labdata.back().plot_data.use_plot = true;
	labdata.back().plot_data.title = "Фильтрация";
	labdata.back().plot_data.xlabel = "расход";
	labdata.back().plot_data.ylabel = "плотности";
				
	labdata.back().plot_data.plot_lines.push_back(plot_line());

	for (int i = 0; i < 3; i++)
	{
		// расход
		//printf("expenditures[%d] = %f\n", expenditures[i]);
		// плотности
		//printf("densities[%d] = %f\n", densities[i]);

		labdata.back().plot_data.plot_lines.back().data.push_back(plot_data_2d(expenditures[i], densities[i]));
	}
}

bool FiltrationLabTrialResults::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	v.trial = this;

	return false;
}
void FiltrationLabTrialResults::CalcProperties()
{
}
void FiltrationLabTrialResults::PrintfProperties(vector<fmtstr> & text)
{
}
void FiltrationLabTrialResults::PrintfProperties(vector<LabData> & labdata)
{
}
void FiltrationLabTrial::Properties(void)
{
#if LABORATORY_WITH_SURFDOC
	printf("FiltrationLabTrial::PrintfProperties()\n");
	printf("FiltrationLabTrialType = %s\n", FiltrationLabTrial::FiltrationLabTrialTypeToString(filtr_type));
	filtr_type;
	if (this->lab_number)
	{
		LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
		if (lablayer)
		{
			Laboratory * lab = (Laboratory *)lablayer->GetLaboratory();
			if (lab)
			{
				SurfDoc * doc = (SurfDoc *)lab->GetDoc();
				project * prj = dynamic_cast<project *>(doc);
				if (prj)
				{
					char tit[1024]; sprintf(tit, "Фильтрация (лаб. номер %s)", this->lab_number->ID.c_str()); 
					const char * s1 = "расход"; const char * sv = "плотности";
					plot1d_view * plot = prj->AddPlot1DView(PLOT_USERDATA_STRUCTURE, tit, s1, sv, true);
					// массив содержания фракций
					for (int i = 0; i < 3; i++)
					{
						// нагрузки
						double x = expenditures[i];
						// сечения
						double y = densities[i];

						//printf("x = %f y = %f\n", x,y);
						void * udata = NULL;
						plot->AddData(x, y, udata);
					}		
					plot->SetCenterAndScale();
					plot->Update();
				}
			}
		}	
	}
#endif
}


void LabNumber::ReCalcProperties(bool labnumber_recalc_e_log_interp)
{
#if USE_LAB_TRIALS_VECTOR
	for (vector<LabTrial*>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if (*it)
			(*it)->ReCalcProperties(labnumber_recalc_e_log_interp);
	}
#else
	for (map<LabTrial::indication, LabTrial*>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if ((*it).second)
			(*it).second->ReCalcProperties(labnumber_recalc_e_log_interp);
	}
#endif
}

void LabNumber::PrintfProperties(void)
{
	printf("LabNumber::PrintfProperties()\n");

	printf("ID = %s\n", this->ID.c_str());
	printf("s_mine_working_type = %s\n", this->s_mine_working_type.c_str());
	printf("mine_working_number = %s\n", this->mine_working_number.c_str());
	printf("depth = %f\n", this->depth);

#if USE_LAB_TRIALS_VECTOR
	for (vector<LabTrial*>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if (*it)
			(*it)->PrintfProperties();
	}
#else
	for (map<LabTrial::indication, LabTrial*>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if ((*it).second)
			(*it).second->PrintfProperties();
	}
#endif
}

void LabNumber::Properties(void)
{
#if USE_LAB_TRIALS_VECTOR
	for (vector<LabTrial*>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if (*it)
			(*it)->Properties();
	}
#else
	for (map<LabTrial::indication, LabTrial*>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if ((*it).second)
			(*it).second->Properties();
	}
#endif
}
void CompressionValueType_3::Printf()
{

	printf("com_type = %d\n", com_type);

	vt_Compression_nature.Printf();
	vt_Compression_task.Printf();
	vt_Compression_shrinkage.Printf();
}
void CompressionValueType::Printf()
{
	printf("vt_CompressionLabTrial = %d\n", vt_CompressionLabTrial);
	printf("vt_CompressionLabTrialResults_0 = %d\n", vt_CompressionLabTrialResults_0);
#if USE_COMPR_PO_OTN_DEF
	printf("vt_CompressionLabTrialResults_1 = %d\n", vt_CompressionLabTrialResults_1);
#endif
	printf("vt_CompressionLabTrialResults_2 = %d\n", vt_CompressionLabTrialResults_2);
	printf("vt_CompressionLabTrialResults_3 = %d\n", vt_CompressionLabTrialResults_3);
	printf("com_type = %d\n", com_type);
	printf("n_compression_pressures = %d\n", n_compression_pressures);
	printf("compression_pressure = %f\n", compression_pressure);
}

void LabTrialValueType::Printf()
{
	printf("m_indication = %d\n", m_indication); 
	printf("is_result = %d\n", is_result); 
#if USE_LAB_TRIALS_VECTOR
	printf("m_id_vyprob = %d\n", m_id_vyprob); 
#endif
	printf("m_lablayer = %x\n", m_lablayer);

	printf("vt_PhysicalLabTrial = %d\n", vt_PhysicalLabTrial);
	printf("vt_PhysicalLabTrialResults = %d\n", vt_PhysicalLabTrialResults);

	printf("vt_ChemicalLabTrial = %d\n", vt_ChemicalLabTrial);
	printf("vt_ChemicalLabTrialResults = %d\n", vt_ChemicalLabTrialResults);

	printf("vt_FractionsLabTrial = %d\n", vt_FractionsLabTrial);
	printf("vt_FractionsLabTrialResults = %d\n", vt_FractionsLabTrialResults);
	printf("n_fractions = %d\n", n_fractions);
#if !USE_FRACTION_DIAMETERS_INTERVAL
	printf("fraction_diameter = %f\n", fraction_diameter);
#endif
	printf("fraction_diameter_high = %f\n", fraction_diameter_high);
	printf("fraction_diameter_low = %f\n", fraction_diameter_low);

	this->vt_Compression.Printf();
	this->vt_Compression_3.Printf();

	printf("vt_CutLabTrial = %d\n", vt_CutLabTrial);
	printf("vt_CutLabTrialResults = %d\n", vt_CutLabTrialResults);
	printf("cut_type = %d\n", cut_type);
	printf("n_cut_pressures = %d\n", n_cut_pressures);
	printf("cut_pressure = %f\n", cut_pressure);

	printf("vt_PressingLabTrial = %d\n", vt_PressingLabTrial);
	printf("vt_PressingLabTrialResults = %d\n", vt_PressingLabTrialResults);

	printf("vt_FiltrationLabTrial = %d\n", vt_FiltrationLabTrial);
	printf("vt_FiltrationLabTrialResults = %d\n", vt_FiltrationLabTrialResults);
	printf("filtr_type = %d\n", filtr_type);
}
void CompressionValueType_3::clear()
{

	vt_Compression_nature.clear();
	vt_Compression_task.clear();
	vt_Compression_shrinkage.clear();
	com_type = CompressionLabTrial::type::undefined;
}
void CompressionValueType::clear()
{
	vt_CompressionLabTrial = CompressionLabTrial::value_type::none;
	n_compression_value_type = 0;
	every_compression_experiment = true;
	vt_CompressionLabTrialResults_0 = CompressionLabTrialResults::value_type_0::none_0;
#if USE_COMPR_PO_OTN_DEF
	vt_CompressionLabTrialResults_1 = CompressionLabTrialResults::value_type_1::none_1;
#endif
	vt_CompressionLabTrialResults_2 = CompressionLabTrialResults::value_type_2::none_2;
	vt_CompressionLabTrialResults_3 = CompressionLabTrialResults::value_type_3::none_3;
	com_type = CompressionLabTrial::type::undefined;
	n_compression_pressures = 0;
	i_compression_pressure = 0;
	compression_pressure = 0.0;
	compression_zamachivanie = false;
}
LabTrialValueType::LabTrialValueType()
{	
	this->clear();

	vt_Compression.SetParent(this);
	vt_Compression_3.SetParent(this);	
}
void CompressionValueType_3::SetParent(LabTrialValueType * p_LabTrialValueType)
{	
	m_LabTrialValueType = p_LabTrialValueType;

	vt_Compression_nature.SetParent(p_LabTrialValueType);
	vt_Compression_task.SetParent(p_LabTrialValueType);
	vt_Compression_shrinkage.SetParent(p_LabTrialValueType);
}
void LabTrialValueType::clear()
{
	m_indication = LabTrial::indication::undefined_lab_trial_indication;
	is_result = false;
//	use_index = false;
#if USE_LAB_TRIALS_VECTOR
	m_id_vyprob = -1;
#endif


	m_lablayer = NULL;

	this->vt_common_type = LabTrialValueType::common_types::none;

	vt_PhysicalLabTrial = PhysicalLabTrial::value_type::none;
	vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::none;

	vt_ChemicalLabTrial = ChemicalLabTrial::value_type::none;
	vt_ChemicalLabTrialResults = ChemicalLabTrialResults::value_type::none;

	vt_FractionsLabTrial = FractionsLabTrial::value_type::none;
	vt_FractionsLabTrialResults = FractionsLabTrialResults::value_type::none;
	n_fractions = 0;
	i_fraction = 0;
#if !USE_FRACTION_DIAMETERS_INTERVAL
	fraction_diameter = 0.0;
#endif
	fraction_diameter_high = DBL_MAX;
	fraction_diameter_low = DBL_MAX;

	vt_Compression.clear();
	vt_Compression_3.clear();

	vt_CutLabTrial = CutLabTrial::value_type::none;
	vt_CutLabTrialResults = CutLabTrialResults::value_type::none;
	every_cut_experiment = true;

	cut_type = CutLabTrial::type::undefined;
	n_cut_pressures = 0;
	i_cut_pressure = 0;
	cut_pressure = 0.0;

	vt_PressingLabTrial = PressingLabTrial::value_type::none;
	vt_PressingLabTrialResults = PressingLabTrialResults::value_type::none;

	vt_FiltrationLabTrial = FiltrationLabTrial::value_type::none;
	vt_FiltrationLabTrialResults = FiltrationLabTrialResults::value_type::none;
	filtr_type = FiltrationLabTrial::type::undefined;
}

void LabTrialValueType::Init(const LabTrialValueType & ob)
{
	m_indication = ob.m_indication;
	is_result = ob.is_result;
#if USE_LAB_TRIALS_VECTOR
	m_id_vyprob = ob.m_id_vyprob;
#endif


	m_lablayer = ob.m_lablayer;

	this->vt_common_type = ob.vt_common_type;

	vt_PhysicalLabTrial = ob.vt_PhysicalLabTrial;
	vt_PhysicalLabTrialResults = ob.vt_PhysicalLabTrialResults;

	vt_ChemicalLabTrial = ob.vt_ChemicalLabTrial;
	vt_ChemicalLabTrialResults = ob.vt_ChemicalLabTrialResults;

	vt_FractionsLabTrial = ob.vt_FractionsLabTrial;
	vt_FractionsLabTrialResults = ob.vt_FractionsLabTrialResults;
	n_fractions = ob.n_fractions;
	i_fraction = ob.i_fraction;
#if !USE_FRACTION_DIAMETERS_INTERVAL
	fraction_diameter = ob.fraction_diameter;
#endif
	fraction_diameter_high = ob.fraction_diameter_high;
	fraction_diameter_low = ob.fraction_diameter_low;

	vt_Compression = ob.vt_Compression;
	vt_Compression.SetParent(this);
	vt_Compression_3 = ob.vt_Compression_3;
	vt_Compression_3.SetParent(this);	


	vt_CutLabTrial = ob.vt_CutLabTrial;
	vt_CutLabTrialResults = ob.vt_CutLabTrialResults;
	every_cut_experiment = ob.every_cut_experiment;

	cut_type = ob.cut_type;
	n_cut_pressures = ob.n_cut_pressures;
	i_cut_pressure = ob.i_cut_pressure;
	cut_pressure = ob.cut_pressure;

	vt_PressingLabTrial = ob.vt_PressingLabTrial;
	vt_PressingLabTrialResults = ob.vt_PressingLabTrialResults;

	vt_FiltrationLabTrial = ob.vt_FiltrationLabTrial;
	vt_FiltrationLabTrialResults = ob.vt_FiltrationLabTrialResults;
	filtr_type = ob.filtr_type;
}
int CompressionValueType::GetSignForReliabilityK()
{
	if (this->m_LabTrialValueType)
	{
		if (this->m_LabTrialValueType->is_result)
		{
			switch(this->n_compression_value_type)
			{
			case 0:
				{
					return CompressionLabTrialResults::GetSignForReliabilityK(vt_CompressionLabTrialResults_0);
				}
				break;
#if USE_COMPR_PO_OTN_DEF
			case 1:
				{
					return CompressionLabTrialResults::GetSignForReliabilityK(vt_CompressionLabTrialResults_1);
				}
				break;
#endif
			case 2:
				{
					return CompressionLabTrialResults::GetSignForReliabilityK(vt_CompressionLabTrialResults_2);
				}
				break;
			case 3:
				{
					return CompressionLabTrialResults::GetSignForReliabilityK(vt_CompressionLabTrialResults_3);
				}
				break;
			}
		}
		else
		{
			return CompressionLabTrial::GetSignForReliabilityK(vt_CompressionLabTrial);
		}
	}
	return 0;
}
int CompressionValueType_3::GetSignForReliabilityK()
{
	switch(this->com_type)
	{
	case CompressionLabTrial::type::nature_condition:
		return vt_Compression_nature.GetSignForReliabilityK();
		break;
	case CompressionLabTrial::type::task_condition:
		return vt_Compression_task.GetSignForReliabilityK();
		break;
	case CompressionLabTrial::type::shrinkage:
		return vt_Compression_shrinkage.GetSignForReliabilityK();
		break;
	case CompressionLabTrial::type::tri:
		return CompressionLabTrialResults3::GetSignForReliabilityK(this->vt_CompressionLabTrialResults3);
		break;

	default:
		return 0;
	}		
	return 0;
}
int LabTrialValueType::GetSignForReliabilityK()
{
	// Знак для коэффициента надёжности
	switch(m_indication)
	{
	case LabTrial::indication::physical:
		{
			if (is_result)
			{
				return PhysicalLabTrialResults::GetSignForReliabilityK(vt_PhysicalLabTrialResults);
			}
			else
			{
				return PhysicalLabTrial::GetSignForReliabilityK(vt_PhysicalLabTrial);
			}
		}
		break;
	case LabTrial::indication::chemical:
		{
			if (is_result)
			{
				//return ChemicalLabTrialResults::GetSignForReliabilityK(vt_ChemicalLabTrialResults);
			}
			else
			{
				return ChemicalLabTrial::GetSignForReliabilityK(vt_ChemicalLabTrial);
			}
		}
		break;
	case LabTrial::indication::fractions:
		{
			if (is_result)
			{
				//return FractionsLabTrialResults::GetSignForReliabilityK(vt_FractionsLabTrialResults);
			}
			else
			{
				return FractionsLabTrial::GetSignForReliabilityK(vt_FractionsLabTrial);
			}
		}
		break;	
	case LabTrial::indication::compression_3:
		{
			return this->vt_Compression_3.GetSignForReliabilityK();
		}
		break;
	case LabTrial::indication::compression_nature_condition_absolute_deformation:
	case LabTrial::indication::compression_task_condition_absolute_deformation:
	case LabTrial::indication::compression_shrinkage_absolute_deformation:
		{
			return this->vt_Compression.GetSignForReliabilityK();
		}
		break;
	case LabTrial::indication::cut_resistance_nature_condition:
	case LabTrial::indication::cut_resistance_task_condition:
		{
			switch(m_indication)			
			{	
				case LabTrial::indication::cut_resistance_nature_condition:
					//this->cut_type = CutLabTrial::type::nature_condition;
					break;
				case LabTrial::indication::cut_resistance_task_condition:
					//this->cut_type = CutLabTrial::type::task_condition;
					break;
			}
			if (is_result)
			{
				return CutLabTrialResults::GetSignForReliabilityK(vt_CutLabTrialResults);
			}
			else
			{
				return CutLabTrial::GetSignForReliabilityK(vt_CutLabTrial);
			}
		}
		break;
#if 0
	case LabTrial::indication::pressing:
		{
			if (is_result)
			{
				return PressingLabTrialResults::GetSignForReliabilityK(vt_PressingLabTrialResults);
			}
			else
			{
				return PressingLabTrial::GetSignForReliabilityK(vt_PressingLabTrial);
			}
		}
		break;	
	case LabTrial::indication::filtration_coefficient_with_pressures:
	case LabTrial::indication::filtration_coefficient_with_densities:
		{
			switch(m_indication)			
			{	
				case LabTrial::indication::filtration_coefficient_with_pressures:
					//this->filtr_type = FiltrationLabTrial::type::with_pressures;
					break;
				case LabTrial::indication::filtration_coefficient_with_densities:
					//this->filtr_type = FiltrationLabTrial::type::with_densities;
					break;
			}
			if (is_result)
			{
				return FiltrationLabTrialResults::GetSignForReliabilityK(vt_FiltrationLabTrialResults);
			}
			else
			{
				return FiltrationLabTrial::GetSignForReliabilityK(vt_FiltrationLabTrial);
			}
		}
		break;
#endif
	default:
		return 0;
	}
		
	return 0;
}

#if 0
int LabTrialValueType::GetValueTypeInt()
{
	switch(m_indication)
	{
	case LabTrial::indication::physical:
		{
			if (is_result)
			{
				return int(vt_PhysicalLabTrialResults);
			}
			else
			{
				return int(vt_PhysicalLabTrial);
			}
		}
		break;
	case LabTrial::indication::chemical:
		{
			if (is_result)
			{
				return int(vt_ChemicalLabTrialResults);
			}
			else
			{
				return int(vt_ChemicalLabTrial);
			}
		}
		break;
	case LabTrial::indication::fractions:
		{
			if (is_result)
			{
				return int(vt_FractionsLabTrialResults);
			}
			else
			{
				return int(vt_FractionsLabTrial);
			}
		}
		break;	
	case LabTrial::indication::compression_nature_condition_absolute_deformation:
	case LabTrial::indication::compression_task_condition_absolute_deformation:
	case LabTrial::indication::compression_shrinkage_absolute_deformation:
		{
			switch(m_indication)			
			{	
				case LabTrial::indication::compression_nature_condition_absolute_deformation:
					//this->com_type = CompressionLabTrial::type::nature_condition;
					break;
				case LabTrial::indication::compression_task_condition_absolute_deformation:
					//this->com_type = CompressionLabTrial::type::task_condition;
					break;
				case LabTrial::indication::compression_shrinkage_absolute_deformation:
					//this->com_type = CompressionLabTrial::type::shrinkage;
					break;
			}
			if (is_result)
			{
				return int(vt_CompressionLabTrialResults);
			}
			else
			{
				return int(vt_CompressionLabTrial);
			}
		}
		break;
	case LabTrial::indication::cut_resistance_nature_condition:
	case LabTrial::indication::cut_resistance_task_condition:
		{
			switch(m_indication)			
			{	
				case LabTrial::indication::cut_resistance_nature_condition:
					//this->cut_type = CutLabTrial::type::nature_condition;
					break;
				case LabTrial::indication::cut_resistance_task_condition:
					//this->cut_type = CutLabTrial::type::task_condition;
					break;
			}
			if (is_result)
			{
				return int(vt_CutLabTrialResults);
			}
			else
			{
				return int(vt_CutLabTrial);
			}
		}
		break;
	case LabTrial::indication::pressing:
		{
			if (is_result)
			{
				return int(vt_PressingLabTrialResults);
			}
			else
			{
				return int(vt_PressingLabTrial);
			}
		}
		break;	
	case LabTrial::indication::filtration_coefficient_with_pressures:
	case LabTrial::indication::filtration_coefficient_with_densities:
		{
			switch(m_indication)			
			{	
				case LabTrial::indication::filtration_coefficient_with_pressures:
					//this->filtr_type = FiltrationLabTrial::type::with_pressures;
					break;
				case LabTrial::indication::filtration_coefficient_with_densities:
					//this->filtr_type = FiltrationLabTrial::type::with_densities;
					break;
			}
			if (is_result)
			{
				return int(vt_FiltrationLabTrialResults);
			}
			else
			{
				return int(vt_FiltrationLabTrial);
			}
		}
		break;
	default:
		return 0;
	}
}
#endif
int CompressionValueType::GetI()
{
	if (this->m_LabTrialValueType)
	{
		if (this->m_LabTrialValueType->is_result)
		{
			return 0;
		}
		else
		{
			return this->i_compression_pressure;
		}
	}
    
	return 0;
}

int CompressionValueType_3::GetI()
{
	switch(this->com_type)
	{
	case CompressionLabTrial::type::nature_condition:
		return vt_Compression_nature.GetI();
	case CompressionLabTrial::type::task_condition:
		return vt_Compression_task.GetI();
	case CompressionLabTrial::type::shrinkage:
		return vt_Compression_shrinkage.GetI();
	case CompressionLabTrial::type::tri:
		return 0;//CompressionLabTrialResults3::GetI(this->vt_CompressionLabTrialResults3);
	default:
		return 0;
	}		
	return 0;    
}

int LabTrialValueType::GetI()
{
	switch(m_indication)
	{
	case LabTrial::indication::physical:
		{
			if (is_result)
			{
				return 0;
			}
			else
			{
				return 0;
			}
		}
		break;
	case LabTrial::indication::chemical:
		{
			if (is_result)
			{
				return 0;
			}
			else
			{
				return 0;
			}
		}
		break;
	case LabTrial::indication::fractions:
		{
			if (is_result)
			{
				return 0;
			}
			else
			{
				return this->i_fraction;
			}
		}
		break;	
	case LabTrial::indication::compression_3:
		{
			return this->vt_Compression_3.GetI();
		}
		break;
	case LabTrial::indication::compression_nature_condition_absolute_deformation:
	case LabTrial::indication::compression_task_condition_absolute_deformation:
	case LabTrial::indication::compression_shrinkage_absolute_deformation:
		{
			return this->vt_Compression.GetI();
		}
		break;
	case LabTrial::indication::cut_resistance_nature_condition:
	case LabTrial::indication::cut_resistance_task_condition:
		{
			if (is_result)
			{
				return 0;
			}
			else
			{
				return this->i_cut_pressure;
			}
		}
		break;
	case LabTrial::indication::pressing:
		{
			if (is_result)
			{
				return 0;
			}
			else
			{
				return 0;
			}
		}
		break;	
	case LabTrial::indication::filtration_coefficient_with_pressures:
	case LabTrial::indication::filtration_coefficient_with_densities:
		{
			if (is_result)
			{
				return 0;
			}
			else
			{
				return 0;
			}
		}
		break;
	default:
		return 0;
	}
}
const char * CompressionValueType::GetValueTypeString()
{
	if (this->m_LabTrialValueType)
	{
		if (this->m_LabTrialValueType->is_result)
		{
			switch(this->n_compression_value_type)
			{
			case 0:
				{
					return CompressionLabTrialResults::ValueTypeToString(vt_CompressionLabTrialResults_0, this->m_LabTrialValueType->m_lablayer);
				}
				break;
#if USE_COMPR_PO_OTN_DEF
			case 1:
				{
					return CompressionLabTrialResults::ValueTypeToString(vt_CompressionLabTrialResults_1, this->m_LabTrialValueType->m_lablayer, this->every_compression_experiment);
				}
				break;
#endif
			case 2:
				{
					return CompressionLabTrialResults::ValueTypeToString(vt_CompressionLabTrialResults_2, this->m_LabTrialValueType->m_lablayer, this->every_compression_experiment);
				}
				break;
			case 3:
				{
					return CompressionLabTrialResults::ValueTypeToString(vt_CompressionLabTrialResults_3, this->m_LabTrialValueType->m_lablayer, this->every_compression_experiment);
				}
				break;
			}
		}
		else
		{
			if (vt_CompressionLabTrial == CompressionLabTrial::value_type::vt_absolute_deformation)
			{
				char str[4096];
				sprintf(str, "%s давл. %f", CompressionLabTrial::ValueTypeToString(vt_CompressionLabTrial), this->compression_pressure);
				DeleteEndZeros(str);	
				return _strdup( str );
			}
			else
				return CompressionLabTrial::ValueTypeToString(vt_CompressionLabTrial);
		}

	}
	
}
const char * CompressionValueType_3::GetValueTypeString()
{
	switch(this->com_type)
	{
	case CompressionLabTrial::type::nature_condition:
		return vt_Compression_nature.GetValueTypeString();
	case CompressionLabTrial::type::task_condition:
		return vt_Compression_task.GetValueTypeString();
	case CompressionLabTrial::type::shrinkage:
		return vt_Compression_shrinkage.GetValueTypeString();
	case CompressionLabTrial::type::tri:
		return CompressionLabTrialResults3::ValueTypeToString(this->vt_CompressionLabTrialResults3);
	default:
		return "";
	}		
	return "";    
}
const char * LabTrialValueType::GetValueTypeString()
{
	switch(m_indication)
	{
	case LabTrial::indication::undefined_lab_trial_indication:
		{
			switch (this->vt_common_type)
			{
			case LabTrialValueType::common_types::depth:
				return "Глубина, м";
			}
		}
		break;
	case LabTrial::indication::physical:
		{
			if (is_result)
			{
				return PhysicalLabTrialResults::ValueTypeToString(vt_PhysicalLabTrialResults);
			}
			else
			{
				return PhysicalLabTrial::ValueTypeToString(vt_PhysicalLabTrial);
			}
		}
		break;
	case LabTrial::indication::chemical:
		{
			if (is_result)
			{
//				return ChemicalLabTrialResults::ValueTypeToString(vt_ChemicalLabTrialResults);
			}
			else
			{
				return ChemicalLabTrial::ValueTypeToString(vt_ChemicalLabTrial);
			}
		}
		break;
	case LabTrial::indication::fractions:
		{
			if (is_result)
			{
				return FractionsLabTrialResults::ValueTypeToString(vt_FractionsLabTrialResults);
			}
			else
			{
				if (vt_FractionsLabTrial == FractionsLabTrial::value_type::vt_fractions_content)
				{
					char shigh[4096];
					char slow[4096];
					sprintf(shigh, "%f", this->fraction_diameter_high);
					sprintf(slow,  "%f", this->fraction_diameter_low);
					DeleteEndZeros(shigh);
					DeleteEndZeros(slow);	
					
					char str[4096];
					if (this->fraction_diameter_high == DBL_MAX)
					{
						if (this->fraction_diameter_low >= 200.)
						{
							sprintf(str, "Фракция валунов и глыб ( > %s)", slow);
						}
						else if (this->fraction_diameter_low >= 20.)
						{
							sprintf(str, "Фракция гальки и щебеня ( > %s)", slow);
						}						
						else if (this->fraction_diameter_low >= 2.)
						{
							sprintf(str, "Фракция Гравия и дресвы ( > %s)", slow);
						}
						else if (this->fraction_diameter_low >= 1.0)
						{
							sprintf(str, "Грубо песчаная фракция ( > %s)", slow);
						}						
						else if (this->fraction_diameter_low >= 0.5)
						{
							sprintf(str, "Круно песчаная фракция ( > %s)", slow);
						}
						else
							sprintf(str, "%s диам. > %s", FractionsLabTrial::ValueTypeToString(vt_FractionsLabTrial), slow);
					}
					else if (this->fraction_diameter_low == -DBL_MAX)
					{
						if (this->fraction_diameter_high <= 0.005)
						{
							sprintf(str, "Глинистая фракция ( < %s)", shigh);
						}
						else
							sprintf(str, "%s диам. < %s", FractionsLabTrial::ValueTypeToString(vt_FractionsLabTrial), shigh);
					}
					else
					{
						if (this->fraction_diameter_low >= 800. && this->fraction_diameter_high < DBL_MAX)
						{
							sprintf(str, "Фракция крупных валунов и глыб (%s - %s)", shigh, slow);
						}						
						else if (this->fraction_diameter_low >= 400. && this->fraction_diameter_high <= 800)
						{
							sprintf(str, "Фракция средних валунов и глыб (%s - %s)", shigh, slow);
						}							
						else if (this->fraction_diameter_low >= 200. && this->fraction_diameter_high <= 400)
						{
							sprintf(str, "Фракция мелких валунов и глыб (%s - %s)", shigh, slow);
						}	

						else if (this->fraction_diameter_low >= 200. && this->fraction_diameter_high < DBL_MAX)
						{
							sprintf(str, "Фракция валунов и глыб (%s - %s)", shigh, slow);
						}	



						else if (this->fraction_diameter_low >= 100. && this->fraction_diameter_high <= 200.0)
						{
							sprintf(str, "Фракция очень крупных гальки и щебеня (%s - %s)", shigh, slow);
						}							
						else if (this->fraction_diameter_low >= 60. && this->fraction_diameter_high <= 100.0)
						{
							sprintf(str, "Фракция крупных гальки и щебеня (%s - %s)", shigh, slow);
						}						
						else if (this->fraction_diameter_low >= 40. && this->fraction_diameter_high <= 60.0)
						{
							sprintf(str, "Фракция средних гальки и щебеня (%s - %s)", shigh, slow);
						}						
						else if (this->fraction_diameter_low >= 20. && this->fraction_diameter_high <= 40.0)
						{
							sprintf(str, "Фракция мелких гальки и щебеня (%s - %s)", shigh, slow);
						}						
						
						else if (this->fraction_diameter_low >= 20. && this->fraction_diameter_high <= 200.0)
						{
							sprintf(str, "Фракция гальки и щебеня (%s - %s)", shigh, slow);
						}	


						else if (this->fraction_diameter_low >= 10. && this->fraction_diameter_high <= 20.0)
						{
							sprintf(str, "Фракция крупных гравия и дресвы (%s - %s)", shigh, slow);
						}						
						else if (this->fraction_diameter_low >= 4. && this->fraction_diameter_high <= 10.0)
						{
							sprintf(str, "Фракция крупных гравия и дресвы (%s - %s)", shigh, slow);
						}						
						else if (this->fraction_diameter_low >= 2. && this->fraction_diameter_high <= 4.0)
						{
							sprintf(str, "Фракция крупных гравия и дресвы (%s - %s)", shigh, slow);
						}						
						
						else if (this->fraction_diameter_low >= 2. && this->fraction_diameter_high <= 20.0)
						{
							sprintf(str, "Фракция Гравия и дресвы (%s - %s)", shigh, slow);
						}

						else if (this->fraction_diameter_low >= 1. && this->fraction_diameter_high <= 2.0)
						{
							sprintf(str, "Грубая песчаная фракция (%s - %s)", shigh, slow);
						}						
						else if (this->fraction_diameter_low >= 0.5 && this->fraction_diameter_high <= 1.0)
						{
							sprintf(str, "Крупная песчаная фракция (%s - %s)", shigh, slow);
						}						
						else if (this->fraction_diameter_low >= 0.25 && this->fraction_diameter_high <= 0.5)
						{
							sprintf(str, "Средняя песчаная фракция (%s - %s)", shigh, slow);
						}
						else if (this->fraction_diameter_low >= 0.1 && this->fraction_diameter_high <= 0.25)
						{
							sprintf(str, "Мелкая песчаная фракция (%s - %s)", shigh, slow);
						}
						else if (this->fraction_diameter_low >= 0.05 && this->fraction_diameter_high <= 0.1)
						{
							sprintf(str, "Тонкая песчаная фракция (%s - %s)", shigh, slow);
						}

						else if (this->fraction_diameter_low >= 0.05 && this->fraction_diameter_high <= 2.0)
						{
							sprintf(str, "Песчаная фракция (%s - %s)", shigh, slow);
						}


						else if (this->fraction_diameter_low >= 0.01 && this->fraction_diameter_high <= 0.05)
						{
							sprintf(str, "Крупная пылеватая фракция (%s - %s)", shigh, slow);
						}
						else if (this->fraction_diameter_low >= 0.005 && this->fraction_diameter_high <= 0.01)
						{
							sprintf(str, "Мелкая пылеватая фракция (%s - %s)", shigh, slow);
						}


						else if (this->fraction_diameter_low >= 0.005 && this->fraction_diameter_high <= 0.05)
						{
							sprintf(str, "Пылеватая фракция (%s - %s)", shigh, slow);
						}

						else
							sprintf(str, "%s диам. %s - %s", FractionsLabTrial::ValueTypeToString(vt_FractionsLabTrial), shigh, slow);
					}

					return _strdup( str );
				}
				else
					return FractionsLabTrial::ValueTypeToString(vt_FractionsLabTrial);
			}
		}
		break;	
	case LabTrial::indication::compression_3:
		{
			return this->vt_Compression_3.GetValueTypeString();
		}
		break;
	case LabTrial::indication::compression_nature_condition_absolute_deformation:
	case LabTrial::indication::compression_task_condition_absolute_deformation:
	case LabTrial::indication::compression_shrinkage_absolute_deformation:
		{
			return this->vt_Compression.GetValueTypeString();
		}
		break;
	case LabTrial::indication::cut_resistance_nature_condition:
	case LabTrial::indication::cut_resistance_task_condition:
		{
			switch(m_indication)			
			{	
				case LabTrial::indication::cut_resistance_nature_condition:
					//this->cut_type = CutLabTrial::type::nature_condition;
					break;
				case LabTrial::indication::cut_resistance_task_condition:
					//this->cut_type = CutLabTrial::type::task_condition;
					break;
			}
			if (is_result)
			{
				return CutLabTrialResults::ValueTypeToString(vt_CutLabTrialResults, this->every_cut_experiment);
			}
			else
			{
				if (vt_CutLabTrial == CutLabTrial::value_type::vt_cut_resistance)
				{
					char str[4096];
					sprintf(str, "%s давл. %f", CutLabTrial::ValueTypeToString(vt_CutLabTrial), this->cut_pressure);
					DeleteEndZeros(str);	
					return _strdup( str );
				}
				else
					return CutLabTrial::ValueTypeToString(vt_CutLabTrial);
			}
		}
		break;
#if 0
	case LabTrial::indication::pressing:
		{
			if (is_result)
			{
				return PressingLabTrialResults::ValueTypeToString(vt_PressingLabTrialResults);
			}
			else
			{
				return PressingLabTrial::ValueTypeToString(vt_PressingLabTrial);
			}
		}
		break;	
	case LabTrial::indication::filtration_coefficient_with_pressures:
	case LabTrial::indication::filtration_coefficient_with_densities:
		{
			switch(m_indication)			
			{	
				case LabTrial::indication::filtration_coefficient_with_pressures:
					//this->filtr_type = FiltrationLabTrial::type::with_pressures;
					break;
				case LabTrial::indication::filtration_coefficient_with_densities:
					//this->filtr_type = FiltrationLabTrial::type::with_densities;
					break;
			}
			if (is_result)
			{
				return FiltrationLabTrialResults::ValueTypeToString(vt_FiltrationLabTrialResults);
			}
			else
			{
				return FiltrationLabTrial::ValueTypeToString(vt_FiltrationLabTrial);
			}
		}
		break;
#endif
	default:
		return "";
	}
		
	return "";
}

int LabTrialValueType::IsEvery()
{
	switch(m_indication)
	{
	case LabTrial::indication::undefined_lab_trial_indication:
		{
			return -1;
		}
		break;
	case LabTrial::indication::physical:
		{
			return -1;
		}
		break;
	case LabTrial::indication::chemical:
		{
			return -1;
		}
		break;
	case LabTrial::indication::fractions:
		{
			return -1;
		}
		break;	
	case LabTrial::indication::compression_3:
		{
			return this->vt_Compression_3.IsEvery();
		}
		break;
	case LabTrial::indication::compression_nature_condition_absolute_deformation:
	case LabTrial::indication::compression_task_condition_absolute_deformation:
	case LabTrial::indication::compression_shrinkage_absolute_deformation:
		{
			return this->vt_Compression.IsEvery();
		}
		break;
	case LabTrial::indication::cut_resistance_nature_condition:
	case LabTrial::indication::cut_resistance_task_condition:
		{
			return this->every_cut_experiment;
		}
		break;
#if 0
	case LabTrial::indication::pressing:
		{
			return -1;
		}
		break;	
	case LabTrial::indication::filtration_coefficient_with_pressures:
	case LabTrial::indication::filtration_coefficient_with_densities:
		{
			return -1;
		}
		break;
#endif
	default:
		return -1;
	}
		
	return -1;
}

void CompressionValueType_3::EnumValueTypes(LabLayer * lab_layer, LabParameters * lab_params, vector<fmtstr> * text, vector<LabData> * labdata, bool (LabLayer::*CallBack)(LabTrialValueType & vt, vector<fmtstr> * text, vector<LabData> * labdata))
{
	CompressionLabParameters3 * com_lab_params_3 = dynamic_cast<CompressionLabParameters3 *>(lab_params);

	if (com_lab_params_3)
	{
		this->com_type = CompressionLabTrial::type::nature_condition;
		vt_Compression_nature.com_type = CompressionLabTrial::type::nature_condition;
		vt_Compression_nature.EnumValueTypes(lab_layer, &com_lab_params_3->params_nature, text, labdata, CallBack);
		
		this->com_type = CompressionLabTrial::type::task_condition;
		vt_Compression_task.com_type = CompressionLabTrial::type::task_condition;
		vt_Compression_task.EnumValueTypes(lab_layer, &com_lab_params_3->params_task, text, labdata, CallBack);
		
		this->com_type = CompressionLabTrial::type::shrinkage;
		vt_Compression_shrinkage.com_type = CompressionLabTrial::type::shrinkage;
		vt_Compression_shrinkage.EnumValueTypes(lab_layer, &com_lab_params_3->params_shrinkage, text, labdata, CallBack);
	}

	bool res = false;

	if (com_lab_params_3)
	{
		for (CompressionLabTrialResults3::value_type 
			vt = CompressionLabTrialResults3::value_type::none;
			vt != CompressionLabTrialResults3::value_type::end; 
		vt++)
		{
			this->com_type = CompressionLabTrial::type::tri;
			this->vt_CompressionLabTrialResults3 = vt;
			res |= lab_layer->EvalCallBack(CallBack, *(this->m_LabTrialValueType), text, labdata);
		}
	}
}
void CompressionValueType::EnumValueTypes(LabLayer * lab_layer, LabParameters * lab_params, vector<fmtstr> * text, vector<LabData> * labdata, bool (LabLayer::*CallBack)(LabTrialValueType & vt, vector<fmtstr> * text, vector<LabData> * labdata))
{
	if (this->m_LabTrialValueType)
	{
		bool res = false;			

		char str[1024];
		switch(this->m_LabTrialValueType->m_indication)			
		{	
			case LabTrial::indication::compression_nature_condition_absolute_deformation:
				this->com_type = CompressionLabTrial::type::nature_condition;
				break;
			case LabTrial::indication::compression_task_condition_absolute_deformation:
				this->com_type = CompressionLabTrial::type::task_condition;
				break;
			case LabTrial::indication::compression_shrinkage_absolute_deformation:
				this->com_type = CompressionLabTrial::type::shrinkage;
				break;
		}
		CompressionLabParameters * com_lab_params = dynamic_cast<CompressionLabParameters *>(lab_params);
		if (this->m_LabTrialValueType->is_result)
		{
			//sprintf(str, "Компрессия %s (расчётн.):", CompressionLabTrial::CompressionLabTrialTypeToStringRus(com_type));
			
			//if (text) text->push_back(fmtstr(str, NULL, true, false));

			for (this->n_compression_value_type = 0; this->n_compression_value_type <= 4; this->n_compression_value_type++)
			{
				switch(this->n_compression_value_type)
				{
				case 0:
					{
						if ((com_lab_params && com_lab_params->parameters_results ? com_lab_params->parameters_results->GetCheckedLabParam() : true))
						{
							for (CompressionLabTrialResults::value_type_0 vt_0 = CompressionLabTrialResults::value_type_0::none_0;
								vt_0 != CompressionLabTrialResults::value_type_0::end_0; vt_0++)
							{
								this->vt_CompressionLabTrialResults_0 = vt_0;
								res |= lab_layer->EvalCallBack(CallBack, *(this->m_LabTrialValueType), text, labdata);
							}
						}
					}
					break;
#if USE_COMPR_PO_OTN_DEF
				case 1:
					{
						this->every_compression_experiment = true;
						if ((com_lab_params && com_lab_params->parameters_results1_every ? com_lab_params->parameters_results1_every->GetCheckedLabParam() : true))
						{
							for (CompressionLabTrialResults::value_type_1 vt_1 = CompressionLabTrialResults::value_type_1::none_1;
								vt_1 != CompressionLabTrialResults::value_type_1::end_1; vt_1++)
							{
								this->vt_CompressionLabTrialResults_1 = vt_1;
								res |= lab_layer->EvalCallBack(CallBack, *(this->m_LabTrialValueType), text, labdata);
							}
						}
						this->every_compression_experiment = false;

						if ((com_lab_params && com_lab_params->parameters_results1_common ? com_lab_params->parameters_results1_common->GetCheckedLabParam() : true))
						{
							/*lab_layer->CompressionNormatives1(m_indication, text, labdata);
							if (labdata)
							{
								labdata->push_back(LabData());
								text = &labdata->back().text;
							}	*/							
							
							/*for (CompressionLabTrialResults::value_type_1 vt_1 = CompressionLabTrialResults::value_type_1::none_1;
								vt_1 != CompressionLabTrialResults::value_type_1::end_1; vt_1++)
							{
								this->vt_CompressionLabTrialResults_1 = vt_1;
								res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
							}*/
						}
					}
					break;
#endif
				case 2:
					{
						this->every_compression_experiment = true;
						if ((com_lab_params && com_lab_params->parameters_results2_every ? com_lab_params->parameters_results2_every->GetCheckedLabParam() : true))
						{
							for (CompressionLabTrialResults::value_type_2 vt_2 = CompressionLabTrialResults::value_type_2::none_2;
								vt_2 != CompressionLabTrialResults::value_type_2::end_2; vt_2++)
							{
								this->vt_CompressionLabTrialResults_2 = vt_2;
								res |= lab_layer->EvalCallBack(CallBack, *(this->m_LabTrialValueType), text, labdata);
							}
						}
						this->every_compression_experiment = false;
						if ((com_lab_params && com_lab_params->parameters_results2_common ? com_lab_params->parameters_results2_common->GetCheckedLabParam() : true))
						{
							/*lab_layer->CompressionNormatives1(m_indication, text, labdata);
							if (labdata)
							{
								labdata->push_back(LabData());
								text = &labdata->back().text;
							}	*/
							/*for (CompressionLabTrialResults::value_type_2 vt_2 = CompressionLabTrialResults::value_type_2::none_2;
								vt_2 != CompressionLabTrialResults::value_type_2::end_2; vt_2++)
							{
								this->vt_CompressionLabTrialResults_2 = vt_2;
								res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
							}*/
						}
					}
					break;
				case 3:
					{
						this->every_compression_experiment = true;
						if ((com_lab_params && com_lab_params->parameters_results3_every ? com_lab_params->parameters_results3_every->GetCheckedLabParam() : true))
						{
							for (CompressionLabTrialResults::value_type_3 vt_3 = CompressionLabTrialResults::value_type_3::none_3;
								vt_3 != CompressionLabTrialResults::value_type_3::end_3; vt_3++)
							{
								this->vt_CompressionLabTrialResults_3 = vt_3;
								res |= lab_layer->EvalCallBack(CallBack, *(this->m_LabTrialValueType), text, labdata);
							}
						}
						this->every_compression_experiment = false;
						if ((com_lab_params && com_lab_params->parameters_results3_common ? com_lab_params->parameters_results3_common->GetCheckedLabParam() : true))
						{
							/*lab_layer->CompressionNormatives1(m_indication, text, labdata);
							if (labdata)
							{
								labdata->push_back(LabData());
								text = &labdata->back().text;
							}	*/

							/*for (CompressionLabTrialResults::value_type_3 vt_3 = CompressionLabTrialResults::value_type_3::none_3;
								vt_3 != CompressionLabTrialResults::value_type_3::end_3; vt_3++)
							{
								this->vt_CompressionLabTrialResults_3 = vt_3;
								res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
							}*/
						}
					}
					break;
				}
			}
			



			//if (!res && text) text->erase(text->end() - 1);
		}
		else
		{
			if (lab_params->parameters_initial && lab_params->parameters_initial->GetCheckedLabParam())
			{				
				sprintf(str, "Компрессия %s:", CompressionLabTrial::CompressionLabTrialTypeToStringRus(com_type));
				if (text) text->push_back(fmtstr(str, NULL, true, false));
				this->vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_absolute_deformation;
				res |= lab_layer->EvalCallBack(CallBack, *(this->m_LabTrialValueType), text, labdata);			
				if (!res && text) text->erase(text->end() - 1);
			}
		}
	}
}
void LabTrialValueType::EnumValueTypes(LabLayer * lab_layer, vector<fmtstr> * text, vector<LabData> * labdata, bool (LabLayer::*CallBack)(LabTrialValueType & vt, vector<fmtstr> * text, vector<LabData> * labdata))
{
		
	LabParameters * lab_params = lab_layer->FindLabParameters(m_indication);

	if (!lab_params) return;

	bool res = false;			
	char str[1024];
	switch(m_indication)
	{
	case LabTrial::indication::physical:
		{
			if (is_result)
			{
				if (lab_params->parameters_results && lab_params->parameters_results->GetCheckedLabParam())
				{
					if (text) text->push_back(fmtstr("Физические свойства (расчётн.):", NULL, true, false));
					for (PhysicalLabTrialResults::value_type vt = PhysicalLabTrialResults::value_type::none;
						vt != PhysicalLabTrialResults::value_type::end; vt++)
					{
						this->vt_PhysicalLabTrialResults = vt;
						res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
					}
					if (!res && text) text->erase(text->end() - 1);
				}
			}
			else
			{
				if (lab_params->parameters_initial && lab_params->parameters_initial->GetCheckedLabParam())
				{
					if (text) text->push_back(fmtstr("Физические свойства:", NULL, true, false));
					for (PhysicalLabTrial::value_type vt = PhysicalLabTrial::value_type::none;
						vt != PhysicalLabTrial::value_type::end; vt++)
					{
						this->vt_PhysicalLabTrial = vt;
						res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
					}
					if (!res && text) text->erase(text->end() - 1);
				}
			}
		}
		break;
	case LabTrial::indication::chemical:
		{
			if (is_result)
			{
				if (lab_params->parameters_results && lab_params->parameters_results->GetCheckedLabParam())
				{
					if (text) text->push_back(fmtstr("Химические свойства (расчётн.):", NULL, true, false));
					for (ChemicalLabTrialResults::value_type vt = ChemicalLabTrialResults::value_type::none;
						vt != ChemicalLabTrialResults::value_type::end; vt++)
					{
						this->vt_ChemicalLabTrialResults = vt;
						res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
					}
					if (!res && text) text->erase(text->end() - 1);
				}
			}
			else
			{
				if (lab_params->parameters_initial && lab_params->parameters_initial->GetCheckedLabParam())
				{
					if (text) text->push_back(fmtstr("Химические свойства:", NULL, true, false));
					for (ChemicalLabTrial::value_type vt = ChemicalLabTrial::value_type::none;
						vt != ChemicalLabTrial::value_type::end; vt++)
					{
						this->vt_ChemicalLabTrial = vt;
						res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
					}
					if (!res && text) text->erase(text->end() - 1);
				}
			}
		}
		break;
	case LabTrial::indication::fractions:
		{
			if (is_result)
			{
				if (lab_params->parameters_results && lab_params->parameters_results->GetCheckedLabParam())
				{
					if (text) text->push_back(fmtstr("Фракции (расчётн.):", NULL, true, false));
					for (FractionsLabTrialResults::value_type vt = FractionsLabTrialResults::value_type::none;
						vt != FractionsLabTrialResults::value_type::end; vt++)
					{
						this->vt_FractionsLabTrialResults = vt;
						res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
					}
					if (!res && text) text->erase(text->end() - 1);
				}
			}
			else
			{
				if (lab_params->parameters_initial && lab_params->parameters_initial->GetCheckedLabParam())
				{
					if (text) text->push_back(fmtstr("Фракции:", NULL, true, false));
					for (FractionsLabTrial::value_type vt = FractionsLabTrial::value_type::vt_fractions_content;
						vt != FractionsLabTrial::value_type::end; vt++)
					{
						this->vt_FractionsLabTrial = vt;
						res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
					}
					if (!res && text) text->erase(text->end() - 1);
				}
			}
		}
		break;	
	case LabTrial::indication::compression_3:
		{
			this->vt_Compression_3.EnumValueTypes(lab_layer, lab_params, text, labdata, CallBack);
		}
		break;
	case LabTrial::indication::compression_nature_condition_absolute_deformation:
	case LabTrial::indication::compression_task_condition_absolute_deformation:
	case LabTrial::indication::compression_shrinkage_absolute_deformation:
		{
			this->vt_Compression.EnumValueTypes(lab_layer, lab_params, text, labdata, CallBack);
		}
		break;
	case LabTrial::indication::cut_resistance_nature_condition:
	case LabTrial::indication::cut_resistance_task_condition:
		{
			switch(m_indication)			
			{	
				case LabTrial::indication::cut_resistance_nature_condition:
					this->cut_type = CutLabTrial::type::nature_condition;
					break;
				case LabTrial::indication::cut_resistance_task_condition:
					this->cut_type = CutLabTrial::type::task_condition;
					break;
			}
			if (is_result)
			{
				if (every_cut_experiment)
				{
					if (lab_params->parameters_results && lab_params->parameters_results->GetCheckedLabParam())
					{
						sprintf(str, "Срез %s (расчётн.):", CutLabTrial::CutLabTrialTypeToStringRus(cut_type));
						if (text) text->push_back(fmtstr(str, NULL, true, false));
						for (CutLabTrialResults::value_type vt = CutLabTrialResults::value_type::none;
							vt != CutLabTrialResults::value_type::end; vt++)
						{
							this->vt_CutLabTrialResults = vt;
							res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
						}
						if (!res && text) text->erase(text->end() - 1);
					}
				}
				else
				{
				}
			}
			else
			{
				if (lab_params->parameters_initial && lab_params->parameters_initial->GetCheckedLabParam())
				{				
					sprintf(str, "Срез %s:", CutLabTrial::CutLabTrialTypeToStringRus(cut_type));
					if (text) text->push_back(fmtstr(str, NULL, true, false));
#if 0
					this->vt_CutLabTrial = CutLabTrial::value_type::vt_cut_resistance;
					res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
#else
					for (CutLabTrial::value_type vt = CutLabTrial::value_type::none;
						vt != CutLabTrial::value_type::end; vt++)
					{
						this->vt_CutLabTrial = vt;
						res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
					}
#endif
					if (!res && text) text->erase(text->end() - 1);
				}
			}
		}
		break;
	case LabTrial::indication::pressing:
		{
			if (is_result)
			{
				if (lab_params->parameters_results && lab_params->parameters_results->GetCheckedLabParam())
				{
					if (text) text->push_back(fmtstr("Одноосное сжатие (расчётн.):", NULL, true, false));
					for (PressingLabTrialResults::value_type vt = PressingLabTrialResults::value_type::none;
						vt != PressingLabTrialResults::value_type::end; vt++)
					{
						this->vt_PressingLabTrialResults = vt;
						res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
					}
					if (!res && text) text->erase(text->end() - 1);
				}
			}
			else
			{
				if (lab_params->parameters_initial && lab_params->parameters_initial->GetCheckedLabParam())
				{				
					if (text) text->push_back(fmtstr("Одноосное сжатие:", NULL, true, false));
					for (PressingLabTrial::value_type vt = PressingLabTrial::value_type::none;
						vt != PressingLabTrial::value_type::end; vt++)
					{
						this->vt_PressingLabTrial = vt;
						res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
					}
					if (!res && text) text->erase(text->end() - 1);
				}
			}
		}
		break;	
	case LabTrial::indication::filtration_coefficient_with_pressures:
	case LabTrial::indication::filtration_coefficient_with_densities:
		{
			switch(m_indication)			
			{	
				case LabTrial::indication::filtration_coefficient_with_pressures:
					this->filtr_type = FiltrationLabTrial::type::with_pressures;
					break;
				case LabTrial::indication::filtration_coefficient_with_densities:
					this->filtr_type = FiltrationLabTrial::type::with_densities;
					break;
			}
			if (is_result)
			{
				if (lab_params->parameters_results && lab_params->parameters_results->GetCheckedLabParam())
				{
					if (text) text->push_back(fmtstr("Фильтрация (расчётн.):", NULL, true, false));
					for (FiltrationLabTrialResults::value_type vt = FiltrationLabTrialResults::value_type::none;
						vt != FiltrationLabTrialResults::value_type::end; vt++)
					{
						this->vt_FiltrationLabTrialResults = vt;
						res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
					}
					if (!res && text) text->erase(text->end() - 1);
				}
			}
			else
			{
				if (lab_params->parameters_initial && lab_params->parameters_initial->GetCheckedLabParam())
				{					
					if (text) text->push_back(fmtstr("Фильтрация:", NULL, true, false));
					for (FiltrationLabTrial::value_type vt = FiltrationLabTrial::value_type::none;
						vt != FiltrationLabTrial::value_type::end; vt++)
					{
						this->vt_FiltrationLabTrial = vt;
						res |= lab_layer->EvalCallBack(CallBack, *this, text, labdata);
					}
					if (!res && text) text->erase(text->end() - 1);
				}
			}
		}
		break;
	default:
		{
		}
	}
}
int CompressionValueType_3::Get_n_compression_value_type()
{
	switch(this->com_type)
	{
	case CompressionLabTrial::type::nature_condition:
		return vt_Compression_nature.n_compression_value_type;
	case CompressionLabTrial::type::task_condition:
		return vt_Compression_task.n_compression_value_type;
	case CompressionLabTrial::type::shrinkage:
		return vt_Compression_shrinkage.n_compression_value_type;
	}
	return -1;
}
int CompressionValueType_3::IsEvery()
{
	switch(this->com_type)
	{
	case CompressionLabTrial::type::nature_condition:
		return vt_Compression_nature.IsEvery();
	case CompressionLabTrial::type::task_condition:
		return vt_Compression_task.IsEvery();
	case CompressionLabTrial::type::shrinkage:
		return vt_Compression_shrinkage.IsEvery();
	}
	return -1;
}
int CompressionValueType::IsEvery()
{
	if (this->m_LabTrialValueType)
	{	
		if (this->m_LabTrialValueType->is_result)
		{	
			return this->every_compression_experiment;
		}
	}
	return -1;
}

bool CompressionValueType_3::IsChecked(LabLayer * lab_layer, LabParameters * lab_params)
{
printf("CompressionValueType_3::IsChecked\n");
	CompressionLabParameters3 * comp_lab_params_3 = dynamic_cast<CompressionLabParameters3*>(lab_params);
	if(comp_lab_params_3)
	{
		switch(this->com_type)
		{
		case CompressionLabTrial::type::nature_condition:
			return vt_Compression_nature.IsChecked(lab_layer, &comp_lab_params_3->params_nature);
		case CompressionLabTrial::type::task_condition:
			return vt_Compression_task.IsChecked(lab_layer, &comp_lab_params_3->params_task);
		case CompressionLabTrial::type::shrinkage:
			return vt_Compression_shrinkage.IsChecked(lab_layer, &comp_lab_params_3->params_shrinkage);
		case CompressionLabTrial::type::tri:
			{
				LabParameter * param = comp_lab_params_3->params_tri.FindLabParameter(this->vt_CompressionLabTrialResults3);
				if (param)
				{
					return param->GetCheckedLabParam();
				}
			}
		}
	}
	return false;
}
bool CompressionValueType::IsChecked(LabLayer * lab_layer, LabParameters * lab_params)
{
printf("CompressionValueType::IsChecked \n");
	if (!lab_layer)
	{
		return false;
	}
printf("CompressionValueType::IsChecked 1 m_LabTrialValueType = %x\n", m_LabTrialValueType);
	if (this->m_LabTrialValueType)
	{	
printf("CompressionValueType::IsChecked 1 this->m_LabTrialValueType->is_result = %d\n", this->m_LabTrialValueType->is_result);
		if (this->m_LabTrialValueType->is_result)
		{						
			CompressionLabParameters * comp_lab_params = dynamic_cast<CompressionLabParameters*>(lab_params);
			if (comp_lab_params)
			{
				switch(this->n_compression_value_type)
				{
				case 0:
					{
						CompressionLabParametersResults * params_results = dynamic_cast<CompressionLabParametersResults*>(comp_lab_params->parameters_results);
						if (params_results)
						{
							LabParameter * param = params_results->FindLabParameter(this->vt_CompressionLabTrialResults_0);
							if (param)
							{
								return param->GetCheckedLabParam();
							}
						}
					}
					break;
#if 0
				case 1:
					{
						if (this->every_compression_experiment)
						{
							CompressionLabParametersResults1 * params_results1_every = dynamic_cast<CompressionLabParametersResults1*>(comp_lab_params->parameters_results1_every);
							if (params_results1_every)
							{
								LabParameter * param = params_results1_every->FindLabParameter(this->vt_CompressionLabTrialResults_1);
								if (param)
								{
									return param->GetCheckedLabParam();
								}
							}
						}
						else
						{
							CompressionLabParametersResults1 * params_results1_common = dynamic_cast<CompressionLabParametersResults1*>(comp_lab_params->parameters_results1_common);
							if (params_results1_common)
							{
								LabParameter * param = params_results1_common->FindLabParameter(this->vt_CompressionLabTrialResults_1);
								if (param)
								{
									return param->GetCheckedLabParam();
								}
							}
						}
					}
					break;
#endif
				case 2:
					{
						if (this->every_compression_experiment)
						{
							CompressionLabParametersResults2 * params_results2_every = dynamic_cast<CompressionLabParametersResults2*>(comp_lab_params->parameters_results2_every);
							if (params_results2_every)
							{
								LabParameter * param = params_results2_every->FindLabParameter(this->vt_CompressionLabTrialResults_2);
								if (param)
								{
									return param->GetCheckedLabParam();
								}
							}
						}
						else
						{
							CompressionLabParametersResults2 * params_results2_common = dynamic_cast<CompressionLabParametersResults2*>(comp_lab_params->parameters_results2_common);
							if (params_results2_common)
							{
								LabParameter * param = params_results2_common->FindLabParameter(this->vt_CompressionLabTrialResults_2);
								if (param)
								{
									return param->GetCheckedLabParam();
								}
							}
						}
					}
					break;
				case 3:
					{
						if (this->every_compression_experiment)
						{
							CompressionLabParametersResults3 * params_results3_every = dynamic_cast<CompressionLabParametersResults3*>(comp_lab_params->parameters_results3_every);
							if (params_results3_every)
							{
								LabParameter * param = params_results3_every->FindLabParameter(this->vt_CompressionLabTrialResults_3);
								if (param)
								{
									return param->GetCheckedLabParam();
								}
							}
						}
						else
						{
							CompressionLabParametersResults3 * params_results3_common = dynamic_cast<CompressionLabParametersResults3*>(comp_lab_params->parameters_results3_common);
							if (params_results3_common)
							{
								LabParameter * param = params_results3_common->FindLabParameter(this->vt_CompressionLabTrialResults_3);
								if (param)
								{
									return param->GetCheckedLabParam();
								}
							}
						}
					}
					break;
				}

			}
		}
		else
		{
//printf("CompressionValueType::IsChecked initial\n");
			CompressionLabParametersInitial * params = dynamic_cast<CompressionLabParametersInitial*>(lab_params->parameters_initial);
			if (params)
			{	
//printf("CompressionValueType::IsChecked initial 1\n");
				LabParameter * param = params->FindLabParameter(*(this->m_LabTrialValueType));
				if (param)
				{
//printf("CompressionValueType::IsChecked initial 2\n");
					return param->GetCheckedLabParam();
				}
			}
		}
	}
}

bool LabTrialValueType::IsChecked(LabLayer * lab_layer)
{
//if (m_indication == 12) printf("IsChecked\n");
	if (!lab_layer)
	{
		return false;
	}

	LabParameters * lab_params = lab_layer->FindLabParameters(this->m_indication);
	if (m_indication != LabTrial::indication::undefined_lab_trial_indication && !lab_params)
	{
		return false;
	}

	if (m_indication != LabTrial::indication::compression_3)
	{
		if (lab_params && !lab_params->parameters_results)
		{
			return false;
		}

		if (lab_params && !lab_params->parameters_initial)
		{
			return false;
		}
	}

	switch(m_indication)
	{
	case LabTrial::indication::undefined_lab_trial_indication:
		{
			switch (this->vt_common_type)
			{
			case LabTrialValueType::common_types::depth:
				{
					if(lab_layer->lab_parameter_depth)
					{
						return lab_layer->lab_parameter_depth->GetCheckedLabParam();
					}
				}
				break;
			}
		}
		break;
	case LabTrial::indication::physical:
		{
			if (is_result)
			{
				PhysicalLabParametersResults *	params_results = dynamic_cast<PhysicalLabParametersResults*>(lab_params->parameters_results);
				if (params_results)
				{
					LabParameter * param = params_results->FindLabParameter(this->vt_PhysicalLabTrialResults);
					if (param)
					{
						return param->GetCheckedLabParam();
					}
				}
			}
			else
			{
				PhysicalLabParametersInitial *	params = dynamic_cast<PhysicalLabParametersInitial*>(lab_params->parameters_initial);
				if (params)
				{
					LabParameter * param = params->FindLabParameter(this->vt_PhysicalLabTrial);
					if (param)
					{
						return param->GetCheckedLabParam();
					}
				}
			}

		}
		break;
	case LabTrial::indication::chemical:
		{
			if (is_result)
			{
				ChemicalLabParametersResults *	params_results = dynamic_cast<ChemicalLabParametersResults*>(lab_params->parameters_results);
				if (params_results)
				{
					LabParameter * param = params_results->FindLabParameter(this->vt_ChemicalLabTrialResults);
					if (param)
					{
						return param->GetCheckedLabParam();
					}
				}
			}
			else
			{
				ChemicalLabParametersInitial * params = dynamic_cast<ChemicalLabParametersInitial*>(lab_params->parameters_initial);
				if (params)
				{					
					LabParameter * param = params->FindLabParameter(this->vt_ChemicalLabTrial);
					if (param)
					{
						return param->GetCheckedLabParam();
					}
				}
			}
		}
		break;
	case LabTrial::indication::fractions:
		{
			if (is_result)
			{
				FractionsLabParametersResults *	params_results = dynamic_cast<FractionsLabParametersResults*>(lab_params->parameters_results);
				if (params_results)
				{
					LabParameter * param = params_results->FindLabParameter(this->vt_FractionsLabTrialResults);
					if (param)
					{
						return param->GetCheckedLabParam();
					}
				}
			}
			else
			{
				FractionsLabParametersInitial * params = dynamic_cast<FractionsLabParametersInitial*>(lab_params->parameters_initial);
				if (params)
				{		
#if FRACTION_LAB_PARAM_INITIAL_MAP
					if (this->vt_FractionsLabTrial == FractionsLabTrial::value_type::vt_fractions_content)
					{
						LabParameter * param = params->FindLabParameter(*this);
						if (param)
						{
							return param->GetCheckedLabParam();
						}
					}
					else
					{
						LabParameter * param = params->FindLabParameter(this->vt_FractionsLabTrial);
						if (param)
						{
							return param->GetCheckedLabParam();
						}
					}
#endif
				}
			}
		}
		break;	
	case LabTrial::indication::compression_3:
		{
			return vt_Compression_3.IsChecked(lab_layer, lab_params);
		}
		break;
	case LabTrial::indication::compression_nature_condition_absolute_deformation:
	case LabTrial::indication::compression_task_condition_absolute_deformation:
	case LabTrial::indication::compression_shrinkage_absolute_deformation:
		{
			return vt_Compression.IsChecked(lab_layer, lab_params);
		}
		break;
	case LabTrial::indication::cut_resistance_nature_condition:
	case LabTrial::indication::cut_resistance_task_condition:
		{            
			if (is_result)
			{
				if (every_cut_experiment)
				{
					CutLabParametersResults * params_results = dynamic_cast<CutLabParametersResults*>(lab_params->parameters_results);
					if (params_results)
					{
						LabParameter * param = params_results->FindLabParameter(this->vt_CutLabTrialResults);
						if (param)
						{
							return param->GetCheckedLabParam();
						}
					}
				}
				else
				{
					CutLabParameters * cut_params = dynamic_cast<CutLabParameters *>(lab_params);
					if(cut_params && cut_params->parameters_results_common)
					{
						LabParameter * param = cut_params->parameters_results_common->FindLabParameter(this->vt_CutLabTrialResults);
						if (param)
						{
							return param->GetCheckedLabParam();
						}

					}
				}
			}
			else
			{
				CutLabParametersInitial * params = dynamic_cast<CutLabParametersInitial*>(lab_params->parameters_initial);
				if (params)
				{
#if CUT_LAB_PARAM_INITIAL_MAP
					LabParameter * param = params->FindLabParameter(this->vt_CutLabTrial);
					if (param)
					{
						return param->m_bChecked;
					}
#endif
					LabParameter * param = params->FindLabParameter(*this);
					if (param)
					{
						return param->GetCheckedLabParam();
					}
				}
			}
		}
		break;
	case LabTrial::indication::pressing:
		{
			if (is_result)
			{
				PressingLabParametersResults * params_results = dynamic_cast<PressingLabParametersResults*>(lab_params->parameters_results);
				if (params_results)
				{
					LabParameter * param = params_results->FindLabParameter(this->vt_PressingLabTrialResults);
					if (param)
					{
						return param->GetCheckedLabParam();
					}
				}
			}
			else
			{
				PressingLabParametersInitial * params = dynamic_cast<PressingLabParametersInitial*>(lab_params->parameters_initial);
				if (params)
				{	
					LabParameter * param = params->FindLabParameter(this->vt_PressingLabTrial);
					if (param)
					{
						return param->GetCheckedLabParam();
					}
				}
			}
		}
		break;	
	case LabTrial::indication::filtration_coefficient_with_pressures:
	case LabTrial::indication::filtration_coefficient_with_densities:
		{
			if (is_result)
			{
				FiltrationLabParametersResults * params_results = dynamic_cast<FiltrationLabParametersResults*>(lab_params->parameters_results);
				if (params_results)
				{
					LabParameter * param = params_results->FindLabParameter(this->vt_FiltrationLabTrialResults);
					if (param)
					{
						return param->GetCheckedLabParam();
					}
				}
			}
			else
			{
				FiltrationLabParametersInitial * params = dynamic_cast<FiltrationLabParametersInitial*>(lab_params->parameters_initial);
				if (params)
				{
					LabParameter * param = params->FindLabParameter(this->vt_FiltrationLabTrial);
					if (param)
					{
						return param->GetCheckedLabParam();
					}
				}
			}
		}
		break;
	default:
		{
			return false;
		}
	}
	return false;
}


bool LabNumber::GetValue(LabTrialValueType & vt, trial_got_value & v)
{
	if (!this->m_bChecked_LabObject) 
		return false;

	if(vt.m_indication == LabTrial::indication::undefined_lab_trial_indication)
	{
		switch(vt.vt_common_type)
		{
		case LabTrialValueType::common_types::depth:
			{
				v.v = this->depth;
				v.pf = NULL;
				return true;
			}
			break;
		}
	}
#if USE_LAB_TRIALS_VECTOR
	LabTrial * labtrial = this->FindLabTrial(vt.m_indication, vt.m_id_vyprob);
	if (labtrial)
	{
		if(vt.is_result)
		{
			LabTrialResults * labtrialres = labtrial->results;
			if (labtrialres && labtrialres->GetValue(vt, v))
			{
				return true;
			}
		}
		else
		{
			if (labtrial->GetValue(vt, v))
			{
				return true;
			}
		}
	}
#else
	map<LabTrial::indication, LabTrial*>::iterator it = this->lab_trials.find(vt.m_indication);
	if (it != this->lab_trials.end())
	{
		if ((*it).second)
		{
			LabTrial * labtrial = (*it).second;

			if(vt.is_result)
			{
				LabTrialResults * labtrialres = labtrial->results;
				if (labtrialres && labtrialres->GetValue(vt, v))
				{
					return true;
				}
			}
			else
			{
				if (labtrial->GetValue(vt, v))
				{
					return true;
				}
			}
		}
	}
#endif
	return false;
}
bool LabLayer::EvalNormative2(LabTrialValueType & vt, vector<fmtstr> * text, vector<LabData> * labdata)
{		
	LabParameters * lab_params = this->FindLabParameters(vt.m_indication);
	switch(vt.m_indication)
	{
	case LabTrial::indication::compression_3:
		{
			CompressionLabParameters3 * comp_lab_param = dynamic_cast<CompressionLabParameters3 *>(lab_params);
			if (comp_lab_param)
			{
#if USE_COMPR_PO_OTN_DEF
				if (comp_lab_param->GetResult1CommonCheckedLabParam())
					this->Compression3Normatives_common_y(vt.m_indication, text, labdata);
#endif
				if (comp_lab_param->GetResult2CommonCheckedLabParam())
					this->Compression3Normatives_common_e(vt.m_indication, text, labdata);
				if (comp_lab_param->GetResult3CommonCheckedLabParam())
					this->Compression3Normatives_common_gurvich(vt.m_indication, text, labdata);
			}
			else
			{
#if USE_COMPR_PO_OTN_DEF	
				this->Compression3Normatives_common_y(vt.m_indication, text, labdata);
#endif
				this->Compression3Normatives_common_e(vt.m_indication, text, labdata);
				this->Compression3Normatives_common_gurvich(vt.m_indication, text, labdata);
			}
		}
		break;	
	case LabTrial::indication::compression_nature_condition_absolute_deformation:
	case LabTrial::indication::compression_task_condition_absolute_deformation:
	case LabTrial::indication::compression_shrinkage_absolute_deformation:
		{
			CompressionLabParameters * comp_lab_param = dynamic_cast<CompressionLabParameters *>(lab_params);
			if (comp_lab_param)
			{
#if USE_COMPR_PO_OTN_DEF
				if ( (comp_lab_param && comp_lab_param->parameters_results1_common) ? comp_lab_param->parameters_results1_common->GetCheckedLabParam() : true)
					this->CompressionNormatives_common_y(vt.m_indication, text, labdata);
#endif
				if ( (comp_lab_param && comp_lab_param->parameters_results2_common) ? comp_lab_param->parameters_results2_common->GetCheckedLabParam() : true)
					this->CompressionNormatives_common_e(vt.m_indication, text, labdata);
				if ( (comp_lab_param && comp_lab_param->parameters_results3_common) ? comp_lab_param->parameters_results3_common->GetCheckedLabParam() : true)
					this->CompressionNormatives_common_gurvich(vt.m_indication, text, labdata);
			}
			else
			{
#if USE_COMPR_PO_OTN_DEF	
				this->CompressionNormatives_common_y(vt.m_indication, text, labdata);
#endif
				this->CompressionNormatives_common_e(vt.m_indication, text, labdata);
				this->CompressionNormatives_common_gurvich(vt.m_indication, text, labdata);
			}
		}
		break;
	case LabTrial::indication::cut_resistance_nature_condition:
	case LabTrial::indication::cut_resistance_task_condition:
		{
			CutLabParameters * cut_lab_param = dynamic_cast<CutLabParameters *>(lab_params);
			if (cut_lab_param)
			{
				if ( (cut_lab_param && cut_lab_param->parameters_results_common) ? cut_lab_param->parameters_results_common->GetCheckedLabParam() : true)
					this->CutNormatives_common(vt.m_indication, text, labdata);
			}
			else
			{
				this->CutNormatives_common(vt.m_indication, text, labdata);
			}
		}
		break;
	}
	return true;
}
bool LabLayer::EvalCallBack(bool (LabLayer::*CallBack)(LabTrialValueType & vt, vector<fmtstr> * text, vector<LabData> * labdata), LabTrialValueType & vt, vector<fmtstr> * text, vector<LabData> * labdata)
{
	int i = 0;
	switch(vt.m_indication)
	{
	case LabTrial::indication::fractions:
		{
			if (vt.is_result)
			{
			}
			else
			{
				switch (vt.vt_FractionsLabTrial)
				{	
				case FractionsLabTrial::value_type::vt_fractions_content:
					{
						bool res = false;
						vt.vt_FractionsLabTrial = FractionsLabTrial::value_type::vt_n_fractions;						
						if (this->LabLayer::GetValueCallBack(vt, text))
						{
							for (i = 0; i < vt.n_fractions; i++)
							{
#if USE_FRACTION_DIAMETERS_INTERVAL
								vt.i_fraction = i;
								vt.vt_FractionsLabTrial = FractionsLabTrial::value_type::vt_fractions_diameter_low;
								bool res_low = this->LabLayer::GetValueCallBack(vt, text);
								vt.vt_FractionsLabTrial = FractionsLabTrial::value_type::vt_fractions_diameter_high;
								bool res_high = this->LabLayer::GetValueCallBack(vt, text);
								
								if (res_low && res_high)
								{
									vt.vt_FractionsLabTrial = FractionsLabTrial::value_type::vt_fractions_content;
									res |= (this->*CallBack)(vt, text, labdata);
								}
#else
								vt.vt_FractionsLabTrial = FractionsLabTrial::value_type::vt_fractions_diameter;
								vt.i_fraction = i;
								if (this->LabLayer::GetValueCallBack(vt, text))
								{
									vt.fraction_diameter_high = vt.fraction_diameter_low;
									vt.fraction_diameter_low = i == vt.n_fractions - 1 ? -DBL_MAX : vt.fraction_diameter;
									
									vt.vt_FractionsLabTrial = FractionsLabTrial::value_type::vt_fractions_content;
									res |= (this->*CallBack)(vt, text, labdata);
								}
#endif
							}							
							vt.fraction_diameter_high = DBL_MAX;
							vt.fraction_diameter_low = DBL_MAX;
						}	
						return res;
					}
					break;			
				}
			}			
		}
		break;

	case LabTrial::indication::compression_3:
		{
			switch(vt.vt_Compression_3.com_type)
			{
			case CompressionLabTrial::type::nature_condition:
				{
					if (vt.is_result)
					{
					}
					else
					{				
						switch (vt.vt_Compression_3.vt_Compression_nature.vt_CompressionLabTrial)
						{	
						case CompressionLabTrial::value_type::vt_absolute_deformation:
							{
								bool res = false;
								vt.vt_Compression_3.vt_Compression_nature.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_n_pressures;						
								if (this->LabLayer::GetValueCallBack(vt, text))
								{
									//printf("vt.n_compression_pressures = %d\n", vt.n_compression_pressures);

									for (i = 0; i < vt.vt_Compression_3.vt_Compression_nature.n_compression_pressures; i++)
									{
										vt.vt_Compression_3.vt_Compression_nature.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_pressure;
										vt.vt_Compression_3.vt_Compression_nature.i_compression_pressure = i;
										if (this->LabLayer::GetValueCallBack(vt, text))
										{
											vt.vt_Compression_3.vt_Compression_nature.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_absolute_deformation;
											res |= (this->*CallBack)(vt, text, labdata);
										}
									}							
								}	
								return res;
							}
							break;			
						}
					}
				}
				break;
			case CompressionLabTrial::type::task_condition:
				{
					if (vt.is_result)
					{
					}
					else
					{				
						switch (vt.vt_Compression_3.vt_Compression_task.vt_CompressionLabTrial)
						{	
						case CompressionLabTrial::value_type::vt_absolute_deformation:
							{
								bool res = false;
								vt.vt_Compression_3.vt_Compression_task.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_n_pressures;						
								if (this->LabLayer::GetValueCallBack(vt, text))
								{
									//printf("vt.n_compression_pressures = %d\n", vt.n_compression_pressures);

									for (i = 0; i < vt.vt_Compression_3.vt_Compression_task.n_compression_pressures; i++)
									{
										vt.vt_Compression_3.vt_Compression_task.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_pressure;
										vt.vt_Compression_3.vt_Compression_task.i_compression_pressure = i;
										if (this->LabLayer::GetValueCallBack(vt, text))
										{
											vt.vt_Compression_3.vt_Compression_task.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_absolute_deformation;
											res |= (this->*CallBack)(vt, text, labdata);
										}
									}							
								}	
								return res;
							}
							break;			
						}
					}
				}
				break;
			case CompressionLabTrial::type::shrinkage:
				{
					if (vt.is_result)
					{
					}
					else
					{				
						switch (vt.vt_Compression_3.vt_Compression_shrinkage.vt_CompressionLabTrial)
						{	
						case CompressionLabTrial::value_type::vt_absolute_deformation:
							{
								bool res = false;
								vt.vt_Compression_3.vt_Compression_shrinkage.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_n_pressures;						
								if (this->LabLayer::GetValueCallBack(vt, text))
								{
									//printf("vt.n_compression_pressures = %d\n", vt.n_compression_pressures);

									for (i = 0; i < vt.vt_Compression_3.vt_Compression_shrinkage.n_compression_pressures; i++)
									{
										vt.vt_Compression_3.vt_Compression_shrinkage.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_pressure;
										vt.vt_Compression_3.vt_Compression_shrinkage.i_compression_pressure = i;
										if (this->LabLayer::GetValueCallBack(vt, text))
										{
											vt.vt_Compression_3.vt_Compression_shrinkage.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_absolute_deformation;
											res |= (this->*CallBack)(vt, text, labdata);
										}
									}							
								}	
								return res;
							}
							break;			
						}
					}
				}
				break;
			}
		}
		break;

	case LabTrial::indication::compression_nature_condition_absolute_deformation:
	case LabTrial::indication::compression_task_condition_absolute_deformation:
	case LabTrial::indication::compression_shrinkage_absolute_deformation:
		{
			if (vt.is_result)
			{
			}
			else
			{				
				switch (vt.vt_Compression.vt_CompressionLabTrial)
				{	
				case CompressionLabTrial::value_type::vt_absolute_deformation:
					{
						bool res = false;
						vt.vt_Compression.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_n_pressures;						
						if (this->LabLayer::GetValueCallBack(vt, text))
						{
							//printf("vt.n_compression_pressures = %d\n", vt.n_compression_pressures);

							for (i = 0; i < vt.vt_Compression.n_compression_pressures; i++)
							{
								vt.vt_Compression.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_pressure;
								vt.vt_Compression.i_compression_pressure = i;
								if (this->LabLayer::GetValueCallBack(vt, text))
								{
									vt.vt_Compression.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_absolute_deformation;
									res |= (this->*CallBack)(vt, text, labdata);
								}
							}							
						}	
						return res;
					}
					break;			
				}
			}
		}
		break;
	case LabTrial::indication::cut_resistance_nature_condition:
	case LabTrial::indication::cut_resistance_task_condition:
		{
			if (vt.is_result)
			{
			}
			else
			{				
				switch (vt.vt_CutLabTrial)
				{	
				case CutLabTrial::value_type::vt_cut_resistance:
					{
						bool res = false;
						vt.vt_CutLabTrial = CutLabTrial::value_type::vt_n_pressures;						
						if (this->LabLayer::GetValueCallBack(vt, text))
						{
							for (i = 0; i < vt.n_cut_pressures; i++)
							{
								vt.vt_CutLabTrial = CutLabTrial::value_type::vt_pressure;
								vt.i_cut_pressure = i;
								if (this->LabLayer::GetValueCallBack(vt, text))
								{
									vt.vt_CutLabTrial = CutLabTrial::value_type::vt_cut_resistance;
									res |= (this->*CallBack)(vt, text, labdata);
								}
							}							
						}	
						return res;
					}
					break;		
				}
			}
		}
		break;
	}
	return (this->*CallBack)(vt, text, labdata);
}
bool LabLayer::GetValueCallBack(LabTrialValueType & vt, vector<fmtstr> * text)
{

	trial_got_value v;

	bool got = false;
	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		if (*it)
		{
			if ((*it)->GetValue(vt, v))
			{
				got = true;	
				break;
			}
		}
	}
	if (got)
	{	
		switch(vt.m_indication)
		{
		case LabTrial::indication::fractions:
			{
				if (vt.is_result)
				{
				}
				else
				{
					switch (vt.vt_FractionsLabTrial)
					{
					case FractionsLabTrial::value_type::vt_n_fractions:
						{
							vt.n_fractions = int(v.v);
							return true;
						}
						break;
#if USE_FRACTION_DIAMETERS_INTERVAL
					case FractionsLabTrial::value_type::vt_fractions_diameter_high:
						{
							vt.fraction_diameter_high = v.v;
							return true;
						}
						break;
					case FractionsLabTrial::value_type::vt_fractions_diameter_low:
						{
							vt.fraction_diameter_low = v.v;
							return true;
						}
						break;
#else
					case FractionsLabTrial::value_type::vt_fractions_diameter:
						{
							vt.fraction_diameter = v.v;
							return true;
						}
						break;
#endif
					}
				}				
			}
			break;
		case LabTrial::indication::compression_nature_condition_absolute_deformation:
		case LabTrial::indication::compression_task_condition_absolute_deformation:
		case LabTrial::indication::compression_shrinkage_absolute_deformation:
			{
				if (vt.is_result)
				{
				}
				else
				{				
					switch (vt.vt_Compression.vt_CompressionLabTrial)
					{	
					case CompressionLabTrial::value_type::vt_n_pressures:
						{
							vt.vt_Compression.n_compression_pressures = int(v.v);
							return true;
						}
						break;
					case CompressionLabTrial::value_type::vt_pressure:
						{
							vt.vt_Compression.compression_pressure = v.v;
							return true;
						}
						break;
					}

				}
			}
			break;
		case LabTrial::indication::compression_3:
			{
				switch(vt.vt_Compression_3.com_type)
				{
				case CompressionLabTrial::type::nature_condition:
					{
						if (vt.is_result)
						{
						}
						else
						{				
							switch (vt.vt_Compression_3.vt_Compression_nature.vt_CompressionLabTrial)
							{	
							case CompressionLabTrial::value_type::vt_n_pressures:
								{
									vt.vt_Compression_3.vt_Compression_nature.n_compression_pressures = int(v.v);
									return true;
								}
								break;
							case CompressionLabTrial::value_type::vt_pressure:
								{
									vt.vt_Compression_3.vt_Compression_nature.compression_pressure = v.v;
									return true;
								}
								break;
							}

						}
					}
					break;
				case CompressionLabTrial::type::task_condition:
					{
						if (vt.is_result)
						{
						}
						else
						{				
							switch (vt.vt_Compression_3.vt_Compression_task.vt_CompressionLabTrial)
							{	
							case CompressionLabTrial::value_type::vt_n_pressures:
								{
									vt.vt_Compression_3.vt_Compression_task.n_compression_pressures = int(v.v);
									return true;
								}
								break;
							case CompressionLabTrial::value_type::vt_pressure:
								{
									vt.vt_Compression_3.vt_Compression_task.compression_pressure = v.v;
									return true;
								}
								break;
							}

						}
					}
					break;
				case CompressionLabTrial::type::shrinkage:
					{
						if (vt.is_result)
						{
						}
						else
						{				
							switch (vt.vt_Compression_3.vt_Compression_shrinkage.vt_CompressionLabTrial)
							{	
							case CompressionLabTrial::value_type::vt_n_pressures:
								{
									vt.vt_Compression_3.vt_Compression_shrinkage.n_compression_pressures = int(v.v);
									return true;
								}
								break;
							case CompressionLabTrial::value_type::vt_pressure:
								{
									vt.vt_Compression_3.vt_Compression_shrinkage.compression_pressure = v.v;
									return true;
								}
								break;
							}

						}
					}
					break;
				}
			}
			break;

		case LabTrial::indication::cut_resistance_nature_condition:
		case LabTrial::indication::cut_resistance_task_condition:
			{
				if (vt.is_result)
				{
				}
				else
				{				
					switch (vt.vt_CutLabTrial)
					{	
					case CutLabTrial::value_type::vt_n_pressures:
						{
							vt.n_cut_pressures = int(v.v);
							return true;
						}
						break;
					case CutLabTrial::value_type::vt_pressure:
						{
							vt.cut_pressure = v.v;
							return true;
						}
						break;
					}
				}
			}
			break;
		}
	}		
	return got;
}
void LabLayer::PrintLabNumbers(vector<fmtstr> * text)
{
	bool got = false;
	int size = 0;
	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		if (*it)
		{
			if ((*it)->m_bChecked_LabObject)
			{
				got = true;	
				size++;
			}
		}
	}
	if (got)
	{
		char str[4098];
		char szBuff[128];
		int j;


		sprintf (str, "Лаб. номер:");
		if (text) text->push_back(fmtstr(str, NULL, size == 0, true));

		j = 0;
		for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
			it != this->lab_numbers.end(); it++)
		{
			if (*it)
			{
				if ((*it)->m_bChecked_LabObject)
				{
					sprintf(str, "%s", (*it)->ID.c_str());
					if (text) text->push_back(fmtstr(str, NULL, j == size-1, true));
					j++;		
				}
			}
		}

		sprintf (str, "Выработка:");
		if (text) text->push_back(fmtstr(str, NULL, size == 0, true));

		j = 0;
		for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
			it != this->lab_numbers.end(); it++)
		{
			if (*it)
			{
				if ((*it)->m_bChecked_LabObject)
				{
					strcpy(szBuff, (*it)->s_mine_working_type.c_str());
					OemToChar(szBuff, szBuff);

					sprintf(str, "%s %s", szBuff, (*it)->mine_working_number.c_str());

					if (text) text->push_back(fmtstr(str, NULL, j == size-1, true));
					j++;	
				}
			}
		}
#if 0
		LabTrialValueType vt;
		vt.clear();
		vt.m_indication = LabTrial::indication::undefined_lab_trial_indication;
		vt.vt_common_type = LabTrialValueType::common_types::depth;
		if (vt.IsChecked(this))
#else
		if (this->lab_parameter_depth && this->lab_parameter_depth->GetCheckedLabParam())
#endif
		{
			sprintf (str, "Глубина:");
			if (text) text->push_back(fmtstr(str, NULL, size == 0, true));

			j = 0;
			for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
				it != this->lab_numbers.end(); it++)
			{
				if (*it)
				{
					if ((*it)->m_bChecked_LabObject)
					{
						sprintf(str, "%f", (*it)->depth);
						DeleteEndZeros(str);
						if (text) text->push_back(fmtstr(str, NULL, j == size-1, true));
						j++;	
					}
				}
			}
		}
	}
}
void LabLayer::PrintNormativeHeaders(vector<fmtstr> * text)
{
	char str[4098];
	sprintf (str, " ");
	if (text) text->push_back(fmtstr(str, NULL, false, true));

	sprintf (str, "n");
	if (text) text->push_back(fmtstr(str, NULL, false, true));

	sprintf (str, "Xn");
	if (text) text->push_back(fmtstr(str, NULL, false, true));

	sprintf (str, "S");
	if (text) text->push_back(fmtstr(str, NULL, false, true));

	sprintf (str, "V");
	if (text) text->push_back(fmtstr(str, NULL, false, true));

//	sprintf (str, "ro_85");
//	if (text) text->push_back(fmtstr(str, NULL, false, true));

//	sprintf (str, "ro_95");
//	if (text) text->push_back(fmtstr(str, NULL, false, true));

	sprintf (str, "X_85");
	if (text) text->push_back(fmtstr(str, NULL, false, true));

	sprintf (str, "X_95");
	if (text) text->push_back(fmtstr(str, NULL, false, true));

	sprintf (str, "X_99");
	if (text) text->push_back(fmtstr(str, NULL, true, true));
}	
bool LabLayer::PrintAndNormativesCallBack(LabTrialValueType & vt, vector<fmtstr> * text, vector<LabData> * labdata)
{		
	bool res1 = true, res2 = true;
	if (LabLayer::context_with_lab_number_trial_list)
		res1 = PrintCallBack(vt, text, labdata);
	if (LabLayer::context_with_normatives)
		res2 = NormativesCallBack(vt, text, labdata);

	return res1 && res2;
}
bool LabLayer::PrintCallBack(LabTrialValueType & vt, vector<fmtstr> * text, vector<LabData> * labdata)
{
//if (vt.m_indication == 12) printf("PrintCallBack\n");
	if (!vt.IsChecked(this)) return false;
//if (vt.m_indication == 12) printf("PrintCallBack 2\n");

	trial_got_value v;

	bool got = false;
	int size = 0;
	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		if (*it)
		{
			if ((*it)->m_bChecked_LabObject)
			{
				if ((*it)->GetValue(vt, v))
				{
					got = true;	
				}
					
				size++;
			}
		}
	}
	if (got)
	{
//if (vt.m_indication == 12) printf("PrintCallBack 3\n");
		char str[4098];
		sprintf (str, "%s:", vt.GetValueTypeString());

		if (text) text->push_back(fmtstr(str, NULL, false, true));

		int j = 0;

		for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
			it != this->lab_numbers.end(); it++)
		{
			if (*it)
			{
				if ((*it)->m_bChecked_LabObject)
				{
					if ((*it)->GetValue(vt, v))
					{
						if (vt.m_indication == LabTrial::indication::physical && vt.is_result && vt.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_ground_type)
						{		
							CGround::ground_type t = (CGround::ground_type)(int)v.v;
							CGround::s_Quantity = CGround::Quantity::singular;
							sprintf(str, "%s\0",  CGround::GrountTypeToStringRus(t));
						}						
						else if (vt.m_indication == LabTrial::indication::physical && vt.is_result && vt.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_vlazhnost)
						{		
							PhysicalLabTrialResults::SandVlazhnost vzh = (PhysicalLabTrialResults::SandVlazhnost)(int)v.v;
							sprintf(str, "%s\0",  PhysicalLabTrialResults::SandVlazhnostToStringSmall(vzh));
						}
						else if (vt.m_indication == LabTrial::indication::physical && vt.is_result && vt.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_Consistencia_nature)
						{		
							PhysicalLabTrialResults::Consistencia con = (PhysicalLabTrialResults::Consistencia)(int)v.v;
							sprintf(str, "%s\0",  PhysicalLabTrialResults::ConsistenciaToStringSmall(con));
						}
						else if (vt.m_indication == LabTrial::indication::physical && vt.is_result && vt.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_Consistencia_water_saturated)
						{		
							PhysicalLabTrialResults::Consistencia con = (PhysicalLabTrialResults::Consistencia)(int)v.v;
							sprintf(str, "%s\0",  PhysicalLabTrialResults::ConsistenciaToStringSmall(con));
						}

						else if (vt.m_indication == LabTrial::indication::fractions && vt.is_result && vt.vt_FractionsLabTrialResults == FractionsLabTrialResults::value_type::vt_clay_soil_class)
						{
							FractionsLabTrialResults::ClaySoilsClass clay_soil_class = (FractionsLabTrialResults::ClaySoilsClass)(int)v.v;
							sprintf(str, "%s\0",  FractionsLabTrialResults::ClaySoilsClassToStringSmall(clay_soil_class));
						}
						else if (vt.m_indication == LabTrial::indication::fractions && vt.is_result && vt.vt_FractionsLabTrialResults == FractionsLabTrialResults::value_type::vt_sand_soil_class)
						{
							FractionsLabTrialResults::SandSoilsClass sand_soil_class = (FractionsLabTrialResults::SandSoilsClass)(int)v.v;
							sprintf(str, "%s\0",  FractionsLabTrialResults::SandSoilsClassToStringSmall(sand_soil_class));
						}
						else if (vt.m_indication == LabTrial::indication::fractions && vt.is_result && vt.vt_FractionsLabTrialResults == FractionsLabTrialResults::value_type::vt_neodnorodnost)
						{
							FractionsLabTrialResults::Neodnorodnost no = (FractionsLabTrialResults::Neodnorodnost)(int)v.v;
							sprintf(str, "%s\0",  FractionsLabTrialResults::NeodnorodnostToStringSmall(no));
						}
						else if (
							(vt.m_indication == LabTrial::indication::cut_resistance_nature_condition
							||
							vt.m_indication == LabTrial::indication::cut_resistance_task_condition)
							&& !vt.is_result && vt.vt_CutLabTrial == CutLabTrial::value_type::vt_hid)
						{
							long id_hid = (long)v.v;
							sprintf(str, "%s\0",  GetZrizHid_small(id_hid));
						}
						else if (
							(vt.m_indication == LabTrial::indication::cut_resistance_nature_condition
							||
							vt.m_indication == LabTrial::indication::cut_resistance_task_condition)
							&& !vt.is_result && vt.vt_CutLabTrial == CutLabTrial::value_type::vt_shema)
						{
							long id_shema = (long)v.v;
							sprintf(str, "%s\0",  GetZrizShema_small(id_shema));
						}
						else if (
							(vt.m_indication == LabTrial::indication::cut_resistance_nature_condition
							||
							vt.m_indication == LabTrial::indication::cut_resistance_task_condition)
							&& !vt.is_result && vt.vt_CutLabTrial == CutLabTrial::value_type::vt_stan)
						{
							long id_stan = (long)v.v;
							sprintf(str, "%s\0",  GetZrizStan_small(id_stan));
						}
						else
						{
							sprintf(str, "%f", v.v);
							DeleteEndZeros(str);
							if (strlen(str) > max_str_len_val_printf_fmtstr)
								sprintf(str, "%e", v.v);
						}
						if (text) text->push_back(fmtstr(str, v.pf, j == size-1, true));
					}
					else
					{
						if (text) text->push_back(fmtstr(" ", NULL,  j == size-1, true));
					}
						
					j++;	
				}
			}
		}
		return true;
	}		
//if (vt.m_indication == 12) printf("PrintCallBack 4\n");
	return false;
}
bool CorrelationCoefficient(vector<double> & v1, vector<double> & v2, vector<string> & vsx, double & k, PlotData * plot_data)
{
	size_t i, len = v1.size();

	if (len != v2.size())
		return false;

	if (len != vsx.size())
		return false;


	double 
		sum1 = 0.0,
		sum2 = 0.0;

	for (i = 0; i < len; i++)
	{
		sum1 += v1[i];
		sum2 += v2[i];
	}
	double 
		mean1 = sum1 / len,
		mean2 = sum2 / len;

	double 
		sigma1 = 0.0,
		sigma2 = 0.0,
		Cov = 0.0;

	if(plot_data)
	{
		plot_data->plot_lines.push_back(plot_line());
		plot_data->plot_lines.push_back(plot_line());
	}

	for (i = 0; i < len; i++)
	{
		sigma1 += (v1[i] - mean1)*(v1[i] - mean1);
		sigma2 += (v2[i] - mean2)*(v2[i] - mean2);
		Cov += (v1[i] - mean1)*(v2[i] - mean2);
	}

	for (i = 0; i < len; i++)
	{
		char str[1024];

		if(plot_data)
		{
			sprintf(str, "%0.3f", v1[i]); DeleteEndZeros(str);
			plot_data->plot_lines[0].data.push_back(plot_data_2d(i, (v1[i] - mean1)/sqrt(sigma1), vsx[i], str));
			sprintf(str, "%0.3f", v2[i]); DeleteEndZeros(str);
			plot_data->plot_lines[1].data.push_back(plot_data_2d(i, (v2[i] - mean2)/sqrt(sigma2), vsx[i], str));
		}
	}	
	k = Cov/sqrt(sigma1*sigma2);

	return true;
}

bool LabLayer::CorrelationCoefficient(LabTrialValueType & vt1, LabTrialValueType & vt2, vector<fmtstr> * text, vector<LabData> * labdata)
{
	trial_got_value v1;
	trial_got_value v2;

	vector <double> vv1, vv2;
	vector<string> vsx;
			
	//int i1 = vt1.GetI();		
	//int i2 = vt2.GetI();

	bool got = false;
	int size = 0;
	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		if (*it)
		{
			if ((*it)->GetValue(vt1, v1) && (*it)->GetValue(vt2, v2))
			{
				got = true;	
				vv1.push_back(v1.v);
				vv2.push_back(v2.v);
				vsx.push_back((*it)->ID);
			}
				
			size++;
		}
	}
		
	char str[4098];
	sprintf (str, "Коэффициент корреляции ( %s , %s ):", vt1.GetValueTypeString(), vt2.GetValueTypeString());
	
	if (labdata)
	{
		labdata->push_back(LabData());
		labdata->back().plot_data.title = str;
		labdata->back().plot_data.xlabel = "Лабораторный номер";
		labdata->back().plot_data.use_plot = true;
		labdata->back().plot_data.use_sx = true;
		labdata->back().plot_data.use_sy = true;
		labdata->back().plot_data.x_ax_not_dubl = true;
		
		text = &labdata->back().text;

		labdata->back().plot_data.lin_interp.push_back(LinInterp());
		labdata->back().plot_data.lin_interp.back().m_a0 = 0.0;
		labdata->back().plot_data.lin_interp.back().m_a1 = 0.0;
		labdata->back().plot_data.lin_interp.back().line_color = RGB(92,200,178);
		labdata->back().plot_data.lin_interp.back().line_style = PS_DOT;

	}

	double k;
	if (got && ::CorrelationCoefficient(vv1, vv2, vsx, k, labdata ? &labdata->back().plot_data : NULL))
	{

		if (text) text->push_back(fmtstr(str, NULL, false, false));

		sprintf(str, "%f", k);
		DeleteEndZeros(str);
		if (text) text->push_back(fmtstr(str, NULL, true,false));

		if (labdata)
		{
			sprintf (str, "Коэффициент корреляции ( %s , %s ) = %f", vt1.GetValueTypeString(), vt2.GetValueTypeString(), k);
			DeleteEndZeros(str);
			labdata->back().plot_data.title = str;
		}
	}		
	return false;
}
vector<excluded_lab_trial> Laboratory::excluded_trials;
bool LabLayer::CalcNormative(LabTrialValueType & vt, 
	vector<trial_got_value> & vv, 
	int & n, // количество определений
	trial_value & vn, // нормативное значение
	double & S, // среднеквадратическое отклонение 
	double & V  // коэффициент вариации
	)
{
	vector<trial_got_value>::iterator it;
	n = vv.size();

	while (n >= 6)
	{
		double sum = 0.0;
		n = 0;
		for (it = vv.begin();	it != vv.end(); it++)
		{
			if ((*it).pf)
			{
				if (*(*it).pf == TRIAL_VALUE_DEFINED || *(*it).pf == TRIAL_VALUE_INCLUDED || *(*it).pf == TRIAL_VALUE_DEFINED_CANNOT_EXCLUDED || *(*it).pf == TRIAL_VALUE_DEFINED_CAN_EXCLUDED_ONLY_BY_MINSQLIN || *(*it).pf == TRIAL_VALUE_EXCLUDED_BY_MINSQLIN || *(*it).pf == TRIAL_VALUE_INCLUDED_TO_MINSQLIN)  
				{
					// если значение ещё не исключено (1)
					// или если это значение нельзя исключать (2)
					sum += (*it).v;
					n++;
				}
			}
		}
		
		double vmean = sum / n;

		double sum2 = 0.0;
		for (it = vv.begin();	it != vv.end(); it++)
		{
			if ((*it).pf)
			{
				if (*(*it).pf == TRIAL_VALUE_DEFINED || *(*it).pf == TRIAL_VALUE_INCLUDED || *(*it).pf == TRIAL_VALUE_DEFINED_CANNOT_EXCLUDED || *(*it).pf == TRIAL_VALUE_DEFINED_CAN_EXCLUDED_ONLY_BY_MINSQLIN || *(*it).pf == TRIAL_VALUE_EXCLUDED_BY_MINSQLIN || *(*it).pf == TRIAL_VALUE_INCLUDED_TO_MINSQLIN)  
					// если значение ещё не исключено (1)
					// или если это значение нельзя исключать (2)
					sum2 += (vmean - (*it).v) * (vmean - (*it).v);
			}
		}	

		double sigma = sqrt(sum2/(n-1));


		double nju;// статистический критерий исключения возможных ошибок
		if(!GetNju_0_95(n, nju))
			return false;

		bool excluded = false;

		for (it = vv.begin(); it != vv.end(); it++)
		{
			if (fabs((*it).v - vmean) > nju * sigma)
				// если выполняется условие исключения
			{	
				if ((*it).pf)
				{	
					if (*(*it).pf == TRIAL_VALUE_DEFINED)  // если значение ранее не исключено
					{
						// исключаем
						*(*it).pf = TRIAL_VALUE_EXCLUDED;
						excluded = true;

						if ((*it).trial)
							(*it).trial->ExcludeConnected();

						if (!this->excluded_list_filled)
						{
							excluded_lab_trial exlt;

							char s[128];
							sprintf(s, "%s\0", this->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
							OemToChar(s, s);						
#endif

							exlt.lab_layer_number = s;
							exlt.labnumer_ID = (*it).lab_number ? (*it).lab_number->ID : "undefined";
							exlt.depth = (*it).lab_number ? (*it).lab_number->depth : 0.0;
							exlt.m_mine_working_type = (*it).lab_number ? (*it).lab_number->m_mine_working_type : LabNumber::mine_working_type::undefined;
							exlt.mine_working_number = (*it).lab_number ? (*it).lab_number->mine_working_number : "undefined";

							exlt.pf = (*it).pf;
							exlt.v = (*it).v;
							exlt.vt = vt;

							exlt.trial = (*it).trial;

							Laboratory::excluded_trials.push_back(exlt);
						}
					}
				}
			}
		}

		// заново рассчитываем количество неисключённых значений
		n = 0;
		for (it = vv.begin();	it != vv.end(); it++)
		{
			if ((*it).pf)
			{
				if (*(*it).pf == TRIAL_VALUE_DEFINED || *(*it).pf == TRIAL_VALUE_INCLUDED || *(*it).pf == TRIAL_VALUE_DEFINED_CANNOT_EXCLUDED || *(*it).pf == TRIAL_VALUE_DEFINED_CAN_EXCLUDED_ONLY_BY_MINSQLIN || *(*it).pf == TRIAL_VALUE_EXCLUDED_BY_MINSQLIN || *(*it).pf == TRIAL_VALUE_INCLUDED_TO_MINSQLIN)  
					// если значение ещё не исключено (1)
					// или если это значение нельзя исключать (2)
				{
					n++;
				}
			}
		}
		if (!excluded)
		{
			vn = vmean;
			S = sigma;
			V = S / vn.v;			
			return true;
		}
	}
	return false;
}

bool LabLayer::CalcNormative(
	vector<trial_got_value> & vv, 
	int & norm, // нормативное значение
	int & n
	)
{
	map<int,int> freq;

	freq.clear();
	for (vector<trial_got_value>::iterator it = vv.begin();	it != vv.end(); it++)
	{
		int value = (int)(*it).v;
		if (freq.find(value) == freq.end())
		{
			freq.insert(map<int,int>::value_type(value, 1));
		}
		else
		{
			freq[value]++;
		}
	}

	n = 0;
	for (map<int,int>::iterator mit = freq.begin(); mit != freq.end(); mit++)
	{
		if ((*mit).second > n)
		{
			n = (*mit).second;
			norm = (*mit).first;
		}
		else if ((*mit).second == n)
		{
			return false;
		}
	}
	return true;
}

bool Get_t_alpha( alpha_value av, int K, double & t_alpha)
{
	double valpha[] = {0.85, 0.90, 0.95, 0.975, 0.98, 0.99};
	//																															17	18		19	20		21
	int vK[]		= {   3,    4,   5,     6,    7,    8,    9,   10,   11,   12,   13,   14,   15,   16,   17,   18,   19,   20,   25,   30,   40,   60};
	double vt085 []	= {1.25, 1.19, 1.16, 1.13, 1.12, 1.11, 1.10, 1.10, 1.09, 1.08, 1.08, 1.08, 1.07, 1.07, 1.07, 1.07, 1.07, 1.06, 1.06, 1.05, 1.05, 1.05};
	double vt090 []	= {1.64, 1.53, 1.48, 1.44, 1.41, 1.40, 1.38, 1.37, 1.36, 1.36, 1.35, 1.34, 1.34, 1.34, 1.33, 1.33, 1.33, 1.32, 1.32, 1.31, 1.30, 1.30};
	double vt095 []	= {2.35, 2.13, 2.01, 1.94, 1.90, 1.86, 1.83, 1.81, 1.80, 1.78, 1.77, 1.76, 1.75, 1.75, 1.74, 1.73, 1.73, 1.72, 1.71, 1.70, 1.68, 1.67};
	double vt0975[]	= {3.18, 2.78, 2.57, 2.45, 2.37, 2.31, 2.26, 2.23, 2.20, 2.18, 2.16, 2.15, 2.13, 2.12, 2.11, 2.10, 2.09, 2.09, 2.06, 2.04, 2.02, 2.00};
	double vt098 []	= {3.45, 3.02, 2.74, 2.63, 2.54, 2.49, 2.44, 2.40, 2.36, 2.33, 2.30, 2.28, 2.27, 2.26, 2.25, 2.24, 2.23, 2.22, 2.19, 2.17, 2.14, 2.12};
	double vt099 []	= {4.54, 3.75, 3.36, 3.14, 3.00, 2.90, 2.82, 2.76, 2.72, 2.68, 2.65, 2.62, 2.60, 2.58, 2.57, 2.55, 2.54, 2.53, 2.49, 2.46, 2.42, 2.39};

	double * vt = NULL;
	switch (av)
	{
	case av_085:
		vt = vt085;
		break;
	case av_090:
		vt = vt090;
		break;
	case av_095:
		vt = vt095;
		break;
	case av_0975:
		vt = vt0975;
		break;
	case av_098:
		vt = vt098;
		break;
	case av_099:
		vt = vt099;
		break;
	}

	if (!vt)
		return false;

	if (K >= 3 && K <= 20)
	{
		t_alpha = vt[K-3];
		return true;
	}
	else if (K >= 20 && K <= 25)
	{
		t_alpha = vt[17] + (double(K - 20) / 5.0 ) * (vt[18]-vt[17]);
		return true;
	}	
	else if (K >= 25 && K <= 30)
	{
		t_alpha = vt[18] + (double(K - 25) / 5.0 ) * (vt[19]-vt[18]);
		return true;
	}
	else if (K >= 30 && K <= 40)
	{
		t_alpha = vt[19] + (double(K - 30) / 10.0 ) * (vt[20]-vt[19]);
		return true;
	}		
	else if (K >= 40 && K <= 60)
	{
		t_alpha = vt[20] + (double(K - 40) / 20.0 ) * (vt[21]-vt[20]);
		return true;
	}
	else if (K > 60)
	{
		t_alpha = vt[21];
		return true;
	}
	return false;
}
bool LabLayer::NormativesCallBack(LabTrialValueType & vt, vector<fmtstr> * text, vector<LabData> * labdata)
{
	// Знак для коэффициента надёжности
	int sign = vt.GetSignForReliabilityK();

	trial_got_value v;
	vector<trial_got_value> vv;

	bool got = false;
	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		if (*it)
		{
			if ((*it)->GetValue(vt, v))
			{
				v.lab_number = (*it);
				vv.push_back(v);
				got = true;	
			}
		}
	}
	return this->NormativesCallBack_body(sign, got, vv, vt, text, labdata);
}
bool LabLayer::NormativesCallBack_body(int sign, bool got, vector<trial_got_value> &vv, LabTrialValueType & vt, vector<fmtstr> * text, vector<LabData> * labdata)
{
	char str[4098];
	sprintf (str, "%s:", vt.GetValueTypeString());

	trial_value vn;
	double S;
	double V;
	int n = -1;
	if (got && CalcNormative(vt, vv, n, vn, S, V))
	{
		if (!vt.IsChecked(this)) text = NULL;

		if (text) text->push_back(fmtstr(str, NULL, false, true));

		sprintf (str, "%d", n);
		if (text) text->push_back(fmtstr(str, NULL, false, true));

		sprintf (str, "%f", vn.v);
		DeleteEndZeros(str);
		if (strlen(str) > max_str_len_val_printf_fmtstr)
			sprintf (str, "%e", vn.v);
		if (text) text->push_back(fmtstr(str, NULL, false, true));

		sprintf (str, "%f", S);
		DeleteEndZeros(str);
		if (strlen(str) > max_str_len_val_printf_fmtstr)
			sprintf (str, "%e", S);
		if (text) text->push_back(fmtstr(str, NULL, false, true));

		sprintf (str, "%f", V);
		DeleteEndZeros(str);
		if (strlen(str) > max_str_len_val_printf_fmtstr)
			sprintf (str, "%e", V);
		if (text) text->push_back(fmtstr(str, NULL, false, true));


		int K = n - 1;
		double t_alpha;
		trial_value ro_85; //bool calculed_ro_85 = false;
		trial_value ro_95; //bool calculed_ro_95 = false;
		trial_value ro_99; //bool calculed_ro_99 = false;

		alpha_value av = av_085;
		if (Get_t_alpha(av, K, t_alpha))
		{
			ro_85 = t_alpha * V / sqrt(double(n));
//			calculed_ro_85 = true;
		}

		av = av_095;
		if (Get_t_alpha(av, K, t_alpha))
		{
			ro_95 = t_alpha * V / sqrt(double(n));
//			calculed_ro_95 = true;
		}

		av = av_099;
		if (Get_t_alpha(av, K, t_alpha))
		{
			ro_99 = t_alpha * V / sqrt(double(n));
//			calculed_ro_99 = true;
		}


		trial_value v85; bool calculed_v85 = false;
		if (ro_85.f && sign)
		{
			v85 = vn * (1.0 + sign * ro_85);
			sprintf (str, "%f", v85.v);
			DeleteEndZeros(str);
			if (strlen(str) > max_str_len_val_printf_fmtstr)
				sprintf (str, "%e", v85.v);
			if (text) text->push_back(fmtstr(str, NULL, false, true));
			calculed_v85 = true;
		}
		else
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));
		}

		trial_value v95; bool calculed_v95 = false;
		if (ro_95.f && sign)
		{
			v95 = vn * (1.0 + sign * ro_95);
			sprintf (str, "%f", v95.v);
			DeleteEndZeros(str);
			if (strlen(str) > max_str_len_val_printf_fmtstr)
				sprintf (str, "%e", v95.v);
			if (text) text->push_back(fmtstr(str, NULL, false, true));
			calculed_v95 = true;
		}
		else
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));
		}

		trial_value v99; bool calculed_v99 = false;
		if (ro_99.f && sign)
		{
			v99 = vn * (1.0 + sign * ro_99);
			sprintf (str, "%f", v99.v);
			DeleteEndZeros(str);
			if (strlen(str) > max_str_len_val_printf_fmtstr)
				sprintf (str, "%e", v99.v);
			if (text) text->push_back(fmtstr(str, NULL, false, true));
			calculed_v99 = true;
		}
		else
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));
		}

		if (text) text->push_back(fmtstr("", NULL, true, true));

		if (vt.vt_CutLabTrialResults == CutLabTrialResults::value_type::vt_tgfi)
		{
			trial_value fi_n, fi_85, fi_95, fi_99;

			sprintf (str, "Угол внутреннего трения:");
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", n);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			fi_n = atan(vn.v)/PI*180.;
			sprintf (str, "%f", fi_n.v);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));
			if (text) text->push_back(fmtstr("", NULL, false, true));
			
			
			if (calculed_v85)
			{
				fi_85 = atan(v85.v)/PI*180.;
				sprintf (str, "%f", fi_85.v);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));
			}
			else
			{
				if (text) text->push_back(fmtstr("", NULL, false, true));
			}

			if (calculed_v95)
			{
				fi_95 = atan(v95.v)/PI*180.;
				sprintf (str, "%f", fi_95.v);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));
			}
			else
			{
				if (text) text->push_back(fmtstr("", NULL, false, true));
			}


			if (calculed_v99)
			{
				fi_99 = atan(v99.v)/PI*180.;
				sprintf (str, "%f", fi_99.v);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));
			}
			else
			{
				if (text) text->push_back(fmtstr("", NULL, false, true));
			}

			if (text) text->push_back(fmtstr("", NULL, true, true));

			LabTrialValueType vt_fi = vt;
			vt_fi.vt_CutLabTrialResults = CutLabTrialResults::value_type::vt_fi;

			if (this->lab_normatives)
				this->lab_normatives->values.insert(map<LabTrialValueType, 
				normative_value>::value_type(vt_fi, 
				normative_value(n, fi_n, fi_85, fi_95, fi_99, S, V, ro_85, ro_95, ro_99)));
		}

		//добавить нормативное значение в склад нормативных значений текущего слоя

		if (this->lab_normatives)
			this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt, normative_value(n, vn, v85, v95, v99, S, V, ro_85, ro_95, ro_99)));

		return true;
	}	
	else
	{
		switch (vt.m_indication)
		{
		case LabTrial::indication::physical:
			{
				if (vt.is_result)
				{
					if (vt.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_ground_type)
					{
						bool res = false;
						int norm;
						if (this->CalcNormative(vv, norm, n))
						{	
							if (vt.IsChecked(this))
							{
								sprintf (str, "%s (by freq):", vt.GetValueTypeString());
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								CGround::ground_type gt = (CGround::ground_type) norm;
								CGround::s_Quantity = CGround::Quantity::singular;
								sprintf (str, "%s", CGround::GrountTypeToStringRus(gt));
								
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								if (text) text->push_back(fmtstr("", NULL, true, true));
								//добавить нормативное значение в склад нормативных значений текущего слоя
								vn = norm;
								//if (this->lab_normatives)
								//	this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt, normative_value(n, vn, vn, vn, vn)));

								res = true;	
							}
						}
						if (this->lab_normatives)
						{
							// определяем тип грунта
							CGround::ground_type gt = CGround::ground_type::Undefined_ground;
							
							LabTrialValueType vtp;
							vtp.clear();
							vtp.m_indication = LabTrial::indication::physical;
							vtp.is_result = true;
							vtp.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_plasticity_index;
							vtp.m_lablayer = this;
							
							map<LabTrialValueType, normative_value>::iterator itmp = this->lab_normatives->values.find(vtp);
							if (itmp != this->lab_normatives->values.end())
							{
								// определяем тип грунта
								gt = DefineGroundType((*itmp).second.v_n.v);

								sprintf (str, "%s (by IP):", vt.GetValueTypeString());
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								CGround::s_Quantity = CGround::Quantity::singular;
								sprintf (str, "%s", CGround::GrountTypeToStringRus(gt));
								
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								if (text) text->push_back(fmtstr("", NULL, true, true));
								//добавить нормативное значение в склад нормативных значений текущего слоя
								vn = gt;
								if (this->lab_normatives)
									this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt, normative_value(n, vn, vn, vn, vn)));

								res = true;	
							}
							else
							{
								if (n >= 6)
								{
									// определяем тип грунта
									gt = CGround::ground_type::Sand;

									sprintf (str, "%s (by no IP):", vt.GetValueTypeString());
									if (text) text->push_back(fmtstr(str, NULL, false, true));

									CGround::s_Quantity = CGround::Quantity::singular;
									sprintf (str, "%s", CGround::GrountTypeToStringRus(gt));
									
									if (text) text->push_back(fmtstr(str, NULL, false, true));

									if (text) text->push_back(fmtstr("", NULL, true, true));
									//добавить нормативное значение в склад нормативных значений текущего слоя
									vn = gt;
									if (this->lab_normatives)
										this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt, normative_value(n, vn, vn, vn, vn)));

									res = true;	
								}
							}
						}

						return res;
					}
					if (vt.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_vlazhnost)
					{
						int norm;
						if (this->CalcNormative(vv, norm, n))
						{	
							if (vt.IsChecked(this))
							{
								sprintf (str, "%s:", vt.GetValueTypeString());
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								PhysicalLabTrialResults::SandVlazhnost vzh = (PhysicalLabTrialResults::SandVlazhnost) norm;
								sprintf (str, "%s", PhysicalLabTrialResults::SandVlazhnostToString(vzh));
								
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								if (text) text->push_back(fmtstr("", NULL, true, true));
								//добавить нормативное значение в склад нормативных значений текущего слоя
								vn = norm;
								if (this->lab_normatives)
									this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt, normative_value(n, vn, vn, vn, vn)));

								return true;	
							}
						}
					}
					if (vt.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_Consistencia_nature)
					{
						bool res = false;
						int norm;
						if (this->CalcNormative(vv, norm, n))
						{	
							if (vt.IsChecked(this))
							{
								sprintf (str, "%s (by freq):", vt.GetValueTypeString());
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								PhysicalLabTrialResults::Consistencia con = (PhysicalLabTrialResults::Consistencia) norm;
								sprintf (str, "%s", PhysicalLabTrialResults::ConsistenciaToString(con));
								
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								if (text) text->push_back(fmtstr("", NULL, true, true));
								//добавить нормативное значение в склад нормативных значений текущего слоя
								vn = norm;
								//if (this->lab_normatives)
								//	this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt, normative_value(n, vn, vn, vn, vn)));

								res = true;	
							}
						}
						if (this->lab_normatives)
						{
							// определяем IL
							
							LabTrialValueType vtf;
							vtf.clear();
							vtf.m_indication = LabTrial::indication::physical;
							vtf.is_result = true;
							vtf.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_fluidity_index_nature;
							vtf.m_lablayer = this;							
							map<LabTrialValueType, normative_value>::iterator itmf = this->lab_normatives->values.find(vtf);
							
							// определяем тип грунта by IP
							CGround::ground_type gt = CGround::ground_type::Undefined_ground;
							
							LabTrialValueType vtp;
							vtp.clear();
							vtp.m_indication = LabTrial::indication::physical;
							vtp.is_result = true;
							vtp.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_plasticity_index;
							vtp.m_lablayer = this;
							
							map<LabTrialValueType, normative_value>::iterator itmp = this->lab_normatives->values.find(vtp);
							
							if (itmp != this->lab_normatives->values.end() && itmf != this->lab_normatives->values.end())
							{
								// определяем тип грунта
								gt = DefineGroundType((*itmp).second.v_n.v);	

								PhysicalLabTrialResults::Consistencia consistencia_nature = PhysicalLabTrialResults::Consistencia::undefined_cons;



								switch (gt)
								{
								case CGround::ground_type::SandyLoam:
									{
										consistencia_nature = 
											Define_SandyLoam_Consistencia((*itmf).second.v_n.v);
									}
									break;
								case CGround::ground_type::Loam:
								case CGround::ground_type::Clay:
									{
										consistencia_nature = 
											Define_ClayAndLoam_Consistencia((*itmf).second.v_n.v);
									}
									break;
								}

								sprintf (str, "%s (by IL):", vt.GetValueTypeString());
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								sprintf (str, "%s", PhysicalLabTrialResults::ConsistenciaToString(consistencia_nature));
								
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								if (text) text->push_back(fmtstr("", NULL, true, true));
								//добавить нормативное значение в склад нормативных значений текущего слоя
								vn = consistencia_nature;
								if (this->lab_normatives)
									this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt, normative_value(n, vn, vn, vn, vn)));

								res = true;	
							}
						}

						return res;
					}				
					if (vt.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_Consistencia_water_saturated)
					{
						bool res = false;
						int norm;
						if (this->CalcNormative(vv, norm, n))
						{	
							if (vt.IsChecked(this))
							{
								sprintf (str, "%s (by freq):", vt.GetValueTypeString());
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								PhysicalLabTrialResults::Consistencia con = (PhysicalLabTrialResults::Consistencia) norm;
								sprintf (str, "%s", PhysicalLabTrialResults::ConsistenciaToString(con));
								
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								if (text) text->push_back(fmtstr("", NULL, true, true));
								//добавить нормативное значение в склад нормативных значений текущего слоя
								vn = norm;
								//if (this->lab_normatives)
								//	this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt, normative_value(n, vn, vn, vn, vn)));

								res = true;	
							}
						}
						if (this->lab_normatives)
						{
							// определяем IL
							
							LabTrialValueType vtf;
							vtf.clear();
							vtf.m_indication = LabTrial::indication::physical;
							vtf.is_result = true;
							vtf.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_fluidity_index_water_saturated;
							vtf.m_lablayer = this;							
							map<LabTrialValueType, normative_value>::iterator itmf = this->lab_normatives->values.find(vtf);
							
							// определяем тип грунта by IP
							CGround::ground_type gt = CGround::ground_type::Undefined_ground;
							
							LabTrialValueType vtp;
							vtp.clear();
							vtp.m_indication = LabTrial::indication::physical;
							vtp.is_result = true;
							vtp.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_plasticity_index;
							vtp.m_lablayer = this;
							
							map<LabTrialValueType, normative_value>::iterator itmp = this->lab_normatives->values.find(vtp);
							
							if (itmp != this->lab_normatives->values.end() && itmf != this->lab_normatives->values.end())
							{
								// определяем тип грунта
								gt = DefineGroundType((*itmp).second.v_n.v);	

								PhysicalLabTrialResults::Consistencia consistencia_water_saturated = PhysicalLabTrialResults::Consistencia::undefined_cons;

								switch (gt)
								{
								case CGround::ground_type::SandyLoam:
									{
										consistencia_water_saturated = 
											Define_SandyLoam_Consistencia((*itmf).second.v_n.v);
									}
									break;
								case CGround::ground_type::Loam:
								case CGround::ground_type::Clay:
									{
										consistencia_water_saturated = 
											Define_ClayAndLoam_Consistencia((*itmf).second.v_n.v);
									}
									break;
								}

								sprintf (str, "%s (by IL):", vt.GetValueTypeString());
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								sprintf (str, "%s", PhysicalLabTrialResults::ConsistenciaToString(consistencia_water_saturated));
								
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								if (text) text->push_back(fmtstr("", NULL, true, true));
								//добавить нормативное значение в склад нормативных значений текущего слоя
								vn = consistencia_water_saturated;
								if (this->lab_normatives)
									this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt, normative_value(n, vn, vn, vn, vn)));

								res = true;	
							}
						}

						return res;
					}				
				}
			}
			break;

		case LabTrial::indication::fractions:
			{
				if (vt.is_result)
				{
					if (vt.vt_FractionsLabTrialResults == FractionsLabTrialResults::value_type::vt_clay_soil_class)
					{
						int norm;
						if (this->CalcNormative(vv, norm, n))
						{	
							if (vt.IsChecked(this))
							{
								sprintf (str, "%s:", vt.GetValueTypeString());
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								FractionsLabTrialResults::ClaySoilsClass clay_soil_class = (FractionsLabTrialResults::ClaySoilsClass) norm;
								sprintf (str, "%s", FractionsLabTrialResults::ClaySoilsClassToStringSmall(clay_soil_class));
								
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								if (text) text->push_back(fmtstr("", NULL, true, true));

								//добавить нормативное значение в склад нормативных значений текущего слоя
								vn = norm;
								if (this->lab_normatives)
									this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt, normative_value(n, vn, vn, vn, vn)));

								return true;
							}
						}
					}
					if (vt.vt_FractionsLabTrialResults == FractionsLabTrialResults::value_type::vt_sand_soil_class)
					{
						int norm;
						if (this->CalcNormative(vv, norm, n))
						{	
							if (vt.IsChecked(this))
							{
								sprintf (str, "%s:", vt.GetValueTypeString());
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								FractionsLabTrialResults::SandSoilsClass sand_soil_class = (FractionsLabTrialResults::SandSoilsClass) norm;
								sprintf (str, "%s", FractionsLabTrialResults::SandSoilsClassToStringSmall(sand_soil_class));
								
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								if (text) text->push_back(fmtstr("", NULL, true, true));

								//добавить нормативное значение в склад нормативных значений текущего слоя
								vn = norm;
								if (this->lab_normatives)
									this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt, normative_value(n, vn, vn, vn, vn)));

								return true;
							}
						}
					}
					if (vt.vt_FractionsLabTrialResults == FractionsLabTrialResults::value_type::vt_neodnorodnost)
					{
						int norm;
						if (this->CalcNormative(vv, norm, n))
						{	
							if (vt.IsChecked(this))
							{
								sprintf (str, "%s:", vt.GetValueTypeString());
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								FractionsLabTrialResults::Neodnorodnost no = (FractionsLabTrialResults::Neodnorodnost) norm;
								sprintf (str, "%s", FractionsLabTrialResults::NeodnorodnostToString(no));
								
								if (text) text->push_back(fmtstr(str, NULL, false, true));

								if (text) text->push_back(fmtstr("", NULL, true, true));

								//добавить нормативное значение в склад нормативных значений текущего слоя
								vn = norm;
								if (this->lab_normatives)
									this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt, normative_value(n, vn, vn, vn, vn)));

								return true;
							}
						}
					}
				}
			}
			break;
		}
	}
	return false;
}
void LabLayer::CalcProperties()
{
	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		if (*it)
		{
			(*it)->CalcProperties();			
		}
	}
}

void LabLayer::ApplyParams()
{
	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		if (*it)
		{
			(*it)->ApplyParams();			
		}
	}
}

void LabLayer::ApplyZriz()
{
	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		if (*it)
		{
			(*it)->ApplyZriz(0);			
		}
	}
}


void LabLayer::ApplyCompress(bool use_compression3)
{
	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		if (*it)
		{
			(*it)->ApplyCompress(use_compression3, 0);			
		}
	}
}

void LabLayer::ApplyGranular()
{
	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		if (*it)
		{
			(*it)->ApplyGranular();			
		}
	}
}

void LabLayer::ParseTrialIndications()
{
	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		if (*it)
		{
			if (!(*it)->ParseTrialIndications())
			{
				// Ошибка в таком-то лабораторном номере отсутствуют признаки испытаний
				char str[4098];
				sprintf(str, "Ошибка в лабораторном номере %s отсутствуют признаки испытаний", (*it)->ID.c_str());
				//MessageBox(0, str, "Ошибка", 0);
			}
		}
	}
}



void LabLayer::ReCalcProperties(bool layer_recalc_e_log_interp, bool labnumber_recalc_e_log_interp)
{
	this->to_calc_e_log_interp = layer_recalc_e_log_interp;

	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		if (*it)
		{
			(*it)->ReCalcProperties(labnumber_recalc_e_log_interp);			
		}
	}
}


void LabLayer::GetSoilDescription(vector<SoilDescription> & vsd)
{
	vsd.clear();
	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		if (*it)
		{
			vsd.push_back((*it)->GetSoilDescription());			
		}
	}
}

void Get_V_alpha_lambda_095(double K, double lambda, double & V)
{
	double vK[] = {3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 25, 30, 40, 60 };
	double vLambda[] = 
		{0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0};
	double mV[22][11] = {
		{ 2.94, 2.98, 3.02, 3.05, 3.09, 3.11, 3.14, 3.16, 3.17, 3.18, 3.19},
		{ 2.61, 2.64, 2.67, 2.70, 2.72, 2.74, 2.75, 2.76, 2.77, 2.78, 2.78},
		{ 2.44, 2.47, 2.49, 2.51, 2.53, 2.54, 2.55, 2.56, 2.57, 2.57, 2.57},
		{ 2.34, 2.36, 2.38, 2.40, 2.41, 2.43, 2.44, 2.44, 2.45, 2.45, 2.45},
		{ 2.27, 2.29, 2.31, 2.33, 2.34, 2.35, 2.36, 2.36, 2.36, 2.36, 2.36},
		{ 2.22, 2.24, 2.26, 2.27, 2.28, 2.29, 2.30, 2.30, 2.31, 2.31, 2.31},
		{ 2.18, 2.20, 2.22, 2.23, 2.23, 2.24, 2.25, 2.26, 2.26, 2.26, 2.26},
		{ 2.15, 2.17, 2.19, 2.20, 2.21, 2.22, 2.22, 2.23, 2.23, 2.23, 2.23},
		{ 2.13, 2.15, 2.16, 2.17, 2.18, 2.19, 2.20, 2.20, 2.20, 2.20, 2.20},
		{ 2.11, 2.13, 2.14, 2.15, 2.16, 2.17, 2.18, 2.18, 2.18, 2.18, 2.18},
		{ 2.09, 2.11, 2.12, 2.14, 2.15, 2.15, 2.16, 2.16, 2.16, 2.16, 2.16},
		{ 2.08, 2.10, 2.11, 2.12, 2.13, 2.14, 2.14, 2.14, 2.15, 2.15, 2.15},
		{ 2.07, 2.08, 2.10, 2.11, 2.12, 2.12, 2.13, 2.13, 2.13, 2.13, 2.13},
		{ 2.06, 2.07, 2.09, 2.10, 2.11, 2.11, 2.12, 2.12, 2.12, 2.12, 2.12},
		{ 2.05, 2.06, 2.08, 2.09, 2.10, 2.10, 2.11, 2.11, 2.11, 2.11, 2.11},
		{ 2.04, 2.06, 2.07, 2.08, 2.09, 2.10, 2.10, 2.10, 2.10, 2.10, 2.10},
		{ 2.03, 2.05, 2.06, 2.07, 2.08, 2.09, 2.09, 2.09, 2.09, 2.09, 2.09},
		{ 2.03, 2.04, 2.06, 2.07, 2.08, 2.08, 2.08, 2.09, 2.09, 2.09, 2.09},
		{ 2.00, 2.02, 2.03, 2.04, 2.05, 2.06, 2.06, 2.06, 2.06, 2.06, 2.06},
		{ 1.99, 2.00, 2.02, 2.03, 2.03, 2.04, 2.04, 2.04, 2.04, 2.04, 2.04},
		{ 1.97, 1.99, 2.00, 2.01, 2.01, 2.02, 2.02, 2.02, 2.02, 2.02, 2.02},
		{ 1.95, 1.97, 1.98, 1.99, 2.00, 2.00, 2.00, 2.00, 2.00, 2.00, 2.00}
	};
	const int nLambda = sizeof(vLambda)/sizeof(double); //9
	const int nK = sizeof(vK)/sizeof(double);//13

	double ** zz = AllocDoubleMat(nK, nLambda);
	for (int r = 0; r < nK; r++)
	{
		for (int c = 0; c < nLambda; c++)
		{
			zz[r][c] = mV[r][c];
		}
	}

	linterp2(nLambda, vLambda, nK, vK, zz, lambda, K, V);
	FreeDoubleMat(zz);
}
void LabLayer::CutNormatives_common(LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata)
{


	// нормативные и расчётные значения угла внутреннего трения и удельного сцепления 
	// путём статистической обработки всех пар опытных значений

	vector<x_compression> vx;
	vector<trial_got_value> vy;
	vx.clear();
	vy.clear();

	char s[1024];
	sprintf(s,"\0");

	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		LabNumber * labnumber = (*it);
		if (labnumber)
		{
			LabTrial * trial = labnumber->FindLabTrial(t, -1);
			if (trial)
			{
				CutLabTrial * cut_lab_trial = dynamic_cast<CutLabTrial *>(trial);
				if (cut_lab_trial)
				{
					sprintf(s,"%s\0", CutLabTrial::CutLabTrialTypeToStringRusSmall(cut_lab_trial->cut_type));
					

					for(int i = 0; i < cut_lab_trial->n_pressures; i++)                                
						vx.push_back(cut_lab_trial->pressures[i]);

					for(int i = 0; i < cut_lab_trial->n_pressures; i++)   
					{
						trial_got_value y;
						y = cut_lab_trial->cut_resistances[i];
						y.lab_number = labnumber;
						y.trial = NULL;
						vy.push_back(y);
					}
				}
			}
		}
	}

	
	trial_value c;
	trial_value tgfi;
	double fi;
	trial_value Stau;
	int m;		
	LabTrialValueType vt;
	vt.m_indication = t;
	vt.is_result = false;
	vt.m_lablayer = this;

	vt.vt_CutLabTrial = CutLabTrial::value_type::vt_cut_resistance ;

		
	MinSqLinearStatParameters param; 
	if (MinSqLinearStat(vt, vx, vy, false, c, tgfi, m, Stau, param) && m)							
	{
		fi = atan(tgfi.v)/PI*180.;
			
		// расчётные значения 
		double tau_n_min = c.v + tgfi.v * param.x_min;
		double tau_n_max = c.v + tgfi.v * param.x_max;

		double V;
		Get_V_alpha_lambda_095(double(m-2), param.lambda, V);



		double delta_tau_min = V * Stau.v * param.Kx_min / sqrt(double(m));
		double delta_tau_max = V * Stau.v * param.Kx_max / sqrt(double(m));

		double tau_min = tau_n_min - delta_tau_min;
		double tau_max = tau_n_max - delta_tau_max;

		double gamma_g_tgfi_c;

		bool use_formula_21 = ((tau_min / param.x_min) < (tau_max / param.x_max));

		if (use_formula_21)
		{
			gamma_g_tgfi_c = (tau_n_min + tau_n_max) * param.x_max / (tau_max * (param.x_min + param.x_max));
		}
		else
		{
			gamma_g_tgfi_c = (tau_n_min + tau_n_max) / (tau_min + tau_max);
		}

		double c_95 = c.v / gamma_g_tgfi_c;
		double tgfi_95 = tgfi.v / gamma_g_tgfi_c;
		
		double fi_95 = atan(tgfi_95)/PI*180.;

		if (this->lab_normatives)
		{
			LabTrialValueType vt_res;

			vt_res.clear();
			vt_res.m_indication = t;
			vt_res.is_result = true;
			vt_res.every_cut_experiment = false;

			switch(t)
			{
			case LabTrial::indication::cut_resistance_nature_condition:
				vt_res.cut_type = CutLabTrial::type::nature_condition;
				break;
			case LabTrial::indication::cut_resistance_task_condition:
				vt_res.cut_type = CutLabTrial::type::task_condition;
				break;
			}
			vt_res.m_lablayer = this;

			vt_res.vt_CutLabTrialResults = CutLabTrialResults::value_type::vt_c;
			this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
				normative_value(m, c, trial_value(), trial_value(c_95), trial_value())));
		
			vt_res.vt_CutLabTrialResults = CutLabTrialResults::value_type::vt_tgfi;
			this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
				normative_value(m, tgfi, trial_value(), trial_value(tgfi_95), trial_value(),trial_value(),trial_value(),trial_value(),trial_value(),trial_value(), gamma_g_tgfi_c, param.x_min, param.x_max)));
		
			vt_res.vt_CutLabTrialResults = CutLabTrialResults::value_type::vt_fi;
			this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
				normative_value(m, fi, trial_value(), trial_value(fi_95), trial_value())));
		
			vt_res.vt_CutLabTrialResults = CutLabTrialResults::value_type::vt_Stau;
			this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
				normative_value(m, Stau, trial_value(), trial_value(), trial_value())));
		
		
		}


		char str[4098];
		sprintf (str, "Срез %s (по един.совок.оп.)", s);			
		
		if (text) text->push_back(fmtstr(str, NULL, true, true));

		if (labdata)
		{
			// plot
			labdata->back().plot_data.use_plot = true;
			labdata->back().plot_data.title = "Срез (по един.совок.оп.)";//str;
			labdata->back().plot_data.xlabel = "Давления, МПа";
			labdata->back().plot_data.ylabel = "Сопр.срезу, МПа";

			labdata->back().plot_data.lin_interp.push_back(LinInterp());
			labdata->back().plot_data.lin_interp.back().m_a0 = c.v;
			labdata->back().plot_data.lin_interp.back().m_a1 = tgfi.v;				

			labdata->back().plot_data.lin_interp.push_back(LinInterp());
			labdata->back().plot_data.lin_interp.back().m_a0 = c_95;
			labdata->back().plot_data.lin_interp.back().m_a1 = tgfi_95;
			labdata->back().plot_data.lin_interp.back().line_style = PS_DOT;

			labdata->back().plot_data.plot_lines.push_back(plot_line());

			labdata->back().plot_data.plot_lines.back().line_plot = false;


			for (size_t j = 0; j < vx.size() && j < vy.size(); j++)
			{
				labdata->back().plot_data.plot_lines.back().data.push_back(plot_data_2d(vx[j].x, vy[j].v));
			}



			labdata->push_back(LabData());
			text = &labdata->back().text;
		}
		{
			sprintf (str, "Удельное сцепление");
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", m);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%f", c.v);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "lambda=%f", param.lambda);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "V_95=%f", V);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "%f", c_95);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));
		}

		if (text) text->push_back(fmtstr("", NULL, true, true));

		{
			sprintf (str, "Тангенс угла внутреннего трения");
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", m);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%f", tgfi.v);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "Stau=%f", Stau.v);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "%f", tgfi_95);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));
		}

		if (text) text->push_back(fmtstr("", NULL, true, true));

		{
			sprintf (str, "Угол внутреннего трения");
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", m);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%f", fi);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "g_95=%f", gamma_g_tgfi_c);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "F2%d", use_formula_21);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "%f", fi_95);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}
		if (text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "tau_n_min=%f", tau_n_min);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "tau_n_max=%f", tau_n_max);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if (text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "delta_tau_min=%f", delta_tau_min);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "delta_tau_max=%f", delta_tau_max);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if (text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "param.Kx_min=%f", param.Kx_min);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "param.Kx_max=%f", param.Kx_max);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if (text) text->push_back(fmtstr("", NULL, true, true));

	}
	else
	{
	}
}

map<LabTrialValueType, normative_value>::iterator find2(LabTrialValueType & vt, std::map<LabTrialValueType,normative_value>& m)
{
	for (map<LabTrialValueType, normative_value>::iterator itm = m.begin(); 
		itm != m.end(); itm++)
	{
		if ((*itm).first == vt)
		{
			return itm;
		}
	}
	return m.end();
}
bool LabLayer::DefModuleNewRaschotnMethod = true;
//Def module new raschotn  method 
// считаем коэффициент надёжности для модуля деформации
//по всей совокупности опытов иначе чем срез, 
//изменив знак в формуле 19, перевернув формулу 20 
//и в любом случае не используя формулу 21

// использовать только для вычисления по относительной деформации, потому что 
// прослабление грунта увеличивает относительную деформацию
// в отличие от того, что прослабление грунта уменьшает 
// коеффициент пористости
// или значение сопротивления грунта срезу
#if USE_COMPR_PO_OTN_DEF

bool LabLayer::calc_E(int interval_type, int ntrial, 
			LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata,
			const char * s, 
			int type,
			bool use_text, 
			bool use_text2, 
			vector<x_compression> & vx,
			vector<trial_got_value> & vy, double * pressure_interval)
{
	trial_value a0;
	trial_value a1;
	trial_value Sepsilon;
	int m;		
	LabTrialValueType vt;
	vt.m_indication = t;
	vt.is_result = false;
	vt.m_lablayer = this;
	vt.vt_Compression.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_relative_deformation ;
		
	MinSqLinearStatParameters param; 
	if (this->lab_normatives && this->MinSqLinearStat(vt, vx, vy, true, a0, a1, m, Sepsilon, param) && m)							
	{
		// определяем тип грунта
		CGround::ground_type gt = CGround::ground_type::Undefined_ground;
		// коэффициент Пуассона
		double mju = 0.0;
		double beta = 0.0;
		double beta_tab = GetBeta(mju);
		//double beta_mavrodi = 0.0;
		bool beta_determined = false;


		LabTrialValueType vtWp;
		vtWp.clear();
		vtWp.m_indication = LabTrial::indication::physical;
		vtWp.is_result = false;
		vtWp.vt_PhysicalLabTrial = PhysicalLabTrial::value_type::vt_moisture_on_plasticity_border;
		vtWp.m_lablayer = this;


		LabTrialValueType vtp;
		vtp.clear();
		vtp.m_indication = LabTrial::indication::physical;
		vtp.is_result = true;
		vtp.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_plasticity_index;
		vtp.m_lablayer = this;

		LabTrialValueType vtIL;
		vtIL.clear();
		vtIL.m_indication = LabTrial::indication::physical;
		vtIL.is_result = true;
		if (t == LabTrial::indication::compression_task_condition_absolute_deformation)
			vtIL.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_fluidity_index_water_saturated;
		else
			vtIL.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_fluidity_index_nature;
		vtIL.m_lablayer = this;

		map<LabTrialValueType, normative_value>::iterator itmp = this->lab_normatives->values.find(vtp);
		map<LabTrialValueType, normative_value>::iterator itmIL = this->lab_normatives->values.find(vtIL);
		map<LabTrialValueType, normative_value>::iterator itmWp = this->lab_normatives->values.find(vtWp);
		if (itmp != this->lab_normatives->values.end() && itmIL != this->lab_normatives->values.end() && itmWp != this->lab_normatives->values.end())
		{
			// определяем тип грунта
			gt = DefineGroundType((*itmp).second.v_n.v);
			// показатель текучести
			double IL = (*itmIL).second.v_n.v;
			double Ip = (*itmp).second.v_n.v;
			double Wp = (*itmWp).second.v_n.v;
			// коэффициент Пуассона
			// mju = GetPuasson(gt);
			mju = GetPuasson_interpolation(gt, IL, Ip, Wp);

			beta_tab = GetBeta(mju);
//			beta_mavrodi = GetBetaMavrodi(gt, (*itmp).second.v_n.v);

//			if (CompressionLabTrialResults::use_mavrodi_beta)
//				beta = beta_mavrodi;
//			else
				beta = beta_tab;

			beta_determined = true;

			if (use_text2 && text)
			{
				if (text) text->push_back(fmtstr("Число пластичности (нормативное значение)", NULL, false, true));
				
				char str[4098];

				sprintf (str, "%d", (*itmp).second.n);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "%f", (*itmp).second.v_n.v);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				CGround::s_Quantity = CGround::Quantity::singular;
				sprintf (str, "%s", CGround::GrountTypeToStringRus(gt));
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "mju = %f", mju);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "beta = %f", beta_tab);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

//				sprintf (str, "beta_mavrodi = %f", beta_mavrodi);
//				DeleteEndZeros(str);
//				if (text) text->push_back(fmtstr(str, NULL, false, true));

				if (text) text->push_back(fmtstr("", NULL, true, true));
			}
		}


		LabTrialValueType vte;
		vte.clear();
		vte.m_indication = LabTrial::indication::physical;
		vte.is_result = true;
		vte.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_e;
		vte.m_lablayer = this;

		bool mk_n_determined = false;

		double mk_n;
		double mk_95;

		map<LabTrialValueType, normative_value>::iterator itme = this->lab_normatives->values.find(vte);
		//map<LabTrialValueType, normative_value>::iterator itme = find2(vte, this->lab_normatives->values);
		if (itme != this->lab_normatives->values.end())
		{
			double e_n = (*itme).second.v_n.v;
			//double e_85 = (*itme).second.v_85.v;
			double e_95 = (*itme).second.v_95.v;
			//double e_99 = (*itme).second.v_99.v;

			mk_n = GetMk(gt, e_n);
			mk_95 = GetMk(gt, e_95);
			mk_n_determined = true;


			if (use_text2 && text)
			{
				if (text) text->push_back(fmtstr("Коэффициент пористости (норм. и расч. знач.)", NULL, false, true));
				
				char str[4098];

				sprintf (str, "%d", (*itme).second.n);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "%f", e_n);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));


				if (text) text->push_back(fmtstr("", NULL, false, true));
				if (text) text->push_back(fmtstr("", NULL, false, true));
				if (text) text->push_back(fmtstr("", NULL, false, true));

				sprintf (str, "%f", e_95);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				if (text) text->push_back(fmtstr("", NULL, true, true));
			}

			if (use_text2 && text)
			{
				if (text) text->push_back(fmtstr("Коэффициент mk (норм. и расч. знач.)", NULL, false, true));
				
				char str[4098];

				sprintf (str, "%d", (*itme).second.n);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "%f", mk_n);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				if (text) text->push_back(fmtstr("", NULL, false, true));
				if (text) text->push_back(fmtstr("", NULL, false, true));
				if (text) text->push_back(fmtstr("", NULL, false, true));

				sprintf (str, "%f", mk_95);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				if (text) text->push_back(fmtstr("", NULL, true, true));
			}
		}




		double compression_module = 1.0 / a1.v;
		double deformation_module = beta / a1.v;
		
		//double E = beta / a1.v;
			
		// расчётные значения 
		double epsilon_n_min = a0.v + a1.v * param.x_min;
		double epsilon_n_max = a0.v + a1.v * param.x_max;

		double V;
		Get_V_alpha_lambda_095(double(m-2), param.lambda, V);

		double delta_epsilon_min = V * Sepsilon.v * param.Kx_min / sqrt(double(m));
		double delta_epsilon_max = V * Sepsilon.v * param.Kx_max / sqrt(double(m));
		double gamma_g_epsilon;
		bool use_formula_21 = false;
	if (!LabLayer::DefModuleNewRaschotnMethod)
	{
		double epsilon_min = epsilon_n_min - delta_epsilon_min;
		double epsilon_max = epsilon_n_max - delta_epsilon_max;


		use_formula_21 = ((epsilon_min / param.x_min) < (epsilon_max / param.x_max));

		if (use_formula_21)
		{
			gamma_g_epsilon = (epsilon_n_min + epsilon_n_max) * param.x_max / (epsilon_max * (param.x_min + param.x_max));
		}
		else
		{
			gamma_g_epsilon = (epsilon_n_min + epsilon_n_max) / (epsilon_min + epsilon_max);
		}
	}
	else
	{
		double epsilon_min = epsilon_n_min + delta_epsilon_min;
		double epsilon_max = epsilon_n_max + delta_epsilon_max;



		if (use_formula_21)
		{
			//gamma_g_epsilon = (epsilon_n_min + epsilon_n_max) * param.x_max / (epsilon_max * (param.x_min + param.x_max));
		}
		else
		{
			gamma_g_epsilon = (epsilon_min + epsilon_max) / (epsilon_n_min + epsilon_n_max);
		}
	}
		double compression_module_95 = compression_module / gamma_g_epsilon;
		double deformation_module_95 = beta * compression_module_95;
		
		if (this->lab_normatives)
		{
			LabTrialValueType vt_res;

			vt_res.clear();
			vt_res.m_indication = t;
			vt_res.is_result = true;
			vt_res.m_lablayer = this;

			CompressionValueType * cvt = NULL;
			switch(t)
			{
			case LabTrial::indication::compression_nature_condition_absolute_deformation:
				{
					cvt = &vt_res.vt_Compression;
				}
				break;
			case LabTrial::indication::compression_task_condition_absolute_deformation:
				{
					cvt = &vt_res.vt_Compression;
				}
				break;
			case LabTrial::indication::compression_shrinkage_absolute_deformation:
				{
					cvt = &vt_res.vt_Compression;
				}
				break;
			case LabTrial::indication::compression_3:
				{				
					switch (ntrial)//(com_lab_pars->type)
					{
					case 1://CompressionLabTrial::type::nature_condition:
						{
							vt_res.vt_Compression_3.com_type = CompressionLabTrial::type::nature_condition;
							cvt = &vt_res.vt_Compression_3.vt_Compression_nature;
						}
						break;
					case 2://CompressionLabTrial::type::task_condition:
						{	
							vt_res.vt_Compression_3.com_type = CompressionLabTrial::type::task_condition;
							cvt = &vt_res.vt_Compression_3.vt_Compression_task;
						}
						break;
					case 3://CompressionLabTrial::type::shrinkage:
						{
							vt_res.vt_Compression_3.com_type = CompressionLabTrial::type::shrinkage;
							cvt = &vt_res.vt_Compression_3.vt_Compression_shrinkage;
						}
						break;
					}
				}
				break;
			}
			cvt->every_compression_experiment = false;


			cvt->n_compression_value_type = 1;//y

			if (interval_type)
			{
				if (interval_type == 1)
					cvt->vt_CompressionLabTrialResults_1 = CompressionLabTrialResults::value_type_1::vt_compression_module_y_in_01_02_interval;
				else
					cvt->vt_CompressionLabTrialResults_1 = CompressionLabTrialResults::value_type_1::vt_compression_module_y_in_defined_interval;
				this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
					normative_value(m, compression_module, trial_value(), compression_module_95, trial_value())));
			}
			if (interval_type)
			{

				if (interval_type == 1)
					cvt->vt_CompressionLabTrialResults_1 = CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_01_02_interval;
				else
					cvt->vt_CompressionLabTrialResults_1 = CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_defined_interval;
				this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
					normative_value(m, deformation_module, trial_value(), deformation_module_95, trial_value())));
			}
			if (interval_type)
			{
				if (interval_type == 1)
					cvt->vt_CompressionLabTrialResults_1 = CompressionLabTrialResults::value_type_1::vt_S_lin_y_in_01_02_interval;
				else
					cvt->vt_CompressionLabTrialResults_1 = CompressionLabTrialResults::value_type_1::vt_S_lin_y_in_defined_interval;
				this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
					normative_value(m, Sepsilon, trial_value(), trial_value(), trial_value())));
			}


			if (mk_n_determined && interval_type == 1)
			{
				cvt->vt_CompressionLabTrialResults_1 = CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_01_02_interval_mk;
				this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
					normative_value(m, deformation_module * mk_n, trial_value(), deformation_module_95 * mk_95, trial_value())));
			}		
		}






		char str[4098];
		sprintf (str, "E %s (по един.совок.оп.)", s);			
		if (type == 1 && text) text->push_back(fmtstr(str, NULL, true, true));
		if (labdata)
		{
			if (type == 1)
			{


				// plot
				labdata->back().plot_data.use_plot = true;
				labdata->back().plot_data.y_dir = -1;
				labdata->back().plot_data.title = "Компрессия (по един.совок.оп.)";//str;
				labdata->back().plot_data.xlabel = "Давления, МПа";
				labdata->back().plot_data.ylabel = "Отн.деф.";

				labdata->back().plot_data.plot_lines.push_back(plot_line());
				labdata->back().plot_data.plot_lines.back().line_plot = false;

				for (size_t j = 0; j < vx.size() && j < vy.size(); j++)
				{
					labdata->back().plot_data.plot_lines.back().data.push_back(plot_data_2d(vx[j].x, vy[j].v));
				}

			}
			if (type == 2 || type == 3)
			{
				labdata->back().plot_data.lin_interp.push_back(LinInterp());
				labdata->back().plot_data.lin_interp.back().m_a0 = a0.v;
				labdata->back().plot_data.lin_interp.back().m_a1 = a1.v;

				if ( type == 3)
					labdata->back().plot_data.lin_interp.back().line_color = RGB(0,0,200);


				if (pressure_interval)
				{
					labdata->back().plot_data.lin_interp.back().xmin = pressure_interval[0];
					labdata->back().plot_data.lin_interp.back().xmax = pressure_interval[1];
				}

				labdata->back().plot_data.lin_interp.push_back(LinInterp());
				labdata->back().plot_data.lin_interp.back().m_a0 = a0.v;
				labdata->back().plot_data.lin_interp.back().m_a1 = a1.v * gamma_g_epsilon;
				labdata->back().plot_data.lin_interp.back().line_style = PS_DOT;

				if ( type == 3)
					labdata->back().plot_data.lin_interp.back().line_color = RGB(0,0,200);

				if (pressure_interval)
				{
					labdata->back().plot_data.lin_interp.back().xmin = pressure_interval[0];
					labdata->back().plot_data.lin_interp.back().xmax = pressure_interval[1];
				}

				if (type == 3)
				{
					labdata->push_back(LabData());
					text = &labdata->back().text;
				}
			}
		}

		if(use_text && text && pressure_interval)
		{
			char s1[1024];
			char s2[1024];
			sprintf(s1, "%f", pressure_interval[0]);
			sprintf(s2, "%f", pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);

			sprintf (str, "Компрессионный модуль [%s - %s], МПа", s1, s2);

			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", m);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%f", compression_module);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "lambda=%f", param.lambda);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "V_95=%f", V);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "%f", compression_module_95);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}


		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "Sepsilon=%f", Sepsilon.v);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "g_95=%f", gamma_g_epsilon);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "F2%d", use_formula_21);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "epsilon_n_min=%f", epsilon_n_min);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "epsilon_n_max=%f", epsilon_n_max);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "delta_epsilon_min=%f", delta_epsilon_min);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "delta_epsilon_max=%f", delta_epsilon_max);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "param.Kx_min=%f", param.Kx_min);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "param.Kx_max=%f", param.Kx_max);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if(beta_determined && use_text && text && pressure_interval)
		{
			char s1[1024];
			char s2[1024];
			sprintf(s1, "%f", pressure_interval[0]);
			sprintf(s2, "%f", pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);

			sprintf (str, "Модуль деформации [%s - %s], МПа", s1, s2);

			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", m);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%f", deformation_module);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));


			if (text) text->push_back(fmtstr("", NULL, false, true));
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "%f", deformation_module_95);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}


		if(mk_n_determined && use_text2 && text && pressure_interval)
		{
			char s1[1024];
			char s2[1024];
			sprintf(s1, "%f", pressure_interval[0]);
			sprintf(s2, "%f", pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);

			sprintf (str, "Модуль деформации [%s - %s] * mk, МПа", s1, s2);

			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", m);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%f", deformation_module * mk_n);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));


			if (text) text->push_back(fmtstr("", NULL, false, true));
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "%f", deformation_module_95 * mk_95);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}


		return true;
	}
	else
	{
		return false;
	}
		
	return false;
}

void LabLayer::FillCompressionData1(CompressionLabTrial * compression_lab_trial, 
	char * s,
	vector<x_compression> & vx,
	vector<trial_got_value> & vy,

	double * def_module_01_02_pressure_interval,
	vector<x_compression> & vx_01_02_interval,
	vector<trial_got_value> & vy_in_01_02_interval,

	double * def_module_defined_pressure_interval,
	vector<x_compression> & vx_defined_interval,
	vector<trial_got_value> & vy_in_defined_interval
	)
{
	if (compression_lab_trial)
	{
		sprintf(s,"%s\0", CompressionLabTrial::CompressionLabTrialTypeToStringRusSmall(compression_lab_trial->com_type));
		
		CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(this->FindLabExperiment(LabExperiment::type::compression));
		if(compression)
		{
			bool zamachivanie = false;

			double x;
			//vector<double> vlogx;
//				vector<double> vx;
			trial_got_value y;
//				vector<trial_got_value> vy;

			bool interval_01_02_started = false;
			bool interval_01_02_finished = false;

			bool defined_interval_started = false;
			bool defined_interval_finished = false;

#if USE_LAB_LAYER_HOOP
			compression->hoop_height;
			compression->hoop_diameter;
#endif


			for (int i = 0; i < compression_lab_trial->n_pressures; i++)
			{
#if USE_LAB_LAYER_PRESSURES
				switch(compression_lab_trial->com_type)				
				{
				case CompressionLabTrial::type::nature_condition:
					{
						x = compression->pressures_in_nature_condition[i];
						if (i > 0 && compression->pressures_in_nature_condition[i-1] == compression->pressures_in_nature_condition[i])
						{
							zamachivanie = true;
						}
					}
					break;
				case CompressionLabTrial::type::task_condition:
					{
						x = compression->pressures_in_task_condition[i];
					}
					break;
				case CompressionLabTrial::type::shrinkage:
					{
						x = compression->pressures_on_shrinkage[i];
					}
					break;
				}

#else
				x = compression_lab_trial->pressures[i];
				if (compression_lab_trial->com_type == CompressionLabTrial::type::nature_condition)
				{
					if (i > 0 && compression_lab_trial->pressures[i-1] == compression_lab_trial->pressures[i])
					{
						zamachivanie = true;
					}
				}
#endif
				/*if (i == 0)
				{
					deformation_module_pressure_interval[0] = x;
				}*/

				y = compression_lab_trial->absolute_deformations[i];
#if USE_LAB_LAYER_HOOP
				y.v /= compression->hoop_height;
#else
				y.v /= compression_lab_trial->hoop_height;
#endif
				y.lab_number = compression_lab_trial->lab_number;

				if (!zamachivanie)
				{
					vx.push_back(x);
//						vlogx.push_back(log(x));
					vy.push_back(y);
//						deformation_module_pressure_interval[1] = x;
				}

					double __x0 = CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0];
					double __x1 = CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1];
				if ( ! interval_01_02_started )
				{ 
					if (x >= CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0])
					{
						interval_01_02_started = true;
					}
				}
				if ( ! interval_01_02_finished )
				{
					if (x > CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1])
					{
						interval_01_02_finished = true;
					}
				}
				if (!zamachivanie && interval_01_02_started && !interval_01_02_finished )
				{
					vx_01_02_interval.push_back(x);
					vy_in_01_02_interval.push_back(y);

					if (vx_01_02_interval.size() == 1)
						def_module_01_02_pressure_interval[0] = x;
					def_module_01_02_pressure_interval[1] = x;
				}


				if ( ! defined_interval_started )
				{
					if (x >= this->deformation_module_defined_pressure_interval[0])
					{
						defined_interval_started = true;
					}
				}
				if ( ! defined_interval_finished )
				{
					if (x > this->deformation_module_defined_pressure_interval[1])
					{
						defined_interval_finished = true;
					}
				}
				if (!zamachivanie && defined_interval_started && !defined_interval_finished )
				{
					vx_defined_interval.push_back(x);
					vy_in_defined_interval.push_back(y);

					if (vx_defined_interval.size() == 1)
						def_module_defined_pressure_interval[0] = x;
					def_module_defined_pressure_interval[1] = x;
				}
			}
		}
	}

}

#endif
bool set_common_compression_to_one_plot = false;// реализация на один график не готова
#if USE_COMPR_PO_OTN_DEF	
void LabLayer::Compression3Normatives_common_y(LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata)
{
	if (set_common_compression_to_one_plot)
	{
		Compression3_Normatives_common_y(t, text, labdata);
	}
	else
	{
		Compression3_Normatives_common_y(1, t, text, labdata);
		Compression3_Normatives_common_y(2, t, text, labdata);
		Compression3_Normatives_common_y(3, t, text, labdata);
	}
}

void LabLayer::Compression3_Normatives_common_y(int ntrial, LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata)
{
	// нормативные и расчётные модуля деформации 
	// путём статистической обработки всех пар опытных значений

	vector<x_compression> vx;
	vector<trial_got_value> vy;
	vx.clear();
	vy.clear();

	double def_module_01_02_pressure_interval[2];
	vector<x_compression> vx_01_02_interval;
	vector<trial_got_value> vy_in_01_02_interval;

	double def_module_defined_pressure_interval[2];
	vector<x_compression> vx_defined_interval;
	vector<trial_got_value> vy_in_defined_interval;

	char s[1024];
	sprintf(s,"\0");

	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		LabNumber * labnumber = (*it);
		if (labnumber)
		{
			LabTrial * trial = labnumber->FindLabTrial(t, -1);
			if (trial)
			{
				CompressionLabTrial3 * compression_lab_trial_3 = dynamic_cast<CompressionLabTrial3 *>(trial);

				switch(ntrial)
				{
				case 1:
					{
						if (compression_lab_trial_3 && compression_lab_trial_3->p_trial_1)
						{
							this->FillCompressionData1(compression_lab_trial_3->p_trial_1, 
								s, vx, vy,
								def_module_01_02_pressure_interval,
								vx_01_02_interval,
								vy_in_01_02_interval,
								def_module_defined_pressure_interval,
								vx_defined_interval,
								vy_in_defined_interval);					
						}
					}
					break;
				case 2:
					{
						if (compression_lab_trial_3 && compression_lab_trial_3->p_trial_2)
						{
							this->FillCompressionData1(compression_lab_trial_3->p_trial_2, 
								s, vx, vy,
								def_module_01_02_pressure_interval,
								vx_01_02_interval,
								vy_in_01_02_interval,
								def_module_defined_pressure_interval,
								vx_defined_interval,
								vy_in_defined_interval);					
						}
					}
					break;
				case 3:
					{
						if (compression_lab_trial_3 && compression_lab_trial_3->p_trial_3)
						{
							this->FillCompressionData1(compression_lab_trial_3->p_trial_3, 
								s, vx, vy,
								def_module_01_02_pressure_interval,
								vx_01_02_interval,
								vy_in_01_02_interval,
								def_module_defined_pressure_interval,
								vx_defined_interval,
								vy_in_defined_interval);					
						}
					}
					break;
				}
			}
		}
	}

	// рисуем все точки 
	this->calc_E(0, ntrial, t, text, labdata, s, 1, false, false,  vx,                  vy,                     NULL);
	// рисуем линии в интервале 1-2
	this->calc_E(0, ntrial, t, text, labdata, s, 2, false, false,  vx_01_02_interval,   vy_in_01_02_interval,   def_module_01_02_pressure_interval);
	// рисуем линии в интервале defined_interval
	this->calc_E(0, ntrial, t, text, labdata, s, 3, false, false,  vx_defined_interval, vy_in_defined_interval, def_module_defined_pressure_interval);
	// Пишем результаты вычисления в text в интервале 1-2
	this->calc_E(1, ntrial, t, text, NULL,    s, 2, true,  true,   vx_01_02_interval,   vy_in_01_02_interval,   def_module_01_02_pressure_interval);
	// Пишем результаты вычисления в text в интервале defined_interval
	this->calc_E(2, ntrial, t, text, NULL,    s, 3, true,  false,  vx_defined_interval, vy_in_defined_interval, def_module_defined_pressure_interval);

}

void LabLayer::Compression3_Normatives_common_y(LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata)
{
	// нормативные и расчётные модуля деформации 
	// путём статистической обработки всех пар опытных значений

	vector<x_compression> vx_1;
	vector<trial_got_value> vy_1;
	vx_1.clear();
	vy_1.clear();

	double def_module_01_02_pressure_interval_1[2];
	vector<x_compression> vx_01_02_interval_1;
	vector<trial_got_value> vy_in_01_02_interval_1;

	double def_module_defined_pressure_interval_1[2];
	vector<x_compression> vx_defined_interval_1;
	vector<trial_got_value> vy_in_defined_interval_1;

	char s_1[1024];
	sprintf(s_1,"\0");

	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		LabNumber * labnumber = (*it);
		if (labnumber)
		{
			LabTrial * trial = labnumber->FindLabTrial(t, -1);
			if (trial)
			{
				CompressionLabTrial3 * compression_lab_trial_3 = dynamic_cast<CompressionLabTrial3 *>(trial);

				if (compression_lab_trial_3 && compression_lab_trial_3->p_trial_1)
				{
					this->FillCompressionData1(compression_lab_trial_3->p_trial_1, 
						s_1, vx_1, vy_1,
						def_module_01_02_pressure_interval_1,
						vx_01_02_interval_1,
						vy_in_01_02_interval_1,
						def_module_defined_pressure_interval_1,
						vx_defined_interval_1,
						vy_in_defined_interval_1);					
				}


			}
		}
	}



	vector<x_compression> vx_2;
	vector<trial_got_value> vy_2;
	vx_2.clear();
	vy_2.clear();

	double def_module_01_02_pressure_interval_2[2];
	vector<x_compression> vx_01_02_interval_2;
	vector<trial_got_value> vy_in_01_02_interval_2;

	double def_module_defined_pressure_interval_2[2];
	vector<x_compression> vx_defined_interval_2;
	vector<trial_got_value> vy_in_defined_interval_2;

	char s_2[1024];
	sprintf(s_2,"\0");

	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		LabNumber * labnumber = (*it);
		if (labnumber)
		{
			LabTrial * trial = labnumber->FindLabTrial(t, -1);
			if (trial)
			{
				CompressionLabTrial3 * compression_lab_trial_3 = dynamic_cast<CompressionLabTrial3 *>(trial);


				if (compression_lab_trial_3 && compression_lab_trial_3->p_trial_2)
				{
					this->FillCompressionData1(compression_lab_trial_3->p_trial_2, 
						s_2, vx_2, vy_2,
						def_module_01_02_pressure_interval_2,
						vx_01_02_interval_2,
						vy_in_01_02_interval_2,
						def_module_defined_pressure_interval_2,
						vx_defined_interval_2,
						vy_in_defined_interval_2);					
				}
			}
		}
	}



	vector<x_compression> vx_3;
	vector<trial_got_value> vy_3;
	vx_3.clear();
	vy_3.clear();

	double def_module_01_02_pressure_interval_3[2];
	vector<x_compression> vx_01_02_interval_3;
	vector<trial_got_value> vy_in_01_02_interval_3;

	double def_module_defined_pressure_interval_3[2];
	vector<x_compression> vx_defined_interval_3;
	vector<trial_got_value> vy_in_defined_interval_3;

	char s_3[1024];
	sprintf(s_3,"\0");

	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		LabNumber * labnumber = (*it);
		if (labnumber)
		{
			LabTrial * trial = labnumber->FindLabTrial(t, -1);
			if (trial)
			{
				CompressionLabTrial3 * compression_lab_trial_3 = dynamic_cast<CompressionLabTrial3 *>(trial);

				if (compression_lab_trial_3 && compression_lab_trial_3->p_trial_3)
				{
					this->FillCompressionData1(compression_lab_trial_3->p_trial_3, 
						s_3, vx_3, vy_3,
						def_module_01_02_pressure_interval_3,
						vx_01_02_interval_3,
						vy_in_01_02_interval_3,
						def_module_defined_pressure_interval_3,
						vx_defined_interval_3,
						vy_in_defined_interval_3);					
				}
			}
		}
	}





	// рисуем все точки 
	this->calc_E(0, 1, t, text, labdata, s_1, 1, false, false,  vx_1,                  vy_1,                     NULL);
	// рисуем все точки 
	this->calc_E(0, 2, t, text, labdata, s_2, 1, false, false,  vx_2,                  vy_2,                     NULL);
	// рисуем все точки 
	this->calc_E(0, 3, t, text, labdata, s_3, 1, false, false,  vx_3,                  vy_3,                     NULL);

	// рисуем линии в интервале 1-2
	this->calc_E(0, 1, t, text, labdata, s_1, 2, false, false,  vx_01_02_interval_1,   vy_in_01_02_interval_1,   def_module_01_02_pressure_interval_1);
	// рисуем линии в интервале 1-2
	this->calc_E(0, 2, t, text, labdata, s_2, 2, false, false,  vx_01_02_interval_2,   vy_in_01_02_interval_2,   def_module_01_02_pressure_interval_2);
	// рисуем линии в интервале 1-2
	this->calc_E(0, 3, t, text, labdata, s_3, 2, false, false,  vx_01_02_interval_3,   vy_in_01_02_interval_3,   def_module_01_02_pressure_interval_3);

	// рисуем линии в интервале defined_interval
	this->calc_E(0, 1, t, text, labdata, s_1, 3, false, false,  vx_defined_interval_1, vy_in_defined_interval_1, def_module_defined_pressure_interval_1);
	// рисуем линии в интервале defined_interval
	this->calc_E(0, 2, t, text, labdata, s_2, 3, false, false,  vx_defined_interval_2, vy_in_defined_interval_2, def_module_defined_pressure_interval_2);
	// рисуем линии в интервале defined_interval
	this->calc_E(0, 3, t, text, labdata, s_3, 3, false, false,  vx_defined_interval_3, vy_in_defined_interval_3, def_module_defined_pressure_interval_3);

	// Пишем результаты вычисления в text в интервале 1-2
	this->calc_E(1, 1, t, text, NULL,    s_1, 2, true,  true,   vx_01_02_interval_1,   vy_in_01_02_interval_1,   def_module_01_02_pressure_interval_1);
	// Пишем результаты вычисления в text в интервале 1-2
	this->calc_E(1, 2, t, text, NULL,    s_2, 2, true,  true,   vx_01_02_interval_2,   vy_in_01_02_interval_2,   def_module_01_02_pressure_interval_2);
	// Пишем результаты вычисления в text в интервале 1-2
	this->calc_E(1, 3, t, text, NULL,    s_3, 2, true,  true,   vx_01_02_interval_3,   vy_in_01_02_interval_3,   def_module_01_02_pressure_interval_3);

	// Пишем результаты вычисления в text в интервале defined_interval
	this->calc_E(2, 1, t, text, NULL,    s_1, 3, true,  false,  vx_defined_interval_1, vy_in_defined_interval_1, def_module_defined_pressure_interval_1);
	// Пишем результаты вычисления в text в интервале defined_interval
	this->calc_E(2, 2, t, text, NULL,    s_2, 3, true,  false,  vx_defined_interval_2, vy_in_defined_interval_2, def_module_defined_pressure_interval_2);
	// Пишем результаты вычисления в text в интервале defined_interval
	this->calc_E(2, 3, t, text, NULL,    s_3, 3, true,  false,  vx_defined_interval_3, vy_in_defined_interval_3, def_module_defined_pressure_interval_3);

}

void LabLayer::CompressionNormatives_common_y(LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata)
{
	// нормативные и расчётные модуля деформации 
	// путём статистической обработки всех пар опытных значений

	vector<x_compression> vx;
	vector<trial_got_value> vy;
	vx.clear();
	vy.clear();

	double def_module_01_02_pressure_interval[2];
	vector<x_compression> vx_01_02_interval;
	vector<trial_got_value> vy_in_01_02_interval;

	double def_module_defined_pressure_interval[2];
	vector<x_compression> vx_defined_interval;
	vector<trial_got_value> vy_in_defined_interval;

	char s[1024];
	sprintf(s,"\0");

	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		LabNumber * labnumber = (*it);
		if (labnumber)
		{
			LabTrial * trial = labnumber->FindLabTrial(t, -1);
			if (trial)
			{
				CompressionLabTrial * compression_lab_trial = dynamic_cast<CompressionLabTrial *>(trial);

				this->FillCompressionData1(compression_lab_trial, 
					s, vx, vy,
					def_module_01_02_pressure_interval,
					vx_01_02_interval,
					vy_in_01_02_interval,
					def_module_defined_pressure_interval,
					vx_defined_interval,
					vy_in_defined_interval);
			}
		}
	}

	// рисуем все точки 
	this->calc_E(0, 0, t, text, labdata, s, 1, false, false,  vx,                  vy,                     NULL);
	// рисуем линии в интервале 1-2
	this->calc_E(0, 0, t, text, labdata, s, 2, false, false,  vx_01_02_interval,   vy_in_01_02_interval,   def_module_01_02_pressure_interval);
	// рисуем линии в интервале defined_interval
	this->calc_E(0, 0, t, text, labdata, s, 3, false, false,  vx_defined_interval, vy_in_defined_interval, def_module_defined_pressure_interval);
	// Пишем результаты вычисления в text в интервале 1-2
	this->calc_E(1, 0, t, text, NULL,    s, 2, true,  true,   vx_01_02_interval,   vy_in_01_02_interval,   def_module_01_02_pressure_interval);
	// Пишем результаты вычисления в text в интервале defined_interval
	this->calc_E(2, 0, t, text, NULL,    s, 3, true,  false,  vx_defined_interval, vy_in_defined_interval, def_module_defined_pressure_interval);

}

#endif
bool LabLayer::calc_E2(int interval_type, int ntrial, 
			LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata,
			const char * s, 
			int type,
			bool use_text, 
			bool use_text2, 
			vector<x_compression> & vx,
			vector<trial_got_value> & ve, double * pressure_interval)
{
	trial_value a0;
	trial_value a1;
	trial_value Se;
	int m;		
	LabTrialValueType vt;
	vt.m_indication = t;
	vt.is_result = false;
	vt.m_lablayer = this;

	vt.vt_Compression.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_relative_deformation ;
		
	MinSqLinearStatParameters param; 
	if (this->lab_normatives && this->MinSqLinearStat(vt, vx, ve, true, a0, a1, m, Se, param) && m)							
	{
		// определяем тип грунта
		CGround::ground_type gt = CGround::ground_type::Undefined_ground;
		// коэффициент Пуассона
		double mju = 0.0;
		double beta = 0.0;
		double beta_tab = GetBeta(mju);
		//double beta_mavrodi = 0.0;
		bool beta_determined = false;


		LabTrialValueType vtWp;
		vtWp.clear();
		vtWp.m_indication = LabTrial::indication::physical;
		vtWp.is_result = false;
		vtWp.vt_PhysicalLabTrial = PhysicalLabTrial::value_type::vt_moisture_on_plasticity_border;
		vtWp.m_lablayer = this;

		LabTrialValueType vtp;
		vtp.clear();
		vtp.m_indication = LabTrial::indication::physical;
		vtp.is_result = true;
		vtp.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_plasticity_index;
		vtp.m_lablayer = this;

		LabTrialValueType vtIL;
		vtIL.clear();
		vtIL.m_indication = LabTrial::indication::physical;
		vtIL.is_result = true;
		if (t == LabTrial::indication::compression_task_condition_absolute_deformation)
			vtIL.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_fluidity_index_water_saturated;
		else
			vtIL.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_fluidity_index_nature;
		vtIL.m_lablayer = this;

		map<LabTrialValueType, normative_value>::iterator itmp = this->lab_normatives->values.find(vtp);
		map<LabTrialValueType, normative_value>::iterator itmIL = this->lab_normatives->values.find(vtIL);
		map<LabTrialValueType, normative_value>::iterator itmWp = this->lab_normatives->values.find(vtWp);
		if (itmp != this->lab_normatives->values.end() && itmIL != this->lab_normatives->values.end() && itmWp != this->lab_normatives->values.end())
		{
			// определяем тип грунта
			gt = DefineGroundType((*itmp).second.v_n.v);
			// показатель текучести
			double IL = (*itmIL).second.v_n.v;
			double Ip = (*itmp).second.v_n.v;
			double Wp = (*itmWp).second.v_n.v;
			// коэффициент Пуассона
			// mju = GetPuasson(gt);
			mju = GetPuasson_interpolation(gt, IL, Ip, Wp);

			beta_tab = GetBeta(mju);
//			beta_mavrodi = GetBetaMavrodi(gt, (*itmp).second.v_n.v);

//			if (CompressionLabTrialResults::use_mavrodi_beta)
//				beta = beta_mavrodi;
//			else
				beta = beta_tab;

			beta_determined = true;

			if (use_text2 && text)
			{
				if (text) text->push_back(fmtstr("Число пластичности (нормативное значение)", NULL, false, true));
				
				char str[4098];

				sprintf (str, "%d", (*itmp).second.n);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "%f", (*itmp).second.v_n.v);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				CGround::s_Quantity = CGround::Quantity::singular;
				sprintf (str, "%s", CGround::GrountTypeToStringRus(gt));
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "mju = %f", mju);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "beta = %f", beta_tab);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

//				sprintf (str, "beta_mavrodi = %f", beta_mavrodi);
//				DeleteEndZeros(str);
//				if (text) text->push_back(fmtstr(str, NULL, false, true));

				if (text) text->push_back(fmtstr("", NULL, true, true));
			}
		}


		LabTrialValueType vte;
		vte.clear();
		vte.m_indication = LabTrial::indication::physical;
		vte.is_result = true;
		vte.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_e;
		vte.m_lablayer = this;

		bool mk_n_determined = false;

		double mk_n;
		double mk_95;

		map<LabTrialValueType, normative_value>::iterator itme = this->lab_normatives->values.find(vte);
		//map<LabTrialValueType, normative_value>::iterator itme = find2(vte, this->lab_normatives->values);
		if (itme != this->lab_normatives->values.end())
		{
			double e_n = (*itme).second.v_n.v;
			//double e_85 = (*itme).second.v_85.v;
			double e_95 = (*itme).second.v_95.v;
			//double e_99 = (*itme).second.v_99.v;

			mk_n = GetMk(gt, e_n);
			mk_95 = GetMk(gt, e_95);
			mk_n_determined = true;


			if (use_text2 && text)
			{
				if (text) text->push_back(fmtstr("Коэффициент пористости (норм. и расч. знач.)", NULL, false, true));
				
				char str[4098];

				sprintf (str, "%d", (*itme).second.n);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "%f", e_n);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));


				if (text) text->push_back(fmtstr("", NULL, false, true));
				if (text) text->push_back(fmtstr("", NULL, false, true));
				if (text) text->push_back(fmtstr("", NULL, false, true));

				sprintf (str, "%f", e_95);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				if (text) text->push_back(fmtstr("", NULL, true, true));
			}

			if (use_text2 && text)
			{
				if (text) text->push_back(fmtstr("Коэффициент mk (норм. и расч. знач.)", NULL, false, true));
				
				char str[4098];

				sprintf (str, "%d", (*itme).second.n);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "%f", mk_n);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				if (text) text->push_back(fmtstr("", NULL, false, true));
				if (text) text->push_back(fmtstr("", NULL, false, true));
				if (text) text->push_back(fmtstr("", NULL, false, true));

				sprintf (str, "%f", mk_95);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				if (text) text->push_back(fmtstr("", NULL, true, true));
			}
		}

		// расчётные значения 
		double e_n_min = a0.v + a1.v * param.x_min;
		double e_n_max = a0.v + a1.v * param.x_max;


		double compression_module_e = -(1.0 + e_n_min) / a1.v;
		double deformation_module_e = beta * compression_module_e;

	
		//double E = beta / a1.v;
			

		double V;
		Get_V_alpha_lambda_095(double(m-2), param.lambda, V);

		double delta_e_min = V * Se.v * param.Kx_min / sqrt(double(m));
		double delta_e_max = V * Se.v * param.Kx_max / sqrt(double(m));
		double gamma_g_e;
		bool use_formula_21 = false;
		
		if (true)//(!LabLayer::DefModuleNewRaschotnMethod)
		{
			double e_min = e_n_min - delta_e_min;
			double e_max = e_n_max - delta_e_max;


			use_formula_21 = ((e_min / param.x_min) < (e_max / param.x_max));

			// в любом случае не используем формулу 21
			// т.к. формула 21 имеет физический смысл только для среза
			// формула 21 отражает тот факт, что удельное сцепление 
			// для расчётных значений не может быть отрицательным 
			// однако для компрессии нет никаких физических 
			// предпосылок накладывать это ограничение для коэффициента a0 
			use_formula_21 = false;

			if (use_formula_21)
			{
				gamma_g_e = (e_n_min + e_n_max) * param.x_max / (e_max * (param.x_min + param.x_max));
			}
			else
			{
				gamma_g_e = (e_n_min + e_n_max) / (e_min + e_max);
			}
		}
		else
		{
			double e_min = e_n_min + delta_e_min;
			double e_max = e_n_max + delta_e_max;



			if (use_formula_21)
			{
				//gamma_g_epsilon = (epsilon_n_min + epsilon_n_max) * param.x_max / (epsilon_max * (param.x_min + param.x_max));
			}
			else
			{
				gamma_g_e = (e_min + e_max) / (e_n_min + e_n_max);
			}
		}
		//double compression_module_e_95 = compression_module_e / gamma_g_e;
		double compression_module_e_95 = -(1.0 + (e_n_min - delta_e_min)) / (a1.v * gamma_g_e);
		double deformation_module_e_95 = beta * compression_module_e_95;
		
		if (this->lab_normatives)
		{
			LabTrialValueType vt_res;

			vt_res.clear();
			vt_res.m_indication = t;
			vt_res.is_result = true;
			vt_res.m_lablayer = this;

			CompressionValueType * cvt = NULL;
			switch(t)
			{
			case LabTrial::indication::compression_nature_condition_absolute_deformation:
				{
					cvt = &vt_res.vt_Compression;
				}
				break;
			case LabTrial::indication::compression_task_condition_absolute_deformation:
				{
					cvt = &vt_res.vt_Compression;
				}
				break;
			case LabTrial::indication::compression_shrinkage_absolute_deformation:
				{
					cvt = &vt_res.vt_Compression;
				}
				break;
			case LabTrial::indication::compression_3:
				{				
					switch (ntrial)//(com_lab_pars->type)
					{
					case 1://CompressionLabTrial::type::nature_condition:
						{
							vt_res.vt_Compression_3.com_type = CompressionLabTrial::type::nature_condition;
							cvt = &vt_res.vt_Compression_3.vt_Compression_nature;
						}
						break;
					case 2://CompressionLabTrial::type::task_condition:
						{	
							vt_res.vt_Compression_3.com_type = CompressionLabTrial::type::task_condition;
							cvt = &vt_res.vt_Compression_3.vt_Compression_task;
						}
						break;
					case 3://CompressionLabTrial::type::shrinkage:
						{
							vt_res.vt_Compression_3.com_type = CompressionLabTrial::type::shrinkage;
							cvt = &vt_res.vt_Compression_3.vt_Compression_shrinkage;
						}
						break;
					}
				}
				break;
			}
			cvt->every_compression_experiment = false;


			cvt->n_compression_value_type = 2;//e

			if (interval_type)
			{
				if (interval_type == 1)
					cvt->vt_CompressionLabTrialResults_2 = CompressionLabTrialResults::value_type_2::vt_compression_module_e_in_01_02_interval;
				else
					cvt->vt_CompressionLabTrialResults_2 = CompressionLabTrialResults::value_type_2::vt_compression_module_e_in_defined_interval;
				this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
					normative_value(m, compression_module_e, trial_value(), compression_module_e_95, trial_value())));
			}
			if (interval_type)
			{
				if (interval_type == 1)
					cvt->vt_CompressionLabTrialResults_2 = CompressionLabTrialResults::value_type_2::vt_deformation_module_e_in_01_02_interval;
				else
					cvt->vt_CompressionLabTrialResults_2 = CompressionLabTrialResults::value_type_2::vt_deformation_module_e_in_defined_interval;
				this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
					normative_value(m, deformation_module_e, trial_value(), deformation_module_e_95, trial_value())));
			}
			if (interval_type)
			{
				if (interval_type == 1)
					cvt->vt_CompressionLabTrialResults_2 = CompressionLabTrialResults::value_type_2::vt_S_lin_e_in_01_02_interval;
				else
					cvt->vt_CompressionLabTrialResults_2 = CompressionLabTrialResults::value_type_2::vt_S_lin_e_in_defined_interval;
				this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
					normative_value(m, Se, trial_value(), trial_value(), trial_value())));
			}

			if (mk_n_determined  && interval_type == 1)
			{
				cvt->vt_CompressionLabTrialResults_2 = CompressionLabTrialResults::value_type_2::vt_deformation_module_e_in_01_02_interval_mk;
				this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
					normative_value(m, deformation_module_e * mk_n, trial_value(), deformation_module_e_95 * mk_95, trial_value())));
			}		
		}






		char str[4098];
		sprintf (str, "E %s (по един.совок.оп.)", s);			
		if (type == 1 && text) text->push_back(fmtstr(str, NULL, true, true));
		if (labdata)
		{
			if (type == 1)
			{
				if (labdata)
				{
					labdata->push_back(LabData());
					text = &labdata->back().text;
				}
				// plot
				labdata->back().plot_data.use_plot = true;
				labdata->back().plot_data.y_dir = +1;
				labdata->back().plot_data.title = "Компрессионная кривая (по един.совок.оп.)";//str;
				labdata->back().plot_data.xlabel = "Давления, МПа";
				labdata->back().plot_data.ylabel = "Коэф.порист.";

				labdata->back().plot_data.plot_lines.push_back(plot_line());
				labdata->back().plot_data.plot_lines.back().line_plot = false;

				for (size_t j = 0; j < vx.size() && j < ve.size(); j++)
				{
					labdata->back().plot_data.plot_lines.back().data.push_back(plot_data_2d(vx[j].x, ve[j].v));
				}

			}
			if (type == 2 || type == 3)
			{
				labdata->back().plot_data.lin_interp.push_back(LinInterp());
				labdata->back().plot_data.lin_interp.back().m_a0 = a0.v;
				labdata->back().plot_data.lin_interp.back().m_a1 = a1.v;

				if ( type == 3)
					labdata->back().plot_data.lin_interp.back().line_color = RGB(0,0,200);


				if (pressure_interval)
				{
					labdata->back().plot_data.lin_interp.back().xmin = pressure_interval[0];
					labdata->back().plot_data.lin_interp.back().xmax = pressure_interval[1];
				}

				labdata->back().plot_data.lin_interp.push_back(LinInterp());
				labdata->back().plot_data.lin_interp.back().m_a0 = (e_n_min - delta_e_min) - (a1.v * gamma_g_e) * param.x_min;//a0.v;//??????
				labdata->back().plot_data.lin_interp.back().m_a1 = a1.v * gamma_g_e;
				labdata->back().plot_data.lin_interp.back().line_style = PS_DOT;

				if ( type == 3)
					labdata->back().plot_data.lin_interp.back().line_color = RGB(0,0,200);

				if (pressure_interval)
				{
					labdata->back().plot_data.lin_interp.back().xmin = pressure_interval[0];
					labdata->back().plot_data.lin_interp.back().xmax = pressure_interval[1];
				}

			}
		}

		if (use_text && text && pressure_interval)
		{
			char s1[1024];
			char s2[1024];
			sprintf(s1, "%f", pressure_interval[0]);
			sprintf(s2, "%f", pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);

			sprintf (str, "Компрессионный модуль [%s - %s], МПа", s1, s2);

			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", m);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%f", compression_module_e);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "lambda=%f", param.lambda);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "V_95=%f", V);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "%f", compression_module_e_95);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}


		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "Se=%f", Se.v);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "g_95=%f", gamma_g_e);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "F2%d", use_formula_21);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "e_n_min=%f", e_n_min);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "e_n_max=%f", e_n_max);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "delta_e_min=%f", delta_e_min);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "delta_e_max=%f", delta_e_max);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "param.Kx_min=%f", param.Kx_min);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "param.Kx_max=%f", param.Kx_max);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if(beta_determined && use_text && text && pressure_interval)
		{
			char s1[1024];
			char s2[1024];
			sprintf(s1, "%f", pressure_interval[0]);
			sprintf(s2, "%f", pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);

			sprintf (str, "Модуль деформации [%s - %s], МПа", s1, s2);

			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", m);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%f", deformation_module_e);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));


			if (text) text->push_back(fmtstr("", NULL, false, true));
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "%f", deformation_module_e_95);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}


		if(mk_n_determined && use_text2 && text && pressure_interval)
		{
			char s1[1024];
			char s2[1024];
			sprintf(s1, "%f", pressure_interval[0]);
			sprintf(s2, "%f", pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);

			sprintf (str, "Модуль деформации [%s - %s] * mk, МПа", s1, s2);

			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", m);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%f", deformation_module_e * mk_n);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));


			if (text) text->push_back(fmtstr("", NULL, false, true));
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "%f", deformation_module_e_95 * mk_95);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}


		return true;
	}
	else
	{
		return false;
	}
		
	return false;
}


void LabLayer::FillCompressionData2(CompressionLabTrial * compression_lab_trial, 
	double e0,
	char * s,
	vector<x_compression> & vx,
	vector<trial_got_value> & ve,

	double * def_module_01_02_pressure_interval,
	vector<x_compression> & vx_01_02_interval,
	vector<trial_got_value> & ve_in_01_02_interval,

	double * def_module_defined_pressure_interval,
	vector<x_compression> & vx_defined_interval,
	vector<trial_got_value> & ve_in_defined_interval
	)
{
	if (compression_lab_trial)
	{
		sprintf(s,"%s\0", CompressionLabTrial::CompressionLabTrialTypeToStringRusSmall(compression_lab_trial->com_type));
		
		CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(this->FindLabExperiment(LabExperiment::type::compression));
		if(compression)
		{
			bool zamachivanie = false;

			double x;
			//vector<double> vlogx;
//				vector<double> vx;
			trial_got_value y;
			trial_got_value e;
//				vector<trial_got_value> vy;

			bool interval_01_02_started = false;
			bool interval_01_02_finished = false;

			bool defined_interval_started = false;
			bool defined_interval_finished = false;

#if USE_LAB_LAYER_HOOP
			compression->hoop_height;
			compression->hoop_diameter;
#endif


			for (int i = 0; i < compression_lab_trial->n_pressures; i++)
			{
#if USE_LAB_LAYER_PRESSURES
				switch(compression_lab_trial->com_type)				
				{
				case CompressionLabTrial::type::nature_condition:
					{
						x = compression->pressures_in_nature_condition[i];
						if (i > 0 && compression->pressures_in_nature_condition[i-1] == compression->pressures_in_nature_condition[i])
						{
							zamachivanie = true;
						}
					}
					break;
				case CompressionLabTrial::type::task_condition:
					{
						x = compression->pressures_in_task_condition[i];
					}
					break;
				case CompressionLabTrial::type::shrinkage:
					{
						x = compression->pressures_on_shrinkage[i];
					}
					break;
				}

#else
				x = compression_lab_trial->pressures[i];
				if (compression_lab_trial->com_type == CompressionLabTrial::type::nature_condition)
				{
					if (i > 0 && compression_lab_trial->pressures[i-1] == compression_lab_trial->pressures[i])
					{
						zamachivanie = true;
					}
				}
#endif
				/*if (i == 0)
				{
					deformation_module_pressure_interval[0] = x;
				}*/

				y = compression_lab_trial->absolute_deformations[i];
#if USE_LAB_LAYER_HOOP
				y.v /= compression->hoop_height;
#else
				y.v /= compression_lab_trial->hoop_height;
#endif
				y.lab_number = compression_lab_trial->lab_number;

				e = y;
				e.v = e0 - (1.0 + e0) * y.v;
				e.lab_number = compression_lab_trial->lab_number;

				if (!zamachivanie)
				{
					vx.push_back(x);
//						vlogx.push_back(log(x));
					ve.push_back(e);
//						deformation_module_pressure_interval[1] = x;
				}

				if ( ! interval_01_02_started )
				{
					if (x >= CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0])
					{
						interval_01_02_started = true;
					}
				}
				if ( ! interval_01_02_finished )
				{
					if (x > CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1])
					{
						interval_01_02_finished = true;
					}
				}
				if (!zamachivanie && interval_01_02_started && !interval_01_02_finished )
				{
					vx_01_02_interval.push_back(x);
					ve_in_01_02_interval.push_back(e);

					if (vx_01_02_interval.size() == 1)
						def_module_01_02_pressure_interval[0] = x;
					def_module_01_02_pressure_interval[1] = x;
				}


				if ( ! defined_interval_started )
				{
					if (x >= this->deformation_module_defined_pressure_interval[0])
					{
						defined_interval_started = true;
					}
				}
				if ( ! defined_interval_finished )
				{
					if (x > this->deformation_module_defined_pressure_interval[1])
					{
						defined_interval_finished = true;
					}
				}
				if (!zamachivanie && defined_interval_started && !defined_interval_finished )
				{
					vx_defined_interval.push_back(x);
					ve_in_defined_interval.push_back(e);

					if (vx_defined_interval.size() == 1)
						def_module_defined_pressure_interval[0] = x;
					def_module_defined_pressure_interval[1] = x;
				}
			}
		}
	}
}
void LabLayer::CompressionNormatives_common_e(LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata)
{
	// нормативные и расчётные модуля деформации 
	// путём статистической обработки всех пар опытных значений

	vector<x_compression> vx;
	vector<trial_got_value> ve;
	vx.clear();
	ve.clear();

	double def_module_01_02_pressure_interval[2];
	vector<x_compression> vx_01_02_interval;
	vector<trial_got_value> ve_in_01_02_interval;

	double def_module_defined_pressure_interval[2];
	vector<x_compression> vx_defined_interval;
	vector<trial_got_value> ve_in_defined_interval;

	char s[1024];
	sprintf(s,"\0");

	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		LabNumber * labnumber = (*it);
		if (labnumber)
		{
			LabTrial * trial = labnumber->FindLabTrial(t, -1);
			PhysicalLabTrial * phys =  dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
			if (phys)
			{
				PhysicalLabTrialResults * phys_res =  dynamic_cast<PhysicalLabTrialResults *>(phys->results);
				if (phys_res)
				{
					if (!phys_res->calculed)
						phys_res->CalcProperties();					
						
					double e0 = phys_res->e.v;
//					double e1_in_01_02_pressure_interval;
//					double e1_in_defined_pressure_interval;

					if (trial)
					{
						CompressionLabTrial * compression_lab_trial = dynamic_cast<CompressionLabTrial *>(trial);
						this->FillCompressionData2(compression_lab_trial, 
							e0, s, vx, ve,
							def_module_01_02_pressure_interval,
							vx_01_02_interval,
							ve_in_01_02_interval,
							def_module_defined_pressure_interval,
							vx_defined_interval,
							ve_in_defined_interval);
					}
				}
			}
		}
	}





	// рисуем все точки 
	this->calc_E2(0, 0, t, text, labdata, s, 1, false, false,  vx,                  ve,                     NULL);
	// рисуем линии в интервале 1-2
	this->calc_E2(0, 0, t, text, labdata, s, 2, false, false,  vx_01_02_interval,   ve_in_01_02_interval,   def_module_01_02_pressure_interval);
	// рисуем линии в интервале defined_interval
	this->calc_E2(0, 0, t, text, labdata, s, 3, false, false,  vx_defined_interval, ve_in_defined_interval, def_module_defined_pressure_interval);
	if (labdata)
	{
		labdata->push_back(LabData());
		text = &labdata->back().text;
	}	
	// Пишем результаты вычисления в text в интервале 1-2
	this->calc_E2(1, 0, t, text, NULL,    s, 2, true,  true,   vx_01_02_interval,   ve_in_01_02_interval,   def_module_01_02_pressure_interval);
	// Пишем результаты вычисления в text в интервале defined_interval
	this->calc_E2(2, 0, t, text, NULL,    s, 3, true,  false,  vx_defined_interval, ve_in_defined_interval, def_module_defined_pressure_interval);



	// рисуем все точки 
	this->calc_E2_(t, text, labdata, s, 1, false, false,  vx, ve, NULL);

	// рисуем логарифмическую интерполяцию компрессионной кривой
	this->calc_E2_(t, text, labdata, s, 3, false, false,  vx, ve, NULL);
	if (labdata)
	{
		labdata->push_back(LabData());
		text = &labdata->back().text;
	}

	// рисуем логарифмическую интерполяцию компрессионной кривой
	this->calc_E2_(t, text, labdata, s, 4, false, false,  vx, ve, NULL);
	if (labdata)
	{
		labdata->push_back(LabData());
		text = &labdata->back().text;
	}

	// Пишем результаты вычисления в text
	this->calc_E2_(t, text, NULL,    s, 3, true, true,  vx, ve, NULL);
}

void LabLayer::Compression3_Normatives_common_e(int ntrial, LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata)
{
	// нормативные и расчётные модуля деформации 
	// путём статистической обработки всех пар опытных значений

	vector<x_compression> vx;
	vector<trial_got_value> ve;
	vx.clear();
	ve.clear();

	double def_module_01_02_pressure_interval[2];
	vector<x_compression> vx_01_02_interval;
	vector<trial_got_value> ve_in_01_02_interval;

	double def_module_defined_pressure_interval[2];
	vector<x_compression> vx_defined_interval;
	vector<trial_got_value> ve_in_defined_interval;

	char s[1024];
	sprintf(s,"\0");

	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		LabNumber * labnumber = (*it);
		if (labnumber)
		{
			LabTrial * trial = labnumber->FindLabTrial(t, -1);
			PhysicalLabTrial * phys =  dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
			if (phys)
			{
				PhysicalLabTrialResults * phys_res =  dynamic_cast<PhysicalLabTrialResults *>(phys->results);
				if (phys_res)
				{
					if (!phys_res->calculed)
						phys_res->CalcProperties();					
						
					double e0 = phys_res->e.v;
//					double e1_in_01_02_pressure_interval;
//					double e1_in_defined_pressure_interval;

					if (trial)
					{
						CompressionLabTrial3 * compression_lab_trial_3 = dynamic_cast<CompressionLabTrial3 *>(trial);

						switch(ntrial)
						{
						case 1:
							{
								if (compression_lab_trial_3 && compression_lab_trial_3->p_trial_1)
								{
									this->FillCompressionData2(compression_lab_trial_3->p_trial_1, 
										e0, s, vx, ve,
										def_module_01_02_pressure_interval,
										vx_01_02_interval,
										ve_in_01_02_interval,
										def_module_defined_pressure_interval,
										vx_defined_interval,
										ve_in_defined_interval);
								}
							}
							break;
						case 2:
							{
								if (compression_lab_trial_3 && compression_lab_trial_3->p_trial_2)
								{
									this->FillCompressionData2(compression_lab_trial_3->p_trial_2, 
										e0, s, vx, ve,
										def_module_01_02_pressure_interval,
										vx_01_02_interval,
										ve_in_01_02_interval,
										def_module_defined_pressure_interval,
										vx_defined_interval,
										ve_in_defined_interval);
								}
							}
							break;
						case 3:
							{
								if (compression_lab_trial_3 && compression_lab_trial_3->p_trial_3)
								{
									this->FillCompressionData2(compression_lab_trial_3->p_trial_3, 
										e0, s, vx, ve,
										def_module_01_02_pressure_interval,
										vx_01_02_interval,
										ve_in_01_02_interval,
										def_module_defined_pressure_interval,
										vx_defined_interval,
										ve_in_defined_interval);
								}
							}
							break;
						}
					}
				}
			}
		}
	}





	// рисуем все точки 
	this->calc_E2(0, ntrial, t, text, labdata, s, 1, false, false,  vx,                  ve,                     NULL);
	// рисуем линии в интервале 1-2
	this->calc_E2(0, ntrial, t, text, labdata, s, 2, false, false,  vx_01_02_interval,   ve_in_01_02_interval,   def_module_01_02_pressure_interval);
	// рисуем линии в интервале defined_interval
	this->calc_E2(0, ntrial, t, text, labdata, s, 3, false, false,  vx_defined_interval, ve_in_defined_interval, def_module_defined_pressure_interval);
	if (labdata)
	{
		labdata->push_back(LabData());
		text = &labdata->back().text;
	}	
	// Пишем результаты вычисления в text в интервале 1-2
	this->calc_E2(1, ntrial, t, text, NULL,    s, 2, true,  true,   vx_01_02_interval,   ve_in_01_02_interval,   def_module_01_02_pressure_interval);
	// Пишем результаты вычисления в text в интервале defined_interval
	this->calc_E2(2, ntrial, t, text, NULL,    s, 3, true,  false,  vx_defined_interval, ve_in_defined_interval, def_module_defined_pressure_interval);



	// рисуем все точки 
	this->calc_E2_(t, text, labdata, s, 1, false, false,  vx, ve, NULL);

	// рисуем логарифмическую интерполяцию компрессионной кривой
	this->calc_E2_(t, text, labdata, s, 3, false, false,  vx, ve, NULL);
	if (labdata)
	{
		labdata->push_back(LabData());
		text = &labdata->back().text;
	}

	// рисуем логарифмическую интерполяцию компрессионной кривой
	this->calc_E2_(t, text, labdata, s, 4, false, false,  vx, ve, NULL);
	if (labdata)
	{
		labdata->push_back(LabData());
		text = &labdata->back().text;
	}

	// Пишем результаты вычисления в text
	this->calc_E2_(t, text, NULL,    s, 3, true, true,  vx, ve, NULL);
}

void LabLayer::Compression3_Normatives_common_e(LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata)
{
	// нормативные и расчётные модуля деформации 
	// путём статистической обработки всех пар опытных значений

	vector<x_compression> vx;
	vector<trial_got_value> ve;
	vx.clear();
	ve.clear();

	double def_module_01_02_pressure_interval[2];
	vector<x_compression> vx_01_02_interval;
	vector<trial_got_value> ve_in_01_02_interval;

	double def_module_defined_pressure_interval[2];
	vector<x_compression> vx_defined_interval;
	vector<trial_got_value> ve_in_defined_interval;

	char s[1024];
	sprintf(s,"\0");

	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		LabNumber * labnumber = (*it);
		if (labnumber)
		{
			LabTrial * trial = labnumber->FindLabTrial(t, -1);
			PhysicalLabTrial * phys =  dynamic_cast<PhysicalLabTrial *>(labnumber->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
			if (phys)
			{
				PhysicalLabTrialResults * phys_res =  dynamic_cast<PhysicalLabTrialResults *>(phys->results);
				if (phys_res)
				{
					if (!phys_res->calculed)
						phys_res->CalcProperties();					
						
					double e0 = phys_res->e.v;
//					double e1_in_01_02_pressure_interval;
//					double e1_in_defined_pressure_interval;

					if (trial)
					{
						CompressionLabTrial * compression_lab_trial = dynamic_cast<CompressionLabTrial *>(trial);
						this->FillCompressionData2(compression_lab_trial, 
							e0, s, vx, ve,
							def_module_01_02_pressure_interval,
							vx_01_02_interval,
							ve_in_01_02_interval,
							def_module_defined_pressure_interval,
							vx_defined_interval,
							ve_in_defined_interval);
					}
				}
			}
		}
	}





	// рисуем все точки 
	this->calc_E2(0, 0, t, text, labdata, s, 1, false, false,  vx,                  ve,                     NULL);
	// рисуем линии в интервале 1-2
	this->calc_E2(0, 0, t, text, labdata, s, 2, false, false,  vx_01_02_interval,   ve_in_01_02_interval,   def_module_01_02_pressure_interval);
	// рисуем линии в интервале defined_interval
	this->calc_E2(0, 0, t, text, labdata, s, 3, false, false,  vx_defined_interval, ve_in_defined_interval, def_module_defined_pressure_interval);
	if (labdata)
	{
		labdata->push_back(LabData());
		text = &labdata->back().text;
	}	
	// Пишем результаты вычисления в text в интервале 1-2
	this->calc_E2(0, 0, t, text, NULL,    s, 2, true,  true,   vx_01_02_interval,   ve_in_01_02_interval,   def_module_01_02_pressure_interval);
	// Пишем результаты вычисления в text в интервале defined_interval
	this->calc_E2(0, 0, t, text, NULL,    s, 3, true,  false,  vx_defined_interval, ve_in_defined_interval, def_module_defined_pressure_interval);



	// рисуем все точки 
	this->calc_E2_(t, text, labdata, s, 1, false, false,  vx, ve, NULL);

	// рисуем логарифмическую интерполяцию компрессионной кривой
	this->calc_E2_(t, text, labdata, s, 3, false, false,  vx, ve, NULL);
	if (labdata)
	{
		labdata->push_back(LabData());
		text = &labdata->back().text;
	}

	// рисуем логарифмическую интерполяцию компрессионной кривой
	this->calc_E2_(t, text, labdata, s, 4, false, false,  vx, ve, NULL);
	if (labdata)
	{
		labdata->push_back(LabData());
		text = &labdata->back().text;
	}

	// Пишем результаты вычисления в text
	this->calc_E2_(t, text, NULL,    s, 3, true, true,  vx, ve, NULL);
}

void LabLayer::Compression3Normatives_common_e(LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata)
{
	if (set_common_compression_to_one_plot)
	{
		Compression3_Normatives_common_e(t, text, labdata);
	}
	else
	{
		Compression3_Normatives_common_e(1, t, text, labdata);
		Compression3_Normatives_common_e(2, t, text, labdata);
		Compression3_Normatives_common_e(3, t, text, labdata);
	}
}

bool LabLayer::calc_E2_(
			LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata,
			const char * s, 
			int type,
			bool use_text, 
			bool use_text2, 
			vector<x_compression> & vx,
			vector<trial_got_value> & ve, double * pressure_interval)
{
	trial_value a0;
	trial_value a1;
	trial_value Se;
	int m;		
	LabTrialValueType vt;
	vt.m_indication = t;
	vt.is_result = false;
	vt.m_lablayer = this;

	vt.vt_Compression.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_relative_deformation ;

	if (to_calc_e_log_interp && ve.size())
	{
		printf("ve.size() = %u\n", ve.size());
		LogInterpOfCompression(0.3, 0, ve.size(), vx, ve, this->e_log_interp.minus_A, this->e_log_interp.x_0, this->e_log_interp.m_C, this->e_log_interp.m_log, this->e_log_interp.Sy_log);
		to_calc_e_log_interp = false;
	}

	vector<x_compression> vlogx;
	vlogx.resize(vx.size());
	for (size_t ii = 0; ii < vx.size(); ii++)
	{
		vlogx[ii] = log(vx[ii].x + this->e_log_interp.x_0);
	}

	MinSqLinearStatParameters param; 
	if (this->lab_normatives && this->MinSqLinearStat(vt, vlogx, ve, true, a0, a1, m, Se, param) && m)							
	{
		// определяем тип грунта
		CGround::ground_type gt = CGround::ground_type::Undefined_ground;
		// коэффициент Пуассона
		double mju = 0.0;
		double beta = 0.0;
		double beta_tab = GetBeta(mju);
		//double beta_mavrodi = 0.0;
		bool beta_determined = false;


		LabTrialValueType vtWp;
		vtWp.clear();
		vtWp.m_indication = LabTrial::indication::physical;
		vtWp.is_result = false;
		vtWp.vt_PhysicalLabTrial = PhysicalLabTrial::value_type::vt_moisture_on_plasticity_border;
		vtWp.m_lablayer = this;

		LabTrialValueType vtp;
		vtp.clear();
		vtp.m_indication = LabTrial::indication::physical;
		vtp.is_result = true;
		vtp.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_plasticity_index;
		vtp.m_lablayer = this;

		LabTrialValueType vtIL;
		vtIL.clear();
		vtIL.m_indication = LabTrial::indication::physical;
		vtIL.is_result = true;
		if (t == LabTrial::indication::compression_task_condition_absolute_deformation)
			vtIL.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_fluidity_index_water_saturated;
		else
			vtIL.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_fluidity_index_nature;
		vtIL.m_lablayer = this;

		map<LabTrialValueType, normative_value>::iterator itmp = this->lab_normatives->values.find(vtp);
		map<LabTrialValueType, normative_value>::iterator itmIL = this->lab_normatives->values.find(vtIL);
		map<LabTrialValueType, normative_value>::iterator itmWp = this->lab_normatives->values.find(vtWp);
		if (itmp != this->lab_normatives->values.end() && itmIL != this->lab_normatives->values.end() && itmWp != this->lab_normatives->values.end())
		{
			// определяем тип грунта
			gt = DefineGroundType((*itmp).second.v_n.v);
			// показатель текучести
			double IL = (*itmIL).second.v_n.v;
			double Ip = (*itmp).second.v_n.v;
			double Wp = (*itmWp).second.v_n.v;
			// коэффициент Пуассона
			// mju = GetPuasson(gt);
			mju = GetPuasson_interpolation(gt, IL, Ip, Wp);
			beta_tab = GetBeta(mju);
//			beta_mavrodi = GetBetaMavrodi(gt, (*itmp).second.v_n.v);

//			if (CompressionLabTrialResults::use_mavrodi_beta)
//				beta = beta_mavrodi;
//			else
				beta = beta_tab;

			beta_determined = true;

			if (use_text2 && text)
			{
				if (text) text->push_back(fmtstr("MinSqLinearStat (результат)", NULL, false, true));
				
				char str[4098];

				sprintf (str, "m = %d", m);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "a0.v = %f", a0.v);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "a1.v = %f", a1.v);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				if (text) text->push_back(fmtstr("", NULL, true, true));
			}
			if (use_text2 && text)
			{
				if (text) text->push_back(fmtstr("Число пластичности (нормативное значение)", NULL, false, true));
				
				char str[4098];

				sprintf (str, "%d", (*itmp).second.n);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "%f", (*itmp).second.v_n.v);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				CGround::s_Quantity = CGround::Quantity::singular;
				sprintf (str, "%s", CGround::GrountTypeToStringRus(gt));
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "mju = %f", mju);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "beta = %f", beta_tab);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

//				sprintf (str, "beta_mavrodi = %f", beta_mavrodi);
//				DeleteEndZeros(str);
//				if (text) text->push_back(fmtstr(str, NULL, false, true));


				if (text) text->push_back(fmtstr("", NULL, true, true));
			}
		}


		// расчётные значения 
		double e_n_min = a0.v + a1.v * param.x_min;
		double e_n_max = a0.v + a1.v * param.x_max;


		//double compression_module_e = -(1.0 + e_n_min) / a1.v;
		//double deformation_module_e = beta * compression_module_e;

	
		//double E = beta / a1.v;
			

		double V;
		Get_V_alpha_lambda_095(double(m-2), param.lambda, V);

		double delta_e_min = V * Se.v * param.Kx_min / sqrt(double(m));
		double delta_e_max = V * Se.v * param.Kx_max / sqrt(double(m));
		double gamma_g_e;
		bool use_formula_21 = false;
		
		if (true)//(!LabLayer::DefModuleNewRaschotnMethod)
		{
			double e_min = e_n_min - delta_e_min;
			double e_max = e_n_max - delta_e_max;


			use_formula_21 = ((e_min / param.x_min) < (e_max / param.x_max));

			// в любом случае не используем формулу 21
			// т.к. формула 21 имеет физический смысл только для среза
			// формула 21 отражает тот факт, что удельное сцепление 
			// для расчётных значений не может быть отрицательным 
			// однако для компрессии нет никаких физических 
			// предпосылок накладывать это ограничение для коэффициента a0 
			use_formula_21 = false;

			if (use_formula_21)
			{
				gamma_g_e = (e_n_min + e_n_max) * param.x_max / (e_max * (param.x_min + param.x_max));
			}
			else
			{
				gamma_g_e = (e_n_min + e_n_max) / (e_min + e_max);
			}
		}
		else
		{
			double e_min = e_n_min + delta_e_min;
			double e_max = e_n_max + delta_e_max;



			if (use_formula_21)
			{
				//gamma_g_epsilon = (epsilon_n_min + epsilon_n_max) * param.x_max / (epsilon_max * (param.x_min + param.x_max));
			}
			else
			{
				gamma_g_e = (e_min + e_max) / (e_n_min + e_n_max);
			}
		}

		this->e_log_interp_95.x_0 = this->e_log_interp.x_0;
		this->e_log_interp_95.minus_A = this->e_log_interp.minus_A * gamma_g_e;
		this->e_log_interp_95.m_C = this->e_log_interp.m_C / gamma_g_e;

//		double compression_module_e_95 = compression_module_e / gamma_g_e;
//		double deformation_module_e_95 = beta * compression_module_e_95;

		LabTrialValueType vte;
		vte.clear();
		vte.m_indication = LabTrial::indication::physical;
		vte.is_result = true;
		vte.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_e;
		vte.m_lablayer = this;

		map<LabTrialValueType, normative_value>::iterator itme = this->lab_normatives->values.find(vte);

		char str[4098];
		sprintf (str, "E %s (по един.совок.оп.)", s);			
		if (type == 1 && text) text->push_back(fmtstr(str, NULL, true, true));
		if (labdata)
		{
			if (type == 1)
			{
				if (labdata)
				{
					labdata->push_back(LabData());
					text = &labdata->back().text;
				}
				// plot
				labdata->back().plot_data.use_plot = true;
				labdata->back().plot_data.y_dir = +1;
				labdata->back().plot_data.title = "Компрессионная кривая (по един.совок.оп.)";//str;
				labdata->back().plot_data.xlabel = "Давления, МПа";
				labdata->back().plot_data.ylabel = "Коэф.порист.";

				labdata->back().plot_data.plot_lines.push_back(plot_line());
				labdata->back().plot_data.plot_lines.back().line_plot = false;

				for (size_t j = 0; j < vx.size() && j < ve.size(); j++)
				{
					labdata->back().plot_data.plot_lines.back().data.push_back(plot_data_2d(vx[j].x, ve[j].v));
				}

				if (true)
				{
					labdata->back().plot_data.log_interp.push_back(LogInterp());
					labdata->back().plot_data.log_interp.back().m_C = this->e_log_interp_95.m_C.v;
					labdata->back().plot_data.log_interp.back().m_A = -this->e_log_interp_95.minus_A.v;
					labdata->back().plot_data.log_interp.back().m_x0 = this->e_log_interp_95.x_0;
					labdata->back().plot_data.log_interp.back().line_color = RGB(0,0,200);
					labdata->back().plot_data.log_interp.back().line_width = 1;	
					labdata->back().plot_data.log_interp.back().line_style = PS_DOT;
				}

				if (true)
				{
					labdata->back().plot_data.log_interp.push_back(LogInterp());
					labdata->back().plot_data.log_interp.back().m_C = this->e_log_interp.m_C.v;
					labdata->back().plot_data.log_interp.back().m_A = -this->e_log_interp.minus_A.v;
					labdata->back().plot_data.log_interp.back().m_x0 = this->e_log_interp.x_0;
					labdata->back().plot_data.log_interp.back().line_color = RGB(0,0,200);
					labdata->back().plot_data.log_interp.back().line_width = 1;	
				}

			}
			if (type == 4)
			{
				if (labdata)
				{
					labdata->push_back(LabData());
					text = &labdata->back().text;
				}
				// plot
				labdata->back().plot_data.use_plot = true;
				labdata->back().plot_data.y_dir = +1;
				labdata->back().plot_data.title = "Модуль деформации нормативное и расчётное (0.95) значение ";//str;
				labdata->back().plot_data.xlabel = "Давления, МПа";
				labdata->back().plot_data.ylabel = "Модуль деформации";
				labdata->back().plot_data.zero_min_y = false;
				labdata->back().plot_data.x_ax_not_dubl = true;

				double max_x = -DBL_MAX;

				for (size_t ii = 0; ii < vx.size(); ii++)
				{
					if (max_x < vx[ii].x)
						max_x = vx[ii].x;
				}

				if (1 && itme != this->lab_normatives->values.end())
				{
					labdata->back().plot_data.plot_lines.push_back(plot_line());
					labdata->back().plot_data.plot_lines.back().line_plot = true;

					double e0 = (*itme).second.v_n.v;

					for (double x = 0.0; x<= 0.7; x+=0.05)
					{
#if !USE_e0_IN_E_CALCULATION 
						double E_x = beta * 
							(1.0 + this->e_log_interp.minus_A.v * log(x + this->e_log_interp.x_0) +
							this->e_log_interp.m_C.v) 
							* (x + this->e_log_interp.x_0) / (-this->e_log_interp.minus_A.v);
#else
						double E_x = beta * 
							(1.0 + e0) 
							* (x + this->e_log_interp.x_0) / (-this->e_log_interp.minus_A.v);
#endif
						//printf("x = %f, E_x = %f param.x_max = %f\n", x, E_x, param.x_max);
						
						labdata->back().plot_data.plot_lines.back().data.push_back(
							plot_data_2d(x, E_x));
					}
				}


				if (1 && itme != this->lab_normatives->values.end())
				{
					labdata->back().plot_data.plot_lines.push_back(plot_line());
					labdata->back().plot_data.plot_lines.back().line_plot = true;
					labdata->back().plot_data.plot_lines.back().line_style = PS_DOT;

					double e0_95 = (*itme).second.v_95.v;

					for (double x = 0.0; x<= 0.7; x+=0.05)
					{
#if !USE_e0_IN_E_CALCULATION 
						double E_x_95 = beta * 
							(1.0 + this->e_log_interp_95.minus_A.v * log(x + this->e_log_interp_95.x_0) +
							this->e_log_interp_95.m_C.v) 
							* (x + this->e_log_interp_95.x_0) / (-this->e_log_interp_95.minus_A.v);
#else
						double E_x_95 = beta * 
							(1.0 + e0_95) 
							* (x + this->e_log_interp_95.x_0) / (-this->e_log_interp_95.minus_A.v);
#endif
						//printf("x = %f, E_x_95 = %f\n", x, E_x_95);

						labdata->back().plot_data.plot_lines.back().data.push_back(
							plot_data_2d(x, E_x_95));
					}
				}



			}
		}
#if 0
		if (use_text && text && pressure_interval)
		{
			char s1[1024];
			char s2[1024];
			sprintf(s1, "%f", pressure_interval[0]);
			sprintf(s2, "%f", pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);

			sprintf (str, "Компрессионный модуль [%s - %s], МПа", s1, s2);

			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", m);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%f", compression_module_e);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "lambda=%f", param.lambda);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "V_95=%f", V);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "%f", compression_module_e_95);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}


#endif
		if(use_text && text && itme != this->lab_normatives->values.end())
		{
			e_p = this->e_log_interp.minus_A.v*log(this->deformation_module_defined_pressure + this->e_log_interp.x_0) + this->e_log_interp.m_C.v;
			
			// double a = dedp = A/(p+x0);
			// dsdx = minus_A/(x+x0)
			a_p = - this->e_log_interp.minus_A.v / (this->deformation_module_defined_pressure + this->e_log_interp.x_0);

#if !USE_e0_IN_E_CALCULATION 
			E_p = beta * (1.0 + e_p) / a_p;
#else
			double e0 = (*itme).second.v_n.v;
			E_p = beta * (1.0 + e0) / a_p;
#endif

			sprintf(str, "e = %f*ln(p+%f)+%f", this->e_log_interp.minus_A.v, this->e_log_interp.x_0, this->e_log_interp.m_C.v);
			text->push_back(fmtstr(str, &this->e_log_interp.m_C.f, true, false));
			
			char sp[1024];
			sprintf(sp, "%f", this->deformation_module_defined_pressure);
			DeleteEndZeros(sp);

			sprintf(str, "e(%s) = %f", sp, this->e_p);
			text->push_back(fmtstr(str, NULL, true, false));

			
			sprintf(str, "a(%s) = %f", sp, this->a_p);
			text->push_back(fmtstr(str, NULL, true, false));


			sprintf(str, "E(%s) = %f", sp, this->E_p);
			text->push_back(fmtstr(str, NULL, true, false));
		}
		if(use_text && text && itme != this->lab_normatives->values.end())
		{
			e_p_95 = this->e_log_interp_95.minus_A.v*log(this->deformation_module_defined_pressure + this->e_log_interp_95.x_0) + this->e_log_interp_95.m_C.v;
			
			// double a = dedp = A/(p+x0);
			// dsdx = minus_A/(x+x0)
			a_p_95 = - this->e_log_interp_95.minus_A.v / (this->deformation_module_defined_pressure + this->e_log_interp_95.x_0);

#if !USE_e0_IN_E_CALCULATION 
			E_p_95 = beta * (1.0 + e_p_95) / a_p_95;
#else
			double e0_95 = (*itme).second.v_95.v;
			E_p_95 = beta * (1.0 + e0_95) / a_p_95;
#endif

			sprintf(str, "e_95 = %f*ln(p+%f)+%f", this->e_log_interp_95.minus_A.v, this->e_log_interp_95.x_0, this->e_log_interp_95.m_C.v);
			text->push_back(fmtstr(str, &this->e_log_interp_95.m_C.f, true, false));
			
			char sp[1024];
			sprintf(sp, "%f", this->deformation_module_defined_pressure);
			DeleteEndZeros(sp);

			sprintf(str, "e_95(%s) = %f", sp, this->e_p_95);
			text->push_back(fmtstr(str, NULL, true, false));

			
			sprintf(str, "a_95(%s) = %f", sp, this->a_p_95);
			text->push_back(fmtstr(str, NULL, true, false));


			sprintf(str, "E_95(%s) = %f", sp, this->E_p_95);
			text->push_back(fmtstr(str, NULL, true, false));
		}
		
		if (use_text && text)
		{
			sprintf (str, "");

			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", m);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "");
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "lambda=%f", param.lambda);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "V_95=%f", V);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "");
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}


		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "Se=%f", Se.v);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "g_95=%f", gamma_g_e);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "F2%d", use_formula_21);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "e_n_min=%f", e_n_min);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "e_n_max=%f", e_n_max);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "delta_e_min=%f", delta_e_min);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "delta_e_max=%f", delta_e_max);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "param.Kx_min=%f", param.Kx_min);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "param.Kx_max=%f", param.Kx_max);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

#if 0
		if(beta_determined && use_text && text && pressure_interval)
		{
			char s1[1024];
			char s2[1024];
			sprintf(s1, "%f", pressure_interval[0]);
			sprintf(s2, "%f", pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);

			sprintf (str, "Модуль деформации [%s - %s], МПа", s1, s2);

			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", m);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%f", deformation_module_e);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));


			if (text) text->push_back(fmtstr("", NULL, false, true));
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "%f", deformation_module_e_95);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}
#endif
		return true;
	}
	else
	{
		return false;
	}
		
	return false;
}


bool LabLayer::calc_E3(int interval_type, int ntrial, 
			LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata,
			const char * s, 
			int type,
			bool use_text, 
			bool use_text2, 
			vector<x_compression> & vx,
			vector<trial_got_value> & vy, double * pressure_interval)
{
	trial_value a0;
	trial_value a1;
	trial_value Sepsilon;
	int m;		
	LabTrialValueType vt;
	vt.m_indication = t;
	vt.is_result = false;
	vt.m_lablayer = this;

	vt.vt_Compression.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_relative_deformation ;
		
	MinSqLinearStatParameters param; 
	if (this->lab_normatives && this->MinSqLinearStat(vt, vx, vy, true, a0, a1, m, Sepsilon, param) && m)							
	{
		// определяем тип грунта
		CGround::ground_type gt = CGround::ground_type::Undefined_ground;
		// коэффициент Пуассона
		double mju = 0.0;
		//double beta = GetBeta(mju);
		bool mju_determined = false;


		LabTrialValueType vtWp;
		vtWp.clear();
		vtWp.m_indication = LabTrial::indication::physical;
		vtWp.is_result = false;
		vtWp.vt_PhysicalLabTrial = PhysicalLabTrial::value_type::vt_moisture_on_plasticity_border;
		vtWp.m_lablayer = this;

		LabTrialValueType vtp;
		vtp.clear();
		vtp.m_indication = LabTrial::indication::physical;
		vtp.is_result = true;
		vtp.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_plasticity_index;
		vtp.m_lablayer = this;

		LabTrialValueType vtIL;
		vtIL.clear();
		vtIL.m_indication = LabTrial::indication::physical;
		vtIL.is_result = true;
		vtIL.vt_PhysicalLabTrialResults = PhysicalLabTrialResults::value_type::vt_fluidity_index_nature;
		vtIL.m_lablayer = this;

		map<LabTrialValueType, normative_value>::iterator itmp = this->lab_normatives->values.find(vtp);
		map<LabTrialValueType, normative_value>::iterator itmIL = this->lab_normatives->values.find(vtIL);
		map<LabTrialValueType, normative_value>::iterator itmWp = this->lab_normatives->values.find(vtWp);
		if (itmp != this->lab_normatives->values.end() && itmIL != this->lab_normatives->values.end() && itmWp != this->lab_normatives->values.end())
		{
			// определяем тип грунта
			gt = DefineGroundType((*itmp).second.v_n.v);
			// показатель текучести
			double IL = (*itmIL).second.v_n.v;
			double Ip = (*itmp).second.v_n.v;
			double Wp = (*itmWp).second.v_n.v;
			// коэффициент Пуассона
			// mju = GetPuasson(gt);
			mju = GetPuasson_interpolation(gt, IL, Ip, Wp);
			mju_determined = true;

			if (use_text2 && text)
			{
				if (text) text->push_back(fmtstr("Число пластичности (нормативное значение)", NULL, false, true));
				
				char str[4098];

				sprintf (str, "%d", (*itmp).second.n);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "%f", (*itmp).second.v_n.v);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "%s", CGround::GrountTypeToStringRus(gt));
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "mju = %f", mju);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				if (text) text->push_back(fmtstr("", NULL, false, true));

				if (text) text->push_back(fmtstr("", NULL, true, true));
			}
		}



		LabTrialValueType vtkp;
		vtkp.clear();
		vtkp.m_indication = t;
		vtkp.is_result = true;
		vtkp.vt_Compression.n_compression_value_type = 3;
		vtkp.vt_Compression.vt_CompressionLabTrialResults_3 = CompressionLabTrialResults::value_type_3::vt_Kp;
		vtkp.m_lablayer = this;

		bool kp_n_determined = false;

		double kp_n;
		double kp_95;

		map<LabTrialValueType, normative_value>::iterator itme = this->lab_normatives->values.find(vtkp);
		//map<LabTrialValueType, normative_value>::iterator itme = find2(vte, this->lab_normatives->values);
		if (itme != this->lab_normatives->values.end())
		{
			kp_n = (*itme).second.v_n.v;
			//double e_85 = (*itme).second.v_85.v;
			kp_95 = (*itme).second.v_95.v;
			//double e_99 = (*itme).second.v_99.v;

			kp_n_determined = true;


			if (use_text2 && text)
			{
				if (text) text->push_back(fmtstr("Коэффициент Kp (норм. и расч. знач.)", NULL, false, true));
				
				char str[4098];

				sprintf (str, "%d", (*itme).second.n);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				sprintf (str, "%f", kp_n);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));


				if (text) text->push_back(fmtstr("", NULL, false, true));
				if (text) text->push_back(fmtstr("", NULL, false, true));
				if (text) text->push_back(fmtstr("", NULL, false, true));

				sprintf (str, "%f", kp_95);
				DeleteEndZeros(str);
				if (text) text->push_back(fmtstr(str, NULL, false, true));

				if (text) text->push_back(fmtstr("", NULL, true, true));
			}


		}


		double shtamp_compression_module = 1.0 / a1.v;
		double shtamp_deformation_module = 10. * (1.0 - mju * mju) * 0.79 * Gurvich::shtamp_diameter / a1.v;
		
		// расчётные значения 
		double epsilon_n_min = a0.v + a1.v * param.x_min;
		double epsilon_n_max = a0.v + a1.v * param.x_max;

		double V;
		Get_V_alpha_lambda_095(double(m-2), param.lambda, V);

		double delta_epsilon_min = V * Sepsilon.v * param.Kx_min / sqrt(double(m));
		double delta_epsilon_max = V * Sepsilon.v * param.Kx_max / sqrt(double(m));

		double gamma_g_epsilon;
		bool use_formula_21 = false;
		if (!LabLayer::DefModuleNewRaschotnMethod)
		{
			double epsilon_min = epsilon_n_min - delta_epsilon_min;
			double epsilon_max = epsilon_n_max - delta_epsilon_max;


			use_formula_21 = ((epsilon_min / param.x_min) < (epsilon_max / param.x_max));

			if (use_formula_21)
			{
				gamma_g_epsilon = (epsilon_n_min + epsilon_n_max) * param.x_max / (epsilon_max * (param.x_min + param.x_max));
			}
			else
			{
				gamma_g_epsilon = (epsilon_n_min + epsilon_n_max) / (epsilon_min + epsilon_max);
			}
		}
		else
		{
			double epsilon_min = epsilon_n_min + delta_epsilon_min;
			double epsilon_max = epsilon_n_max + delta_epsilon_max;



			if (use_formula_21)
			{
				//gamma_g_epsilon = (epsilon_n_min + epsilon_n_max) * param.x_max / (epsilon_max * (param.x_min + param.x_max));
			}
			else
			{
				gamma_g_epsilon = (epsilon_min + epsilon_max) / (epsilon_n_min + epsilon_n_max);
			}
		}
		double shtamp_compression_module_95 = shtamp_compression_module / gamma_g_epsilon;
		double shtamp_deformation_module_95 = shtamp_deformation_module / gamma_g_epsilon;
		
		if (this->lab_normatives)
		{
			LabTrialValueType vt_res;

			vt_res.clear();
			vt_res.m_indication = t;
			vt_res.is_result = true;
			vt_res.m_lablayer = this;

			CompressionValueType * cvt = NULL;
			switch(t)
			{
			case LabTrial::indication::compression_nature_condition_absolute_deformation:
				{
					cvt = &vt_res.vt_Compression;
				}
				break;
			case LabTrial::indication::compression_task_condition_absolute_deformation:
				{
					cvt = &vt_res.vt_Compression;
				}
				break;
			case LabTrial::indication::compression_shrinkage_absolute_deformation:
				{
					cvt = &vt_res.vt_Compression;
				}
				break;
			case LabTrial::indication::compression_3:
				{				
					switch (ntrial)//(com_lab_pars->type)
					{
					case 1://CompressionLabTrial::type::nature_condition:
						{
							vt_res.vt_Compression_3.com_type = CompressionLabTrial::type::nature_condition;
							cvt = &vt_res.vt_Compression_3.vt_Compression_nature;
						}
						break;
					case 2://CompressionLabTrial::type::task_condition:
						{	
							vt_res.vt_Compression_3.com_type = CompressionLabTrial::type::task_condition;
							cvt = &vt_res.vt_Compression_3.vt_Compression_task;
						}
						break;
					case 3://CompressionLabTrial::type::shrinkage:
						{
							vt_res.vt_Compression_3.com_type = CompressionLabTrial::type::shrinkage;
							cvt = &vt_res.vt_Compression_3.vt_Compression_shrinkage;
						}
						break;
					}
				}
				break;
			}
			cvt->every_compression_experiment = false;


			cvt->n_compression_value_type = 3;//gurvich shtamp
#if 0 
			//vt_shtamp_compression_module_in_01_02_interval' : is not a member of 'CompressionLabTrialResults::value_type_3'
			if (interval_type)
			{
				if (interval_type == 1)
					cvt->vt_CompressionLabTrialResults_3 = CompressionLabTrialResults::value_type_3::vt_shtamp_compression_module_in_01_02_interval;
				else
					cvt->vt_CompressionLabTrialResults_3 = CompressionLabTrialResults::value_type_3::vt_shtamp_compression_module_in_defined_interval;
				this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
					normative_value(m, shtamp_compression_module, trial_value(), shtamp_compression_module_95, trial_value())));
			}
#endif
			if (interval_type)
			{
				if (interval_type == 1)
					cvt->vt_CompressionLabTrialResults_3 = CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_01_02_interval;
				else
					cvt->vt_CompressionLabTrialResults_3 = CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_defined_interval;
				this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
					normative_value(m, shtamp_deformation_module, trial_value(), shtamp_deformation_module_95, trial_value())));
			}
			if (interval_type)
			{
				if (interval_type == 1)
					cvt->vt_CompressionLabTrialResults_3 = CompressionLabTrialResults::value_type_3::vt_shtamp_Sy_lin_in_01_02_interval;
				else
					cvt->vt_CompressionLabTrialResults_3 = CompressionLabTrialResults::value_type_3::vt_shtamp_Sy_lin_in_defined_interval;
				this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
					normative_value(m, Sepsilon, trial_value(), trial_value(), trial_value())));
			}
			if (interval_type)
			{
				if (kp_n_determined)
				{
					if (interval_type == 1)
						cvt->vt_CompressionLabTrialResults_3 = CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_01_02_interval_Kp;
					else
						cvt->vt_CompressionLabTrialResults_3 = CompressionLabTrialResults::value_type_3::vt_shtamp_deformation_module_in_defined_interval_Kp;
					this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
						normative_value(m, shtamp_deformation_module * kp_n, trial_value(), shtamp_deformation_module_95 * kp_95, trial_value())));
						
					cvt->vt_CompressionLabTrialResults_3 = CompressionLabTrialResults::value_type_3::vt_Kp;
					this->lab_normatives->values.insert(map<LabTrialValueType, normative_value>::value_type(vt_res, 
						normative_value(m, kp_n, trial_value(), kp_95, trial_value())));
				}
			}
		}






		char str[4098];
		sprintf (str, "Модуль Деформации под штампом прогноз по Гурвичу %s (по един.совок.оп.)", s);			
		if (type == 1 && text) text->push_back(fmtstr(str, NULL, true, false));
		if (labdata)
		{
			if (type == 1)
			{


				// plot
				labdata->back().plot_data.use_plot = true;
				labdata->back().plot_data.y_dir = -1;
				labdata->back().plot_data.title = "Осадки под штампом прогноз по Гурвичу (по един.совок.оп.)";//str;
				labdata->back().plot_data.xlabel = "Давления, МПа";
				labdata->back().plot_data.ylabel = "Осадка, мм";

				labdata->back().plot_data.plot_lines.push_back(plot_line());							
				labdata->back().plot_data.plot_lines.back().line_plot = false;


				for (size_t j = 0; j < vx.size() && j < vy.size(); j++)
				{
					labdata->back().plot_data.plot_lines.back().data.push_back(plot_data_2d(vx[j].x, vy[j].v));
				}

			}
			if (type == 2 || type == 3)
			{
				labdata->back().plot_data.lin_interp.push_back(LinInterp());
				labdata->back().plot_data.lin_interp.back().m_a0 = a0.v;
				labdata->back().plot_data.lin_interp.back().m_a1 = a1.v;

				if ( type == 3)
					labdata->back().plot_data.lin_interp.back().line_color = RGB(0,0,200);


				if (pressure_interval)
				{
					labdata->back().plot_data.lin_interp.back().xmin = pressure_interval[0];
					labdata->back().plot_data.lin_interp.back().xmax = pressure_interval[1];
				}

				labdata->back().plot_data.lin_interp.push_back(LinInterp());
				labdata->back().plot_data.lin_interp.back().m_a0 = a0.v;
				labdata->back().plot_data.lin_interp.back().m_a1 = a1.v * gamma_g_epsilon;
				labdata->back().plot_data.lin_interp.back().line_style = PS_DOT;

				if ( type == 3)
					labdata->back().plot_data.lin_interp.back().line_color = RGB(0,0,200);

				if (pressure_interval)
				{
					labdata->back().plot_data.lin_interp.back().xmin = pressure_interval[0];
					labdata->back().plot_data.lin_interp.back().xmax = pressure_interval[1];
				}

				if (type == 3)
				{
					labdata->push_back(LabData());
					text = &labdata->back().text;
				}
			}
		}

		if(use_text && text && pressure_interval)
		{
			char s1[1024];
			char s2[1024];
			sprintf(s1, "%f", pressure_interval[0]);
			sprintf(s2, "%f", pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);

			sprintf (str, "Компрессионный модуль (штамп) [%s - %s], МПа", s1, s2);

			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", m);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%f", shtamp_compression_module);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "lambda=%f", param.lambda);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "V_95=%f", V);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "%f", shtamp_compression_module_95);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}


		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "Sepsilon=%f", Sepsilon.v);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "g_95=%f", gamma_g_epsilon);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "F2%d", use_formula_21);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "epsilon_n_min=%f", epsilon_n_min);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "epsilon_n_max=%f", epsilon_n_max);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "delta_epsilon_min=%f", delta_epsilon_min);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "delta_epsilon_max=%f", delta_epsilon_max);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if (use_text && text)
		{
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "param.Kx_min=%f", param.Kx_min);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "param.Kx_max=%f", param.Kx_max);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}

		if(mju_determined && use_text && text && pressure_interval)
		{
			char s1[1024];
			char s2[1024];
			sprintf(s1, "%f", pressure_interval[0]);
			sprintf(s2, "%f", pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);

			sprintf (str, "Модуль деформации (штамп) [%s - %s], МПа", s1, s2);

			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", m);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%f", shtamp_deformation_module);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));


			if (text) text->push_back(fmtstr("", NULL, false, true));
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "%f", shtamp_deformation_module_95);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}


		if(kp_n_determined && mju_determined && use_text && text && pressure_interval)
		{
			char s1[1024];
			char s2[1024];
			sprintf(s1, "%f", pressure_interval[0]);
			sprintf(s2, "%f", pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);

			sprintf (str, "Модуль деформации (штамп) [%s - %s] * Kp, МПа", s1, s2);

			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%d", m);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			sprintf (str, "%f", shtamp_deformation_module * kp_n);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));


			if (text) text->push_back(fmtstr("", NULL, false, true));
			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			sprintf (str, "%f", shtamp_deformation_module_95 * kp_95);
			DeleteEndZeros(str);
			if (text) text->push_back(fmtstr(str, NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, false, true));

			if (text) text->push_back(fmtstr("", NULL, true, true));
		}


		return true;
	}
	else
	{
		return false;
	}
		
	return false;
}

void LabLayer::FillCompressionData3(CompressionLabTrial * compression_lab_trial, 
	char * s,
	vector<x_compression> & vx,
	vector<trial_got_value> & vy,

	double * def_module_01_02_pressure_interval,
	vector<x_compression> & vx_01_02_interval,
	vector<trial_got_value> & vy_in_01_02_interval,

	double * def_module_defined_pressure_interval,
	vector<x_compression> & vx_defined_interval,
	vector<trial_got_value> & vy_in_defined_interval
	)
{
	if (compression_lab_trial)
	{
		CompressionLabTrialResults * compression_lab_trial_results = dynamic_cast<CompressionLabTrialResults *>(compression_lab_trial->results);
		if (compression_lab_trial_results)
		{

			sprintf(s,"%s\0", CompressionLabTrial::CompressionLabTrialTypeToStringRusSmall(compression_lab_trial->com_type));
			//CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(this->FindLabExperiment(LabExperiment::type::compression));
			//if(compression)
			{
				bool zamachivanie = false;

				double x;
				//vector<double> vlogx;
//				vector<double> vx;
				trial_got_value y;
//				vector<trial_got_value> vy;

				bool interval_01_02_started = false;
				bool interval_01_02_finished = false;

				bool defined_interval_started = false;
				bool defined_interval_finished = false;

//							compression->hoop_height;
//							compression->hoop_diameter;

				int n_pressures = compression_lab_trial_results->m_gurvich.shtamp_vx.size();

				for (int i = 0; i < n_pressures; i++)
				{
					x = compression_lab_trial_results->m_gurvich.shtamp_vx[i].x;
					y = compression_lab_trial_results->m_gurvich.shtamp_vy[i];
					//if (i > 0 && compression_lab_trial_results->m_gurvich.shtamp_vx[i-1] == compression_lab_trial_results->m_gurvich.shtamp_vx[i])
					if (compression_lab_trial_results->m_gurvich.shtamp_vx[i].voda)
					{
						zamachivanie = true;
					}


					/*if (i == 0)
					{
						deformation_module_pressure_interval[0] = x;
					}*/

					//y = compression_lab_trial->absolute_deformations[i];
					//y.v /= compression->hoop_height;
					y.lab_number = compression_lab_trial->lab_number;

					if (!zamachivanie)
					{
						vx.push_back(x);
//						vlogx.push_back(log(x));
						vy.push_back(y);
//						deformation_module_pressure_interval[1] = x;
					}

					if ( ! interval_01_02_started )
					{
						if (x >= CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0])
						{
							interval_01_02_started = true;
						}
					}
					if ( ! interval_01_02_finished )
					{
						if (x > CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1])
						{
							interval_01_02_finished = true;
						}
					}
					if (!zamachivanie && interval_01_02_started && !interval_01_02_finished )
					{
						vx_01_02_interval.push_back(x);
						vy_in_01_02_interval.push_back(y);

						if (vx_01_02_interval.size() == 1)
							def_module_01_02_pressure_interval[0] = x;
						def_module_01_02_pressure_interval[1] = x;
					}


					if ( ! defined_interval_started )
					{
						if (x >= this->deformation_module_defined_pressure_interval[0])
						{
							defined_interval_started = true;
						}
					}
					if ( ! defined_interval_finished )
					{
						if (x > this->deformation_module_defined_pressure_interval[1])
						{
							defined_interval_finished = true;
						}
					}
					if (!zamachivanie && defined_interval_started && !defined_interval_finished )
					{
						vx_defined_interval.push_back(x);
						vy_in_defined_interval.push_back(y);

						if (vx_defined_interval.size() == 1)
							def_module_defined_pressure_interval[0] = x;
						def_module_defined_pressure_interval[1] = x;
					}
				}
			}
		}
	}
}
void LabLayer::Compression3_Normatives_common_gurvich(int ntrial, LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata)
{
	// нормативные и расчётные модуля деформации 
	// путём статистической обработки всех пар 
	// значений косвенным методом рассчитанные для штампа
	// 

	vector<x_compression> vx;
	vector<trial_got_value> vy;
	vx.clear();
	vy.clear();

	double def_module_01_02_pressure_interval[2];
	vector<x_compression> vx_01_02_interval;
	vector<trial_got_value> vy_in_01_02_interval;

	double def_module_defined_pressure_interval[2];
	vector<x_compression> vx_defined_interval;
	vector<trial_got_value> vy_in_defined_interval;

	char s[1024];
	sprintf(s,"\0");

	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		LabNumber * labnumber = (*it);
		if (labnumber)
		{
			LabTrial * trial = labnumber->FindLabTrial(t, -1);
			if (trial)
			{
				CompressionLabTrial3 * compression_lab_trial_3 = dynamic_cast<CompressionLabTrial3 *>(trial);

				switch(ntrial)
				{
				case 1:
					{
						if (compression_lab_trial_3 && compression_lab_trial_3->p_trial_1)
						{
							this->FillCompressionData3(compression_lab_trial_3->p_trial_1, 
								s, vx, vy,
								def_module_01_02_pressure_interval,
								vx_01_02_interval,
								vy_in_01_02_interval,
								def_module_defined_pressure_interval,
								vx_defined_interval,
								vy_in_defined_interval);					
						}
					}
					break;
				case 2:
					{
						if (compression_lab_trial_3 && compression_lab_trial_3->p_trial_2)
						{
							this->FillCompressionData3(compression_lab_trial_3->p_trial_2, 
								s, vx, vy,
								def_module_01_02_pressure_interval,
								vx_01_02_interval,
								vy_in_01_02_interval,
								def_module_defined_pressure_interval,
								vx_defined_interval,
								vy_in_defined_interval);					
						}
					}
					break;
				case 3:
					{
						if (compression_lab_trial_3 && compression_lab_trial_3->p_trial_3)
						{
							this->FillCompressionData3(compression_lab_trial_3->p_trial_3, 
								s, vx, vy,
								def_module_01_02_pressure_interval,
								vx_01_02_interval,
								vy_in_01_02_interval,
								def_module_defined_pressure_interval,
								vx_defined_interval,
								vy_in_defined_interval);					
						}
					}
					break;
				}
				/*CompressionLabTrial * compression_lab_trial = dynamic_cast<CompressionLabTrial *>(trial);
				
				this->FillCompressionData3(compression_lab_trial, 
					s, vx, vy,
					def_module_01_02_pressure_interval,
					vx_01_02_interval,
					vy_in_01_02_interval,
					def_module_defined_pressure_interval,
					vx_defined_interval,
					vy_in_defined_interval);*/
			}
		}
	}

	// рисуем все точки 
	this->calc_E3(0, ntrial, t, text, labdata, s, 1, false, false,  vx,                  vy,                     NULL);
	// рисуем линии в интервале 1-2
	this->calc_E3(0, ntrial, t, text, labdata, s, 2, false, false,  vx_01_02_interval,   vy_in_01_02_interval,   def_module_01_02_pressure_interval);
	// рисуем линии в интервале defined_interval
	this->calc_E3(0, ntrial, t, text, labdata, s, 3, false, false,  vx_defined_interval, vy_in_defined_interval, def_module_defined_pressure_interval);
	// Пишем результаты вычисления в text в интервале 1-2
	this->calc_E3(1, ntrial, t, text, NULL,    s, 2, true,  true,   vx_01_02_interval,   vy_in_01_02_interval,   def_module_01_02_pressure_interval);
	// Пишем результаты вычисления в text в интервале defined_interval
	this->calc_E3(2, ntrial, t, text, NULL,    s, 3, true,  false,  vx_defined_interval, vy_in_defined_interval, def_module_defined_pressure_interval);
}

void LabLayer::Compression3_Normatives_common_gurvich(LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata)
{
	// нормативные и расчётные модуля деформации 
	// путём статистической обработки всех пар 
	// значений косвенным методом рассчитанные для штампа
	// 

	vector<x_compression> vx;
	vector<trial_got_value> vy;
	vx.clear();
	vy.clear();

	double def_module_01_02_pressure_interval[2];
	vector<x_compression> vx_01_02_interval;
	vector<trial_got_value> vy_in_01_02_interval;

	double def_module_defined_pressure_interval[2];
	vector<x_compression> vx_defined_interval;
	vector<trial_got_value> vy_in_defined_interval;

	char s[1024];
	sprintf(s,"\0");

	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		LabNumber * labnumber = (*it);
		if (labnumber)
		{
			LabTrial * trial = labnumber->FindLabTrial(t, -1);
			if (trial)
			{
				CompressionLabTrial * compression_lab_trial = dynamic_cast<CompressionLabTrial *>(trial);
				
				this->FillCompressionData3(compression_lab_trial, 
					s, vx, vy,
					def_module_01_02_pressure_interval,
					vx_01_02_interval,
					vy_in_01_02_interval,
					def_module_defined_pressure_interval,
					vx_defined_interval,
					vy_in_defined_interval);
			}
		}
	}

	// рисуем все точки 
	this->calc_E3(0, 0, t, text, labdata, s, 1, false, false,  vx,                  vy,                     NULL);
	// рисуем линии в интервале 1-2
	this->calc_E3(0, 0, t, text, labdata, s, 2, false, false,  vx_01_02_interval,   vy_in_01_02_interval,   def_module_01_02_pressure_interval);
	// рисуем линии в интервале defined_interval
	this->calc_E3(0, 0, t, text, labdata, s, 3, false, false,  vx_defined_interval, vy_in_defined_interval, def_module_defined_pressure_interval);
	// Пишем результаты вычисления в text в интервале 1-2
	this->calc_E3(0, 0, t, text, NULL,    s, 2, true,  true,   vx_01_02_interval,   vy_in_01_02_interval,   def_module_01_02_pressure_interval);
	// Пишем результаты вычисления в text в интервале defined_interval
	this->calc_E3(0, 0, t, text, NULL,    s, 3, true,  false,  vx_defined_interval, vy_in_defined_interval, def_module_defined_pressure_interval);
}

void LabLayer::Compression3Normatives_common_gurvich(LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata)
{
	if (set_common_compression_to_one_plot)
	{
		Compression3_Normatives_common_gurvich(t, text, labdata);
	}
	else
	{
		Compression3_Normatives_common_gurvich(1, t, text, labdata);
		Compression3_Normatives_common_gurvich(2, t, text, labdata);
		Compression3_Normatives_common_gurvich(3, t, text, labdata);
	}
}

void LabLayer::CompressionNormatives_common_gurvich(LabTrial::indication t, vector<fmtstr> *& text, vector<LabData> * labdata)
{
	// нормативные и расчётные модуля деформации 
	// путём статистической обработки всех пар 
	// значений косвенным методом рассчитанные для штампа
	// 

	vector<x_compression> vx;
	vector<trial_got_value> vy;
	vx.clear();
	vy.clear();

	double def_module_01_02_pressure_interval[2];
	vector<x_compression> vx_01_02_interval;
	vector<trial_got_value> vy_in_01_02_interval;

	double def_module_defined_pressure_interval[2];
	vector<x_compression> vx_defined_interval;
	vector<trial_got_value> vy_in_defined_interval;

	char s[1024];
	sprintf(s,"\0");

	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		LabNumber * labnumber = (*it);
		if (labnumber)
		{
			LabTrial * trial = labnumber->FindLabTrial(t, -1);
			if (trial)
			{
				CompressionLabTrial * compression_lab_trial = dynamic_cast<CompressionLabTrial *>(trial);
				
				this->FillCompressionData3(compression_lab_trial, 
					s, vx, vy,
					def_module_01_02_pressure_interval,
					vx_01_02_interval,
					vy_in_01_02_interval,
					def_module_defined_pressure_interval,
					vx_defined_interval,
					vy_in_defined_interval);
			}
		}
	}

	// рисуем все точки 
	this->calc_E3(0, 0, t, text, labdata, s, 1, false, false,  vx,                  vy,                     NULL);
	// рисуем линии в интервале 1-2
	this->calc_E3(0, 0, t, text, labdata, s, 2, false, false,  vx_01_02_interval,   vy_in_01_02_interval,   def_module_01_02_pressure_interval);
	// рисуем линии в интервале defined_interval
	this->calc_E3(0, 0, t, text, labdata, s, 3, false, false,  vx_defined_interval, vy_in_defined_interval, def_module_defined_pressure_interval);
	// Пишем результаты вычисления в text в интервале 1-2
	this->calc_E3(1, 0, t, text, NULL,    s, 2, true,  true,   vx_01_02_interval,   vy_in_01_02_interval,   def_module_01_02_pressure_interval);
	// Пишем результаты вычисления в text в интервале defined_interval
	this->calc_E3(2, 0, t, text, NULL,    s, 3, true,  false,  vx_defined_interval, vy_in_defined_interval, def_module_defined_pressure_interval);
}

bool LabLayer::context_with_lab_number_trial_list = true;
bool LabLayer::context_with_normatives = true;
bool LabLayer::context_with_normatives_by_all_experiences = true;
bool LabLayer::context_with_korrelation = false;
void LabLayer::Normatives(vector<fmtstr> * text, vector<LabData> * labdata)
{
	if (this->lab_normatives) this->lab_normatives->values.clear();

	if (labdata)
	{
		labdata->push_back(LabData());
		text = &labdata->back().text;
	}

	LabTrialValueType vt;
		
	this->CalcProperties();
		
	if (LabLayer::context_with_lab_number_trial_list)
		this->PrintLabNumbers(text);
		
	if (LabLayer::context_with_normatives || LabLayer::context_with_normatives_by_all_experiences)
		this->PrintNormativeHeaders(text);

	for (LabTrial::indication Indication = LabTrial::indication::undefined_lab_trial_indication;
		Indication != LabTrial::indication::end; Indication++)
	{	
		LabParameters * lab_params = this->FindLabParameters(Indication);
		if ((lab_params && lab_params->GetCheckedLabParam()) || (!text && !labdata))
		{
			if (labdata)
			{
				labdata->push_back(LabData());
				text = &labdata->back().text;
			}

			vt.clear();
			vt.m_indication = Indication;
			vt.is_result = false;
			vt.m_lablayer = this;


			if (				
				(lab_params && lab_params->parameters_initial && lab_params->parameters_initial->GetCheckedLabParam())
				||
				(lab_params && !lab_params->parameters_initial) // compression_3
				)
			{
#if 1
				if (LabLayer::context_with_lab_number_trial_list)
					vt.EnumValueTypes(this, text, labdata, &LabLayer::PrintCallBack);
				if (LabLayer::context_with_normatives)
					vt.EnumValueTypes(this, text, labdata, &LabLayer::NormativesCallBack);
#else					
				vt.EnumValueTypes(this, text, labdata, PrintAndNormativesCallBack);
#endif
			}

			if (LabNumber::context_with_results)
			{
				vt.is_result = true;
#if 1
				if (LabLayer::context_with_lab_number_trial_list)
					vt.EnumValueTypes(this, text, labdata, &LabLayer::PrintCallBack);
				if (LabLayer::context_with_normatives)
				{						
					vt.EnumValueTypes(this, text, labdata, &LabLayer::NormativesCallBack);
				}	

				if (LabLayer::context_with_normatives_by_all_experiences)
					this->EvalNormative2(vt, text, labdata);
#else
				vt.EnumValueTypes(this, text, labdata, PrintAndNormativesCallBack);
				if (LabLayer::context_with_normatives)
					this->EvalNormative2(vt, text, labdata);
#endif
			}
			else
			{
				vt.is_result = true;
				vt.EnumValueTypes(this, NULL, NULL, &LabLayer::NormativesCallBack);
			}
		}
	}

	if (LabLayer::context_with_korrelation)
	{
		vector<LabTrialValueType> vvt;
		this->GetChecked(vvt);

		if (vvt.size() >= 2)
		{
			//vector<fmtstr> * text = NULL;
			//vector<LabData> * labdata = NULL;        

			//labdata = Labdata;
			//text = Text;
			
			if (labdata)
			{
				labdata->push_back(LabData());
				text = &labdata->back().text;
			}			

			if (CorrelationCoefficient(vvt[0], vvt[1], text, labdata))
			{
			}
		}
	}
}

void LabLayer_PrintfProperties(LabLayer * lab_layer, vector<fmtstr> * text, vector<LabData> * labdata)
{
	char str[4098];
	char s[128];
	sprintf(s, "%s\0", lab_layer->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
	OemToChar(s,s);	
#endif
	sprintf(str, "Лабораторный слой = %s", s);
	if(text)text->push_back(fmtstr(str, NULL, true, false));

	lab_layer->Normatives(text, labdata);
}

void LabLayer::PrintfProperties(vector<fmtstr> & text)
{ 
	LabLayer_PrintfProperties(this, &text, NULL);
}

LabLayer * Laboratory::FindLabLayer(long id_ige)
{
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			if ((*it)->id_ige == id_ige)
			{
				return (*it);
			}
		}
	}
	return NULL;
}

LabNumber * Laboratory::FindLabNumber(const char * id)
{
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			LabNumber * found = (*it)->FindLabNumber(id);
			if (found)
				return found;

		}
	}
	return NULL;
}
LabNumber * Laboratory::FindLabNumber(long id_kt, long id_prob)
{
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			LabNumber * found = (*it)->FindLabNumber(id_kt, id_prob);
			if (found)
				return found;
		}
	}
	return NULL;
}

void Laboratory::ApplyParams()
{
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			(*it)->ApplyParams();
		}
	}
}
	
void Laboratory::ApplyZriz()
{
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			(*it)->ApplyZriz();
		}
	}
}

	
void Laboratory::ApplyCompress(bool use_compression3)
{
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			(*it)->ApplyCompress(use_compression3);
		}
	}
}

void Laboratory::ApplyGranular()
{
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			(*it)->ApplyGranular();
		}
	}
}

void Laboratory::ParseTrialIndications()
{
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			(*it)->ParseTrialIndications();
		}
	}
}

void Laboratory::ReCalcProperties(bool layer_recalc_e_log_interp, bool labnumber_recalc_e_log_interp)
{
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			(*it)->ReCalcProperties(layer_recalc_e_log_interp, labnumber_recalc_e_log_interp);
		}
	}
}

void Laboratory::FillLabParameters()
{
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			(*it)->FillLabParameters();
		}
	}
}


void Laboratory::Normatives()
{
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			(*it)->Normatives(NULL, NULL);
			(*it)->excluded_list_filled = true;
		}
	}
}


void Laboratory::UpdateExcluded()
{
	for (vector<excluded_lab_trial>::iterator it = Laboratory::excluded_trials.begin();
		it != Laboratory::excluded_trials.end(); it++)
	{
		if ((*it).check_included)
		{
			if ((*it).pf)
			{
				if (*(*it).pf == TRIAL_VALUE_EXCLUDED)
					*(*it).pf = TRIAL_VALUE_INCLUDED;

				if (*(*it).pf == TRIAL_VALUE_EXCLUDED_BY_MINSQLIN)
					*(*it).pf = TRIAL_VALUE_INCLUDED_TO_MINSQLIN;

				if((*it).trial)
					(*it).trial->IncludeConnected();
			}
		}
		else
		{
			if ((*it).pf)
			{
				if (*(*it).pf == TRIAL_VALUE_INCLUDED)
					*(*it).pf = TRIAL_VALUE_EXCLUDED;

				if (*(*it).pf == TRIAL_VALUE_INCLUDED_TO_MINSQLIN)
					*(*it).pf = TRIAL_VALUE_EXCLUDED_BY_MINSQLIN;

				if((*it).trial)
					(*it).trial->ExcludeConnected();
			}
		}
	}
}

void LabLayer::PrintfProperties(vector<LabData> & labdata)
{
	labdata.push_back(LabData());
	LabLayer_PrintfProperties(this, &labdata.back().text, &labdata);
}

bool LabNumber::context_with_results = true;

void LabNumber::CalcProperties()
{

#if USE_LAB_TRIALS_VECTOR
	for (vector<LabTrial*>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if (*it)
		{
			if (LabNumber::context_with_results && (*it)->results)
			{
				if(!(*it)->results->calculed)
					(*it)->results->CalcProperties();
			}
		}
	}
#else
	for (map<LabTrial::indication, LabTrial*>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if ((*it).second)
		{
			if (LabNumber::context_with_results && (*it).second->results)
			{
				if(!(*it).second->results->calculed)
					(*it).second->results->CalcProperties();
			}
		}
	}
#endif
}
void LabNumber::PrintfProperties(vector<fmtstr> & text)
{
	char str[4098];

	sprintf(str, "Лабораторный номер = %s", this->ID.c_str());
	text.push_back(fmtstr(str, NULL, true, false));

	sprintf(str, "%s № %s", LabNumber::MineWorkingTypeToStringRus(this->m_mine_working_type), this->mine_working_number.c_str());
	text.push_back(fmtstr(str, NULL, true, false));

	sprintf(str, "Глубина опробования %f\0", this->depth);
	DeleteEndZeros(str);
	text.push_back(fmtstr(str, NULL, true, false));

	this->CalcProperties();

#if USE_LAB_TRIALS_VECTOR
	for (vector<LabTrial*>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if (*it)
		{
			(*it)->PrintfProperties(text);
			if (LabNumber::context_with_results && (*it)->results)
			{
				(*it)->results->PrintfProperties(text);
			}
		}
	}
#else
	for (map<LabTrial::indication, LabTrial*>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if ((*it).second)
		{
			(*it).second->PrintfProperties(text);
			if (LabNumber::context_with_results && (*it).second->results)
			{
				(*it).second->results->PrintfProperties(text);
			}
		}
	}
#endif
}


void LabNumber::PrintfProperties(vector<LabData> & labdata)
{
	labdata.push_back(LabData());

	char str[4098];

	sprintf(str, "Лабораторный номер = %s", this->ID.c_str());
	labdata.back().text.push_back(fmtstr(str, NULL, true, false));

	sprintf(str, "%s № %s", LabNumber::MineWorkingTypeToStringRus(this->m_mine_working_type), this->mine_working_number.c_str());
	labdata.back().text.push_back(fmtstr(str, NULL, true, false));

	sprintf(str, "Глубина опробования %f\0", this->depth);
	DeleteEndZeros(str);
	labdata.back().text.push_back(fmtstr(str, NULL, true, false));

	this->CalcProperties();

#if USE_LAB_TRIALS_VECTOR
	for (vector<LabTrial*>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if (*it)
		{
			(*it)->PrintfProperties(labdata);
			if (LabNumber::context_with_results && (*it)->results)
			{
				(*it)->results->PrintfProperties(labdata);
			}
		}
	}
#else
	for (map<LabTrial::indication, LabTrial*>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if ((*it).second)
		{
			(*it).second->PrintfProperties(labdata);
			if (LabNumber::context_with_results && (*it).second->results)
			{
				(*it).second->results->PrintfProperties(labdata);
			}
		}
	}
#endif
}

struct MyLabTrial
{
	LabTrial * m_trial;
	LabTrial::indication m_indication;

	MyLabTrial (LabTrial * trial, LabTrial::indication indication)
	{
		m_trial = trial;
		m_indication = indication;
	}
};
CGround::ground_type LabNumber::GetGroundType(
	FractionsLabTrialResults::SandSoilsClass & ssc,
	FractionsLabTrialResults::ClaySoilsClass & csc)
{
	csc = FractionsLabTrialResults::ClaySoilsClass::undefined_clay_soil;
	ssc = FractionsLabTrialResults::SandSoilsClass::undefined_sand_soil;
	CGround::ground_type gt = CGround::ground_type::Undefined_ground;
	map<int, MyLabTrial> my_trials;

	for (vector<LabTrial*>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if (*it)
		{
			int n = 0;
			bool to_insert = false;
			switch ((*it)->trial_indication)
			{
			case LabTrial::indication::fractions:
				{
					n = 1;
					to_insert = true;
				}
				break;
			case LabTrial::indication::physical:
				{
					n = 2;
					if ((*it)->m_id_vyprob == MEAN_PHYS_VYPROB)
						to_insert = true;
				}
				break;
			}

			if (to_insert)
				my_trials.insert(map<int, MyLabTrial>::value_type(n, MyLabTrial((*it), (*it)->trial_indication)));
		}
	}



	map<int, MyLabTrial>::iterator found_fractions = my_trials.find(1);
	if (found_fractions != my_trials.end())
	{
		//
		
		FractionsLabTrial * frac = dynamic_cast<FractionsLabTrial *>((*found_fractions).second.m_trial);
		if (frac)
		{
			FractionsLabTrialResults * res = dynamic_cast<FractionsLabTrialResults *>(frac->results);
			if (res)
			{
				if(!res->calculed)
					res->CalcProperties();
				csc = res->m_clay_soil_class;
				switch(csc)
				{
				case FractionsLabTrialResults::ClaySoilsClass::undefined_clay_soil:
				case FractionsLabTrialResults::ClaySoilsClass::sand:
					gt = CGround::ground_type::Sand;
					break;
				case FractionsLabTrialResults::ClaySoilsClass::loam:
					gt = CGround::ground_type::Loam;
					break;
				case FractionsLabTrialResults::ClaySoilsClass::sandyLoam:
					gt = CGround::ground_type::SandyLoam;
					break;
				case FractionsLabTrialResults::ClaySoilsClass::clay:
					gt = CGround::ground_type::Clay;
					break;
				}
				ssc = res->m_sand_soil_class;
			}
		}
	}
	else
	{
		map<int, MyLabTrial>::iterator found_phys = my_trials.find(2);
		if (found_phys != my_trials.end())
		{
			PhysicalLabTrial * phys = dynamic_cast<PhysicalLabTrial *>((*found_phys).second.m_trial);
			if (phys)
			{
				PhysicalLabTrialResults * res = dynamic_cast<PhysicalLabTrialResults *>(phys->results);
				if (res)
				{
					if(!res->calculed)
						res->CalcProperties();
					gt = res->t;
				}
			}

		}
	}
	return gt;
}
string LabNumber::GetSoilDescription(bool from_db)
{
	if (from_db)
	{
		// название грунта из базы данных
		return grunt_name;
		return soil_name;
	}
	else
	{

		string S = "", s;

		CGround::s_Quantity = CGround::Quantity::plural;
		CGround::s_Quantity = CGround::Quantity::singular;


		map<int, MyLabTrial> my_trials;

		for (vector<LabTrial*>::iterator it = this->lab_trials.begin();
			it != this->lab_trials.end(); it++)
		{
			if (*it)
			{
				int n = 0;
				bool to_insert = true;;
				switch ((*it)->trial_indication)
				{
				case LabTrial::indication::fractions:
					{
						n = 2;
					}
					break;
				case LabTrial::indication::physical:
					{
						n = 1;
						if ((*it)->m_id_vyprob != MEAN_PHYS_VYPROB)
							to_insert = false;
					}
					break;
				case LabTrial::indication::chemical:
					{
						n = 3;
					}
					break;
				case LabTrial::indication::compression_3:
					{
						n = 4;
					}
					break;
				}

				if (to_insert)
					my_trials.insert(map<int, MyLabTrial>::value_type(n, MyLabTrial((*it), (*it)->trial_indication)));
			}
		}

		for(map<int, MyLabTrial>::iterator it = my_trials.begin();
			it != my_trials.end(); it++)
		{
			if ((*it).second.m_trial)
			{
				s = (*it).second.m_trial->GetSoilDescription();
				S += s;;
			}
		}





		// сформировать название грунта исходя из его свойств
		return S;
	}		
	return "";
}

SoilDescription LabNumber::GetSoilDescription()
{
	SoilDescription sd;

	sd.lab_n = this->lab_n;
	sd.lab_number = this;

#if USE_LAB_TRIALS_VECTOR
	for (vector<LabTrial*>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if (*it)
		{
			(*it)->GetSoilDescription(sd);
		}
	}
#else
	for (map<LabTrial::indication, LabTrial*>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if ((*it).second)
		{
			(*it).second->GetSoilDescription(sd);
		}
	}
#endif

	if (this)
	{
		sd.pck = this->pck;
		sd.pcb = this->pcb;
		sd.zond_type = this->zond_type;
	}
	return sd;
}


#if USE_LAB_TRIALS_VECTOR
LabTrial * LabNumber::CreateNewLabTrial(LabTrial::indication t, long id_vyprob)
{
	return (LabTrial*)LabTrial::operator new (sizeof(LabTrial),t, id_vyprob);
}
#else
LabTrial * LabNumber::CreateNewLabTrial(LabTrial::indication t)
{
	return (LabTrial*)LabTrial::operator new (sizeof(LabTrial),t);
}
#endif

#if USE_LAB_TRIALS_VECTOR
LabTrial * LabNumber::FindLabTrial(LabTrial::indication t, long id_vyprob)
{	
	for (vector<LabTrial *>::iterator it = this->lab_trials.begin();
		it != this->lab_trials.end(); it++)
	{
		if (*it)
		{
			if (
				(id_vyprob == (*it)->m_id_vyprob && (*it)->trial_indication == t)
				||
				(id_vyprob == -1 && (*it)->trial_indication == t)
				)
			{
				return (*it);
			}
		}
	}
	return NULL;
}

#else

LabTrial * LabNumber::FindLabTrial(LabTrial::indication t)
{	
	if(this->lab_trials.find(t) != this->lab_trials.end())
		return this->lab_trials[t];

	return NULL;
}
#endif
#if USE_LAB_TRIALS_VECTOR
LabTrial * LabNumber::AddNewLabTrial(LabTrial::indication t, LabTrial * lab_trial, long id_vyprob)
{
	this->lab_trials.push_back(lab_trial);	
	this->lab_trials.back()->SetLabNumber(this);
	return this->lab_trials.back();
}

LabTrial * LabNumber::AddNewLabTrial(LabTrial::indication t, long id_vyprob)
{
	LabTrial * lab_trial = this->CreateNewLabTrial(t, id_vyprob);
	if (lab_trial) 
	{
		this->AddNewLabTrial(t, lab_trial, id_vyprob);
//		this->ReDrawItem_OnTree(this->m_pSurfDoc ? this->m_pSurfDoc->hwndTV : NULL);
	}

	if(this->lab_layer)
	{
		this->lab_layer->AddNewLabParameters(t);
	}

	return lab_trial;
}
#else
LabTrial * LabNumber::AddNewLabTrial(LabTrial::indication t, LabTrial * lab_trial)
{
	if(this->lab_trials.find(t) != this->lab_trials.end())
		return NULL;

	this->lab_trials.insert(map<LabTrial::indication, LabTrial*>::value_type(t, lab_trial));	
	this->lab_trials[t]->SetLabNumber(this);
	return this->lab_trials[t];
}

LabTrial * LabNumber::AddNewLabTrial(LabTrial::indication t)
{
	LabTrial * lab_trial = this->CreateNewLabTrial(t);
	if (lab_trial) 
	{
		this->AddNewLabTrial(t, lab_trial);
//		this->ReDrawItem_OnTree(this->m_pSurfDoc ? this->m_pSurfDoc->hwndTV : NULL);
	}

	if(this->lab_layer)
	{
		this->lab_layer->AddNewLabParameters(t);
	}

	return lab_trial;
}
#endif


LabExperiment::LabExperiment()
{
	this->Init();
}
LabExperiment::~LabExperiment()
{
}
void LabExperiment::Init()
{
	this->lab_layer = NULL;
	this->exp_type = LabExperiment::type::undefined_lab_experiment;
}
const char * LabExperiment::LabExperimentTypeToString(LabExperiment::type t)
{
	switch (t)
	{
	case undefined_lab_experiment:
		return "undefined";
	case compression:
		return "compression";
	case cut:
		return "cut";
	case filtration:
		return "filtration";
	case pressing:
		return "pressing";
	case fractions:
		return "fractions";
	default:
		return "";
	}
	return "";
}

void * LabExperiment::operator new  (size_t size, LabExperiment::type t)
{
	//printf("LabExperiment::operator new (size_t size = %d, LabExperiment::type(%d) = %s\n", size, int(t), LabExperiment::LabExperimentTypeToString(t));

	switch (t)
	{
	case undefined_lab_experiment:
		return NULL;
	case compression:
		return reinterpret_cast<void*>(new CompressionLabExperiment);
	case cut:
		return reinterpret_cast<void*>(new CutLabExperiment);
	case filtration:
		return reinterpret_cast<void*>(new FiltrationLabExperiment);
	case pressing:
		return reinterpret_cast<void*>(new PressingLabExperiment);
	case fractions:
		return reinterpret_cast<void*>(new FractionsLabExperiment);
	default:
		return NULL;
	}
	return NULL;
}

void LabExperiment::operator delete(void * p, LabExperiment::type t)
{
	switch (t)
	{
	case undefined_lab_experiment:
		return;
	case compression:
		::operator delete(reinterpret_cast<CompressionLabExperiment*>(p));
		break;
	case cut:
		::operator delete(reinterpret_cast<CutLabExperiment*>(p));
		break;
	case filtration:
		::operator delete(reinterpret_cast<FiltrationLabExperiment*>(p));
		break;
	case pressing:
		::operator delete(reinterpret_cast<PressingLabExperiment*>(p));
		break;
	case fractions:
		::operator delete(reinterpret_cast<FractionsLabExperiment*>(p));
		break;
	default:
		return;
	}
}


CompressionLabExperiment::CompressionLabExperiment()
{
	this->Init();
}
CompressionLabExperiment::~CompressionLabExperiment()
{
}
void CompressionLabExperiment::Init()
{
	this->LabExperiment::Init();

	this->exp_type = LabExperiment::type::compression;

#if !USE_LAB_LAYER_PRESSURES
	this->lab_layer_n_pressures_in_nature_condition = 0;
	this->lab_layer_n_pressures_in_task_condition = 0;
	this->lab_layer_n_pressures_on_shrinkage = 0;

	this->lab_layer_pressures_in_nature_condition = NULL;
	this->lab_layer_pressures_in_task_condition = NULL;
	this->lab_layer_pressures_on_shrinkage = NULL;
#else
	this->n_pressures_in_nature_condition = 0;
	this->n_pressures_in_task_condition = 0;
	this->n_pressures_on_shrinkage = 0;

	this->pressures_in_nature_condition = NULL;
	this->pressures_in_task_condition = NULL;
	this->pressures_on_shrinkage = NULL;
#endif

	this->task_moisture_v = 0.0;
	this->task_density = 0.0;

	lab_layer_hoop_defined = false;

}
void CompressionLabExperiment::PrintfProperties()
{
}

bool CompressionLabExperiment::ParseTaskMoisture()
{
	return false;
}
CutLabExperiment::CutLabExperiment()
{
	this->Init();
}
CutLabExperiment::~CutLabExperiment()
{
}
void CutLabExperiment::Init()
{
	this->LabExperiment::Init();

	this->exp_type = LabExperiment::type::cut;

#if !USE_LAB_LAYER_CUT_PRESSURES
	this->lab_layer_n_pressures_in_nature_condition = 0;
	this->lab_layer_n_pressures_in_task_condition = 0;

	this->lab_layer_pressures_in_nature_condition = NULL;
	this->lab_layer_pressures_in_task_condition = NULL;
#else
	this->n_pressures_in_nature_condition = 0;
	this->n_pressures_in_task_condition = 0;

	this->pressures_in_nature_condition = NULL;
	this->pressures_in_task_condition = NULL;
#endif
	this->task_moisture_v = 0.0;

	this->hoop_diameter = 0.0;
	this->hoop_height = 0.0;
}
void CutLabExperiment::PrintfProperties()
{
}
bool CutLabExperiment::ParseTaskMoisture()
{
	return false;
}

FiltrationLabExperiment::FiltrationLabExperiment()
{
	this->Init();
}
FiltrationLabExperiment::~FiltrationLabExperiment()
{
}
void FiltrationLabExperiment::Init()
{
	this->LabExperiment::Init();

	this->exp_type = LabExperiment::type::filtration;

}
void FiltrationLabExperiment::PrintfProperties()
{
}

PressingLabExperiment::PressingLabExperiment()
{
	this->Init();
}
PressingLabExperiment::~PressingLabExperiment()
{
}
void PressingLabExperiment::Init()
{
	this->LabExperiment::Init();

	this->exp_type = LabExperiment::type::pressing;

	this->task_moisture_v = 0.0;

}
void PressingLabExperiment::PrintfProperties()
{
}
bool PressingLabExperiment::ParseTaskMoisture()
{
	return false;
}
FractionsLabExperiment::FractionsLabExperiment()
{
	this->Init();
}
FractionsLabExperiment::~FractionsLabExperiment()
{
}
void FractionsLabExperiment::Init()
{
	this->LabExperiment::Init();

	this->exp_type = LabExperiment::type::fractions;


#if !USE_LAB_LAYER_FRACTIONS
	// количество фракций, 
	lab_layer_n_fractions = 0;
	// массив диаметров фракций
	lab_layer_fractions_diameters = NULL;
#else
	// количество фракций, 
	this->n_fractions = 0;
	// массив диаметров фракций
	this->fractions_diameters = NULL;
#endif

}
void FractionsLabExperiment::PrintfProperties()
{
}
LabLayer::LabLayer(Laboratory * p_lab, const char * fn) : LabParam(NULL)
{
	filename				= fn;

	this->id_ige			= -1;
	this->p_laboratory		= p_lab;
	this->ID				= "";
	this->layer_number		= "";
	this->experiments_scheme = "";

	this->is_compression	= false;
	this->is_cut			= false;
	this->is_filtracion		= false;
	this->is_pressing		= false;
	this->is_filtracion		= false;

	this->check_draw		= true;

	this->excluded_list_filled = false;

	lab_object_type = LabObject::type::laboratory_layer;

	deformation_module_defined_pressure = 0.27;

	deformation_module_defined_pressure_interval[0] = 0.2;
	deformation_module_defined_pressure_interval[1] = 0.3;

	lab_normatives = new LabNormatives;

	this->LabParam::m_bChecked_LabParam = true;
	this->LabParam::lab_layer = this;
	this->LabParam::m_bExpanded_LabParam = false;
	 
	LabTrialValueType Vt;
	Vt.clear();
	Vt.m_lablayer = this;
	Vt.vt_common_type = LabTrialValueType::common_types::depth;
	lab_parameter_depth = new LabParameter(this, this, Vt); // ??? NULL ???

	this->LabParam::SetLabLayer(this);

	to_calc_e_log_interp = true;

}
LabLayer::~LabLayer()
{
	if (lab_normatives) delete lab_normatives;
}
void LabLayer::Properties()
{
}
void LabLayer::PrintfProperties()
{
	printf("LabLayer::PrintfProperties()\n");

	printf("ID = %s\n", ID.c_str());
	printf("layer_number = %s\n", layer_number.c_str());
	printf("experiments_scheme = %s\n", experiments_scheme.c_str());

	printf("is_compression	= %d\n", is_compression);
	printf("is_cut			= %d\n", is_cut);
	printf("is_filtracion	= %d\n", is_filtracion);
	printf("is_pressing     = %d\n", is_pressing);
	printf("is_fractions    = %d\n", is_fractions);
}

bool LabLayer::ParseExperimentsScheme()
{
	if (strlen(this->experiments_scheme.c_str()) >=5)
	{
		for (size_t i = 0; i < 5; i++)
		{
			bool good = this->experiments_scheme.c_str()[0] == '1' || this->experiments_scheme.c_str()[0] == '0';
			if (!good)
				return false;
		}

		if (this->experiments_scheme.c_str()[0] == '1')
			this->is_compression = true;
		else
			this->is_compression = false;

		if (this->experiments_scheme.c_str()[1] == '1')
			this->is_cut = true;
		else
			this->is_cut = false;

		if (this->experiments_scheme.c_str()[2] == '1')
			this->is_filtracion = true;
		else
			this->is_filtracion = false;


		if (this->experiments_scheme.c_str()[3] == '1')
			this->is_pressing = true;
		else
			this->is_pressing = false;

		if (this->experiments_scheme.c_str()[4] == '1')
			this->is_fractions = true;
		else
			this->is_fractions = false;

		return true;

	}
	return false;
}
void LabLayer::FormExperimentsScheme()
{
	this->is_compression = NULL != this->FindLabExperiment(LabExperiment::type::compression);
	this->is_cut = NULL != this->FindLabExperiment(LabExperiment::type::cut);
	this->is_filtracion = NULL != this->FindLabExperiment(LabExperiment::type::filtration);
	this->is_pressing = NULL != this->FindLabExperiment(LabExperiment::type::pressing);
	this->is_fractions = NULL != this->FindLabExperiment(LabExperiment::type::fractions);

	char scheme[6];
	sprintf(scheme, 
		"%d%d%d%d%d\0",
		this->is_compression,
		this->is_cut,
		this->is_filtracion,
		this->is_pressing,
		this->is_fractions);

	this->experiments_scheme = scheme;
}
LabParameters::LabParameters(LabLayer * ll) : LabParam(ll)
{
}
void * LabParameters::operator new  (size_t size, LabTrial::indication t, LabLayer * ll)
{
	//printf("LabExperiment::operator new (size_t size = %d, LabExperiment::type(%d) = %s\n", size, int(t), LabExperiment::LabExperimentTypeToString(t));

	switch (t)
	{
	case LabTrial::indication::undefined_lab_trial_indication:
		return NULL;
	case LabTrial::indication::physical:
		return reinterpret_cast<void*>(new PhysicalLabParameters(ll));
	case LabTrial::indication::chemical:
		return reinterpret_cast<void*>(new ChemicalLabParameters(ll));
	case LabTrial::indication::fractions:
		return reinterpret_cast<void*>(new FractionsLabParameters(ll));
	case LabTrial::indication::compression_nature_condition_absolute_deformation:
		return reinterpret_cast<void*>(new CompressionLabParameters(CompressionLabTrial::type::nature_condition, ll, false));
	case LabTrial::indication::compression_task_condition_absolute_deformation:
		return reinterpret_cast<void*>(new CompressionLabParameters(CompressionLabTrial::type::task_condition, ll, false));
	case LabTrial::indication::compression_shrinkage_absolute_deformation:
		return reinterpret_cast<void*>(new CompressionLabParameters(CompressionLabTrial::type::shrinkage, ll, false));
	case LabTrial::indication::cut_resistance_nature_condition:
		return reinterpret_cast<void*>(new CutLabParameters(CutLabTrial::type::nature_condition, ll));
	case LabTrial::indication::cut_resistance_task_condition:
		return reinterpret_cast<void*>(new CutLabParameters(CutLabTrial::type::task_condition, ll));
	case LabTrial::indication::pressing:
		return reinterpret_cast<void*>(new PressingLabParameters(ll));
	case LabTrial::indication::filtration_coefficient_with_pressures:
		return reinterpret_cast<void*>(new FiltrationLabParameters(FiltrationLabTrial::type::with_pressures, ll));
	case LabTrial::indication::filtration_coefficient_with_densities:
		return reinterpret_cast<void*>(new FiltrationLabParameters(FiltrationLabTrial::type::with_densities, ll));
	case LabTrial::indication::compression_3:
		return reinterpret_cast<void*>(new CompressionLabParameters3(ll));
	default:
		return NULL;

	}
	return NULL;
}

void LabParameters::operator delete(void * p, LabTrial::indication t, LabLayer *)
{
	switch (t)
	{
	case LabTrial::indication::undefined_lab_trial_indication:
		return;
	case LabTrial::indication::physical:
		::operator delete(reinterpret_cast<PhysicalLabParameters*>(p));
		break;
	case LabTrial::indication::chemical:
		::operator delete(reinterpret_cast<ChemicalLabParameters*>(p));
		break;
	case LabTrial::indication::fractions:
		::operator delete(reinterpret_cast<FractionsLabParameters*>(p));
		break;
	case LabTrial::indication::compression_nature_condition_absolute_deformation:
		::operator delete(reinterpret_cast<CompressionLabParameters*>(p));
		break;
	case LabTrial::indication::compression_task_condition_absolute_deformation:
		::operator delete(reinterpret_cast<CompressionLabParameters*>(p));
		break;
	case LabTrial::indication::compression_shrinkage_absolute_deformation:
		::operator delete(reinterpret_cast<CompressionLabParameters*>(p));
		break;
	case LabTrial::indication::cut_resistance_nature_condition:
		::operator delete(reinterpret_cast<CutLabParameters*>(p));
		break;
	case LabTrial::indication::cut_resistance_task_condition:
		::operator delete(reinterpret_cast<CutLabParameters*>(p));
		break;
	case LabTrial::indication::pressing:
		::operator delete(reinterpret_cast<PressingLabParameters*>(p));
		break;
	case LabTrial::indication::filtration_coefficient_with_pressures:
		::operator delete(reinterpret_cast<FiltrationLabParameters*>(p));
		break;
	case LabTrial::indication::filtration_coefficient_with_densities:
		::operator delete(reinterpret_cast<FiltrationLabParameters*>(p));
		break;
	case LabTrial::indication::compression_3:
		::operator delete(reinterpret_cast<CompressionLabParameters3*>(p));
		break;
	default:
		return;
	}
}

LabParametersResults::LabParametersResults(LabParameters * p, LabLayer * ll) : LabParam(ll)
{
	this->lab_parameters  = p;
}

LabParametersInitial::LabParametersInitial(LabParameters * p, LabLayer * ll) : LabParam(ll)
{
	this->lab_parameters  = p;
}

PhysicalLabParameters::PhysicalLabParameters(LabLayer * ll) : LabParameters(ll)
{
	this->m_indication = LabTrial::indication::physical;
	this->parameters_initial = new PhysicalLabParametersInitial(this, ll);
	this->parameters_results = new PhysicalLabParametersResults(this, ll);
}
PhysicalLabParametersInitial::PhysicalLabParametersInitial(LabParameters * p, LabLayer * ll) : LabParametersInitial(p,ll)
{
}
void PhysicalLabParametersInitial::FillLabParameters()
{

	LabTrialValueType Vt;
	for (PhysicalLabTrial::value_type vt = PhysicalLabTrial::value_type(PhysicalLabTrial::value_type::none+1);
		vt != PhysicalLabTrial::value_type::end; vt++)
	{
		Vt.clear();
		Vt.is_result = false;
		Vt.m_indication = LabTrial::indication::physical;
		Vt.vt_PhysicalLabTrial = vt;
		Vt.m_lablayer = this->lab_layer;
		if (this->lab_layer && this->lab_layer->GetValueCallBack(Vt, NULL))
		{
			this->m_params.insert(map<PhysicalLabTrial::value_type, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
		}
	}

}
PhysicalLabParametersResults::PhysicalLabParametersResults(LabParameters * p, LabLayer * ll) : LabParametersResults(p,ll)
{
}
void PhysicalLabParametersResults::FillLabParameters()
{
	LabTrialValueType Vt;
	for (PhysicalLabTrialResults::value_type vt = PhysicalLabTrialResults::value_type(PhysicalLabTrialResults::value_type::none+1);
		vt != PhysicalLabTrialResults::value_type::end; vt++)
	{
		Vt.clear();
		Vt.is_result = true;
		Vt.m_indication = LabTrial::indication::physical;
		Vt.vt_PhysicalLabTrialResults = vt;
		Vt.m_lablayer = this->lab_layer;
		if (this->lab_layer && this->lab_layer->GetValueCallBack(Vt, NULL))
			this->m_params.insert(map<PhysicalLabTrialResults::value_type, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
	}
}
ChemicalLabParameters::ChemicalLabParameters(LabLayer * ll) : LabParameters (ll)
{
	this->m_indication = LabTrial::indication::chemical;
	this->parameters_initial = new ChemicalLabParametersInitial(this, ll);
	this->parameters_results = new ChemicalLabParametersResults(this, ll);
}
ChemicalLabParametersInitial::ChemicalLabParametersInitial(LabParameters * p, LabLayer * ll) : LabParametersInitial(p, ll)
{
}
void ChemicalLabParametersInitial::FillLabParameters()
{
	LabTrialValueType Vt;
	for (ChemicalLabTrial::value_type vt = ChemicalLabTrial::value_type(ChemicalLabTrial::value_type::none+1);
		vt != ChemicalLabTrial::value_type::end; vt++)
	{
		Vt.clear();
		Vt.is_result = false;
		Vt.m_indication = LabTrial::indication::chemical;
		Vt.vt_ChemicalLabTrial = vt;
		Vt.m_lablayer = this->lab_layer;
		if (this->lab_layer && this->lab_layer->GetValueCallBack(Vt, NULL))
			this->m_params.insert(map<ChemicalLabTrial::value_type, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
	}
}
ChemicalLabParametersResults::ChemicalLabParametersResults(LabParameters * p, LabLayer * ll) : LabParametersResults(p, ll)
{
}
void ChemicalLabParametersResults::FillLabParameters()
{
	LabTrialValueType Vt;
	for (ChemicalLabTrialResults::value_type vt = ChemicalLabTrialResults::value_type(ChemicalLabTrialResults::value_type::none+1);
		vt != ChemicalLabTrialResults::value_type::end; vt++)
	{
		Vt.clear();
		Vt.is_result = true;
		Vt.m_indication = LabTrial::indication::chemical;
		Vt.vt_ChemicalLabTrialResults = vt;
		Vt.m_lablayer = this->lab_layer;
		if (this->lab_layer && this->lab_layer->GetValueCallBack(Vt, NULL))
			this->m_params.insert(map<ChemicalLabTrialResults::value_type, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
	}
}
FractionsLabParameters::FractionsLabParameters(LabLayer * ll) : LabParameters (ll)
{
	this->m_indication = LabTrial::indication::fractions;
	this->parameters_initial = new FractionsLabParametersInitial(this, ll);
	this->parameters_results = new FractionsLabParametersResults(this, ll);
}
fraction_lab_param::fraction_lab_param()
{
	n_fractions = 0;
	i_fraction = 0;
#if !USE_FRACTION_DIAMETERS_INTERVAL
	fraction_diameter = 0.0;
#endif
	fraction_diameter_high = DBL_MAX;
	fraction_diameter_low = DBL_MAX;
}
FractionsLabParametersInitial::FractionsLabParametersInitial(LabParameters * p, LabLayer * ll) : LabParametersInitial(p, ll)
{
}
void FractionsLabParametersInitial::FillLabParameters()
{
#if FRACTION_LAB_PARAM_INITIAL_MAP
	LabTrialValueType Vt;
	for (FractionsLabTrial::value_type vt = FractionsLabTrial::value_type(FractionsLabTrial::value_type::vt_fractions_content);
		vt != FractionsLabTrial::value_type::end; vt++)
	{				
		if (vt == FractionsLabTrial::value_type::vt_fractions_content)
		{
			if (this->lab_layer && this->lab_layer->GetValueCallBack(Vt, NULL))
			{
				FractionsLabExperiment * fractions = dynamic_cast<FractionsLabExperiment *>(this->lab_layer->FindLabExperiment(LabExperiment::type::fractions));
				if(fractions)
				{
					fraction_lab_param flp;
					flp.n_fractions = fractions->lab_layer_n_fractions ;
					for (int i = 0 ; i < fractions->lab_layer_n_fractions; i++)	
					{
						flp.i_fraction = i;
#if USE_FRACTION_DIAMETERS_INTERVAL
						flp.fraction_diameter_high = fractions->lab_layer_fractions_diameters[i].high;
						flp.fraction_diameter_low  = fractions->lab_layer_fractions_diameters[i].low;
#else
						flp.fraction_diameter = fractions->lab_layer_fractions_diameters[i];
						flp.fraction_diameter_high = flp.fraction_diameter_low;
						flp.fraction_diameter_low = i == flp.n_fractions - 1 ? -DBL_MAX : flp.fraction_diameter;
#endif
						Vt.clear();
						Vt.m_lablayer = this->lab_layer;
						Vt.is_result = false;
						Vt.m_indication = LabTrial::indication::fractions;
						Vt.vt_FractionsLabTrial = vt;
#if !USE_FRACTION_DIAMETERS_INTERVAL
						Vt.fraction_diameter = flp.fraction_diameter;
#endif
						Vt.fraction_diameter_high = flp.fraction_diameter_high;
						Vt.fraction_diameter_low = flp.fraction_diameter_low;
						Vt.n_fractions = flp.n_fractions;
						Vt.i_fraction = flp.i_fraction;

						flp.lab_param = new LabParameter(this, this->lab_layer, Vt);							
							
						this->m_fractions_content.push_back(flp);

					}
				}
			}
			this->m_params.insert(map<FractionsLabTrial::value_type, LabParameter*>::value_type(vt, NULL));
		}
		else
		{
			Vt.clear();
			Vt.is_result = false;
			Vt.m_lablayer = this->lab_layer;
			Vt.m_indication = LabTrial::indication::fractions;
			Vt.vt_FractionsLabTrial = vt;
			if (this->lab_layer && this->lab_layer->GetValueCallBack(Vt, NULL))
				this->m_params.insert(map<FractionsLabTrial::value_type, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
		}
	}
#endif
}
FractionsLabParametersResults::FractionsLabParametersResults(LabParameters * p, LabLayer * ll) : LabParametersResults(p, ll)
{
}
void FractionsLabParametersResults::FillLabParameters()
{
	LabTrialValueType Vt;
	for (FractionsLabTrialResults::value_type vt = FractionsLabTrialResults::value_type(FractionsLabTrialResults::value_type::none+1);
		vt != FractionsLabTrialResults::value_type::end; vt++)
	{			
		Vt.clear();
		Vt.is_result = true;
		Vt.m_indication = LabTrial::indication::fractions;
		Vt.vt_FractionsLabTrialResults = vt;
		Vt.m_lablayer = this->lab_layer;
		if (this->lab_layer && this->lab_layer->GetValueCallBack(Vt, NULL))
			this->m_params.insert(map<FractionsLabTrialResults::value_type, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
	}
}
CompressionLabParameters::CompressionLabParameters(CompressionLabTrial::type t, LabLayer * ll, bool have_parent) : LabParameters (ll)
{
	type = t;
	have_compression_3_parent = have_parent;
	switch(type)
	{
	case CompressionLabTrial::type::nature_condition:
		this->m_indication = LabTrial::indication::compression_nature_condition_absolute_deformation;
		break;
	case CompressionLabTrial::type::task_condition:
		this->m_indication = LabTrial::indication::compression_task_condition_absolute_deformation;
		break;
	case CompressionLabTrial::type::shrinkage:
		this->m_indication = LabTrial::indication::compression_shrinkage_absolute_deformation;
		break;
	case CompressionLabTrial::type::tri:
		this->m_indication = LabTrial::indication::compression_3;
		break;
	}

	this->parameters_initial = new CompressionLabParametersInitial(this, ll);
	this->parameters_results = new CompressionLabParametersResults(this, ll);
#if USE_COMPR_PO_OTN_DEF	
	this->parameters_results1_every  = new CompressionLabParametersResults1(this, ll, true);
	this->parameters_results1_common = new CompressionLabParametersResults1(this, ll, false);
#endif
	this->parameters_results2_every  = new CompressionLabParametersResults2(this, ll, true);
	this->parameters_results2_common = new CompressionLabParametersResults2(this, ll, false);
	this->parameters_results3_every  = new CompressionLabParametersResults3(this, ll, true);
	this->parameters_results3_common = new CompressionLabParametersResults3(this, ll, false);
}
CompressionLabParameters3::CompressionLabParameters3(LabLayer * ll) : LabParameters (ll),
params_nature (CompressionLabTrial::type::nature_condition, ll, true),
params_task (CompressionLabTrial::type::task_condition, ll, true),
params_shrinkage (CompressionLabTrial::type::shrinkage, ll, true),
params_tri (this, ll, true)

{
	this->m_indication = LabTrial::indication::compression_3;
	this->parameters_initial = NULL;
	this->parameters_results = NULL;
}
CompressionLabParametersInitial::CompressionLabParametersInitial(LabParameters * p, LabLayer * ll) : LabParametersInitial(p, ll)
{
}
void CompressionLabParametersInitial::FillLabParameters()
{
	if (this->lab_layer)
	{
		CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(this->lab_layer->FindLabExperiment(LabExperiment::type::compression));
		if(compression)
		{
			CompressionLabParameters * com_lab_pars = dynamic_cast<CompressionLabParameters *>(this->lab_parameters);
			if (com_lab_pars)
			{
				LabTrialValueType Vt;
				Vt.clear();
				Vt.is_result = false;
				Vt.m_lablayer = this->lab_layer;
				CompressionValueType * cvt = NULL;

				if (com_lab_pars->have_compression_3_parent)
				{				
					Vt.m_indication = LabTrial::indication::compression_3;
					switch (com_lab_pars->type)
					{
					case CompressionLabTrial::type::nature_condition:
						{
							Vt.vt_Compression_3.com_type = CompressionLabTrial::type::nature_condition;
							cvt = &Vt.vt_Compression_3.vt_Compression_nature;
						}
						break;
					case CompressionLabTrial::type::task_condition:
						{	
							Vt.vt_Compression_3.com_type = CompressionLabTrial::type::task_condition;
							cvt = &Vt.vt_Compression_3.vt_Compression_task;
						}
						break;
					case CompressionLabTrial::type::shrinkage:
						{
							Vt.vt_Compression_3.com_type = CompressionLabTrial::type::shrinkage;
							cvt = &Vt.vt_Compression_3.vt_Compression_shrinkage;
						}
						break;
					}
				}
				else
				{
					switch (com_lab_pars->type)
					{
					case CompressionLabTrial::type::nature_condition:
						{
							Vt.m_indication = LabTrial::indication::compression_nature_condition_absolute_deformation;
						}
						break;
					case CompressionLabTrial::type::task_condition:
						{	
							Vt.m_indication = LabTrial::indication::compression_task_condition_absolute_deformation;
						}
						break;
					case CompressionLabTrial::type::shrinkage:
						{
							Vt.m_indication = LabTrial::indication::compression_shrinkage_absolute_deformation;
						}
						break;
					case CompressionLabTrial::type::tri:
						{
							Vt.m_indication = LabTrial::indication::compression_3;
						}
						break;
					}
					cvt = &Vt.vt_Compression;
				}
				if (cvt)
					cvt->vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_absolute_deformation;
				switch (com_lab_pars->type)
				{
				case CompressionLabTrial::type::nature_condition:
					{
						bool zamachivanie = false;
						for (int i = 0 ; i < compression->lab_layer_n_pressures_in_nature_condition; i++)	
						{
							compression_lab_param clp;
							clp.com_type = com_lab_pars->type;
							clp.n_compression_pressures = compression->lab_layer_n_pressures_in_nature_condition;
							clp.i_compression_pressure = i;
							clp.compression_pressure = compression->lab_layer_pressures_in_nature_condition[i];


							if (i > 0 && compression->lab_layer_pressures_in_nature_condition[i] == compression->lab_layer_pressures_in_nature_condition[i-1])
								zamachivanie = true;
							clp.zamachivanie = zamachivanie;
								
							cvt->com_type = clp.com_type;
							cvt->n_compression_pressures = clp.n_compression_pressures;
							cvt->i_compression_pressure = clp.i_compression_pressure;
							cvt->compression_pressure = clp.compression_pressure;
							cvt->compression_zamachivanie = clp.zamachivanie;

								
							clp.lab_param = new LabParameter(this, this->lab_layer, Vt);
							this->m_absolute_deformations.push_back(clp);
						}
					}
					break;
				case CompressionLabTrial::type::task_condition:
					{
						// массив pressures
						bool zamachivanie = false;
						for (int i = 0 ; i < compression->lab_layer_n_pressures_in_task_condition; i++)									
						{
							compression_lab_param clp;
							clp.com_type = com_lab_pars->type;
							clp.n_compression_pressures = compression->lab_layer_n_pressures_in_task_condition;
							clp.i_compression_pressure = i;
							clp.compression_pressure = compression->lab_layer_pressures_in_task_condition[i];

							if (i > 0 && compression->lab_layer_pressures_in_task_condition[i] == compression->lab_layer_pressures_in_task_condition[i-1])
								zamachivanie = true;
							clp.zamachivanie = zamachivanie;

							cvt->com_type = clp.com_type;
							cvt->n_compression_pressures = clp.n_compression_pressures;
							cvt->i_compression_pressure = clp.i_compression_pressure;
							cvt->compression_pressure = clp.compression_pressure;
							cvt->compression_zamachivanie = clp.zamachivanie;

							clp.lab_param = new LabParameter(this, this->lab_layer, Vt);
							this->m_absolute_deformations.push_back(clp);
						}
						
					}
					break;
				case CompressionLabTrial::type::shrinkage:
					{
						// массив pressures
						bool zamachivanie = false;
						for (int i = 0 ; i < compression->lab_layer_n_pressures_on_shrinkage; i++)									
						{
							compression_lab_param clp;
							clp.com_type = com_lab_pars->type;
							clp.n_compression_pressures = compression->lab_layer_n_pressures_on_shrinkage;
							clp.i_compression_pressure = i;
							clp.compression_pressure = compression->lab_layer_pressures_on_shrinkage[i];

							if (i > 0 && compression->lab_layer_pressures_on_shrinkage[i] == compression->lab_layer_pressures_on_shrinkage[i-1])
								zamachivanie = true;
							clp.zamachivanie = zamachivanie;

							cvt->com_type = clp.com_type;
							cvt->n_compression_pressures = clp.n_compression_pressures;
							cvt->i_compression_pressure = clp.i_compression_pressure;
							cvt->compression_pressure = clp.compression_pressure;
							cvt->compression_zamachivanie = clp.zamachivanie;

							clp.lab_param = new LabParameter(this, this->lab_layer, Vt);
							this->m_absolute_deformations.push_back(clp);
						}					
					}
					break;
				}
			}
		}
	}						

}
bool CompressionLabParameters::Is_Used_Result_Parameter(int n_compression_value_type, int vt, bool every, LabTrialValueType & Vt)
{
	Vt.clear();
	Vt.is_result = true;
	Vt.m_lablayer = lab_layer;
	
	CompressionValueType * cvt = NULL;

	if (this->have_compression_3_parent)
	{				
		Vt.m_indication = LabTrial::indication::compression_3;
		switch (this->type)
		{
		case CompressionLabTrial::type::nature_condition:
			{
				Vt.vt_Compression_3.com_type = CompressionLabTrial::type::nature_condition;
				cvt = &Vt.vt_Compression_3.vt_Compression_nature;
			}
			break;
		case CompressionLabTrial::type::task_condition:
			{	
				Vt.vt_Compression_3.com_type = CompressionLabTrial::type::task_condition;
				cvt = &Vt.vt_Compression_3.vt_Compression_task;
			}
			break;
		case CompressionLabTrial::type::shrinkage:
			{
				Vt.vt_Compression_3.com_type = CompressionLabTrial::type::shrinkage;
				cvt = &Vt.vt_Compression_3.vt_Compression_shrinkage;
			}
			break;
		}
	}
	else
	{
		switch (this->type)
		{
		case CompressionLabTrial::type::nature_condition:
			{
				Vt.m_indication = LabTrial::indication::compression_nature_condition_absolute_deformation;
			}
			break;
		case CompressionLabTrial::type::task_condition:
			{	
				Vt.m_indication = LabTrial::indication::compression_task_condition_absolute_deformation;
			}
			break;
		case CompressionLabTrial::type::shrinkage:
			{
				Vt.m_indication = LabTrial::indication::compression_shrinkage_absolute_deformation;
			}
			break;
		case CompressionLabTrial::type::tri:
			{
				Vt.m_indication = LabTrial::indication::compression_3;
			}
			break;
		}
		cvt = &Vt.vt_Compression;
	}
	if (cvt)
	{
		cvt->every_compression_experiment = every;
		cvt->n_compression_value_type = n_compression_value_type;
		switch(n_compression_value_type)
		{
		case 0:
			{
				cvt->vt_CompressionLabTrialResults_0 = (CompressionLabTrialResults::value_type_0)vt;
			}
			break;
#if USE_COMPR_PO_OTN_DEF
		case 1:
			{
				cvt->vt_CompressionLabTrialResults_1 = (CompressionLabTrialResults::value_type_1)vt;
			}
			break;
#endif
		case 2:
			{
				cvt->vt_CompressionLabTrialResults_2 = (CompressionLabTrialResults::value_type_2)vt;
			}
			break;
		case 3:
			{
				cvt->vt_CompressionLabTrialResults_3 = (CompressionLabTrialResults::value_type_3)vt;
			}
			break;
		}
	}

	return (lab_layer && lab_layer->GetValueCallBack(Vt, NULL));
}

CompressionLabParametersResults::CompressionLabParametersResults(LabParameters * p, LabLayer * ll) : LabParametersResults(p, ll)
{
}
void CompressionLabParametersResults::FillLabParameters()
{
	CompressionLabParameters * com_lab_pars = dynamic_cast<CompressionLabParameters *>(this->lab_parameters);
	for (CompressionLabTrialResults::value_type_0 vt = CompressionLabTrialResults::value_type_0(CompressionLabTrialResults::value_type_0::none_0+1);
		vt != CompressionLabTrialResults::value_type_0::end_0; vt++)
	{
		LabTrialValueType Vt;
		if (com_lab_pars && com_lab_pars->Is_Used_Result_Parameter(0, vt, true, Vt))
		{
			this->m_params.insert(map<CompressionLabTrialResults::value_type_0, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
		}
	}
}
#if USE_COMPR_PO_OTN_DEF	
CompressionLabParametersResults1::CompressionLabParametersResults1(LabParameters * p, LabLayer * ll, bool ev) : LabParametersResults(p, ll)
{
	every = ev;
}
void CompressionLabParametersResults1::FillLabParameters()
{
	CompressionLabParameters * com_lab_pars = dynamic_cast<CompressionLabParameters *>(this->lab_parameters);
	for (CompressionLabTrialResults::value_type_1 vt = CompressionLabTrialResults::value_type_1(CompressionLabTrialResults::value_type_1::none_1+1);
		vt != CompressionLabTrialResults::value_type_1::end_1; vt++)
	{
		LabTrialValueType Vt;
		if (com_lab_pars && com_lab_pars->Is_Used_Result_Parameter(1, vt, this->every, Vt))
			this->m_params.insert(map<CompressionLabTrialResults::value_type_1, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
	}
}

#endif
CompressionLabParametersResults2::CompressionLabParametersResults2(LabParameters * p, LabLayer * ll, bool ev) : LabParametersResults(p, ll)
{
	every = ev;
}
void CompressionLabParametersResults2::FillLabParameters()
{
	CompressionLabParameters * com_lab_pars = dynamic_cast<CompressionLabParameters *>(this->lab_parameters);
	for (CompressionLabTrialResults::value_type_2 vt = CompressionLabTrialResults::value_type_2(CompressionLabTrialResults::value_type_2::none_2+1);
		vt != CompressionLabTrialResults::value_type_2::end_2; vt++)
	{
		LabTrialValueType Vt;
		if (com_lab_pars && com_lab_pars->Is_Used_Result_Parameter(2, vt, this->every, Vt))
			this->m_params.insert(map<CompressionLabTrialResults::value_type_2, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
	}
}

CompressionLabParametersResults3::CompressionLabParametersResults3(LabParameters * p, LabLayer * ll, bool ev) : LabParametersResults(p, ll)
{
	every = ev;
}
void CompressionLabParametersResults3::FillLabParameters()
{
	this->m_bChecked_LabParam = false;

	CompressionLabParameters * com_lab_pars = dynamic_cast<CompressionLabParameters *>(this->lab_parameters);
	for (CompressionLabTrialResults::value_type_3 vt = CompressionLabTrialResults::value_type_3(CompressionLabTrialResults::value_type_3::none_3+1);
		vt != CompressionLabTrialResults::value_type_3::end_3; vt++)
	{
		LabTrialValueType Vt;
		if (com_lab_pars && com_lab_pars->Is_Used_Result_Parameter(3, vt, this->every, Vt))
		{
			LabParameter * lab_paramerer = new LabParameter(this, this->lab_layer, Vt);
			if (lab_paramerer)
			{
				//lab_paramerer->UnCheck();
				lab_paramerer->m_bChecked_LabParam = false;
				this->m_params.insert(map<CompressionLabTrialResults::value_type_3, LabParameter*>::value_type(vt, lab_paramerer));
			}
		}
	}
}
CompressionLabParametersResult_tri::CompressionLabParametersResult_tri(LabParameters * p, LabLayer * ll, bool ev) : LabParametersResults(p, ll)
{
	every = ev;
}
void CompressionLabParametersResult_tri::FillLabParameters()
{
	for (CompressionLabTrialResults3::value_type vt = CompressionLabTrialResults3::value_type(CompressionLabTrialResults3::value_type::none+1);
		vt != CompressionLabTrialResults3::value_type::end; vt++)
	{
		LabTrialValueType Vt;
		Vt.clear();
		Vt.m_indication = LabTrial::indication::compression_3;
		Vt.is_result = true;
		Vt.m_lablayer = lab_layer;
		Vt.vt_Compression_3.com_type = CompressionLabTrial::type::tri;
		Vt.vt_Compression_3.vt_CompressionLabTrialResults3 = vt;
		if (lab_layer && lab_layer->GetValueCallBack(Vt, NULL));
			this->m_params.insert(map<CompressionLabTrialResults3::value_type, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
	}
}

CutLabParameters::CutLabParameters(CutLabTrial::type t, LabLayer * ll) : LabParameters(ll)
{
	type = t;
	switch(type)
	{
	case CutLabTrial::type::nature_condition:
		this->m_indication = LabTrial::indication::cut_resistance_nature_condition;
		break;
	case CutLabTrial::type::task_condition:
		this->m_indication = LabTrial::indication::cut_resistance_task_condition;
		break;
	}
	this->parameters_initial = new CutLabParametersInitial(this, ll);
	this->parameters_results = new CutLabParametersResults(this, ll);
	this->parameters_results_common = new CutLabParametersResults_common(this, ll);
}
CutLabParametersInitial::CutLabParametersInitial(LabParameters * p, LabLayer * ll) : LabParametersInitial(p, ll)
{
}
void CutLabParametersInitial::FillLabParameters()
{
#if CUT_LAB_PARAM_INITIAL_MAP
	for (CutLabTrial::value_type vt = CutLabTrial::value_type(CutLabTrial::value_type::none+1);
		vt != CutLabTrial::value_type::end; vt++)
		this->m_params.insert(map<CutLabTrial::value_type, LabParameter*>::value_type(vt, new LabParameter(this, ll)));
#endif
	if (this->lab_layer)
	{
		CutLabExperiment * cut = dynamic_cast<CutLabExperiment *>(this->lab_layer->FindLabExperiment(LabExperiment::type::cut));
		if(cut)
		{
			CutLabParameters * cut_lab_pars = dynamic_cast<CutLabParameters *>(this->lab_parameters);
			if (cut_lab_pars)
			{								
				LabTrialValueType Vt;
				Vt.clear();
				Vt.is_result = false;
				Vt.vt_CutLabTrial = CutLabTrial::value_type::vt_cut_resistance;
				Vt.m_lablayer = this->lab_layer;

				switch (cut_lab_pars->type)
				{
				case CutLabTrial::type::nature_condition:
					{
						Vt.m_indication = LabTrial::indication::cut_resistance_nature_condition;
						Vt.cut_type = CutLabTrial::type::nature_condition;
						for (int i = 0 ; i < cut->lab_layer_n_pressures_in_nature_condition; i++)	
						{
							cut_lab_param clp;
							clp.cut_type = cut_lab_pars->type;
							clp.n_cut_pressures = cut->lab_layer_n_pressures_in_nature_condition;
							clp.i_cut_pressure = i;
							clp.cut_pressure = cut->lab_layer_pressures_in_nature_condition[i];

							Vt.n_cut_pressures = clp.n_cut_pressures;
							Vt.i_cut_pressure = clp.i_cut_pressure;
							Vt.cut_pressure = clp.cut_pressure;

							clp.lab_param = new LabParameter(this, this->lab_layer, Vt);								
								
							this->m_cut_resistance.push_back(clp);
						}
					}
					break;
				case CutLabTrial::type::task_condition:
					{
						Vt.m_indication = LabTrial::indication::cut_resistance_task_condition;
						Vt.cut_type = CutLabTrial::type::task_condition;
						// массив pressures
						for (int i = 0 ; i < cut->lab_layer_n_pressures_in_task_condition; i++)									
						{
							cut_lab_param clp;
							clp.cut_type = cut_lab_pars->type;
							clp.n_cut_pressures = cut->lab_layer_n_pressures_in_task_condition;
							clp.i_cut_pressure = i;
							clp.cut_pressure = cut->lab_layer_pressures_in_task_condition[i];

							Vt.n_cut_pressures = clp.n_cut_pressures;
							Vt.i_cut_pressure = clp.i_cut_pressure;
							Vt.cut_pressure = clp.cut_pressure;

							clp.lab_param = new LabParameter(this, this->lab_layer, Vt);

							this->m_cut_resistance.push_back(clp);
						}
						
					}
					break;
				}
			}
		}
	}						

}
#if 0
bool CutLabParameters::Is_Used_Result_Parameter(int n_cut_value_type, int vt)
{
	LabTrialValueType Vt;
	Vt.clear();
	Vt.is_result = true;
	Vt.n_cut_value_type = n_cut_value_type;
							
	switch (this->type)
	{
	case CutLabTrial::type::nature_condition:
		{
			Vt.m_indication = LabTrial::indication::cut_resistance_nature_condition;
		}
		break;
	case CutLabTrial::type::task_condition:
		{	
			Vt.m_indication = LabTrial::indication::cut_resistance_task_condition;
		}
		break;

	}

	switch(n_compression_value_type)
	{
	case 0:
		{
			Vt.vt_CompressionLabTrialResults_0 = (CompressionLabTrialResults::value_type_0)vt;
		}
		break;
	case 1:
		{
			Vt.vt_CompressionLabTrialResults_1 = (CompressionLabTrialResults::value_type_1)vt;
		}
		break;
	case 2:
		{
			Vt.vt_CompressionLabTrialResults_2 = (CompressionLabTrialResults::value_type_2)vt;
		}
		break;
	case 3:
		{
			Vt.vt_CompressionLabTrialResults_3 = (CompressionLabTrialResults::value_type_3)vt;
		}
		break;
	}
	return (lab_layer && lab_layer->GetValueCallBack(Vt, NULL));
}


#endif
CutLabParametersResults::CutLabParametersResults(LabParameters * p, LabLayer * ll) : LabParametersResults(p, ll)
{
}
void CutLabParametersResults::FillLabParameters()
{	
	LabTrialValueType Vt;
	for (CutLabTrialResults::value_type vt = CutLabTrialResults::value_type(CutLabTrialResults::value_type::none+1);
		vt != CutLabTrialResults::value_type::end; vt++)
	{
		Vt.clear();
		Vt.is_result = true;
		Vt.m_lablayer = this->lab_layer;
		CutLabParameters * cut_lab_pars = dynamic_cast<CutLabParameters *>(this->lab_parameters);
		if (cut_lab_pars)
		{								
			switch (cut_lab_pars->type)
			{
			case CutLabTrial::type::nature_condition:
				{
					Vt.m_indication = LabTrial::indication::cut_resistance_nature_condition;
					Vt.cut_type = CutLabTrial::type::nature_condition;
				}
				break;
			case CutLabTrial::type::task_condition:
				{	
					Vt.m_indication = LabTrial::indication::cut_resistance_task_condition;
					Vt.cut_type = CutLabTrial::type::task_condition;
				}
				break;
			}
		}
		Vt.vt_CutLabTrialResults = vt;
		Vt.every_cut_experiment = true;
		if (this->lab_layer && this->lab_layer->GetValueCallBack(Vt, NULL))
			this->m_params.insert(map<CutLabTrialResults::value_type, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
	}
}

CutLabParametersResults_common::CutLabParametersResults_common(LabParameters * p, LabLayer * ll) : LabParametersResults(p, ll)
{
}
void CutLabParametersResults_common::FillLabParameters()
{
	LabTrialValueType Vt;
	for (CutLabTrialResults::value_type vt = CutLabTrialResults::value_type(CutLabTrialResults::value_type::none+1);
		vt != CutLabTrialResults::value_type::end; vt++)
	{
		Vt.clear();
		Vt.is_result = true;
		Vt.m_lablayer = this->lab_layer;
		CutLabParameters * cut_lab_pars = dynamic_cast<CutLabParameters *>(this->lab_parameters);
		if (cut_lab_pars)
		{								
			switch (cut_lab_pars->type)
			{
			case CutLabTrial::type::nature_condition:
				{
					Vt.m_indication = LabTrial::indication::cut_resistance_nature_condition;
					Vt.cut_type = CutLabTrial::type::nature_condition;
				}
				break;
			case CutLabTrial::type::task_condition:
				{	
					Vt.m_indication = LabTrial::indication::cut_resistance_task_condition;
					Vt.cut_type = CutLabTrial::type::task_condition;
				}
				break;
			}
		}
		Vt.vt_CutLabTrialResults = vt;
		Vt.every_cut_experiment = false;
		if (this->lab_layer && this->lab_layer->GetValueCallBack(Vt, NULL))
			this->m_params.insert(map<CutLabTrialResults::value_type, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
	}
}
PressingLabParameters::PressingLabParameters(LabLayer * ll) : LabParameters(ll)
{
	this->m_indication = LabTrial::indication::pressing;
	this->parameters_initial = new PressingLabParametersInitial(this, ll);
	this->parameters_results = new PressingLabParametersResults(this, ll);
}
PressingLabParametersInitial::PressingLabParametersInitial(LabParameters * p, LabLayer * ll) : LabParametersInitial(p, ll)
{
}
void PressingLabParametersInitial::FillLabParameters()
{
	LabTrialValueType Vt;
	for (PressingLabTrial::value_type vt = PressingLabTrial::value_type(PressingLabTrial::value_type::none+1);
		vt != PressingLabTrial::value_type::end; vt++)
	{
		Vt.clear();
		Vt.is_result = false;
		Vt.m_indication = LabTrial::indication::pressing;
		Vt.vt_PressingLabTrial = vt;
		if (this->lab_layer && this->lab_layer->GetValueCallBack(Vt, NULL))
			this->m_params.insert(map<PressingLabTrial::value_type, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
	}
}
PressingLabParametersResults::PressingLabParametersResults(LabParameters * p, LabLayer * ll) : LabParametersResults(p, ll)
{
}
void PressingLabParametersResults::FillLabParameters()
{
	LabTrialValueType Vt;
	for (PressingLabTrialResults::value_type vt = PressingLabTrialResults::value_type(PressingLabTrialResults::value_type::none+1);
		vt != PressingLabTrialResults::value_type::end; vt++)
	{
		Vt.clear();
		Vt.is_result = true;
		Vt.m_indication = LabTrial::indication::pressing;
		Vt.vt_PressingLabTrialResults = vt;
		Vt.m_lablayer = this->lab_layer;
		if (this->lab_layer && this->lab_layer->GetValueCallBack(Vt, NULL))
			this->m_params.insert(map<PressingLabTrialResults::value_type, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
	}
}

FiltrationLabParameters::FiltrationLabParameters(FiltrationLabTrial::type t, LabLayer * ll) : LabParameters(ll)
{
	type = t;
	switch(type)
	{
	case FiltrationLabTrial::type::with_densities:
		this->m_indication = LabTrial::indication::filtration_coefficient_with_densities;
		break;
	case FiltrationLabTrial::type::with_pressures:
		this->m_indication = LabTrial::indication::filtration_coefficient_with_pressures;
		break;
	}
	this->parameters_initial = new FiltrationLabParametersInitial(this, ll);
	this->parameters_results = new FiltrationLabParametersResults(this, ll);
}
FiltrationLabParametersInitial::FiltrationLabParametersInitial(LabParameters * p, LabLayer * ll) : LabParametersInitial(p, ll)
{
}
void FiltrationLabParametersInitial::FillLabParameters()
{
	FiltrationLabParameters * filtr_lab_parameters = dynamic_cast <FiltrationLabParameters *>(this->lab_parameters);

	if (filtr_lab_parameters)
	{
		LabTrialValueType Vt;
		for (FiltrationLabTrial::value_type vt = FiltrationLabTrial::value_type(FiltrationLabTrial::value_type::none+1);
			vt != FiltrationLabTrial::value_type::end; vt++)
		{
			Vt.clear();
			Vt.is_result = false;
			Vt.m_lablayer = this->lab_layer;
			Vt.filtr_type = filtr_lab_parameters->GetType();
			switch(Vt.filtr_type)
			{
			case FiltrationLabTrial::type::with_densities:
				Vt.m_indication = LabTrial::indication::filtration_coefficient_with_densities;
				break;
			case FiltrationLabTrial::type::with_pressures:
				Vt.m_indication = LabTrial::indication::filtration_coefficient_with_pressures;
				break;
			}
			Vt.vt_FiltrationLabTrial = vt;

			if (this->lab_layer && this->lab_layer->GetValueCallBack(Vt, NULL))
				this->m_params.insert(map<FiltrationLabTrial::value_type, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
		}
	}
}
FiltrationLabParametersResults::FiltrationLabParametersResults(LabParameters * p, LabLayer * ll) : LabParametersResults(p, ll)
{
}
void FiltrationLabParametersResults::FillLabParameters()
{
	FiltrationLabParameters * filtr_lab_parameters = dynamic_cast <FiltrationLabParameters *>(this->lab_parameters);

	if (filtr_lab_parameters)
	{
		LabTrialValueType Vt;
		for (FiltrationLabTrialResults::value_type vt = FiltrationLabTrialResults::value_type(FiltrationLabTrialResults::value_type::none+1);
			vt != FiltrationLabTrialResults::value_type::end; vt++)
		{
			Vt.clear();
			Vt.is_result = true;
			Vt.m_lablayer = this->lab_layer;
			Vt.filtr_type = filtr_lab_parameters->GetType();
			switch(Vt.filtr_type)
			{
			case FiltrationLabTrial::type::with_densities:
				Vt.m_indication = LabTrial::indication::filtration_coefficient_with_densities;
				break;
			case FiltrationLabTrial::type::with_pressures:
				Vt.m_indication = LabTrial::indication::filtration_coefficient_with_pressures;
				break;
			}
			Vt.vt_FiltrationLabTrialResults = vt;

			if (this->lab_layer && this->lab_layer->GetValueCallBack(Vt, NULL))
				this->m_params.insert(map<FiltrationLabTrialResults::value_type, LabParameter*>::value_type(vt, new LabParameter(this, this->lab_layer, Vt)));
		}
	}
}

LabParameters * LabLayer::CreateNewLabParameters(LabTrial::indication t)
{
	return (LabParameters*)LabParameters::operator new (sizeof(LabParameters), t, this);
}

LabParameters * LabLayer::FindLabParameters(LabTrial::indication t)
{
	if(this->lab_parameters.find(t) != this->lab_parameters.end())
		return this->lab_parameters[t];

	return NULL;
}
LabParameters * LabLayer::AddNewLabParameters(LabTrial::indication t, LabParameters * lab_params)
{
	if(this->lab_parameters.find(t) != this->lab_parameters.end())
		return NULL;

	this->lab_parameters.insert(map<LabTrial::indication, LabParameters*>::value_type(t, lab_params));	
	this->lab_parameters[t]->SetLabLayer(this);
	return this->lab_parameters[t];
}
LabParameters * LabLayer::AddNewLabParameters(LabTrial::indication t)
{
	if(this->lab_parameters.find(t) != this->lab_parameters.end())
		return NULL;

	LabParameters * lab_params = this->CreateNewLabParameters(t);
	if (lab_params) 
	{
		this->AddNewLabParameters(t, lab_params);
//		this->ReDrawItem_OnTree(this->m_pSurfDoc ? this->m_pSurfDoc->hwndTV : NULL);
	}
	return lab_params;
}
LabExperiment * LabLayer::CreateNewLabExperiment(LabExperiment::type t)
{
	return (LabExperiment*)LabExperiment::operator new (sizeof(LabExperiment),t);
}
LabExperiment * LabLayer::FindLabExperiment(LabExperiment::type t)
{
	if(this->lab_experiments.find(t) != this->lab_experiments.end())
		return this->lab_experiments[t];

	return NULL;
}
LabExperiment * LabLayer::AddNewLabExperiment(LabExperiment::type t, LabExperiment * lab_experiment)
{
	if(this->lab_experiments.find(t) != this->lab_experiments.end())
		return NULL;

	this->lab_experiments.insert(map<LabExperiment::type, LabExperiment*>::value_type(t, lab_experiment));	
	this->lab_experiments[t]->SetLabLayer(this);
	return this->lab_experiments[t];
}
LabExperiment * LabLayer::AddNewLabExperiment(LabExperiment::type t)
{
	LabExperiment * lab_experiment = this->CreateNewLabExperiment(t);
	if (lab_experiment) 
	{
		this->AddNewLabExperiment(t, lab_experiment);
//		this->ReDrawItem_OnTree(this->m_pSurfDoc ? this->m_pSurfDoc->hwndTV : NULL);
	}
	return lab_experiment;
}

LabNumber * LabLayer::AddNewLabNumber()
{
	LabNumber * lab_number = new LabNumber(this);
	this->lab_numbers.push_back(lab_number);
	return lab_number;
}

LabNumber * LabLayer::FindLabNumber(long id_kt, long id_prob)
{
	for (vector<LabNumber*>::iterator it = lab_numbers.begin();
		it != lab_numbers.end(); it++)
	{
		if ((*it) && (*it)->id_kt == id_kt && (*it)->id_prob == id_prob)
		{
			return (*it);
		}
	}
	return NULL;
}
LabNumber * LabLayer::FindLabNumber(const char * id)
{
	for (vector<LabNumber*>::iterator it = lab_numbers.begin();
		it != lab_numbers.end(); it++)
	{
		if ((*it) && strcmp((*it)->ID.c_str(), id) == 0)
		{
			return (*it);
		}
	}
	return NULL;
}

LabNumber::LabNumber(LabLayer * lablayer)
{
	this->lab_layer = lablayer;
	this->depth = 0.0;
	this->ID = "";
	this->s_mine_working_type = "";
	this->m_mine_working_type = LabNumber::mine_working_type::undefined;
	this->mine_working_number = "";

	this->is_trial_indication_1 = false;
	this->is_trial_indication_2 = false;
	this->is_trial_indication_3 = false;
	this->is_trial_indication_4 = false;
	this->is_trial_indication_5 = false;
	this->is_trial_indication_6 = false;
	this->is_trial_indication_7 = false;
	this->is_trial_indication_8 = false;
	this->is_trial_indication_9 = false;
	this->is_trial_indication_10 = false;
	this->is_trial_indication_11 = false;
	this->is_trial_indication_12 = false;

	lab_object_type = LabObject::type::laboratory_number;

	lab_n = -1;
	
	id_kodprob = -1;
	id_gr = -1;


	id_obj = -1;

	id_kt = -1; // ID комплексной точки
	kt_idtyp = -1;
	id_prob = -1;

	m_prop_values.clear();

	get_soil_description_from_db = false;

	soil_name = "";// из WenGeo
	grunt_name = "";// Сгенерированное имя на основе свойств

	id_ige = -1;

	zond_type = -1;
}
void LabNumber::ParseMineWorkingType()
{
	m_mine_working_type = LabNumber::mine_working_type::undefined;

	if (s_mine_working_type.size())
	{
		char szBuff[128];
		strcpy(szBuff, s_mine_working_type.c_str());
		OemToChar(szBuff, szBuff);

		setlocale( LC_ALL, "Russian" );
		char * buff = _strlwr( _strdup( szBuff ) );
		setlocale( LC_ALL, "English" );

		if (buff[0] == 'с' || buff[0] == 'c')
			m_mine_working_type = LabNumber::mine_working_type::well;

		if (buff[0] == 'ш')
			m_mine_working_type = LabNumber::mine_working_type::hole;
	}
}

const char * LabNumber::MineWorkingTypeToStringRus(mine_working_type t)
{
	switch(t)
	{
	case LabNumber::mine_working_type::undefined:
		return "undefined";
	case LabNumber::mine_working_type::well:
		return "Скважина";
	case LabNumber::mine_working_type::hole:
		return "Шурф";
	default:
		return "";

	}
}


bool LabNumber::ParseTrialIndications()
{
	is_trial_indication_1	= false;
	is_trial_indication_2	= false;
	is_trial_indication_3	= false;
	is_trial_indication_4	= false;
	is_trial_indication_5	= false;
	is_trial_indication_6	= false;
	is_trial_indication_7	= false;
	is_trial_indication_8	= false;
	is_trial_indication_9	= false;
	is_trial_indication_10	= false;
	is_trial_indication_11	= false;
	is_trial_indication_12	= false;

	bool result = false;

	for (map<LabTrial::indication, LabTrial::indication>::iterator it = trial_indications.begin();
		it != trial_indications.end(); it++)
	{
		bool got = true;
		switch ((*it).first)
		{
		case 1:
			is_trial_indication_1	= true;
			break;
		case 2:
			is_trial_indication_2	= true;
			break;
		case 3:
			is_trial_indication_3	= true;
			break;
		case 4:
			is_trial_indication_4	= true;
			break;
		case 5:
			is_trial_indication_5	= true;
			break;
		case 6:
			is_trial_indication_6	= true;
			break;
		case 7:
			is_trial_indication_7	= true;
			break;
		case 8:
			is_trial_indication_8	= true;
			break;
		case 9:
			is_trial_indication_9	= true;
			break;
		case 10:
			is_trial_indication_10	= true;
			break;
		case 11:
			is_trial_indication_11	= true;
			break;
		case 12:
			{
				is_trial_indication_12	= true;
			}
			break;
		default:
			got = false;
		}
		if (got)
			result = true;
	}
	return result;
}
char * ParsingLabInputFileLine(char * p1, char * out)
{
	int delim = ',';
	if (p1)
	{
		char * p2 = strchr(p1, delim); 
		if (p2)
		{
			strncpy(out, p1, p2-p1);
			out[p2-p1] = '\0';
			p1 = p2 + 1;
			return p1;
		}
	}
	return NULL;
}
void LabNumber::FillContextMenu(HMENU& hMenu)
{

	//this->LabObject::FillContextMenu(hMenu);
	AppendMenu( hMenu, MFT_SEPARATOR, 0, NULL );
	AppendMenu( hMenu, MFT_STRING, ID_TREE_OBJECTSAVEAS, "Lab &Number Save As" );
}
void LabLayer::FillContextMenu(HMENU& hMenu)
{

	//this->LabObject::FillContextMenu(hMenu);
	AppendMenu( hMenu, MFT_SEPARATOR, 0, NULL );
	AppendMenu( hMenu, MFT_STRING, ID_TREE_OBJECTSAVEAS, "Lab &Layer Save As" );
}

void LabObject::CreateMyPopupMenu(HWND hWnd)
{
	printf("LabObject::CreateMyPopupMenu\n");

	HMENU hMenu = CreatePopupMenu();
	HMENU hSubMenu = NULL;
	HMENU hSubMenu2 = NULL;
	Well_Laboratory_Analize::FillPopupMenu(hMenu, hSubMenu, hSubMenu2);

	POINT point;
	GetCursorPos(&point);
	
	TrackPopupMenu( hMenu, TPM_RIGHTBUTTON | 
		TPM_TOPALIGN |
		TPM_LEFTALIGN, 
		point.x,
		point.y, 0, hWnd, NULL );
	
	DestroyMenu( hMenu );
	if(hSubMenu)
		DestroyMenu( hSubMenu );
	if(hSubMenu2)
		DestroyMenu( hSubMenu2 );
}


void LabObject::CreateContextMenu(HWND hWnd, LPARAM lParam) 
{
	HMENU hMenu = CreatePopupMenu();
	// call virtual FillContextMenu
	this->FillContextMenu(hMenu);
	
	TrackPopupMenu( hMenu, TPM_RIGHTBUTTON | 
		TPM_TOPALIGN |
		TPM_LEFTALIGN, 
		LOWORD( lParam ),
		HIWORD( lParam ), 0, hWnd, NULL );
	
	DestroyMenu( hMenu );
}
void LabLayer::FillContextMenuParamVirtual(HMENU& hMenu)
{
	AppendMenu( hMenu, MFT_STRING, ID_TREE_LAB_LAYERPARAMRORRELATIONCOEFFICIENT,   "Коэффициент корреляции" );
}

void LabParameter::FillContextMenuParamVirtual(HMENU& hMenu)
{
	AppendMenu( hMenu, MFT_STRING, ID_TREE_LAB_PARAM_ADDCUBE,   "AddCube" );
}

void LabParam::Fill_Context_Menu_Param(HMENU& hMenu)
{
	this->FillContextMenuParamVirtual(hMenu);

	AppendMenu( hMenu, MFT_SEPARATOR, 0, NULL );
	AppendMenu( hMenu, MFT_STRING, ID_TREE_LAB_PARAMCHECK,   "Check" );
	AppendMenu( hMenu, MFT_STRING, ID_TREE_LAB_PARAMUNCHECK, "Uncheck" );

	AppendMenu( hMenu, MFT_SEPARATOR, 0, NULL );
	AppendMenu( hMenu, MFT_STRING, ID_TREE_LAB_PARAMCHECKALL,   "Check All Layers" );
	AppendMenu( hMenu, MFT_STRING, ID_TREE_LAB_PARAMUNCHECKALL, "Uncheck All Layers" );
	
	AppendMenu( hMenu, MFT_SEPARATOR, 0, NULL );



	

}
void LabParam::CreateContextMenuParam(HWND hWnd, LPARAM lParam) 
{
	HMENU hMenu = CreatePopupMenu();
	// call virtual FillContextMenu
	//this->FillContextMenu(hMenu);
	this->Fill_Context_Menu_Param(hMenu);
	
	TrackPopupMenu( hMenu, TPM_RIGHTBUTTON | 
		TPM_TOPALIGN |
		TPM_LEFTALIGN, 
		LOWORD( lParam ),
		HIWORD( lParam ), 0, hWnd, NULL );
	
	DestroyMenu( hMenu );
}
void LabParam::Check(HWND hwndTV) 
{
	this->m_bChecked_LabParam = true;
	TreeView_SetCheckState3(hwndTV, this->myTreeItem_LabParam, &this->m_bChecked_LabParam);
}
void LabParam::UnCheck(HWND hwndTV) 
{
	this->m_bChecked_LabParam = false;
	TreeView_SetCheckState3(hwndTV, this->myTreeItem_LabParam, &this->m_bChecked_LabParam);
}
void LabObject::SetSizeAndPosOfContextWindow(HWND hWnd, int CX, int CY)
{
	int shift = 10;

	HWND hWndParent = ::GetParent(hWnd);
	RECT rectParentClient;
	GetClientRect(hWndParent, &rectParentClient);
	POINT pt;
	GetCursorPos(&pt);
	ScreenToClient(hWndParent, &pt);


	if (pt.x + CX + shift > rectParentClient.right)
	{
		if (pt.x - CX - shift > rectParentClient.left + shift/2)
			pt.x -= CX + shift;
		else
			pt.x = rectParentClient.left + shift/2;
	}
	else
	{
		pt.x += shift;
	}

	if (pt.y + CY + shift > rectParentClient.bottom)
	{
		if (pt.y - CY - shift > rectParentClient.top+shift/2)
		{
			pt.y -= CY + shift;
		}
		else
			pt.y = rectParentClient.top+shift/2;
	}
	else
	{
		pt.y += shift;
	}
	SetWindowPos(hWnd, HWND_TOP, 0,0, CX, CY, SWP_NOMOVE);
	//SetWindowPos(hWnd, HWND_TOP, pt.x, pt.y, 0, 0, SWP_NOSIZE);
}




void LabLayer::PropSave(bool context_with_plot)
{
	TCHAR filter[] =
						TEXT("Metafiles (*.emf)\0*.emf\0")
						TEXT("All Files (*.*)\0*.*\0");
	char fn_emf[4098];

	char s[128];
	sprintf(s, "%s\0", this->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
	OemToChar(s,s);	
#endif

	switch (context_with_plot)
	{
	case false:
		sprintf(fn_emf, "lab_layer_%s\0", s);
		break;
	case true:
		sprintf(fn_emf, "lab_layer_%s_plot\0", s);
		break;
	}
	char * p = NULL;
	while (p = strchr(fn_emf, '*'))
		*p = 'x';

	DWORD nFilterIndex = 0;
	if (S_OK == SaveFileDlg(NULL, fn_emf, filter, nFilterIndex))
	{
		switch (nFilterIndex)
		{
		case 1:
			this->PropSaveEmf(context_with_plot, fn_emf);
			break;
		}			
	}
}

void LabNumber::PropSave(bool context_with_plot)
{
	TCHAR filter[] =
						TEXT("Metafiles (*.emf)\0*.emf\0")
						TEXT("All Files (*.*)\0*.*\0");
	char fn_emf[4098];

	char s[128];
	sprintf(s, "%s\0", this->lab_layer->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
	OemToChar(s,s);	
#endif

	switch (context_with_plot)
	{
	case false:
		sprintf(fn_emf, "lab_layer_%s_number_%s\0", s, this->ID.c_str());
		break;
	case true:
		sprintf(fn_emf, "lab_layer_%s_number_%s_plot\0", s, this->ID.c_str());
		break;
	}
	char * p = NULL;
	while (p = strchr(fn_emf, '*'))
		*p = 'x';

	DWORD nFilterIndex = 0;
	if (S_OK == SaveFileDlg(NULL, fn_emf, filter, nFilterIndex))
	{
		switch (nFilterIndex)
		{
		case 1:
			this->PropSaveEmf(context_with_plot, fn_emf);
			break;
		}			
	}
}
void LabLayer::Passport_chastnye()
{
	TCHAR filter[] =
						TEXT("Excel files (*.xls)\0*.xls\0")
						TEXT("All Files (*.*)\0*.*\0");
	char fn_xls[4098];

	char s[128];
	sprintf(s, "%s\0", this->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
	OemToChar(s,s);	
#endif


		
	sprintf(fn_xls, "IGE_%s_chastnye\0", s);


	char * p = NULL;
	while (p = strchr(fn_xls, '*'))
		*p = 'x';

	DWORD nFilterIndex = 0;
	if (S_OK == SaveFileDlg(NULL, fn_xls, filter, nFilterIndex))
	{
		switch (nFilterIndex)
		{
		case 1:
			this->Passport_chastnye_or_normatives(0, fn_xls);
			break;
		}			
	}
}


void LabLayer::Passport_normatives(int type)
{
	TCHAR filter[] =
						TEXT("Excel files (*.xls)\0*.xls\0")
						TEXT("All Files (*.*)\0*.*\0");
	char fn_xls[4098];

	char s[128];
	sprintf(s, "%s\0", this->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
	OemToChar(s,s);	
#endif


		
	sprintf(fn_xls, "IGE_%s_normatives%d\0", s, type);


	char * p = NULL;
	while (p = strchr(fn_xls, '*'))
		*p = 'x';

	DWORD nFilterIndex = 0;
	if (S_OK == SaveFileDlg(NULL, fn_xls, filter, nFilterIndex))
	{
		switch (nFilterIndex)
		{
		case 1:
			switch (type)
			{
			case 0:
				{
					this->Passport_normatives(fn_xls);
				}
				break;
			default:
				{
					this->Passport_chastnye_or_normatives(type, fn_xls);
				}
				break;
			}
			break;
		}			
	}
}


void LabNumber::Passport()
{
	TCHAR filter[] =
						TEXT("Excel files (*.xls)\0*.xls\0")
						TEXT("All Files (*.*)\0*.*\0");
	char fn_xls[4098];

	char s[128];
	sprintf(s, "%s\0", this->lab_layer->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
	OemToChar(s,s);	
#endif
		
	sprintf(fn_xls, "IGE_%s_LABN_%s\0", s, this->ID.c_str());

	char * p = NULL;
	while (p = strchr(fn_xls, '*'))
		*p = 'x';

	DWORD nFilterIndex = 0;
	if (S_OK == SaveFileDlg(NULL, fn_xls, filter, nFilterIndex))
	{
		switch (nFilterIndex)
		{
		case 1:
			this->Passport(fn_xls);
			break;
		}			
	}
}


void LabNumber::Passport(const char * fn)
{

	char * p = (char *)strrchr(fn, '.');
	if (p)	*p = '\0';

#if USE_LAB_TRIALS_VECTOR
	for (vector<LabTrial*>::iterator it = lab_trials.begin();
		it != lab_trials.end(); it++)
	{
		if (*it)
			(*it)->Passport(fn);
	}
#else
	for (map<LabTrial::indication, LabTrial*>::iterator it = lab_trials.begin();
		it != lab_trials.end(); it++)
	{
		if ((*it).second)
			(*it).second->Passport(fn);
	}
#endif
}
#if USE_LAB_TRIALS_VECTOR
void LabNumber::PassportCut(const char * fn, long id_vyprob, int cut_passport_type)
#else
void LabNumber::PassportCut(const char * fn)
#endif
{
	char * p = (char *)strrchr(fn, '.');
	if (p)	*p = '\0';
#if USE_LAB_TRIALS_VECTOR
	LabTrial * labtrial = this->FindLabTrial(LabTrial::indication::cut_resistance_nature_condition, id_vyprob);
	if (labtrial)
	{
		CutLabTrial * cut_lab_trial = dynamic_cast<CutLabTrial *>(labtrial);
		cut_lab_trial->cut_passport_type = cut_passport_type;
		labtrial->Passport(fn);
	}
	else
	{
		LabTrial * labtrial = this->FindLabTrial(LabTrial::indication::cut_resistance_task_condition, id_vyprob);
		if (labtrial)
		{
			CutLabTrial * cut_lab_trial = dynamic_cast<CutLabTrial *>(labtrial);
			cut_lab_trial->cut_passport_type = cut_passport_type;
			labtrial->Passport(fn);
		}
	}
#else
	map<LabTrial::indication, LabTrial*>::iterator it = lab_trials.find(LabTrial::indication::cut_resistance_nature_condition);
	if (it != lab_trials.end())
	{
		if ((*it).second)
			(*it).second->Passport(fn);
	}
	else
	{
		map<LabTrial::indication, LabTrial*>::iterator it = lab_trials.find(LabTrial::indication::cut_resistance_task_condition);
		if (it != lab_trials.end())
		{
			if ((*it).second)
				(*it).second->Passport(fn);
		}
	}
#endif

}	
#if USE_LAB_TRIALS_VECTOR
void LabNumber::PassportCompress(const char * fn, long id_vyprob, int compression_passport_type, bool otnosit_def_on_graph)
#else
void LabNumber::PassportCompress(const char * fn)
#endif
{
	char * p = (char *)strrchr(fn, '.');
	if (p)	*p = '\0';
#if USE_LAB_TRIALS_VECTOR
	LabTrial * labtrial = this->FindLabTrial(LabTrial::indication::compression_3, id_vyprob);
	if (labtrial)
	{
		CompressionLabTrial3 * comp3 = dynamic_cast<CompressionLabTrial3 *>(labtrial);
		comp3->compression_passport_type = compression_passport_type;
		comp3->otnosit_def_on_graph = otnosit_def_on_graph;

		labtrial->Passport(fn);
	}
#else
	map<LabTrial::indication, LabTrial*>::iterator it = lab_trials.find(LabTrial::indication::compression_3);
	if (it != lab_trials.end())
	{
		if ((*it).second)
			(*it).second->Passport(fn);
	}
#endif
}

void LabNumber::PassportGranular(const char * fn, int granular_passport_type)
{
	char * p = (char *)strrchr(fn, '.');
	if (p)	*p = '\0';
	LabTrial * labtrial = this->FindLabTrial(LabTrial::indication::fractions, -1);
	if (labtrial)
	{
		FractionsLabTrial * frac = dynamic_cast<FractionsLabTrial *>(labtrial);
		frac->granular_passport_type = granular_passport_type;
		labtrial->Passport(fn);
	}
}

SoilDescription::SoilDescription()
{
	lab_number = NULL;
	lab_n = -1;
	m_ground_type = CGround::ground_type::Undefined_ground;
	m_Consistencia_nature = PhysicalLabTrialResults::Consistencia::undefined_cons;
	m_Consistencia_water_saturated = PhysicalLabTrialResults::Consistencia::undefined_cons;
	m_clay_soil_class = FractionsLabTrialResults::ClaySoilsClass::undefined_clay_soil;
	m_sand_soil_class = FractionsLabTrialResults::SandSoilsClass::undefined_sand_soil;
	m_neodnorodnost = FractionsLabTrialResults::Neodnorodnost::undefined_neodnorodnost;
	m_sand_vlazhnost = PhysicalLabTrialResults::SandVlazhnost::undefined_vlazhnost;
	m_zatorfovannost = ChemicalLabTrialResults::Zatorfovannost::undefined_zatorfovannost;
	m_prosadochnost = CompressionLabTrialResults3::Prosadochnost::undefined_prosadocnist;
	m_nabuhanie = CompressionLabTrialResults3::Nabuhanie::undefined_nabuhanie;
}
SoilDescription::~SoilDescription()
{
}

void PhysicalLabTrial::Passport(const char * fn)
{
}
string PhysicalLabTrial::GetSoilDescription()
{
	PhysicalLabTrialResults * phys_lab_trial_res = dynamic_cast<PhysicalLabTrialResults *>(this->results);
				

	if (phys_lab_trial_res)
	{
		if(!phys_lab_trial_res->calculed)
			phys_lab_trial_res->CalcProperties();

		bool is_sand = false;

		string s = "";
		// определяем тип грунта
		if (phys_lab_trial_res->t != CGround::ground_type::Undefined_ground)
		{
			bool add_ground_name_from_fiz = true;

			LabTrial * lab_trial = this->lab_number->FindLabTrial(LabTrial::indication::fractions, -1);
			FractionsLabTrial * frac_lab_trial = dynamic_cast<FractionsLabTrial *>(lab_trial);
			if (frac_lab_trial)
			{
				FractionsLabTrialResults * frac_res = dynamic_cast<FractionsLabTrialResults *>(frac_lab_trial->results);
				if (frac_res)
				{
					if (!frac_res->calculed)
						frac_res->CalcProperties();

					add_ground_name_from_fiz = frac_res->m_sand_soil_class == FractionsLabTrialResults::SandSoilsClass::undefined_sand_soil;
					//is_sand         = frac_res->m_sand_soil_class != FractionsLabTrialResults::SandSoilsClass::undefined_sand_soil;


					if (frac_res->m_clay_soil_class != FractionsLabTrialResults::ClaySoilsClass::undefined_clay_soil)
					{
						//s += FractionsLabTrialResults::ClaySoilsClassToString(frac_res->m_clay_soil_class);
						//s += " ";

						is_sand = frac_res->m_clay_soil_class != FractionsLabTrialResults::ClaySoilsClass::sand;
					}
					else
					{
		
					}
				}
			}
			if (true)//(add_ground_name_from_fiz)
			{
				s += CGround::GrountTypeToStringRus(phys_lab_trial_res->t);
				s += " ";

				is_sand = phys_lab_trial_res->t == CGround::ground_type::Sand;
			}	
			if (is_sand)
			{
				CGround::s_Gender = CGround::Gender::male;
				if (phys_lab_trial_res->m_sand_vlazhnost != PhysicalLabTrialResults::SandVlazhnost::undefined_vlazhnost)
				{
 					s += PhysicalLabTrialResults::SandVlazhnostToString(phys_lab_trial_res->m_sand_vlazhnost);
					s += " ";
				}
			}		
		}


		if (phys_lab_trial_res->t == CGround::ground_type::Loam)
			CGround::s_Gender = CGround::Gender::male;
		else if (phys_lab_trial_res->t == CGround::ground_type::SandyLoam
				|| phys_lab_trial_res->t == CGround::ground_type::Clay)
			CGround::s_Gender = CGround::Gender::female;

		// Супесь - консистенция
		// Суглинок и глина - консистенция
		if (phys_lab_trial_res->m_Consistencia_nature != PhysicalLabTrialResults::Consistencia::undefined_cons)
		{
			s += PhysicalLabTrialResults::ConsistenciaToString(phys_lab_trial_res->m_Consistencia_nature);
			s += " ";
		}
		if (phys_lab_trial_res->m_Consistencia_water_saturated != PhysicalLabTrialResults::Consistencia::undefined_cons)
		{
			s += "в водонасыщенном состоянии ";
			s += PhysicalLabTrialResults::ConsistenciaToString(phys_lab_trial_res->m_Consistencia_water_saturated);
			s += " ";
		}
		return s;
	}
	return "";
}
void PhysicalLabTrial::GetSoilDescription(SoilDescription & sd)
{
	PhysicalLabTrialResults * phys_lab_trial_res = dynamic_cast<PhysicalLabTrialResults *>(this->results);

	if (phys_lab_trial_res)
	{
		if(!phys_lab_trial_res->calculed)
			phys_lab_trial_res->CalcProperties();

		// определяем тип грунта
		sd.m_ground_type = phys_lab_trial_res->t;
		sd.S = phys_lab_trial_res->S;
		sd.e = phys_lab_trial_res->e;
		sd.plasticity_index = phys_lab_trial_res->plasticity_index;
		sd.fluidity_index_nature = phys_lab_trial_res->fluidity_index_nature;
		sd.fluidity_index_water_saturated = phys_lab_trial_res->fluidity_index_water_saturated;
		
		sd.m_Consistencia_nature = phys_lab_trial_res->m_Consistencia_nature;
		sd.m_Consistencia_water_saturated = phys_lab_trial_res->m_Consistencia_water_saturated;
		sd.m_sand_vlazhnost = phys_lab_trial_res->m_sand_vlazhnost;;
	}
}
void ChemicalLabTrial::Passport(const char * fn)
{
}
string ChemicalLabTrial::GetSoilDescription()
{
	ChemicalLabTrialResults * chem_lab_trial_res = dynamic_cast<ChemicalLabTrialResults *>(this->results);

	if (chem_lab_trial_res)
	{
		if(!chem_lab_trial_res->calculed)
			chem_lab_trial_res->CalcProperties();	

		string s = "";
		if (chem_lab_trial_res->m_zatorfovannost != ChemicalLabTrialResults::Zatorfovannost::undefined_zatorfovannost)
		{
			s += ChemicalLabTrialResults::ZatorfovannostToString(chem_lab_trial_res->m_zatorfovannost);
			s += " ";
		}
		return s;
	}

	return "";
}

void ChemicalLabTrial::GetSoilDescription(SoilDescription & sd)
{
	ChemicalLabTrialResults * chem_lab_trial_res = dynamic_cast<ChemicalLabTrialResults *>(this->results);

	if (chem_lab_trial_res)
	{
		if(!chem_lab_trial_res->calculed)
			chem_lab_trial_res->CalcProperties();	

		sd.m_zatorfovannost = chem_lab_trial_res->m_zatorfovannost;
	}
	if (this->vegetable_remains_content.f || this->organic_matters.f)
	{
		sd.organic = 
			(this->vegetable_remains_content.f ? this->vegetable_remains_content.v : 0.0) + 
			(this->organic_matters.f ? this->organic_matters.v : 0.0);
	}
}
const char * _GetKodProbyGrunta(long val) //id_kodprob
{
	string str;
	switch(val)
	{
	case -1:
		return "";//undefined
		break;	
	case 1:
		return "Бюкс";
		break;	
	case 2:
		return "Монолит";
		break;	
	case 3:
		return "Нарушенная структура";
		break;	
	case 4:
		return "Кольцо";
		break;	
	default : // -1
		return "";//
	}
	return "";

}

BaseLab::language BaseLab::PassportLanguage = BaseLab::language::russian;
string Laboratory::FormsDir = CLabDoc::GetWorkDir() + "Forms";

void FractionsLabTrial::FillZhurnal(MyExcel & m_excel, int i16, int i17)
{
	LPDISPATCH pRange; 
	Range10    m_range;
	if(true)
	{
		char sx1[32], sx2[32], str[1024];
		char SX[32], SY[32];
		char letter = 'L';
		if (n_fractions > 11)
			letter += n_fractions - 11;
#if USE_FRACTION_DIAMETERS_INTERVAL
		double x_low, x_high, y;
		// массив содержания фракций
		for (int i = n_fractions-1; i >= 0 && letter >= 'C'; i--)
		{
			double 
			y = fractions_content[i].v;
#if USE_LAB_LAYER_FRACTIONS
			x_low = fractions->fractions_diameters[i].low;
			x_high = fractions->fractions_diameters[i].high;
#else
			x_low = fractions_diameters[i].low;
			x_high = fractions_diameters[i].high;
#endif

			sprintf(SX, "%c%d", letter, i16);
			sprintf(SY, "%c%d", letter, i17);

			if (x_low == -DBL_MAX)
			{
				sprintf(str, "< %f", x_high); DeleteEndZeros(sx2);
			}
			else if (x_high  == DBL_MAX)
			{
				sprintf(str, "> %f", x_low); DeleteEndZeros(sx1);
			}
			else
			{
				sprintf(sx1, "%f", x_low); DeleteEndZeros(sx1);
				sprintf(sx2, "%f", x_high); DeleteEndZeros(sx2);
				sprintf(str, "%s - %s", sx1, sx2);
			}

			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
			m_range.AttachDispatch(pRange);			   
			m_range.SetValue(COleVariant(str));
			m_range.BorderAround(COleVariant(long(1)), 2, -4105);
			m_range.ReleaseDispatch();									
			
			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
			m_range.AttachDispatch(pRange);			   
			if (y) m_range.SetValue(COleVariant(y));
			m_range.BorderAround(COleVariant(long(1)), 2, -4105);
			m_range.ReleaseDispatch();

			letter--;
		}

#else
		double x,y;
		// массив содержания фракций
		for (int i = n_fractions-1; i >= 0 && letter >= 'C'; i--)
		{
			y = fractions_content[i].v;
#if USE_LAB_LAYER_FRACTIONS
			x = fractions->fractions_diameters[i];
#else
			x = fractions_diameters[i];
#endif

			sprintf(SX, "%c%d", letter, i16);
			sprintf(SY, "%c%d", letter, i17);

			if (i)
			{
#if USE_LAB_LAYER_FRACTIONS
				if (fractions->fractions_diameters[i] == fractions->fractions_diameters[i-1])
#else
				if (fractions_diameters[i] == fractions_diameters[i-1])
#endif
				{
					sprintf(sx2, "< %f", x); DeleteEndZeros(sx2);

					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
					m_range.AttachDispatch(pRange);			   
					m_range.SetValue(COleVariant(sx2));
					m_range.BorderAround(COleVariant(long(1)), 2, -4105);
					m_range.ReleaseDispatch();									
					
					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
					m_range.AttachDispatch(pRange);			   
					if (y) m_range.SetValue(COleVariant(y));
					m_range.BorderAround(COleVariant(long(1)), 2, -4105);
					m_range.ReleaseDispatch();
				}
				else
				{

#if USE_LAB_LAYER_FRACTIONS
					sprintf(sx1, "%f", fractions->fractions_diameters[i-1]); DeleteEndZeros(sx1);
					sprintf(sx2, "%f", fractions->fractions_diameters[i]); DeleteEndZeros(sx2);
#else
					sprintf(sx1, "%f", fractions_diameters[i-1]); DeleteEndZeros(sx1);
					sprintf(sx2, "%f", fractions_diameters[i]); DeleteEndZeros(sx2);
#endif
					sprintf(str, "%s - %s", sx1, sx2);


					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
					m_range.AttachDispatch(pRange);			   
					m_range.SetValue(COleVariant(str));
					m_range.ReleaseDispatch();									
					
					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
					m_range.AttachDispatch(pRange);			   
					if (y) m_range.SetValue(COleVariant(y));
					
					m_range.ReleaseDispatch();								
				}
			}
			else
			{

				sprintf(sx1, "> %f", x); DeleteEndZeros(sx1);

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(sx1));
				m_range.ReleaseDispatch();									
				
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
				m_range.AttachDispatch(pRange);			   
				if (y) m_range.SetValue(COleVariant(y));
				
				m_range.ReleaseDispatch();
			}									
			letter--;
		}

#endif


		while (letter >= 'C')
		{
			sprintf(SX, "%c%d", letter, i16);

			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
			m_range.AttachDispatch(pRange);			   
			m_range.SetValue(COleVariant(""));
			m_range.ReleaseDispatch();

			letter--;
		}
	}
}
void FractionsLabTrial::Passport(const char * fn)
{
	switch(this->granular_passport_type)
	{
	case 0:
		{
			this->Passport_0(fn);
		}
		break;
	case 1:
		{
			this->Passport_1(fn);
		}
		break;
	}
}
void FractionsLabTrial::Passport_0(const char * fn)
{
	if (this->n_fractions == 0)
		return;

	char file0[4098];
	char file[4098];

	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			sprintf(file, "%s_Pasport_GranR.xls", fn);
			sprintf(file0, "%s\\Pasport_GranR.xls", Laboratory::FormsDir.c_str());
		}
		break;
	case BaseLab::language::ukrainian:
		{
			sprintf(file, "%s_Pasport_Gran.xls", fn);
			sprintf(file0, "%s\\Pasport_Gran.xls", Laboratory::FormsDir.c_str());
		}
		break;
	}
	CopyFile(file0, file, FALSE);
 
	LPDISPATCH pRange; 
	Range10    m_range;

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		//try
		{
			m_excel.ExcelOleExecute(file);

			if (this->lab_number)
			{
				char str[1024];

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("D9")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(this->lab_number->depth));
				m_range.ReleaseDispatch();	

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("A9")));
				m_range.AttachDispatch(pRange);
				sprintf(str, "%s\0", this->lab_number->mine_working_number.c_str());
				if ISNUM(str)
				{
					switch(this->lab_number->m_mine_working_type)
					{
					case LabNumber::mine_working_type::hole:
						{
							sprintf(str, "Шурф № %s", this->lab_number->mine_working_number.c_str());
						}
						break;
					case LabNumber::mine_working_type::well:
						{
							// номер выработки
							sprintf(str, "Скв. № %s", this->lab_number->mine_working_number.c_str());
						}
						break;
					}
				}
				m_range.SetValue(COleVariant(str));
				m_range.ReleaseDispatch();	
				
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("H9")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(_GetKodProbyGrunta(this->lab_number->id_kodprob)));
				m_range.ReleaseDispatch();	

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("A12")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(this->lab_number->GetSoilDescription(this->lab_number->get_soil_description_from_db).c_str()));
				m_range.ReleaseDispatch();	

				LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
				if (lablayer)
				{
					Laboratory * lab = (Laboratory *)lablayer->GetLaboratory();

					if (lab)
					{
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("H1")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(lab->contract.c_str()));
						m_range.ReleaseDispatch();	

						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("G3")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(lab->object_name.c_str()));
						m_range.ReleaseDispatch();	
					}
				}						
			}
#if 1
			this->FillZhurnal(m_excel, 16, 17);
#else
			if(true)
			{
				double x,y;
				char sx1[32], sx2[32], str[1024];
				char SX[32], SY[32];
				char letter = 'K';
				if (n_fractions > 11)
					letter += n_fractions - 11;

				// массив содержания фракций
				for (int i = n_fractions-1; i >= 0 && letter >= 'A'; i--)
				{
					y = fractions_content[i].v;
#if USE_LAB_LAYER_FRACTIONS
					x = fractions->fractions_diameters[i];
#else
					x = fractions_diameters[i];
#endif

					sprintf(SX, "%c16", letter);
					sprintf(SY, "%c17", letter);

					if (i)
					{
#if USE_LAB_LAYER_FRACTIONS
						if (fractions->fractions_diameters[i] == fractions->fractions_diameters[i-1])
#else
						if (fractions_diameters[i] == fractions_diameters[i-1])
#endif
						{
							sprintf(sx2, "< %f", x); DeleteEndZeros(sx2);

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(sx2));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();									
							
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
							m_range.AttachDispatch(pRange);			   
							if (y) m_range.SetValue(COleVariant(y));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}
						else
						{

#if USE_LAB_LAYER_FRACTIONS
							sprintf(sx1, "%f", fractions->fractions_diameters[i-1]); DeleteEndZeros(sx1);
							sprintf(sx2, "%f", fractions->fractions_diameters[i]); DeleteEndZeros(sx2);
#else
							sprintf(sx1, "%f", fractions_diameters[i-1]); DeleteEndZeros(sx1);
							sprintf(sx2, "%f", fractions_diameters[i]); DeleteEndZeros(sx2);
#endif
							sprintf(str, "%s - %s", sx1, sx2);


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(str));
							m_range.ReleaseDispatch();									
							
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
							m_range.AttachDispatch(pRange);			   
							if (y) m_range.SetValue(COleVariant(y));
							
							m_range.ReleaseDispatch();								
						}
					}
					else
					{

						sprintf(sx1, "> %f", x); DeleteEndZeros(sx1);

						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(sx1));
						m_range.ReleaseDispatch();									
						
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
						m_range.AttachDispatch(pRange);			   
						if (y) m_range.SetValue(COleVariant(y));
						
						m_range.ReleaseDispatch();
					}									
					letter--;
				}


				while (letter >= 'A')
				{
					sprintf(SX, "%c16", letter);
					sprintf(SY, "%c17", letter);

					sprintf(sx1, "> %f", x); DeleteEndZeros(sx1);

					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
					m_range.AttachDispatch(pRange);			   
					m_range.SetValue(COleVariant(""));
					m_range.ReleaseDispatch();

					letter--;
				}
			}
#endif
			FractionsLabTrialResults * frac_result = dynamic_cast<FractionsLabTrialResults *>(this->results);
			if (frac_result)
			{
				if(!frac_result->calculed)
					frac_result->CalcProperties();
				
				LPDISPATCH pShapes; 
				Shapes10    m_shapes;
					
				VERIFY(pShapes = m_excel.m_worksheet.GetShapes());				
				m_shapes.AttachDispatch(pShapes);	

				long shapes_count = m_shapes.GetCount();
				printf("shapes_count = %d\n", shapes_count);

				for (long ish = 1; ish <= shapes_count; ish++)
				{
					LPDISPATCH pShape; 
					Shape10    m_shape;

					VERIFY(pShape = m_shapes.Item(COleVariant(long(ish))));				
					m_shape.AttachDispatch(pShape);	

					CString shape_name = m_shape.GetName();
					printf("%s\n", (LPCTSTR)shape_name);

					LPDISPATCH pChartObject; 
					ChartObject10    m_chart_object;

					VERIFY(pChartObject = m_excel.m_worksheet.ChartObjects(COleVariant(shape_name)));				
					m_chart_object.AttachDispatch(pChartObject);

					LPDISPATCH pChart;
					_Chart10    m_chart;

					VERIFY(pChart = m_chart_object.GetChart());
					m_chart.AttachDispatch(pChart);

					//xlXYScatterSmooth '72
					m_chart.SetChartType(72);
	#if 0
					LPDISPATCH pRange2; 
					VERIFY(pRange2 = m_excel.m_worksheet.GetRange(COleVariant("A22:B30")));
					m_chart.SetSourceData(pRange2, COleVariant("xlColomn"));    
	#else               


					LPDISPATCH pAxes;
					VERIFY(pAxes = m_chart.Axes(COleVariant(long (1)), 1));//axis X - [AxisGroup As XlAxisGroup = xlPrimary];

					//LPDISPATCH pAxis; 
					Axis10    m_axis;
					m_axis.AttachDispatch(pAxes);

					int len = min(frac_result->v_diameters.size(), frac_result->v_sum_content.size());

					double* pMyOriginalArrayX = new double[len];
					double* pMyOriginalArrayY = new double[len];

					double max_diam = -DBL_MAX, min_diam = DBL_MAX;

					for(int i = 0; i < len; i++)
					{
						pMyOriginalArrayX[i] = frac_result->v_diameters[i];
						pMyOriginalArrayY[i] = frac_result->v_sum_content[i];

						if (max_diam < frac_result->v_diameters[i])
							max_diam = frac_result->v_diameters[i];

						if (min_diam > frac_result->v_diameters[i])
							min_diam = frac_result->v_diameters[i];

					}

					if (frac_result->v_diameters.size())
					{
						try
						{
							m_axis.SetMinimumScale(min_diam);
							m_axis.SetMaximumScale(max_diam);
						}
						catch (CException* pe)
						{
							// catch errors from WinINet 
							TCHAR szErr[4098]; 
							pe->GetErrorMessage(szErr, 4098); 
							AfxMessageBox(szErr);
							pe->Delete();
						}
					}

					/*//Create and fill an array.
					double* pData;
					for(int count = 0; count < len; count++) 
						pMyOriginalArray[count] = count+1;//*/
	                
					//Put it into a safe array.
					COleSafeArray myOleSafeArrayX;
					COleSafeArray myOleSafeArrayY;
					myOleSafeArrayX.CreateOneDim(VT_R8, len, pMyOriginalArrayX); 
					myOleSafeArrayY.CreateOneDim(VT_R8, len, pMyOriginalArrayY); 
					// create one dimension array of 8-byte values
					// 100 entries w/data from pMyOriginalArray.
					
					// Access that safe array.
					//Get a pointer to the Data.
					//myOleSafeArray.AccessData((void**)&pData); 
					//verify all of the data.
					//for(count = 0; count < 10; count++) 
					//	ASSERT(pData[count] == pMyOriginalArray[count]);
					//myOleSafeArray.UnaccessData();
					
					//clean up.
					delete[] pMyOriginalArrayX;	
					delete[] pMyOriginalArrayY;	

					//ActiveChart.SeriesCollection(1).XValues = "={0.001,0.01}"
					//ActiveChart.SeriesCollection(1).Values = "={0.001,0.02}"
					LPDISPATCH pSeries;
					Series10    m_series;
					VERIFY(pSeries = m_chart.SeriesCollection(COleVariant(long(1))));
					m_series.AttachDispatch(pSeries);
					m_series.SetValues(myOleSafeArrayY);
					m_series.SetXValues(myOleSafeArrayX);
					m_series.ReleaseDispatch();
	#endif

					//m_chart.SetAutoScaling(autoscalling);


					m_axis.ReleaseDispatch();
					m_chart.ReleaseDispatch();
					m_chart_object.ReleaseDispatch();				
					m_shape.ReleaseDispatch();

				}

				m_shapes.ReleaseDispatch();

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("E19")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(frac_result->C_u.v));
				m_range.ReleaseDispatch();	
			}				

			m_excel.m_workbook.Save();
		}
		/*
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		*/
		m_excel.ExcelOleRelease();
	}
	else
	{
		printf("!!!!! m_excel.IsApplicationDispatch()\n");
		AfxMessageBox("!!!!! m_excel.IsApplicationDispatch()\n");
	}

}
void Passport_LabNumber(MyExcel & m_excel, LabNumber * lab_number, const char * suffix)
{
	if (lab_number)
	{
		char S[64];
		char str[1024];

		sprintf(S, "Z%s", suffix);
		ExcelRange_SetValue(m_excel, S, COleVariant(lab_number->depth));

		sprintf(S, "LAB_N%s", suffix);
		ExcelRange_SetValue(m_excel, S, COleVariant(lab_number->lab_n));

		sprintf(str, "%s\0", lab_number->mine_working_number.c_str());
		if ISNUM(str)
		{
			switch(lab_number->m_mine_working_type)
			{
			case LabNumber::mine_working_type::hole:
				{
					sprintf(str, "Шурф № %s", lab_number->mine_working_number.c_str());
				}
				break;
			case LabNumber::mine_working_type::well:
				{
					// номер выработки
					sprintf(str, "Скв. № %s", lab_number->mine_working_number.c_str());
				}
				break;
			}
		}

		sprintf(S, "KT%s", suffix);
		ExcelRange_SetValue(m_excel, S, COleVariant(str));

		/*
		VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("H9")));
		m_range.AttachDispatch(pRange);			   
		m_range.SetValue(COleVariant(_GetKodProbyGrunta(lab_number->id_kodprob)));
		m_range.ReleaseDispatch();	

		VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("KODPROBGR")));
		m_range.AttachDispatch(pRange);			   
		m_range.SetValue(COleVariant(_GetKodProbyGrunta(lab_number->id_kodprob)));
		m_range.ReleaseDispatch();	
		*/

		sprintf(S, "GRUNT%s", suffix);
		ExcelRange_SetValue(m_excel, S, COleVariant(lab_number->GetSoilDescription(lab_number->get_soil_description_from_db).c_str()));

		LabLayer * lablayer = (LabLayer *)lab_number->GetLabLayer();
		if (lablayer)
		{
			Laboratory * lab = (Laboratory *)lablayer->GetLaboratory();
			if (lab)
			{
				sprintf(S, "CONTRACT%s", suffix);
				ExcelRange_SetValue(m_excel, S, COleVariant(lab->contract.c_str()));
				sprintf(S, "OBJECT%s", suffix);
				ExcelRange_SetValue(m_excel, S, COleVariant(lab->object_name.c_str()));
			}			
		}
	}
}


void Passport_Graph(MyExcel & m_excel, 
					CompressionLabTrialResults3 * comp_result_3, 
					CompressionLabTrial * p_trial_1,
					bool otnosit_def_on_graph, 
					trial_value e0_1, bool use_table, 
					int ftr, int fr, double max_x, 
					double delta_x, int n_lines,
					Gurvich & gurvich,
					int ftr_g)
{
	if (true)			
	{							
		double x,y;

		LPDISPATCH pShapes; 
		Shapes10    m_shapes;
			
		VERIFY(pShapes = m_excel.m_worksheet.GetShapes());				
		m_shapes.AttachDispatch(pShapes);	

		long shapes_count = m_shapes.GetCount();
		printf("shapes_count = %d\n", shapes_count);

		for (long ish = 1; ish <= shapes_count; ish++)
		{
			switch (ish)
			{
			case 1:// график на первой странице
				{
					LPDISPATCH pShape; 
					Shape10    m_shape;

					VERIFY(pShape = m_shapes.Item(COleVariant(long(ish))));				
					m_shape.AttachDispatch(pShape);	

					CString shape_name = m_shape.GetName();
					printf("%s\n", (LPCTSTR)shape_name);

					LPDISPATCH pChartObject; 
					ChartObject10    m_chart_object;

					VERIFY(pChartObject = m_excel.m_worksheet.ChartObjects(COleVariant(shape_name)));				
					m_chart_object.AttachDispatch(pChartObject);

					LPDISPATCH pChart;
					_Chart10    m_chart;

					VERIFY(pChart = m_chart_object.GetChart());
					m_chart.AttachDispatch(pChart); 
					
					if (use_table)
					{

						char sdataX[64];
						sprintf(sdataX, "=Лист1!R%dC1:R%dC1", ftr, fr-1 + p_trial_1->n_pressures);
						char sdataY[64];
						switch (n_lines)
						{
						case 3:
							{
								for (int isc = 1; isc <= n_lines; isc++)
								{
									switch (isc)
									{
									case 1:
										{
											if (otnosit_def_on_graph)
												sprintf(sdataY, "=Лист1!R%dC3:R%dC3", ftr, fr-1+p_trial_1->n_pressures);
											else
												sprintf(sdataY, "=Лист1!R%dC5:R%dC5", ftr, fr-1+p_trial_1->n_pressures);
										}
										break;
									case 2:
										{
											if (otnosit_def_on_graph)
												sprintf(sdataY, "=Лист1!R%dC10:R%dC10", ftr, fr-1+p_trial_1->n_pressures);
											else
												sprintf(sdataY, "=Лист1!R%dC12:R%dC12", ftr, fr-1+p_trial_1->n_pressures);

										}
										break;
									case 3:
										{
											sprintf(sdataY, "=Лист1!R%dC15:R%dC15", ftr, fr-1+p_trial_1->n_pressures);
										}
										break;
									}

									LPDISPATCH pSeries;
									Series10    m_series;
									VERIFY(pSeries = m_chart.SeriesCollection(COleVariant(long(isc))));
									m_series.AttachDispatch(pSeries);
									m_series.SetValues(COleVariant(sdataY));
									m_series.SetXValues(COleVariant(sdataX));
									m_series.ReleaseDispatch();
								}
							}
							break;
						case 2:
							{
								for (int isc = 1; isc <= n_lines; isc++)
								{
									switch (isc)
									{
									case 1:
										{
											if (otnosit_def_on_graph)
												sprintf(sdataY, "=Лист1!R%dC3:R%dC3", ftr, fr-1+p_trial_1->n_pressures);
											else
												sprintf(sdataY, "=Лист1!R%dC5:R%dC5", ftr, fr-1+p_trial_1->n_pressures);
										}
										break;
									case 2:			
										{
											sprintf(sdataY, "=Лист1!R%dC8:R%dC8", ftr, fr-1+p_trial_1->n_pressures);
										}
										break;
									}


									LPDISPATCH pSeries;
									Series10    m_series;
									VERIFY(pSeries = m_chart.SeriesCollection(COleVariant(long(isc))));
									m_series.AttachDispatch(pSeries);
									m_series.SetXValues(COleVariant(sdataX));
									m_series.SetValues(COleVariant(sdataY));
									m_series.ReleaseDispatch();
								}


							}
							break;
						}
						LPDISPATCH pAxes_x;
						VERIFY(pAxes_x = m_chart.Axes(COleVariant(long (1)), 1));//axis X - [AxisGroup As XlAxisGroup = xlPrimary];
						Axis10    m_axis_x;
						m_axis_x.AttachDispatch(pAxes_x);
						m_axis_x.SetMinimumScale(0.0);
						m_axis_x.SetMaximumScale(max_x + delta_x);
						m_axis_x.ReleaseDispatch();


						//#########################################################3
						//### FIX if (otnosit_def_on_graph)
						//#########################################################3
						// как поведёт себя этот код, если otnosit_def_on_graph = true ?

						double extrim_e2 = otnosit_def_on_graph ? -DBL_MAX : DBL_MAX;

						if (n_lines > 2)
						{
							if (otnosit_def_on_graph)
							{
								sprintf(sdataY, "J%d", fr-1+p_trial_1->n_pressures);
								if (!ExcelRange_GetValue(m_excel, sdataY, extrim_e2))
								{
									sprintf(sdataY, "J%d", fr-2+p_trial_1->n_pressures);
									if (!ExcelRange_GetValue(m_excel, sdataY, extrim_e2))
									{

									}
								}
							}
							else
							{
								sprintf(sdataY, "L%d", fr-1+p_trial_1->n_pressures);
								if (!ExcelRange_GetValue(m_excel, sdataY, extrim_e2))
								{
									sprintf(sdataY, "L%d", fr-2+p_trial_1->n_pressures);
									if (!ExcelRange_GetValue(m_excel, sdataY, extrim_e2))
									{

									}
								}
							}
						}

						double extrim_e1 = otnosit_def_on_graph ? -DBL_MAX : DBL_MAX;
						if (otnosit_def_on_graph)
						{
							sprintf(sdataY, "C%d", fr-1+p_trial_1->n_pressures);
							if (!ExcelRange_GetValue(m_excel, sdataY, extrim_e1))
							{
							}
						}
						else
						{
							sprintf(sdataY, "E%d", fr-1+p_trial_1->n_pressures);
							if (!ExcelRange_GetValue(m_excel, sdataY, extrim_e1))
							{
							}
						}

						if (otnosit_def_on_graph)
						{
							double max_e = max(extrim_e1, extrim_e2);

							LPDISPATCH pAxes_y;
							VERIFY(pAxes_y = m_chart.Axes(COleVariant(long (2)), 1));//axis Y - [AxisGroup As XlAxisGroup = xlPrimary];
							Axis10    m_axis_y;
							m_axis_y.AttachDispatch(pAxes_y);
							if (max_e != -DBL_MAX)
								m_axis_y.SetMaximumScale(max_e);

							m_axis_y.ReleaseDispatch();
						}
						else
						{

							double min_e = min(extrim_e1, extrim_e2);

							LPDISPATCH pAxes_y;
							VERIFY(pAxes_y = m_chart.Axes(COleVariant(long (2)), 1));//axis Y - [AxisGroup As XlAxisGroup = xlPrimary];
							Axis10    m_axis_y;
							m_axis_y.AttachDispatch(pAxes_y);
							if (min_e != DBL_MAX)
								m_axis_y.SetMinimumScale(min_e);

							m_axis_y.ReleaseDispatch();
						}
						//#########################################################3
						//### FIX if (otnosit_def_on_graph)
						//#########################################################3
						// как поведёт себя этот код, если otnosit_def_on_graph = true ?

					}
					else
					{
						if (comp_result_3)
						{
							double max_e = -DBL_MAX, min_e = DBL_MAX;

							int max_isc = 3;
							int i1,i2;

							for (long isc = 1; isc <= max_isc; isc++)
							{
								COleSafeArray myOleSafeArrayX;
								COleSafeArray myOleSafeArrayY;
								switch (isc)
								{
								case 1:
									{
										if (comp_result_3->p_result_1 && p_trial_1)
										{
											int len = p_trial_1->n_pressures;
											bool wat = false;
											bool added_5 = false;
											for (int i = 0; i < p_trial_1->n_pressures; i++)
											{
												x = p_trial_1->pressures[i];	
												bool zam = i && p_trial_1->pressures[i] == p_trial_1->pressures[i-1];
												if (zam)
												{
													wat = true;
													i1 = i-1;
													i2 = i;
													len = i;
												}

												if (wat)
												{
													max_isc = 4;

													if (zam)
													{
														LPDISPATCH pSeriesCollection;
														SeriesCollection10    m_series_collection;
														VERIFY(pSeriesCollection = m_chart.SeriesCollection());
														m_series_collection.AttachDispatch(pSeriesCollection);

														LPDISPATCH pSeries;
														Series10    m_series;
														VERIFY(pSeries = m_series_collection.NewSeries());
														m_series.AttachDispatch(pSeries);

														
														switch (BaseLab::PassportLanguage)
														{
														case BaseLab::language::russian:
															{
																m_series.SetName("Замачивание");
															}
															break;
														case BaseLab::language::ukrainian:
															{
																m_series.SetName("Замочування");
															}
															break;
														}

														m_series.ReleaseDispatch();
														m_series_collection.ReleaseDispatch();
													}
													
													if (!zam)
													{
														max_isc = 5;

														if (!added_5)
														{
															added_5 = true;

															LPDISPATCH pSeriesCollection;
															SeriesCollection10    m_series_collection;
															VERIFY(pSeriesCollection = m_chart.SeriesCollection());
															m_series_collection.AttachDispatch(pSeriesCollection);

															LPDISPATCH pSeries;
															Series10    m_series;
															VERIFY(pSeries = m_series_collection.NewSeries());
															m_series.AttachDispatch(pSeries);

															
															switch (BaseLab::PassportLanguage)
															{
															case BaseLab::language::russian:
																{
																	m_series.SetName("Уплотнение после замачивания");
																}
																break;
															case BaseLab::language::ukrainian:
																{
																	m_series.SetName("Ущільнення після замочування");
																}
																break;
															}
															m_series.ReleaseDispatch();
															m_series_collection.ReleaseDispatch();
														}
													}
												}
											}

											wat = false;
											double* pMyOriginalArrayX = new double[len];
											double* pMyOriginalArrayY = new double[len];

											for (int i = 0; i < len; i++)
											{
												x = p_trial_1->pressures[i];	
												bool zam = i && p_trial_1->pressures[i] == p_trial_1->pressures[i-1];
												if (zam)
												{
													wat = true;
													i1 = i-1;
													i2 = i;
												}

												if (wat)
												{
													max_isc = 4;

													if (!zam)
													{
														max_isc = 5;
													}
												}

												y = p_trial_1->absolute_deformations[i].v;
												y /= p_trial_1->hoop_height;                                                        
												double e = e0_1.v - (1.0 + e0_1.v) * y;

												if (otnosit_def_on_graph)
												{
													pMyOriginalArrayX[i] = x;
													pMyOriginalArrayY[i] = y;

													if (max_e < y)
														max_e = y;

													if (min_e > y)
														min_e = y;
												}												
												else
												{
													pMyOriginalArrayX[i] = x;
													pMyOriginalArrayY[i] = e;

													if (max_e < e)
														max_e = e;

													if (min_e > e)
														min_e = e;
												}
											}


											//Put it into a safe array.
											myOleSafeArrayX.CreateOneDim(VT_R8, len, pMyOriginalArrayX); 
											myOleSafeArrayY.CreateOneDim(VT_R8, len, pMyOriginalArrayY); 
											//clean up.
											delete[] pMyOriginalArrayX;	
											delete[] pMyOriginalArrayY;	
										}
									}
									break;
								case 4:
									{
										if (comp_result_3->p_result_1 && p_trial_1)
										{
											int len = 2;
											double* pMyOriginalArrayX = new double[len];
											double* pMyOriginalArrayY = new double[len];
											for (int i = i1; i <= i2; i++)
											{
												x = p_trial_1->pressures[i];	
												y = p_trial_1->absolute_deformations[i].v;
												y /= p_trial_1->hoop_height;                                                        
												double e = e0_1.v - (1.0 + e0_1.v) * y;

												if (otnosit_def_on_graph)
												{
													pMyOriginalArrayX[i-i1] = x;
													pMyOriginalArrayY[i-i1] = y;

													if (max_e < y)
														max_e = y;

													if (min_e > y)
														min_e = y;
												}
												else
												{
													pMyOriginalArrayX[i-i1] = x;
													pMyOriginalArrayY[i-i1] = e;

													if (max_e < e)
														max_e = e;

													if (min_e > e)
														min_e = e;
												}
											}


											//Put it into a safe array.
											myOleSafeArrayX.CreateOneDim(VT_R8, len, pMyOriginalArrayX); 
											myOleSafeArrayY.CreateOneDim(VT_R8, len, pMyOriginalArrayY); 
											//clean up.
											delete[] pMyOriginalArrayX;	
											delete[] pMyOriginalArrayY;	
										}
									}
									break;
								case 5:
									{
										if (comp_result_3->p_result_1 && p_trial_1)
										{
											int len = p_trial_1->n_pressures-i2;
											double* pMyOriginalArrayX = new double[len];
											double* pMyOriginalArrayY = new double[len];
											bool wat = false;
											for (int i = i2; i < p_trial_1->n_pressures; i++)
											{
												x = p_trial_1->pressures[i];	
												y = p_trial_1->absolute_deformations[i].v;
												y /= p_trial_1->hoop_height;                                                        
												double e = e0_1.v - (1.0 + e0_1.v) * y;

												if (otnosit_def_on_graph)
												{
													pMyOriginalArrayX[i-i2] = x;
													pMyOriginalArrayY[i-i2] = y;

													if (max_e < y)
														max_e = y;

													if (min_e > y)
														min_e = y;
												}
												else
												{
													pMyOriginalArrayX[i-i2] = x;
													pMyOriginalArrayY[i-i2] = e;

													if (max_e < e)
														max_e = e;

													if (min_e > e)
														min_e = e;
												}
											}

											//Put it into a safe array.
											myOleSafeArrayX.CreateOneDim(VT_R8, len, pMyOriginalArrayX); 
											myOleSafeArrayY.CreateOneDim(VT_R8, len, pMyOriginalArrayY); 
											//clean up.
											delete[] pMyOriginalArrayX;	
											delete[] pMyOriginalArrayY;	
										}
									}
									break;
								case 2:
									{
										if ( comp_result_3->p_result_2)
										{
											int len = comp_result_3->p_result_2->vx.size();
											double* pMyOriginalArrayX = new double[len];
											double* pMyOriginalArrayY = new double[len];
											for(int i = 0; i < len; i++)
											{
												pMyOriginalArrayX[i] = comp_result_3->p_result_2->vx[i].x;
												if (otnosit_def_on_graph)
												{
													pMyOriginalArrayY[i] = comp_result_3->p_result_2->vy[i].v;

													if (max_e < comp_result_3->p_result_2->vy[i].v)
														max_e = comp_result_3->p_result_2->vy[i].v;

													if (min_e > comp_result_3->p_result_2->vy[i].v)
														min_e = comp_result_3->p_result_2->vy[i].v;
												}
												else
												{
													pMyOriginalArrayY[i] = comp_result_3->p_result_2->ve[i].v;

													if (max_e < comp_result_3->p_result_2->ve[i].v)
														max_e = comp_result_3->p_result_2->ve[i].v;

													if (min_e > comp_result_3->p_result_2->ve[i].v)
														min_e = comp_result_3->p_result_2->ve[i].v;
												}
											}								                
											//Put it into a safe array.
											myOleSafeArrayX.CreateOneDim(VT_R8, len, pMyOriginalArrayX); 
											myOleSafeArrayY.CreateOneDim(VT_R8, len, pMyOriginalArrayY); 
											//clean up.
											delete[] pMyOriginalArrayX;	
											delete[] pMyOriginalArrayY;	
										}
									}
									break;
								case 3:
									{
										if (comp_result_3)
										{
											int len = comp_result_3->x_prosadka_po_dvum_krivym.size();
											double* pMyOriginalArrayX = new double[len];
											double* pMyOriginalArrayY = new double[len];
											for (size_t i = 0; i < comp_result_3->x_prosadka_po_dvum_krivym.size(); i++)
											{
												x = comp_result_3->x_prosadka_po_dvum_krivym[i];
												y = comp_result_3->otnosit_prosadochnost_po_dvum_krivym[i].v;
												pMyOriginalArrayX[i] = x;
												pMyOriginalArrayY[i] = y;
											}
											//Put it into a safe array.
											myOleSafeArrayX.CreateOneDim(VT_R8, len, pMyOriginalArrayX); 
											myOleSafeArrayY.CreateOneDim(VT_R8, len, pMyOriginalArrayY); 
											//clean up.
											delete[] pMyOriginalArrayX;	
											delete[] pMyOriginalArrayY;	
										}
									}
									break;
								}

								
								

								LPDISPATCH pSeries;
								Series10    m_series;
								VERIFY(pSeries = m_chart.SeriesCollection(COleVariant(long(isc))));
								m_series.AttachDispatch(pSeries);
								m_series.SetValues(myOleSafeArrayY);
								m_series.SetXValues(myOleSafeArrayX);
								m_series.ReleaseDispatch();

							}

							if (max_isc>3)
							{
								LPDISPATCH pLegend;
								Legend11 m_legend;
								VERIFY(pLegend = m_chart.GetLegend());
								m_legend.AttachDispatch(pLegend);

								m_legend.SetHeight(27);
								m_legend.SetTop(225);
								m_legend.ReleaseDispatch();

							}

							min_e = double (0.01 * floor(100 * min_e) );	
							max_e = double (0.01 * ceil(100 * max_e) );	

							LPDISPATCH pAxes;
							VERIFY(pAxes = m_chart.Axes(COleVariant(long (2)), 1));//axis Y - [AxisGroup As XlAxisGroup = xlPrimary];
							Axis10    m_axis;
							m_axis.AttachDispatch(pAxes);
							m_axis.SetMinimumScale(min_e);
							m_axis.SetMaximumScale(max_e);
							m_axis.ReleaseDispatch();
						}


					}
					m_chart.ReleaseDispatch();
					m_chart_object.ReleaseDispatch();				
					m_shape.ReleaseDispatch();
				}
				break;
			case 2:// график на второй странице - Гурвич
				{
					LPDISPATCH pShape; 
					Shape10    m_shape;

					VERIFY(pShape = m_shapes.Item(COleVariant(long(ish))));				
					m_shape.AttachDispatch(pShape);	

					CString shape_name = m_shape.GetName();
					printf("%s\n", (LPCTSTR)shape_name);

					LPDISPATCH pChartObject; 
					ChartObject10    m_chart_object;

					VERIFY(pChartObject = m_excel.m_worksheet.ChartObjects(COleVariant(shape_name)));				
					m_chart_object.AttachDispatch(pChartObject);

					LPDISPATCH pChart;
					_Chart10    m_chart;

					VERIFY(pChart = m_chart_object.GetChart());
					m_chart.AttachDispatch(pChart); 
					
					if (use_table)
					{

						char sdataX[64];
						sprintf(sdataX, "=Лист1!R%dC1:R%dC1", ftr_g, ftr_g + gurvich.shtamp_vx.size());
						char sdataY[64];
						switch (n_lines)
						{
						case 3:
							{
								for (int isc = 1; isc <= n_lines; isc++)
								{
									switch (isc)
									{
									case 1:
										{
											sprintf(sdataY, "=Лист1!R%dC5:R%dC5", ftr_g, ftr_g + gurvich.shtamp_vx.size());
										}
										break;
									case 2:
										{
											sprintf(sdataY, "=Лист1!R%dC12:R%dC12", ftr_g, ftr_g + gurvich.shtamp_vx.size());
										}
										break;
									case 3:
										{
											sprintf(sdataY, "=Лист1!R%dC15:R%dC15", ftr_g, ftr_g + gurvich.shtamp_vx.size());
										}
										break;
									}

									/*try
									{

										LPDISPATCH pSeries;
										Series10    m_series;
										VERIFY(pSeries = m_chart.SeriesCollection(COleVariant(long(isc))));
										m_series.AttachDispatch(pSeries);
										m_series.SetXValues(COleVariant(sdataX));
										m_series.SetValues(COleVariant(sdataY));
										m_series.ReleaseDispatch();
									}
									catch (CException* pe)
									{
										// catch errors from WinINet 
										TCHAR szErr[4098]; 
										pe->GetErrorMessage(szErr, 4098); 
										AfxMessageBox(szErr);
										pe->Delete();
									}*/
								}
							}
							break;
						case 2:
							{
								for (int isc = 1; isc <= n_lines; isc++)
								{
									switch (isc)
									{
									case 1:
										{
											sprintf(sdataY, "=Лист1!R%dC2:R%dC2", ftr_g, ftr_g + gurvich.shtamp_vx.size());
										}
										break;
									case 2:			
										{
											sprintf(sdataY, "=Лист1!R%dC8:R%dC8", ftr_g, ftr_g + gurvich.shtamp_vx.size());
										}
										break;
									}
									/*try
									{

										LPDISPATCH pSeries;
										Series10    m_series;
										VERIFY(pSeries = m_chart.SeriesCollection(COleVariant(long(isc))));
										m_series.AttachDispatch(pSeries);
										m_series.SetXValues(COleVariant(sdataX));
										m_series.SetValues(COleVariant(sdataY));
										m_series.ReleaseDispatch();
									}
									catch (CException* pe)
									{
										// catch errors from WinINet 
										TCHAR szErr[4098]; 
										pe->GetErrorMessage(szErr, 4098); 
										AfxMessageBox(szErr);
										pe->Delete();
									}*/
								}

							}
							break;
						}

						try
						{
							LPDISPATCH pAxes_x;
							VERIFY(pAxes_x = m_chart.Axes(COleVariant(long (1)), 1));//axis X - [AxisGroup As XlAxisGroup = xlPrimary];
							Axis10    m_axis_x;
							m_axis_x.AttachDispatch(pAxes_x);
							m_axis_x.SetMinimumScale(0.0);
							m_axis_x.SetMaximumScale(max_x + delta_x);
							m_axis_x.ReleaseDispatch();
						}
						catch (CException* pe)
						{
							// catch errors from WinINet 
							TCHAR szErr[4098]; 
							pe->GetErrorMessage(szErr, 4098); 
							AfxMessageBox(szErr);
							pe->Delete();
						}
						double min_e2 = DBL_MAX;

						/*if (n_lines > 2)
						{
							sprintf(sdataY, "L%d", fr-1+p_trial_1->n_pressures);
							if (!ExcelRange_GetValue(m_excel, sdataY, min_e2))
							{
								sprintf(sdataY, "L%d", fr-2+p_trial_1->n_pressures);
								if (!ExcelRange_GetValue(m_excel, sdataY, min_e2))
								{

								}
							}
						}*/

						/*double min_e1 = DBL_MAX;
						sprintf(sdataY, "E%d", fr-1+p_trial_1->n_pressures);
						if (!ExcelRange_GetValue(m_excel, sdataY, min_e1))
						{
						}

						double min_e = min(min_e1, min_e2);

						LPDISPATCH pAxes_y;
						VERIFY(pAxes_y = m_chart.Axes(COleVariant(long (2)), 1));//axis Y - [AxisGroup As XlAxisGroup = xlPrimary];
						Axis10    m_axis_y;
						m_axis_y.AttachDispatch(pAxes_y);
						if (min_e != DBL_MAX)
							m_axis_y.SetMinimumScale(min_e);

						m_axis_y.ReleaseDispatch();*/
					}
					else
					{
					}
					m_chart.ReleaseDispatch();
					m_chart_object.ReleaseDispatch();				
					m_shape.ReleaseDispatch();
				}
				break;
			}

		}

		m_shapes.ReleaseDispatch();				
	}	
}
void Passport_Graph(MyExcel & m_excel, CutLabTrial * cut_lab_trial)
{
	if(cut_lab_trial)
	{
		double x,y;
//						char sx1[32], sx2[32];
		char SX[32], SY[32];
		// массив результатов опытов
		for (int i = 0; i < cut_lab_trial->n_pressures; i++)
		{
			y = cut_lab_trial->cut_resistances[i].v;
			x = cut_lab_trial->pressures[i];

			sprintf(SX, "SIGMA_%d", 1+i);
			sprintf(SY, "TAU_%d", 1+i);

			ExcelRange_SetValue(m_excel, SX, COleVariant(x), true);
			ExcelRange_SetValue(m_excel, SY, COleVariant(y), true);	
		}

		if (true)			
		{							
			LPDISPATCH pShapes; 
			Shapes10    m_shapes;
				
			VERIFY(pShapes = m_excel.m_worksheet.GetShapes());				
			m_shapes.AttachDispatch(pShapes);	

			long shapes_count = m_shapes.GetCount();
			printf("shapes_count = %d\n", shapes_count);

			for (long ish = 1; ish <= shapes_count; ish++)
			{
				LPDISPATCH pShape; 
				Shape10    m_shape;

				VERIFY(pShape = m_shapes.Item(COleVariant(long(ish))));				
				m_shape.AttachDispatch(pShape);	

				CString shape_name = m_shape.GetName();
				printf("%s\n", (LPCTSTR)shape_name);

				LPDISPATCH pChartObject; 
				ChartObject10    m_chart_object;

				VERIFY(pChartObject = m_excel.m_worksheet.ChartObjects(COleVariant(shape_name)));				
				m_chart_object.AttachDispatch(pChartObject);

				LPDISPATCH pChart;
				_Chart10    m_chart;

				VERIFY(pChart = m_chart_object.GetChart());
				m_chart.AttachDispatch(pChart);
#if 0
				LPDISPATCH pRange2; 
				VERIFY(pRange2 = m_excel.m_worksheet.GetRange(COleVariant("A22:B30")));
				m_chart.SetSourceData(pRange2, COleVariant("xlColomn"));    
#else               
			
				int len = cut_lab_trial->n_pressures;

				double* pMyOriginalArrayX = new double[cut_lab_trial->n_pressures];
				double* pMyOriginalArrayY = new double[cut_lab_trial->n_pressures];

				double max_x = -DBL_MAX;

				for (int i = 0; i < cut_lab_trial->n_pressures; i++)
				{
					y = cut_lab_trial->cut_resistances[i].v;
#if USE_LAB_LAYER_CUT_PRESSURES
					switch(cut_type)				
					{
					case CutLabTrial::type::nature_condition:
						{
							x = cut->pressures_in_nature_condition[i];
						}
						break;
					case CutLabTrial::type::task_condition:
						{
							x = cut->pressures_in_task_condition[i];
						}
						break;
					}
#else
					x = cut_lab_trial->pressures[i];
#endif

					pMyOriginalArrayX[i] = x;
					pMyOriginalArrayY[i] = y;	

					if (max_x < x)
						max_x = x;
				}

				LPDISPATCH pAxes;
				VERIFY(pAxes = m_chart.Axes(COleVariant(long (1)), 1));//axis X - [AxisGroup As XlAxisGroup = xlPrimary];

				//LPDISPATCH pAxis; 
				Axis10    m_axis;
				m_axis.AttachDispatch(pAxes);

				m_axis.SetMinimumScale(0.0);
				double max_x_scale = m_axis.GetMaximumScale();
				if (max_x_scale < max_x)
				{
					max_x_scale = max_x;
					m_axis.SetMaximumScale(max_x_scale);								
				}

				/*//Create and fill an array.
				double* pData;
				for(int count = 0; count < len; count++) 
					pMyOriginalArray[count] = count+1;//*/
				
				//Put it into a safe array.
				COleSafeArray myOleSafeArrayX;
				COleSafeArray myOleSafeArrayY;
				myOleSafeArrayX.CreateOneDim(VT_R8, len, pMyOriginalArrayX); 
				myOleSafeArrayY.CreateOneDim(VT_R8, len, pMyOriginalArrayY); 
				// create one dimension array of 8-byte values
				// 100 entries w/data from pMyOriginalArray.
				
				// Access that safe array.
				//Get a pointer to the Data.
				//myOleSafeArray.AccessData((void**)&pData); 
				//verify all of the data.
				//for(count = 0; count < 10; count++) 
				//	ASSERT(pData[count] == pMyOriginalArray[count]);
				//myOleSafeArray.UnaccessData();
				
				//clean up.
				delete[] pMyOriginalArrayX;	
				delete[] pMyOriginalArrayY;	

				//ActiveChart.SeriesCollection(1).XValues = "={0.001,0.01}"
				//ActiveChart.SeriesCollection(1).Values = "={0.001,0.02}"

				LPDISPATCH pSeries;
				Series10    m_series;
				VERIFY(pSeries = m_chart.SeriesCollection(COleVariant(long(1))));
				m_series.AttachDispatch(pSeries);
				m_series.SetValues(myOleSafeArrayY);
				m_series.SetXValues(myOleSafeArrayX);
				m_series.ReleaseDispatch();

				CutLabTrialResults * cut_result = dynamic_cast<CutLabTrialResults *>(cut_lab_trial->results);
				if (cut_result)
				{
					if(!cut_result->calculed)
						cut_result->CalcProperties();

					double* pMyOriginalArrayX2 = new double[2];
					double* pMyOriginalArrayY2 = new double[2];

					pMyOriginalArrayX2[0] = 0.0;
					pMyOriginalArrayY2[0] = cut_result->c.v;					

					pMyOriginalArrayX2[1] = max_x_scale;
					pMyOriginalArrayY2[1] = cut_result->c.v + cut_result->tgfi.v * max_x_scale;

					//Put it into a safe array.
					COleSafeArray myOleSafeArrayX2;
					COleSafeArray myOleSafeArrayY2;
					myOleSafeArrayX2.CreateOneDim(VT_R8, 2, pMyOriginalArrayX2); 
					myOleSafeArrayY2.CreateOneDim(VT_R8, 2, pMyOriginalArrayY2); 

					delete[] pMyOriginalArrayX2;	
					delete[] pMyOriginalArrayY2;	

					LPDISPATCH pSeries2;
					Series10    m_series2;
					VERIFY(pSeries2 = m_chart.SeriesCollection(COleVariant(long(2))));
					m_series2.AttachDispatch(pSeries2);
					m_series2.SetValues(myOleSafeArrayY2);
					m_series2.SetXValues(myOleSafeArrayX2);
					m_series2.ReleaseDispatch();
				}

				m_axis.ReleaseDispatch();
#endif
				m_chart.ReleaseDispatch();
				m_chart_object.ReleaseDispatch();				
				m_shape.ReleaseDispatch();

			}

			m_shapes.ReleaseDispatch();				
		}	
	}


}


void Passport_Graph(MyExcel & m_excel, FractionsLabTrialResults * frac_result)
{
	if (frac_result)
	{
		if(!frac_result->calculed)
			frac_result->CalcProperties();
		
		LPDISPATCH pShapes; 
		Shapes10    m_shapes;
			
		VERIFY(pShapes = m_excel.m_worksheet.GetShapes());				
		m_shapes.AttachDispatch(pShapes);	

		long shapes_count = m_shapes.GetCount();
		printf("shapes_count = %d\n", shapes_count);

		for (long ish = 1; ish <= shapes_count; ish++)
		{
			LPDISPATCH pShape; 
			Shape10    m_shape;

			VERIFY(pShape = m_shapes.Item(COleVariant(long(ish))));				
			m_shape.AttachDispatch(pShape);	

			CString shape_name = m_shape.GetName();
			printf("%s\n", (LPCTSTR)shape_name);

			LPDISPATCH pChartObject; 
			ChartObject10    m_chart_object;

			VERIFY(pChartObject = m_excel.m_worksheet.ChartObjects(COleVariant(shape_name)));				
			m_chart_object.AttachDispatch(pChartObject);

			LPDISPATCH pChart;
			_Chart10    m_chart;

			VERIFY(pChart = m_chart_object.GetChart());
			m_chart.AttachDispatch(pChart);

			//xlXYScatterSmooth '72
			m_chart.SetChartType(72);


			LPDISPATCH pAxes;
			VERIFY(pAxes = m_chart.Axes(COleVariant(long (1)), 1));//axis X - [AxisGroup As XlAxisGroup = xlPrimary];

			//LPDISPATCH pAxis; 
			Axis10    m_axis;
			m_axis.AttachDispatch(pAxes);

			int len = min(frac_result->v_diameters.size(), frac_result->v_sum_content.size());

			double* pMyOriginalArrayX = new double[len];
			double* pMyOriginalArrayY = new double[len];

			double max_diam = -DBL_MAX, min_diam = DBL_MAX;

			for(int i = 0; i < len; i++)
			{
				pMyOriginalArrayX[i] = frac_result->v_diameters[i];
				pMyOriginalArrayY[i] = frac_result->v_sum_content[i];

				if (max_diam < frac_result->v_diameters[i])
					max_diam = frac_result->v_diameters[i];

				if (min_diam > frac_result->v_diameters[i])
					min_diam = frac_result->v_diameters[i];

			}

			if (frac_result->v_diameters.size())
			{
				try
				{
					m_axis.SetMinimumScale(min_diam);
					m_axis.SetMaximumScale(max_diam);
				}
				catch (CException* pe)
				{
					// catch errors from WinINet 
					TCHAR szErr[4098]; 
					pe->GetErrorMessage(szErr, 4098); 
					AfxMessageBox(szErr);
					pe->Delete();
				}
			}

			/*//Create and fill an array.
			double* pData;
			for(int count = 0; count < len; count++) 
				pMyOriginalArray[count] = count+1;//*/
	        
			//Put it into a safe array.
			COleSafeArray myOleSafeArrayX;
			COleSafeArray myOleSafeArrayY;
			myOleSafeArrayX.CreateOneDim(VT_R8, len, pMyOriginalArrayX); 
			myOleSafeArrayY.CreateOneDim(VT_R8, len, pMyOriginalArrayY); 
			// create one dimension array of 8-byte values
			// 100 entries w/data from pMyOriginalArray.
			
			// Access that safe array.
			//Get a pointer to the Data.
			//myOleSafeArray.AccessData((void**)&pData); 
			//verify all of the data.
			//for(count = 0; count < 10; count++) 
			//	ASSERT(pData[count] == pMyOriginalArray[count]);
			//myOleSafeArray.UnaccessData();
			
			//clean up.
			delete[] pMyOriginalArrayX;	
			delete[] pMyOriginalArrayY;	

			//ActiveChart.SeriesCollection(1).XValues = "={0.001,0.01}"
			//ActiveChart.SeriesCollection(1).Values = "={0.001,0.02}"
			LPDISPATCH pSeries;
			Series10    m_series;
			VERIFY(pSeries = m_chart.SeriesCollection(COleVariant(long(1))));
			m_series.AttachDispatch(pSeries);
			m_series.SetValues(myOleSafeArrayY);
			m_series.SetXValues(myOleSafeArrayX);
			m_series.ReleaseDispatch();

			//m_chart.SetAutoScaling(autoscalling);


			m_axis.ReleaseDispatch();
			m_chart.ReleaseDispatch();
			m_chart_object.ReleaseDispatch();				
			m_shape.ReleaseDispatch();

		}

		m_shapes.ReleaseDispatch();


	}				

}


void FractionsLabTrial::Passport_1(const char * fn)
{
	if (this->n_fractions == 0)
		return;

	char file0[4098];
	char file[4098];

	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			sprintf(file, "%s_Pasport_GranR2.xls", fn);
			sprintf(file0, "%s\\Pasport_GranR2.xls", Laboratory::FormsDir.c_str());
		}
		break;
	case BaseLab::language::ukrainian:
		{
			sprintf(file, "%s_Pasport_Gran2.xls", fn);
			sprintf(file0, "%s\\Pasport_Gran2.xls", Laboratory::FormsDir.c_str());
		}
		break;
	}
	CopyFile(file0, file, FALSE); 
				

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);

			Passport_LabNumber(m_excel, this->lab_number, "");

			PhysicalLabTrial * phys_trial_m = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
			
			PhysicalLabTrial * phys_trial = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, -1));
			if(!phys_trial)
				phys_trial = phys_trial_m;

			trial_value e0;
			Passport_Phys(m_excel, phys_trial, e0, "", true);

			this->FillZhurnal(m_excel, 30, 32);

			FractionsLabTrialResults * frac_result = dynamic_cast<FractionsLabTrialResults *>(this->results);
			Passport_Graph(m_excel, frac_result);
			if (frac_result)
			{
				ExcelRange_SetValue(m_excel, "CU", COleVariant(frac_result->C_u.v));
				ExcelRange_SetValue(m_excel, "D_10", COleVariant(frac_result->d_10.v));
				ExcelRange_SetValue(m_excel, "D_60", COleVariant(frac_result->d_60.v));
				ExcelRange_SetValue(m_excel, "SOD_CHACTIC", COleVariant(frac_result->m_soderzhanie_chastic));

						
				char sx[128];
				sprintf(sx, "%f", frac_result->m_minimum_krupnosti_chastic);
				DeleteEndZeros(sx);

				char str[128];
				sprintf(str, "%s мм\0", sx);
				ExcelRange_SetValue(m_excel, "MIN_KRUPN_CHAST", COleVariant(str));
			}

			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
	{
		printf("!!!!! m_excel.IsApplicationDispatch()\n");
		AfxMessageBox("!!!!! m_excel.IsApplicationDispatch()\n");
	}

}
string FractionsLabTrial::GetSoilDescription()
{
	FractionsLabTrialResults * frac_lab_trial_res = dynamic_cast<FractionsLabTrialResults *>(this->results);

	if (frac_lab_trial_res)
	{
		if(!frac_lab_trial_res->calculed)
			frac_lab_trial_res->CalcProperties();					

		string s = "";
		if (frac_lab_trial_res->m_sand_soil_class != FractionsLabTrialResults::SandSoilsClass::undefined_sand_soil)
		{
			s += FractionsLabTrialResults::SandSoilsClassToString(frac_lab_trial_res->m_sand_soil_class);
			s += " ";
		}

		if (frac_lab_trial_res->m_clay_soil_class != FractionsLabTrialResults::ClaySoilsClass::undefined_clay_soil)
		{
			s += FractionsLabTrialResults::ClaySoilsClassToString(frac_lab_trial_res->m_clay_soil_class);
			s += " ";
		}

		if (frac_lab_trial_res->m_neodnorodnost != FractionsLabTrialResults::Neodnorodnost::undefined_neodnorodnost)
		{
			s += FractionsLabTrialResults::NeodnorodnostToString(frac_lab_trial_res->m_neodnorodnost);
			s += " ";
		}

		return s;
	}
	return "";
}
void FractionsLabTrial::GetSoilDescription(SoilDescription & sd)
{
	FractionsLabTrialResults * frac_lab_trial_res = dynamic_cast<FractionsLabTrialResults *>(this->results);

	if (frac_lab_trial_res)
	{
		if(!frac_lab_trial_res->calculed)
			frac_lab_trial_res->CalcProperties();	

		sd.C_u = frac_lab_trial_res->C_u;
		sd.d_10 = frac_lab_trial_res->d_10;
		sd.d_60 = frac_lab_trial_res->d_60;

		sd.m_clay_frac_content = frac_lab_trial_res->m_clay_frac_content;
		sd.m_pyl_frac_content  = frac_lab_trial_res->m_pyl_frac_content;

		sd.m_sand_soil_class = frac_lab_trial_res->m_sand_soil_class;
		sd.m_clay_soil_class = frac_lab_trial_res->m_clay_soil_class;
		sd.m_neodnorodnost = frac_lab_trial_res->m_neodnorodnost;
		sd.m_minimum_krupnosti_chastic = frac_lab_trial_res->m_minimum_krupnosti_chastic;
		sd.m_soderzhanie_chastic = frac_lab_trial_res->m_soderzhanie_chastic;
	}
}
void CompressionLabTrial::Passport(const char * fn)
{
}
string CompressionLabTrial::GetSoilDescription()
{
	return "";
}
void CompressionLabTrial::GetSoilDescription(SoilDescription & sd)
{
	CompressionLabTrialResults * compression_lab_trial_res = dynamic_cast<CompressionLabTrialResults *>(this->results);

	if (compression_lab_trial_res)
	{
		if(!compression_lab_trial_res->calculed)
			compression_lab_trial_res->CalcProperties();	

		if (this->com_type == CompressionLabTrial::type::nature_condition)
		{
			sd.compression_module_e_in_01_02_interval = compression_lab_trial_res->compression_module_e_in_01_02_interval;
			sd.compression_module_e_in_defined_interval = compression_lab_trial_res->compression_module_e_in_defined_interval;
			
			sd.deformation_module_e_in_01_02_interval = compression_lab_trial_res->deformation_module_e_in_01_02_interval;
			sd.deformation_module_e_in_defined_interval = compression_lab_trial_res->deformation_module_e_in_defined_interval;
			
			sd.def_module_defined_pressure_interval[0] = compression_lab_trial_res->def_module_defined_pressure_interval[0];
			sd.def_module_defined_pressure_interval[1] = compression_lab_trial_res->def_module_defined_pressure_interval[1];
			
			sd.def_module_01_02_pressure_interval[0] = compression_lab_trial_res->def_module_01_02_pressure_interval[0];
			sd.def_module_01_02_pressure_interval[1] = compression_lab_trial_res->def_module_01_02_pressure_interval[1];
			
			// гурвич
			sd.gurvich_Kp = compression_lab_trial_res->m_gurvich.Kp;

			sd.gurvich_shtamp_deformation_module_01_02_pressure_interval[0] = compression_lab_trial_res->m_gurvich.shtamp_deformation_module_01_02_pressure_interval[0];
			sd.gurvich_shtamp_deformation_module_01_02_pressure_interval[1] = compression_lab_trial_res->m_gurvich.shtamp_deformation_module_01_02_pressure_interval[1];
			sd.gurvich_shtamp_deformation_module_in_01_02_interval = compression_lab_trial_res->m_gurvich.shtamp_deformation_module_in_01_02_interval;
			sd.gurvich_shtamp_deformation_module_in_01_02_interval_Kp = compression_lab_trial_res->m_gurvich.shtamp_deformation_module_in_01_02_interval_Kp;

			sd.gurvich_shtamp_deformation_module_defined_pressure_interval[0] = compression_lab_trial_res->m_gurvich.shtamp_deformation_module_defined_pressure_interval[0];
			sd.gurvich_shtamp_deformation_module_defined_pressure_interval[1] = compression_lab_trial_res->m_gurvich.shtamp_deformation_module_defined_pressure_interval[1];
			sd.gurvich_shtamp_deformation_module_in_defined_interval = compression_lab_trial_res->m_gurvich.shtamp_deformation_module_in_defined_interval;
			sd.gurvich_shtamp_deformation_module_in_defined_interval_Kp = compression_lab_trial_res->m_gurvich.shtamp_deformation_module_in_defined_interval_Kp;
		}
		if (this->com_type == CompressionLabTrial::type::task_condition)
		{
		}
	}
}
string CompressionLabTrial3::GetSoilDescription()
{
	CompressionLabTrialResults3 * comp_lab_trial_res3 = dynamic_cast<CompressionLabTrialResults3 *>(this->results);

	if (comp_lab_trial_res3)
	{
		if(!comp_lab_trial_res3->calculed)
			comp_lab_trial_res3->CalcProperties();	

		string s = "";

		if (comp_lab_trial_res3->m_prosadochnost != CompressionLabTrialResults3::Prosadochnost::undefined_prosadocnist)
		{
			s += CompressionLabTrialResults3::ProsadochnostToString(comp_lab_trial_res3->m_prosadochnost);
			s += " ";
		}

		if (comp_lab_trial_res3->m_nabuhanie != CompressionLabTrialResults3::Nabuhanie::undefined_nabuhanie)
		{
			s += CompressionLabTrialResults3::NabuhanieToString(comp_lab_trial_res3->m_nabuhanie);
			s += " ";
		}

		return s;
			
	}
	return "";
}

void CompressionLabTrial3::GetSoilDescription(SoilDescription & sd)
{
	CompressionLabTrialResults3 * comp_lab_trial_res3 = dynamic_cast<CompressionLabTrialResults3 *>(this->results);

	if (comp_lab_trial_res3)
	{
		if(!comp_lab_trial_res3->calculed)
			comp_lab_trial_res3->CalcProperties();

		sd.davlenie_nabuhania = comp_lab_trial_res3->davlenie_nabuhania;
		sd.svobodnoe_otnositelnoe_nabuhanie = comp_lab_trial_res3->svobodnoe_otnositelnoe_nabuhanie;
		
		if (comp_lab_trial_res3->nachalnoe_prosadochnoe_davlenie_po_dvum_krivym.f
			||
			comp_lab_trial_res3->nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj.f)
		{
			sd.nachalnoe_prosadochnoe_davlenie = 
				min(
				comp_lab_trial_res3->nachalnoe_prosadochnoe_davlenie_po_dvum_krivym.f ? comp_lab_trial_res3->nachalnoe_prosadochnoe_davlenie_po_dvum_krivym.v : DBL_MAX,
				comp_lab_trial_res3->nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj.f ? comp_lab_trial_res3->nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj.v : DBL_MAX
				);
		}

		sd.m_prosadochnost = comp_lab_trial_res3->m_prosadochnost;
		sd.m_nabuhanie = comp_lab_trial_res3->m_nabuhanie;

		// здесь нужно предусмотреть взятие модулей деформации не только 
		// при естественной влежности но и в водонасыщенном состоянии
		if (this->p_trial_1)
			this->p_trial_1->GetSoilDescription(sd);
	}
}
void CompressionLabTrial3::Passport(const char * fn)
{
	switch (id_method)
	{
	case 1:
		{			
			switch(this->compression_passport_type)
			{
			case 0://ID_COMPRESSION_PASPORT "Паспорт (старый)"
				{
					this->Passport_1(fn);
				}
				break;
			case 1://ID_COMPRESSION_PASSPORT1 "Паспорт 1-ой кривой"
				{
					this->Passport_1_new(otnosit_def_on_graph, fn);
				}
				break;
			}
		}
		break;
	case 2:
		{
			switch(this->compression_passport_type)
			{
			case 0://ID_COMPRESSION_PASPORT "Паспорт (старый)"
				{
					this->Passport_2(fn);
				}
				break;
			case 1://ID_COMPRESSION_PASPORT2AS1 "Паспорт каждого кольца отдельно"
				{
					this->Passport_2_as_1(otnosit_def_on_graph, fn);
				}
				break;
			case 2://ID_COMPRESSION_PASSPORT2ASMEAN "Паспорт 2 кривых с усреднёнными физсвойствами"
				{
					this->Passport_2_as_mean(otnosit_def_on_graph, fn);
				}
				break;
			case 3://ID_COMPRESSION_PASPORT2ASDIFFVYPROB "Паспорт 2 кривых с отдельными физсвойствами"
				{
					this->Passport_2_as_diff_vyprob(otnosit_def_on_graph, fn);
				}
				break;
			}			
		}
		break;
	case 3:
		{
			this->Passport_3(fn);
		}
		break;
	case 4:
		{
			this->Passport_1(fn, true);
		}
		break;
	}
}
void Prepare_CompressionLabTrialResults3_Pasport_Header(MyExcel & m_excel, int r)
{
	try
	{
		char c1b = 'A';
		char c2e = 'P';

		char SM[32];
		sprintf(SM, "%c%d:%c%d", c1b, r, c2e, r+1);
		ExcelRange_SetMerge(m_excel, SM, false);
		ExcelRange_CenterVerticalAlignment(m_excel, SM);
		ExcelRange_CenterHorizontalAlignment(m_excel, SM);

		sprintf(SM, "%c%d", c1b, r);
		ExcelRange_SetValue(m_excel, SM, COleVariant("Таблица компрессионных свойств"));
		ExcelRange_SetBold(m_excel, SM);
	}
	catch (CException* pe)
	{
		// catch errors from WinINet 
		TCHAR szErr[4098]; 
		pe->GetErrorMessage(szErr, 4098); 
		AfxMessageBox(szErr);
		pe->Delete();
	}
}
void Prepare_CompressionLabTrialResults3_Pasport_Row(MyExcel & m_excel, char * SX, char * SY, int r, bool to_set_number_format = true)
{
	try
	{
		char c1b = 'A';
		char c1e = 'L';
		char c2b = 'M';
		char c2e = 'P';

		char SM1[32], SM2[32];
		sprintf(SX, "%c%d", c1b, r);
		sprintf(SY, "%c%d", c2b, r);
		sprintf(SM1, "%c%d:%c%d", c1b, r, c1e, r);
		sprintf(SM2, "%c%d:%c%d", c2b, r, c2e, r);
		ExcelRange_SetMerge(m_excel, SM1);
		ExcelRange_SetMerge(m_excel, SM2);
		ExcelRange_SetThinContinuousBorders(m_excel, SM1);
		ExcelRange_SetThinContinuousBorders(m_excel, SM2);

		try
		{
			if (to_set_number_format)
			{
				bool msg_if_catch = false;

				CString ds = m_excel.m_app.GetDecimalSeparator();
				if (ds == ",")
				{
					ExcelRange_SetNumberFormat(m_excel, SM2, "0,000", msg_if_catch);
				}
				if (ds == ".")
				{
					ExcelRange_SetNumberFormat(m_excel, SM2, "0.000", msg_if_catch);
				}

#if 0
				m_excel.m_app.GetLanguageSettings();
				// TODO: тут не учитываются региональные установки не на всех компьютерах работает нормально поэтому выключаем
				// With Application
				//   .DecimalSeparator = ","
				//   .ThousandsSeparator = " "
				//   .UseSystemSeparators = False
				// End With
				if (!ExcelRange_SetNumberFormat(m_excel, SM2, "0,000", msg_if_catch))
					ExcelRange_SetNumberFormat(m_excel, SM2, "0.000", msg_if_catch);
#endif
			}
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		ExcelRange_CenterHorizontalAlignment(m_excel, SM2);
	}
	catch (CException* pe)
	{
		// catch errors from WinINet 
		TCHAR szErr[4098]; 
		pe->GetErrorMessage(szErr, 4098); 
		AfxMessageBox(szErr);
		pe->Delete();
	}
}
void CompressionLabTrialResults3_ToPasport(CompressionLabTrialResults3 * comp_result_3,
										  MyExcel & m_excel, int & r)
{
	try
	{
		if (comp_result_3)
		{
			Prepare_CompressionLabTrialResults3_Pasport_Header(m_excel, r);
			r++;r++;

			char SX[32], SY[32];

			Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r, false);
			ExcelRange_SetValue(m_excel, SX, COleVariant("Свойство"));
			ExcelRange_CenterHorizontalAlignment(m_excel, SX);
			ExcelRange_SetValue(m_excel, SY, COleVariant("Значение"));
			r++;

			if (comp_result_3->prosadka_calculed_po_dvum_krivym)
			{
				Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
				ExcelRange_SetValue(m_excel, SX, COleVariant("Начальное просадочное давление (по двум кривым), МПа"));
				ExcelRange_SetValue(m_excel, SY, COleVariant(comp_result_3->nachalnoe_prosadochnoe_davlenie_po_dvum_krivym.v));
				r++;
			}
			else if (comp_result_3->prosadka_calculed_po_odnoj_krivoj)
			{
				Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
				ExcelRange_SetValue(m_excel, SX, COleVariant("Начальное просадочное давление (по одной кривой), МПа"));
				ExcelRange_SetValue(m_excel, SY, COleVariant(comp_result_3->nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj.v));
				r++;
			}	

			if (comp_result_3->gurvich_shtamp_prosadka_calculed_po_dvum_krivym)
			{
				if(comp_result_3->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_dvum_krivym.f)
				{
					Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
					ExcelRange_SetValue(m_excel, SX, COleVariant("Нач. просадоч. давление (по прогнозу штампа Гурвича) (по двум кривым), МПа"));
					ExcelRange_SetValue(m_excel, SY, COleVariant(comp_result_3->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_dvum_krivym.v));
					r++;
				}
			}
			else if (comp_result_3->gurvich_shtamp_prosadka_calculed_po_odnoj_krivoj)
			{
				if(comp_result_3->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj.f)
				{
					Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
					ExcelRange_SetValue(m_excel, SX, COleVariant("Нач. просадоч. давление (по прогнозу штампа Гурвича) (по одной кривой), МПа"));
					ExcelRange_SetValue(m_excel, SY, COleVariant(comp_result_3->gurvich_shtamp_nachalnoe_prosadochnoe_davlenie_po_odnoj_krivoj.v));
					r++;
				}
			}	

			if (comp_result_3->p_result_1->ocenka_bytovogo_davlenia.f)
			{
				Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
				ExcelRange_SetValue(m_excel, SX, COleVariant("Оценка бытового давления, МПа"));
				ExcelRange_SetValue(m_excel, SY, COleVariant(comp_result_3->p_result_1->ocenka_bytovogo_davlenia.v));
				r++;
			}

			if (comp_result_3->m_prosadochnost != CompressionLabTrialResults3::Prosadochnost::undefined_prosadocnist)
			{
				Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
				ExcelRange_SetValue(m_excel, SX, COleVariant("Тип грунта по просадочности"));
				ExcelRange_SetValue(m_excel, SY, COleVariant(CompressionLabTrialResults3::ProsadochnostToString(comp_result_3->m_prosadochnost)));
				r++;						
			}

			if(comp_result_3->svobodnoe_otnositelnoe_nabuhanie.f)
			{
				Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
				ExcelRange_SetValue(m_excel, SX, COleVariant("Свободное относительное набухание"));
				ExcelRange_SetValue(m_excel, SY, COleVariant(comp_result_3->svobodnoe_otnositelnoe_nabuhanie.v));
				r++;
			}
			if(comp_result_3->davlenie_nabuhania.f)
			{
				Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
				ExcelRange_SetValue(m_excel, SX, COleVariant("Давление набухания, МПа"));
				ExcelRange_SetValue(m_excel, SY, COleVariant(comp_result_3->davlenie_nabuhania.v));
				r++;
			}
			if (comp_result_3->m_nabuhanie != CompressionLabTrialResults3::Nabuhanie::undefined_nabuhanie)
			{
				Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
				ExcelRange_SetValue(m_excel, SX, COleVariant("Тип грунта по набуханию"));
				ExcelRange_SetValue(m_excel, SY, COleVariant(CompressionLabTrialResults3::NabuhanieToString(comp_result_3->m_nabuhanie)));
				r++;						
			}
			if (comp_result_3->m_otzhatoj_vody.f)
			{
				Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
				ExcelRange_SetValue(m_excel, SX, COleVariant("Масса отжатой из второго кольца воды, г"));
				ExcelRange_SetValue(m_excel, SY, COleVariant(comp_result_3->m_otzhatoj_vody.v));
				r++;						
			}
			if (comp_result_3->dejstvit_polnaja_osadka.f)
			{
				Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
				ExcelRange_SetValue(m_excel, SX, COleVariant("Действительная полная осадка, мм"));
				ExcelRange_SetValue(m_excel, SY, COleVariant(comp_result_3->dejstvit_polnaja_osadka.v));
				r++;						
			}
			if (comp_result_3->popravochnyj_koefficient_alpha.f)
			{
				Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
				ExcelRange_SetValue(m_excel, SX, COleVariant("Поправочный коэффициент альфа"));
				ExcelRange_SetValue(m_excel, SY, COleVariant(comp_result_3->popravochnyj_koefficient_alpha.v));
				r++;						
			}
		}
	}
	catch (CException* pe)
	{
		// catch errors from WinINet 
		TCHAR szErr[4098]; 
		pe->GetErrorMessage(szErr, 4098); 
		AfxMessageBox(szErr);
		pe->Delete();
	}
}

void CompressionLabTrial3::Passport_1(const char * fn, bool ws)
{
	char file0[4098];
	char file[4098];

	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			sprintf(file, "%s_Pasport_Comp%dR.xls", fn, ws?4:1);
			sprintf(file0, "%s\\Pasport_Comp1R.xls", Laboratory::FormsDir.c_str());
		}
		break;
	case BaseLab::language::ukrainian:
		{
			sprintf(file, "%s_Pasport_Comp%d.xls", fn, ws?4:1);
			sprintf(file0, "%s\\Pasport_Comp1.xls", Laboratory::FormsDir.c_str());
		}
		break;
	}
	CopyFile(file0, file, FALSE);

	LPDISPATCH pRange; 
	Range10    m_range;

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);

			if (this->lab_number)
			{
				char str[1024];

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(this->lab_number->depth));
				m_range.ReleaseDispatch();	

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("KT")));
				m_range.AttachDispatch(pRange);
				sprintf(str, "%s\0", this->lab_number->mine_working_number.c_str());
				if ISNUM(str)
				{
					switch(this->lab_number->m_mine_working_type)
					{
					case LabNumber::mine_working_type::hole:
						{
							sprintf(str, "Шурф № %s", this->lab_number->mine_working_number.c_str());
						}
						break;
					case LabNumber::mine_working_type::well:
						{
							// номер выработки
							sprintf(str, "Скв. № %s", this->lab_number->mine_working_number.c_str());
						}
						break;
					}
				}
				m_range.SetValue(COleVariant(str));
				m_range.ReleaseDispatch();	

				/*VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("H9")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(_GetKodProbyGrunta(this->lab_number->id_kodprob)));
				m_range.ReleaseDispatch();	*/

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("GRUNT")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(this->lab_number->GetSoilDescription(this->lab_number->get_soil_description_from_db).c_str()));
				m_range.ReleaseDispatch();	


				LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
				if (lablayer)
				{
					Laboratory * lab = (Laboratory *)lablayer->GetLaboratory();

					if (lab)
					{
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("CONTRACT")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(lab->contract.c_str()));
						m_range.ReleaseDispatch();


						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("OBJECT")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(lab->object_name.c_str()));
						m_range.ReleaseDispatch();	
					}

					CompressionLabTrial * p_trial = ws ? this->p_trial_2 : this->p_trial_1;

					
					if(p_trial)
					{
						PhysicalLabTrial * phys_trial = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, p_trial->id_phys_vyprob));
						if(!phys_trial)
							phys_trial = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));

						if (phys_trial)
						{


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("W")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial->moisture_of_nature_large_exchange.v));
							m_range.ReleaseDispatch();	


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("WL")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial->moisture_on_fluidity_border.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("WP")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial->moisture_on_plasticity_border.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("RO")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial->density_of_ground.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("ROS")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial->density_of_ground_particles.v));
							m_range.ReleaseDispatch();	

						}

						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("D")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(p_trial->hoop_diameter));
						m_range.ReleaseDispatch();									


						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("H")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(p_trial->hoop_height));
						m_range.ReleaseDispatch();

						double x,y;
						char SX[32], SY[32], 
							S_epsilon[32], F_epsilon[32], 
							S_d_e[32], F_d_e[32], 
							S_e[32], F_e[32], 
							S_m0[32], F_m0[32], 
							S_E[32], F_E[32];

						// массив результатов опытов
						double max_x = -DBL_MAX;
						bool first_zero_pressure = false;
						if (p_trial->n_pressures && p_trial->pressures[0] == 0.0)
							first_zero_pressure = true;
						
						int fr = 16;
						if (first_zero_pressure) fr = 15;
						bool water = ws ? true : false;

						for (int i = 0; i < p_trial->n_pressures; i++)
						{
							y = p_trial->absolute_deformations[i].v;
							x = p_trial->pressures[i];

							if (max_x < x)
								max_x = x;

							bool zamach = i && p_trial->pressures[i] == p_trial->pressures[i-1];
							if (zamach) water = true;

							sprintf(SX, "A%d", fr+i);
							sprintf(SY, "B%d", fr+i);
							sprintf(S_epsilon, "C%d", fr+i);
							sprintf(F_epsilon, "=B%d/H", fr+i);
							sprintf(S_d_e, "D%d", fr+i);
							sprintf(F_d_e, "=(1+E0)*C%d", fr+i);
							sprintf(S_e, "E%d", fr+i);
							sprintf(F_e, "=E0-(1+E0)*C%d", fr+i);
							sprintf(S_m0, "F%d", fr+i);
							sprintf(F_m0, "=(E%d-E%d)/(A%d-A%d)", fr+i-1, fr+i, fr+i, fr+i-1);
							
							sprintf(S_E, "G%d", fr+i);
							if (water)
								sprintf(F_E, "=BETTA_W*(A%d-A%d)/(C%d-C%d)", fr+i, fr+i-1, fr+i, fr+i-1);
							else
								sprintf(F_E, "=BETTA*(A%d-A%d)/(C%d-C%d)", fr+i, fr+i-1, fr+i, fr+i-1);


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(x));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();									
							
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
							m_range.AttachDispatch(pRange);			   
							if (y) m_range.SetValue(COleVariant(y));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_epsilon)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(F_epsilon));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_d_e)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(F_d_e));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_e)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(F_e));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							if (!zamach && (!first_zero_pressure || (i && first_zero_pressure)))
							{
								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_m0)));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(F_m0));
								m_range.BorderAround(COleVariant(long(1)), 2, -4105);
								m_range.ReleaseDispatch();	

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_E)));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(F_E));
								m_range.BorderAround(COleVariant(long(1)), 2, -4105);
								m_range.ReleaseDispatch();	
							}
						}
			


						CompressionLabTrialResults * comp_result = dynamic_cast<CompressionLabTrialResults *>(p_trial->results);
						
						if (comp_result)
						{
							if(!comp_result->calculed)
								comp_result->CalcProperties();
#if 1
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("BETTA")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->beta_tab.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("BETTA_W")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->beta_tab_ws.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("PUASSON")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->nju_tab.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("PUASSON_W")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->nju_tab_ws.v));
							m_range.ReleaseDispatch();	

#else
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("PUASSON")));
							m_range.AttachDispatch(pRange);			   
							if (ws)
								m_range.SetValue(COleVariant(comp_result->nju_tab_ws.v));
							else
								m_range.SetValue(COleVariant(comp_result->nju_tab.v));

							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("BETTA")));
							m_range.AttachDispatch(pRange);		
							if (ws)
								m_range.SetValue(COleVariant(comp_result->beta_tab_ws.v));
							else
								m_range.SetValue(COleVariant(comp_result->beta_tab.v));
							m_range.ReleaseDispatch();	
#endif
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_ES_L1")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->def_module_01_02_pressure_interval[0]));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_ES_R1")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->def_module_01_02_pressure_interval[1]));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_m01")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->a_in_01_02_interval.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_E1")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->deformation_module_e_in_01_02_interval.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_ES_L2")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->def_module_defined_pressure_interval[0]));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_ES_R2")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->def_module_defined_pressure_interval[1]));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_m02")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->a_in_defined_interval.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_E2")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->deformation_module_e_in_defined_interval.v));
							m_range.ReleaseDispatch();	

						}	
						else
							AfxMessageBox("!comp_result");


						if (true)			
						{							
							LPDISPATCH pShapes; 
							Shapes10    m_shapes;
								
							VERIFY(pShapes = m_excel.m_worksheet.GetShapes());				
							m_shapes.AttachDispatch(pShapes);	

							long shapes_count = m_shapes.GetCount();
							printf("shapes_count = %d\n", shapes_count);

							for (long ish = 1; ish <= shapes_count; ish++)
							{
								LPDISPATCH pShape; 
								Shape10    m_shape;

								VERIFY(pShape = m_shapes.Item(COleVariant(long(ish))));				
								m_shape.AttachDispatch(pShape);	

								CString shape_name = m_shape.GetName();
								printf("%s\n", (LPCTSTR)shape_name);

								LPDISPATCH pChartObject; 
								ChartObject10    m_chart_object;

								VERIFY(pChartObject = m_excel.m_worksheet.ChartObjects(COleVariant(shape_name)));				
								m_chart_object.AttachDispatch(pChartObject);

								LPDISPATCH pChart;
								_Chart10    m_chart;

								VERIFY(pChart = m_chart_object.GetChart());
								m_chart.AttachDispatch(pChart);             


								char sdataX[64];
								sprintf(sdataX, "=Лист1!R15C1:R%dC1", fr-1 + p_trial->n_pressures);
								char sdataY[64];
								for (long isc = 1; isc <= 1; isc++)
								{
									switch (isc)
									{
									case 1:
										{
											sprintf(sdataY, "=Лист1!R15C5:R%dC5", fr-1+p_trial->n_pressures);
										}
										break;
									}

									LPDISPATCH pSeries;
									Series10    m_series;
									VERIFY(pSeries = m_chart.SeriesCollection(COleVariant(long(isc))));
									m_series.AttachDispatch(pSeries);
									m_series.SetValues(COleVariant(sdataY));
									m_series.SetXValues(COleVariant(sdataX));
									m_series.ReleaseDispatch();
								}


								LPDISPATCH pAxes_x;
								VERIFY(pAxes_x = m_chart.Axes(COleVariant(long (1)), 1));//axis X - [AxisGroup As XlAxisGroup = xlPrimary];
								Axis10    m_axis_x;
								m_axis_x.AttachDispatch(pAxes_x);
								m_axis_x.SetMinimumScale(0.0);
								m_axis_x.SetMaximumScale(max_x);
								m_axis_x.ReleaseDispatch();		

								sprintf(sdataY, "E%d", fr-1+p_trial->n_pressures);

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(sdataY)));
								m_range.AttachDispatch(pRange);			   
								VARIANT mine = m_range.GetValue();
								m_range.ReleaseDispatch();	


								double min_e = 0.0;
								if (mine.vt == VT_R8)
								{
									min_e = mine.dblVal;
								}
								else if (mine.vt == (VT_R8 | VT_BYREF))
								{
									min_e = *mine.pdblVal;
								}
								



								
								LPDISPATCH pAxes_y;
								VERIFY(pAxes_y = m_chart.Axes(COleVariant(long (2)), 1));//axis Y - [AxisGroup As XlAxisGroup = xlPrimary];
								Axis10    m_axis_y;
								m_axis_y.AttachDispatch(pAxes_y);
								m_axis_y.SetMinimumScale(min_e);
								m_axis_y.ReleaseDispatch();

								m_chart.ReleaseDispatch();
								m_chart_object.ReleaseDispatch();				
								m_shape.ReleaseDispatch();

							}

							m_shapes.ReleaseDispatch();				
						}	
					}
				}			


				
				CompressionLabTrialResults3 * comp_result_3 = dynamic_cast<CompressionLabTrialResults3 *>(this->results);
				int r = 59;
				CompressionLabTrialResults3_ToPasport(comp_result_3, m_excel, r);
										  

			}

			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
		printf("!!!!! m_excel.IsApplicationDispatch()\n");
}
void CompressionLabTrial3::Passport_2(const char * fn)
{
	char file[4098];
	char file0[4098];

	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			sprintf(file, "%s_Pasport_Comp2R.xls", fn);
			sprintf(file0, "%s\\Pasport_Comp2R.xls", Laboratory::FormsDir.c_str());
		}
		break;
	case BaseLab::language::ukrainian:
		{
			sprintf(file, "%s_Pasport_Comp2.xls", fn);
			sprintf(file0, "%s\\Pasport_Comp2.xls", Laboratory::FormsDir.c_str());
		}
		break;
	}
	CopyFile(file0, file, FALSE);



	LPDISPATCH pRange; 
	Range10    m_range;

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);

			if (this->lab_number)
			{
				char str[1024];

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(this->lab_number->depth));
				m_range.ReleaseDispatch();	

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("KT")));
				m_range.AttachDispatch(pRange);
				sprintf(str, "%s\0", this->lab_number->mine_working_number.c_str());
				if ISNUM(str)
				{
					switch(this->lab_number->m_mine_working_type)
					{
					case LabNumber::mine_working_type::hole:
						{
							sprintf(str, "Шурф № %s", this->lab_number->mine_working_number.c_str());
						}
						break;
					case LabNumber::mine_working_type::well:
						{
							// номер выработки
							sprintf(str, "Скв. № %s", this->lab_number->mine_working_number.c_str());
						}
						break;
					}
				}
				m_range.SetValue(COleVariant(str));
				m_range.ReleaseDispatch();	

				/*VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("H9")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(_GetKodProbyGrunta(this->lab_number->id_kodprob)));
				m_range.ReleaseDispatch();	*/

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("GRUNT")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(this->lab_number->GetSoilDescription(this->lab_number->get_soil_description_from_db).c_str()));
				m_range.ReleaseDispatch();

				trial_value e0;

				LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
				if (lablayer)
				{
					Laboratory * lab = (Laboratory *)lablayer->GetLaboratory();

					if (lab)
					{
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("CONTRACT")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(lab->contract.c_str()));
						m_range.ReleaseDispatch();


						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("OBJECT")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(lab->object_name.c_str()));
						m_range.ReleaseDispatch();	
					}

					
					if(this->p_trial_1 && this->p_trial_2 )
					{
						PhysicalLabTrial * phys_trial_1 = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, this->p_trial_1->id_phys_vyprob));
						if(!phys_trial_1)
							phys_trial_1 = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
						
						PhysicalLabTrial * phys_trial_2 = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, this->p_trial_2->id_phys_vyprob));
						if(!phys_trial_2)
							phys_trial_2 = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));

						if (phys_trial_1)
						{


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("W")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial_1->moisture_of_nature_large_exchange.v));
							m_range.ReleaseDispatch();	


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("WL")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial_1->moisture_on_fluidity_border.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("WP")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial_1->moisture_on_plasticity_border.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("RO")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial_1->density_of_ground.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("ROS")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial_1->density_of_ground_particles.v));
							m_range.ReleaseDispatch();	

							PhysicalLabTrialResults * phys_result_1 = dynamic_cast<PhysicalLabTrialResults *>(phys_trial_1->results);
							if (phys_result_1)
							{
								if (!phys_result_1->calculed)
									phys_result_1->CalcProperties();

								e0 = phys_result_1->e;

								/*VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("E0")));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(phys_result->e.v));
								m_range.ReleaseDispatch();	q*/

							}

						}

						if (phys_trial_2)
						{


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("W")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial_2->moisture_of_nature_large_exchange.v));
							m_range.ReleaseDispatch();	


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("WL")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial_2->moisture_on_fluidity_border.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("WP")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial_2->moisture_on_plasticity_border.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("RO")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial_2->density_of_ground.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("ROS")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial_2->density_of_ground_particles.v));
							m_range.ReleaseDispatch();	

							PhysicalLabTrialResults * phys_result_2 = dynamic_cast<PhysicalLabTrialResults *>(phys_trial_2->results);
							if (phys_result_2)
							{
								if (!phys_result_2->calculed)
									phys_result_2->CalcProperties();

								e0 = phys_result_2->e;

								/*VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("E0")));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(phys_result->e.v));
								m_range.ReleaseDispatch();	q*/

							}

						}


						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("D")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(this->p_trial_1->hoop_diameter));
						m_range.ReleaseDispatch();									


						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("H")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(this->p_trial_1->hoop_height));
						m_range.ReleaseDispatch();	




						double x,y;
						char SX[32], SY[32], 
							S_epsilon[32], F_epsilon[32], 
							S_d_e[32], F_d_e[32], 
							S_e[32], F_e[32], 
							S_m0[32], F_m0[32], 
							S_E[32], F_E[32];
						// массив результатов опытов
						double max_x = -DBL_MAX;
						double min_e = DBL_MAX;


						bool first_zero_pressure = false;
						if (this->p_trial_1->n_pressures && this->p_trial_1->pressures[0] == 0.0)
							first_zero_pressure = true;
						
						int fr = 21;
						if (first_zero_pressure) fr = 20;

						bool water = false;
						for (int i = 0; i < this->p_trial_1->n_pressures; i++)
						{
							y = this->p_trial_1->absolute_deformations[i].v;
							x = this->p_trial_1->pressures[i];

							if (max_x < x)
								max_x = x;

							bool zamach = i && p_trial_1->pressures[i] == p_trial_1->pressures[i-1];
							if (zamach)
								water = true;

							sprintf(SX, "A%d", fr+i);
							sprintf(SY, "B%d", fr+i);
							sprintf(S_epsilon, "C%d", fr+i);
							sprintf(F_epsilon, "=B%d/H", fr+i);
							sprintf(S_d_e, "D%d", fr+i);
							sprintf(F_d_e, "=(1+E0)*C%d", fr+i);
							sprintf(S_e, "E%d", fr+i);
							sprintf(F_e, "=E0-(1+E0)*C%d", fr+i);
							sprintf(S_m0, "F%d", fr+i);
							sprintf(F_m0, "=(E%d-E%d)/(A%d-A%d)", fr+i-1, fr+i, fr+i, fr+i-1);
							
							sprintf(S_E, "G%d", fr+i);
							if (water)
								sprintf(F_E, "=BETTA_W*(A%d-A%d)/(C%d-C%d)", fr+i, fr+i-1, fr+i, fr+i-1);
							else
								sprintf(F_E, "=BETTA*(A%d-A%d)/(C%d-C%d)", fr+i, fr+i-1, fr+i, fr+i-1);


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(x));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();									
							
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
							m_range.AttachDispatch(pRange);			   
							if (y) m_range.SetValue(COleVariant(y));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_epsilon)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(F_epsilon));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_d_e)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(F_d_e));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_e)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(F_e));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							if (!zamach && (!first_zero_pressure || (i && first_zero_pressure)))
							{
								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_m0)));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(F_m0));
								m_range.BorderAround(COleVariant(long(1)), 2, -4105);
								m_range.ReleaseDispatch();	

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_E)));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(F_E));
								m_range.BorderAround(COleVariant(long(1)), 2, -4105);
								m_range.ReleaseDispatch();	
							}
						}
						{
							bool pass_skipped_row = false;
						for (int ii = 0; ii < this->p_trial_2->n_pressures; ii++)
						{
							y = this->p_trial_2->absolute_deformations[ii].v;
							x = this->p_trial_2->pressures[ii];

							int i = ii;
							double xx;
							int skip_row = 0;
							if(!pass_skipped_row) 
							{                                
								sprintf(SX, "A%d", fr+i);
								ExcelRange_GetValue(m_excel, SX, xx);
								if (x != xx)
								{
									pass_skipped_row = true;
									skip_row = 1;
								}
							}
							if(pass_skipped_row) i++;


							sprintf(SY, "H%d", fr+i);
							sprintf(S_epsilon, "I%d", fr+i);
							sprintf(F_epsilon, "=H%d/H", fr+i);
							sprintf(S_d_e, "J%d", fr+i);
							sprintf(F_d_e, "=(1+E0)*I%d", fr+i);
							sprintf(S_e, "K%d", fr+i);
							sprintf(F_e, "=E0-(1+E0)*I%d", fr+i);
							sprintf(S_m0, "L%d", fr+i);
							sprintf(F_m0, "=(K%d-K%d)/(A%d-A%d)", fr+i-1-skip_row, fr+i, fr+i, fr+i-1-skip_row);
							
							sprintf(S_E, "M%d", fr+i);
							sprintf(F_E, "=BETTA_W*(A%d-A%d)/(I%d-I%d)", fr+i, fr+i-1-skip_row, fr+i, fr+i-1-skip_row);


							/*VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(x));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();*/								
							
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
							m_range.AttachDispatch(pRange);			   
							if (y) m_range.SetValue(COleVariant(y));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_epsilon)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(F_epsilon));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_d_e)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(F_d_e));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_e)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(F_e));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							if (!first_zero_pressure || (i && first_zero_pressure))
							{
								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_m0)));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(F_m0));
								m_range.BorderAround(COleVariant(long(1)), 2, -4105);
								m_range.ReleaseDispatch();	

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_E)));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(F_E));
								m_range.BorderAround(COleVariant(long(1)), 2, -4105);
								m_range.ReleaseDispatch();	
							}

						}

						}
			
						CompressionLabTrialResults3 * comp_result3 = dynamic_cast<CompressionLabTrialResults3 *>(this->results);
						if (comp_result3)
						{
							for (size_t i = 0; i < comp_result3->x_prosadka_po_dvum_krivym.size(); i++)
							{
								sprintf(SY, "N%d", 20+i);
								y = comp_result3->otnosit_prosadochnost_po_dvum_krivym[i].v;

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
								m_range.AttachDispatch(pRange);			   
								if (y) m_range.SetValue(COleVariant(y));
								m_range.BorderAround(COleVariant(long(1)), 2, -4105);
								m_range.ReleaseDispatch();	
							}
						}

						CompressionLabTrialResults * comp_result = dynamic_cast<CompressionLabTrialResults *>(this->p_trial_1->results);
						
						if (comp_result)
						{
							if(!comp_result->calculed)
								comp_result->CalcProperties();

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("BETTA")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->beta_tab.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("BETTA_W")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->beta_tab_ws.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("PUASSON")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->nju_tab.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("PUASSON_W")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->nju_tab_ws.v));
							m_range.ReleaseDispatch();	




							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_ES_L1")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->def_module_01_02_pressure_interval[0]));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_ES_R1")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->def_module_01_02_pressure_interval[1]));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_m01")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->a_in_01_02_interval.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_E1")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->deformation_module_e_in_01_02_interval.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_ES_L2")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->def_module_defined_pressure_interval[0]));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_ES_R2")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->def_module_defined_pressure_interval[1]));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_m02")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->a_in_defined_interval.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_E2")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->deformation_module_e_in_defined_interval.v));
							m_range.ReleaseDispatch();	

						}				

						comp_result = dynamic_cast<CompressionLabTrialResults *>(this->p_trial_2->results);
						
						if (comp_result)
						{
							if(!comp_result->calculed)
								comp_result->CalcProperties();					


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("K33")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->a_in_01_02_interval.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("L33")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->deformation_module_e_in_01_02_interval.v));
							m_range.ReleaseDispatch();	


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("O33")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->a_in_defined_interval.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("P33")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->deformation_module_e_in_defined_interval.v));
							m_range.ReleaseDispatch();	
						}				

						if (true)			
						{							
							LPDISPATCH pShapes; 
							Shapes10    m_shapes;
								
							VERIFY(pShapes = m_excel.m_worksheet.GetShapes());				
							m_shapes.AttachDispatch(pShapes);	

							long shapes_count = m_shapes.GetCount();
							printf("shapes_count = %d\n", shapes_count);

							for (long ish = 1; ish <= shapes_count; ish++)
							{
								LPDISPATCH pShape; 
								Shape10    m_shape;

								VERIFY(pShape = m_shapes.Item(COleVariant(long(ish))));				
								m_shape.AttachDispatch(pShape);	

								CString shape_name = m_shape.GetName();
								printf("%s\n", (LPCTSTR)shape_name);

								LPDISPATCH pChartObject; 
								ChartObject10    m_chart_object;

								VERIFY(pChartObject = m_excel.m_worksheet.ChartObjects(COleVariant(shape_name)));				
								m_chart_object.AttachDispatch(pChartObject);

								LPDISPATCH pChart;
								_Chart10    m_chart;

								VERIFY(pChart = m_chart_object.GetChart());
								m_chart.AttachDispatch(pChart); 


#if 0
								char sdataX[64];
								sprintf(sdataX, "=Лист1!R20C1:R%dC1", fr-1 + this->p_trial_1->n_pressures);
								char sdataY[64];
								for (long isc = 1; isc <= 3; isc++)
								{
									switch (isc)
									{
									case 1:
										{
											sprintf(sdataY, "=Лист1!R20C5:R%dC5", fr-1+this->p_trial_1->n_pressures);
										}
										break;
									case 2:
										{
											sprintf(sdataY, "=Лист1!R20C11:R%dC11", fr-1+this->p_trial_1->n_pressures);
										}
										break;
									case 3:
										{
											sprintf(sdataY, "=Лист1!R20C14:R%dC14", fr-1+this->p_trial_1->n_pressures);
										}
										break;
									}

									LPDISPATCH pSeries;
									Series10    m_series;
									VERIFY(pSeries = m_chart.SeriesCollection(COleVariant(long(isc))));
									m_series.AttachDispatch(pSeries);
									m_series.SetValues(COleVariant(sdataY));
									m_series.SetXValues(COleVariant(sdataX));
									m_series.ReleaseDispatch();
								}


								LPDISPATCH pAxes_x;
								VERIFY(pAxes_x = m_chart.Axes(COleVariant(long (1)), 1));//axis X - [AxisGroup As XlAxisGroup = xlPrimary];
								Axis10    m_axis_x;
								m_axis_x.AttachDispatch(pAxes_x);
								m_axis_x.SetMinimumScale(0.0);
								m_axis_x.SetMaximumScale(max_x);
								m_axis_x.ReleaseDispatch();

								sprintf(sdataY, "K%d", fr-1+this->p_trial_1->n_pressures);

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(sdataY)));
								m_range.AttachDispatch(pRange);			   
								VARIANT mine = m_range.GetValue();
								//_variant_t mine = m_range.GetValue();
								m_range.ReleaseDispatch();	

								double min_e = 0.0;
								if (mine.vt == VT_R8)
								{
									min_e = mine.dblVal;
								}
								else if (mine.vt == (VT_R8 | VT_BYREF))
								{
									min_e = *mine.pdblVal;
								}			



								
								LPDISPATCH pAxes_y;
								VERIFY(pAxes_y = m_chart.Axes(COleVariant(long (2)), 1));//axis Y - [AxisGroup As XlAxisGroup = xlPrimary];
								Axis10    m_axis_y;
								m_axis_y.AttachDispatch(pAxes_y);
								m_axis_y.SetMinimumScale(min_e);
								m_axis_y.ReleaseDispatch();
#else
				
								CompressionLabTrialResults3 * comp_result_3 = dynamic_cast<CompressionLabTrialResults3 *>(this->results);
				

								if (comp_result_3)
								{
									double max_e = -DBL_MAX, min_e = DBL_MAX;

									int max_isc = 3;
									int i1,i2;

									for (long isc = 1; isc <= max_isc; isc++)
									{
										COleSafeArray myOleSafeArrayX;
										COleSafeArray myOleSafeArrayY;
										switch (isc)
										{
										case 1:
											{
												if (comp_result_3->p_result_1 && this->p_trial_1)
												{
													int len = this->p_trial_1->n_pressures;
													bool wat = false;
													bool added_5 = false;
													for (int i = 0; i < this->p_trial_1->n_pressures; i++)
													{
														x = this->p_trial_1->pressures[i];	
														bool zam = i && this->p_trial_1->pressures[i] == this->p_trial_1->pressures[i-1];
														if (zam)
														{
															wat = true;
															i1 = i-1;
															i2 = i;
															len = i;
														}

														if (wat)
														{
															max_isc = 4;

															if (zam)
															{
																LPDISPATCH pSeriesCollection;
																SeriesCollection10    m_series_collection;
																VERIFY(pSeriesCollection = m_chart.SeriesCollection());
																m_series_collection.AttachDispatch(pSeriesCollection);

																LPDISPATCH pSeries;
																Series10    m_series;
																VERIFY(pSeries = m_series_collection.NewSeries());
																m_series.AttachDispatch(pSeries);

																
																switch (BaseLab::PassportLanguage)
																{
																case BaseLab::language::russian:
																	{
																		m_series.SetName("Замачивание");
																	}
																	break;
																case BaseLab::language::ukrainian:
																	{
																		m_series.SetName("Замочування");
																	}
																	break;
																}

																m_series.ReleaseDispatch();
																m_series_collection.ReleaseDispatch();
															}
															
															if (!zam)
															{
																max_isc = 5;

																if (!added_5)
																{
																	added_5 = true;

																	LPDISPATCH pSeriesCollection;
																	SeriesCollection10    m_series_collection;
																	VERIFY(pSeriesCollection = m_chart.SeriesCollection());
																	m_series_collection.AttachDispatch(pSeriesCollection);

																	LPDISPATCH pSeries;
																	Series10    m_series;
																	VERIFY(pSeries = m_series_collection.NewSeries());
																	m_series.AttachDispatch(pSeries);

																	
																	switch (BaseLab::PassportLanguage)
																	{
																	case BaseLab::language::russian:
																		{
																			m_series.SetName("Уплотнение после замачивания");
																		}
																		break;
																	case BaseLab::language::ukrainian:
																		{
																			m_series.SetName("Ущільнення після замочування");
																		}
																		break;
																	}
																	m_series.ReleaseDispatch();
																	m_series_collection.ReleaseDispatch();
																}
															}
														}
													}

													wat = false;
													double* pMyOriginalArrayX = new double[len];
													double* pMyOriginalArrayY = new double[len];

													for (int i = 0; i < len; i++)
													{
														x = this->p_trial_1->pressures[i];	
														bool zam = i && this->p_trial_1->pressures[i] == this->p_trial_1->pressures[i-1];
														if (zam)
														{
															wat = true;
															i1 = i-1;
															i2 = i;
														}

														if (wat)
														{
															max_isc = 4;

															if (!zam)
															{
																max_isc = 5;
															}
														}

														y = this->p_trial_1->absolute_deformations[i].v;
														y /= this->p_trial_1->hoop_height;                                                        
														double e = e0.v - (1.0 + e0.v) * y;

														pMyOriginalArrayX[i] = x;
														pMyOriginalArrayY[i] = e;

														if (max_e < e)
															max_e = e;

														if (min_e > e)
															min_e = e;
													}


													//Put it into a safe array.
													myOleSafeArrayX.CreateOneDim(VT_R8, len, pMyOriginalArrayX); 
													myOleSafeArrayY.CreateOneDim(VT_R8, len, pMyOriginalArrayY); 
													//clean up.
													delete[] pMyOriginalArrayX;	
													delete[] pMyOriginalArrayY;	
												}
											}
											break;
										case 4:
											{
												if (comp_result_3->p_result_1 && this->p_trial_1)
												{
													int len = 2;
													double* pMyOriginalArrayX = new double[len];
													double* pMyOriginalArrayY = new double[len];
													for (int i = i1; i <= i2; i++)
													{
														x = this->p_trial_1->pressures[i];	
														y = this->p_trial_1->absolute_deformations[i].v;
														y /= this->p_trial_1->hoop_height;                                                        
														double e = e0.v - (1.0 + e0.v) * y;

														pMyOriginalArrayX[i-i1] = x;
														pMyOriginalArrayY[i-i1] = e;

														if (max_e < e)
															max_e = e;

														if (min_e > e)
															min_e = e;
													}


													//Put it into a safe array.
													myOleSafeArrayX.CreateOneDim(VT_R8, len, pMyOriginalArrayX); 
													myOleSafeArrayY.CreateOneDim(VT_R8, len, pMyOriginalArrayY); 
													//clean up.
													delete[] pMyOriginalArrayX;	
													delete[] pMyOriginalArrayY;	
												}
											}
											break;
										case 5:
											{
												if (comp_result_3->p_result_1 && this->p_trial_1)
												{
													int len = this->p_trial_1->n_pressures-i2;
													double* pMyOriginalArrayX = new double[len];
													double* pMyOriginalArrayY = new double[len];
													bool wat = false;
													for (int i = i2; i < this->p_trial_1->n_pressures; i++)
													{
														x = this->p_trial_1->pressures[i];	
														y = this->p_trial_1->absolute_deformations[i].v;
														y /= this->p_trial_1->hoop_height;                                                        
														double e = e0.v - (1.0 + e0.v) * y;

														pMyOriginalArrayX[i-i2] = x;
														pMyOriginalArrayY[i-i2] = e;

														if (max_e < e)
															max_e = e;

														if (min_e > e)
															min_e = e;
													}

													//Put it into a safe array.
													myOleSafeArrayX.CreateOneDim(VT_R8, len, pMyOriginalArrayX); 
													myOleSafeArrayY.CreateOneDim(VT_R8, len, pMyOriginalArrayY); 
													//clean up.
													delete[] pMyOriginalArrayX;	
													delete[] pMyOriginalArrayY;	
												}
											}
											break;
										case 2:
											{
												if ( comp_result_3->p_result_2)
												{
													int len = comp_result_3->p_result_2->vx.size();
													double* pMyOriginalArrayX = new double[len];
													double* pMyOriginalArrayY = new double[len];
													for(int i = 0; i < len; i++)
													{
														pMyOriginalArrayX[i] = comp_result_3->p_result_2->vx[i].x;
														pMyOriginalArrayY[i] = comp_result_3->p_result_2->ve[i].v;

														if (max_e < comp_result_3->p_result_2->ve[i].v)
															max_e = comp_result_3->p_result_2->ve[i].v;

														if (min_e > comp_result_3->p_result_2->ve[i].v)
															min_e = comp_result_3->p_result_2->ve[i].v;
													}								                
													//Put it into a safe array.
													myOleSafeArrayX.CreateOneDim(VT_R8, len, pMyOriginalArrayX); 
													myOleSafeArrayY.CreateOneDim(VT_R8, len, pMyOriginalArrayY); 
													//clean up.
													delete[] pMyOriginalArrayX;	
													delete[] pMyOriginalArrayY;	
												}
											}
											break;
										case 3:
											{
												CompressionLabTrialResults3 * comp_result3 = dynamic_cast<CompressionLabTrialResults3 *>(this->results);
												if (comp_result3)
												{
													int len = comp_result3->x_prosadka_po_dvum_krivym.size();
													double* pMyOriginalArrayX = new double[len];
													double* pMyOriginalArrayY = new double[len];
													for (size_t i = 0; i < comp_result3->x_prosadka_po_dvum_krivym.size(); i++)
													{
														x = comp_result3->x_prosadka_po_dvum_krivym[i];
														y = comp_result3->otnosit_prosadochnost_po_dvum_krivym[i].v;
														pMyOriginalArrayX[i] = x;
														pMyOriginalArrayY[i] = y;
													}
													//Put it into a safe array.
													myOleSafeArrayX.CreateOneDim(VT_R8, len, pMyOriginalArrayX); 
													myOleSafeArrayY.CreateOneDim(VT_R8, len, pMyOriginalArrayY); 
													//clean up.
													delete[] pMyOriginalArrayX;	
													delete[] pMyOriginalArrayY;	
												}
											}
											break;
										}

										
										

										LPDISPATCH pSeries;
										Series10    m_series;
										VERIFY(pSeries = m_chart.SeriesCollection(COleVariant(long(isc))));
										m_series.AttachDispatch(pSeries);
										m_series.SetValues(myOleSafeArrayY);
										m_series.SetXValues(myOleSafeArrayX);
										m_series.ReleaseDispatch();

									}

									if (max_isc>3)
									{
										LPDISPATCH pLegend;
										Legend11 m_legend;
										VERIFY(pLegend = m_chart.GetLegend());
										m_legend.AttachDispatch(pLegend);

										m_legend.SetHeight(27);
										m_legend.SetTop(204);
										m_legend.ReleaseDispatch();

									}

									min_e = double (0.01 * floor(100 * min_e) );	
									max_e = double (0.01 * ceil(100 * max_e) );	

									LPDISPATCH pAxes;
									VERIFY(pAxes = m_chart.Axes(COleVariant(long (2)), 1));//axis Y - [AxisGroup As XlAxisGroup = xlPrimary];
									Axis10    m_axis;
									m_axis.AttachDispatch(pAxes);
									m_axis.SetMinimumScale(min_e);
									m_axis.SetMaximumScale(max_e);
									m_axis.ReleaseDispatch();
								}
#endif

								m_chart.ReleaseDispatch();
								m_chart_object.ReleaseDispatch();				
								m_shape.ReleaseDispatch();

							}

							m_shapes.ReleaseDispatch();				
						}	
					}
				}			


				CompressionLabTrialResults3 * comp_result_3 = dynamic_cast<CompressionLabTrialResults3 *>(this->results);
				int r = 59;
				CompressionLabTrialResults3_ToPasport(comp_result_3, m_excel, r);
			}

			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
		printf("!!!!! m_excel.IsApplicationDispatch()\n");
}
void CompressionLabTrial3::Passport_2_as_1(bool otnosit_def_on_graph, const char * fn)
{
}
void Passport_Phys(MyExcel & m_excel, PhysicalLabTrial * phys_trial, trial_value & e0, const char * suffix, bool to_set_calculed)
{
	char S[64];
	if (phys_trial)
	{
		if (phys_trial->moisture_of_nature_large_exchange.f)
		{
			sprintf(S, "W%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(phys_trial->moisture_of_nature_large_exchange.v));
		}
		if (phys_trial->moisture_on_fluidity_border.f)
		{
			sprintf(S, "WL%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(phys_trial->moisture_on_fluidity_border.v));
		}
		if (phys_trial->moisture_on_plasticity_border.f)
		{
			sprintf(S, "WP%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(phys_trial->moisture_on_plasticity_border.v));
		}
		
		if (phys_trial->density_of_ground.f)
		{
			sprintf(S, "RO%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(phys_trial->density_of_ground.v));
		}
		if (phys_trial->density_of_ground_particles.f)
		{
			sprintf(S, "ROS%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(phys_trial->density_of_ground_particles.v));
		}

		PhysicalLabTrialResults * phys_result = dynamic_cast<PhysicalLabTrialResults *>(phys_trial->results);
		if (phys_result)
		{
			if (!phys_result->calculed)
				phys_result->CalcProperties();
			if (phys_result->e.f)				
			{
				e0 = phys_result->e;
				sprintf(S, "E0%s", suffix);
				ExcelRange_SetValue(m_excel, S, COleVariant(phys_result->e.v));
			}
			if (phys_result->n.f)				
			{
				sprintf(S, "N%s", suffix);
				ExcelRange_SetValue(m_excel, S, COleVariant(phys_result->n.v));
			}
			if (phys_result->density_of_dry_ground.f)				
			{
				sprintf(S, "ROd%s", suffix);
				ExcelRange_SetValue(m_excel, S, COleVariant(phys_result->density_of_dry_ground.v));
			}
			if (to_set_calculed)
			{
				if (phys_result->S.f)				
				{
					sprintf(S, "Sr%s", suffix);
					ExcelRange_SetValue(m_excel, S, COleVariant(phys_result->S.v));
				}
				if (phys_result->plasticity_index.f)				
				{
					sprintf(S, "IP%s", suffix);
					ExcelRange_SetValue(m_excel, S, COleVariant(phys_result->plasticity_index.v));
				}
				if (phys_result->fluidity_index_nature.f)				
				{
					sprintf(S, "IL%s", suffix);
					ExcelRange_SetValue(m_excel, S, COleVariant(phys_result->fluidity_index_nature.v));
				}
			}
		}
	}
}

void Passport_PhysMean(MyExcel & m_excel, PhysicalLabTrial * phys_trial_1, PhysicalLabTrial * phys_trial_2, const char * suffix)
{
	char S[64];
	if (phys_trial_1 && phys_trial_2)
	{
		if (phys_trial_1->moisture_of_nature_large_exchange.f && phys_trial_2->moisture_of_nature_large_exchange.f)
		{
			sprintf(S, "W%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(0.5 * (phys_trial_1->moisture_of_nature_large_exchange.v + phys_trial_2->moisture_of_nature_large_exchange.v)));
		}
		if (phys_trial_1->moisture_on_fluidity_border.f && phys_trial_2->moisture_on_fluidity_border.f)
		{
			sprintf(S, "WL%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(0.5 * (phys_trial_1->moisture_on_fluidity_border.v + phys_trial_2->moisture_on_fluidity_border.v)));
		}
		if (phys_trial_1->moisture_on_plasticity_border.f && phys_trial_2->moisture_on_plasticity_border.f)
		{
			sprintf(S, "WP%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(0.5 * (phys_trial_1->moisture_on_plasticity_border.v + phys_trial_2->moisture_on_plasticity_border.v)));
		}
		
		if (phys_trial_1->density_of_ground.f && phys_trial_2->density_of_ground.f)
		{
			sprintf(S, "RO%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(0.5 * (phys_trial_1->density_of_ground.v + phys_trial_2->density_of_ground.v)));
		}
		if (phys_trial_1->density_of_ground_particles.f && phys_trial_2->density_of_ground_particles.f)
		{
			sprintf(S, "ROS%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(0.5 * (phys_trial_1->density_of_ground_particles.v + phys_trial_2->density_of_ground_particles.v)));
		}

		PhysicalLabTrialResults * phys_result_1 = dynamic_cast<PhysicalLabTrialResults *>(phys_trial_1->results);
		PhysicalLabTrialResults * phys_result_2 = dynamic_cast<PhysicalLabTrialResults *>(phys_trial_2->results);
		if (phys_result_1 && phys_result_2)
		{
			if (!phys_result_1->calculed)
				phys_result_1->CalcProperties();
			if (!phys_result_2->calculed)
				phys_result_2->CalcProperties();

			if (phys_result_1->e.f && phys_result_2->e.f)				
			{
				sprintf(S, "E0%s", suffix);
				ExcelRange_SetValue(m_excel, S, COleVariant(0.5 * (phys_result_1->e.v + phys_result_2->e.v)));
			}
			if (phys_result_1->n.f && phys_result_2->n.f)				
			{
				sprintf(S, "N%s", suffix);
				ExcelRange_SetValue(m_excel, S, COleVariant(0.5 * (phys_result_1->n.v + phys_result_2->n.v)));
			}
			if (phys_result_1->density_of_dry_ground.f && phys_result_2->density_of_dry_ground.f)				
			{
				sprintf(S, "ROd%s", suffix);
				ExcelRange_SetValue(m_excel, S, COleVariant(0.5 * (phys_result_1->density_of_dry_ground.v + phys_result_2->density_of_dry_ground.v)));
			}

			sprintf(S, "IP%s", suffix);
			if (phys_result_1->plasticity_index.f && phys_result_2->plasticity_index.f)				
			{
				ExcelRange_SetValue(m_excel, S, COleVariant(0.5 * (phys_result_1->plasticity_index.v + phys_result_2->plasticity_index.v)));
			}	
			else
				ExcelRange_SetValue(m_excel, S, COleVariant(""));

			sprintf(S, "IL%s", suffix);
			if (phys_result_1->fluidity_index_nature.f && phys_result_2->fluidity_index_nature.f)				
			{
				ExcelRange_SetValue(m_excel, S, COleVariant(0.5 * (phys_result_1->fluidity_index_nature.v + phys_result_2->fluidity_index_nature.v)));
			}
			else
				ExcelRange_SetValue(m_excel, S, COleVariant(""));
		}
	}
}

void Passport_CompressionBetaPuasson(MyExcel & m_excel, CompressionLabTrialResults * comp_result)	
{
	if (comp_result)
	{
		if(!comp_result->calculed)
			comp_result->CalcProperties();

		if (comp_result->beta_tab.f)
		{
			ExcelRange_SetValue(m_excel, "BETTA", COleVariant(comp_result->beta_tab.v));
		}

		if (comp_result->beta_tab_ws.f)
		{
			ExcelRange_SetValue(m_excel, "BETTA_W", COleVariant(comp_result->beta_tab_ws.v));
		}

		if (comp_result->nju_tab.f)
		{
			ExcelRange_SetValue(m_excel, "PUASSON", COleVariant(comp_result->nju_tab.v));
		}

		if (comp_result->nju_tab_ws.f)
		{
			ExcelRange_SetValue(m_excel, "PUASSON_W", COleVariant(comp_result->nju_tab_ws.v));
		}
	}	
}


void Passport_CompressionLabTrialResults(MyExcel & m_excel, CompressionLabTrialResults * comp_result, const char * suffix)	
{
	char S[64];
	if (comp_result)
	{
		if(!comp_result->calculed)
			comp_result->CalcProperties();

		//if (comp_result->def_module_01_02_pressure_interval[0])
		//{
			sprintf(S, "Z_ES_L1%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(comp_result->def_module_01_02_pressure_interval[0]));
		//}	

		if (comp_result->def_module_01_02_pressure_interval[1])
		{
			sprintf(S, "Z_ES_R1%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(comp_result->def_module_01_02_pressure_interval[1]));
		}	
	
		if (comp_result->a_in_01_02_interval.f)
		{
			sprintf(S, "Z_m01%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(comp_result->a_in_01_02_interval.v));
		}
	
		if (comp_result->deformation_module_e_in_01_02_interval.f)
		{
			sprintf(S, "Z_E1%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(comp_result->deformation_module_e_in_01_02_interval.v));
		}	

		//if (comp_result->def_module_defined_pressure_interval[0])
		//{
			sprintf(S, "Z_ES_L2%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(comp_result->def_module_defined_pressure_interval[0]));
		//}	

		if (comp_result->def_module_defined_pressure_interval[1])
		{
			sprintf(S, "Z_ES_R2%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(comp_result->def_module_defined_pressure_interval[1]));
		}

		if (comp_result->a_in_defined_interval.f)
		{
			sprintf(S, "Z_m02%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(comp_result->a_in_defined_interval.v));
		}
	
		if (comp_result->deformation_module_e_in_defined_interval.f)
		{
			sprintf(S, "Z_E2%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(comp_result->deformation_module_e_in_defined_interval.v));
		}
	}	
}
void Passport_Table1(MyExcel & m_excel, CompressionLabTrial * p_trial_1, int fr, bool first_zero_pressure, const char * S_E0_suffix, double & max_x, double & delta_x)
{
	max_x = -DBL_MAX;
	double x,y;
	char SX[32], SY[32], 
		S_epsilon[32], F_epsilon[32], 
		S_d_e[32], F_d_e[32], 
		S_e[32], F_e[32], 
		S_m0[32], F_m0[32], 
		S_E[32], F_E[32];
	bool water = false;
	for (int i = 0; i < p_trial_1->n_pressures; i++)
	{
		y = p_trial_1->absolute_deformations[i].v;
		x = p_trial_1->pressures[i];

		if (i && x != p_trial_1->pressures[i-1])
		{
			delta_x = x - p_trial_1->pressures[i-1];
		}

		if (max_x < x)
			max_x = x;

		bool zamach = i && p_trial_1->pressures[i] == p_trial_1->pressures[i-1];
		if (zamach)
			water = true;

		sprintf(SX, "A%d", fr+i);
		sprintf(SY, "B%d", fr+i);
		sprintf(S_epsilon, "C%d", fr+i);
		sprintf(F_epsilon, "=B%d/H", fr+i);
		sprintf(S_d_e, "D%d", fr+i);
		sprintf(F_d_e, "=(1+E0%s)*C%d", S_E0_suffix, fr+i);
		sprintf(S_e, "E%d", fr+i);
		sprintf(F_e, "=E0%s-(1+E0%s)*C%d", S_E0_suffix, S_E0_suffix, fr+i);
		sprintf(S_m0, "F%d", fr+i);
		sprintf(F_m0, "=(E%d-E%d)/(A%d-A%d)", fr+i-1, fr+i, fr+i, fr+i-1);
		
		sprintf(S_E, "G%d", fr+i);
		if (water)
			sprintf(F_E, "=BETTA_W*(A%d-A%d)/(C%d-C%d)", fr+i, fr+i-1, fr+i, fr+i-1);
		else
			sprintf(F_E, "=BETTA*(A%d-A%d)/(C%d-C%d)", fr+i, fr+i-1, fr+i, fr+i-1);


		ExcelRange_SetValue(m_excel, SX, COleVariant(x), true);									
		ExcelRange_SetValue(m_excel, SY, COleVariant(y), true);									
		ExcelRange_SetValue(m_excel, S_epsilon, COleVariant(F_epsilon), true);							
		ExcelRange_SetValue(m_excel, S_d_e, COleVariant(F_d_e), true);							
		ExcelRange_SetValue(m_excel, S_e, COleVariant(F_e), true);				



		if (!zamach && (!first_zero_pressure || (i && first_zero_pressure)))
		{
			ExcelRange_SetValue(m_excel, S_m0, COleVariant(F_m0), true);				
			ExcelRange_SetValue(m_excel, S_E, COleVariant(F_E), true);
		}
	}
}

void Passport_Table2(MyExcel & m_excel, CompressionLabTrial * p_trial_2, int fr, bool first_zero_pressure, const char * S_E0_suffix)
{
	double x,y;
	char SX[32], SY[32], 
		S_epsilon[32], F_epsilon[32], 
		S_d_e[32], F_d_e[32], 
		S_e[32], F_e[32], 
		S_m0[32], F_m0[32], 
		S_E[32], F_E[32];

	bool pass_skipped_row = false;
	for (int ii = 0; ii < p_trial_2->n_pressures; ii++)
	{
		y = p_trial_2->absolute_deformations[ii].v;
		x = p_trial_2->pressures[ii];

		int i = ii;
		double xx;
		int skip_row = 0;
		if(!pass_skipped_row) 
		{                                
			sprintf(SX, "A%d", fr+i);
			ExcelRange_GetValue(m_excel, SX, xx);
			if (x != xx)
			{
				pass_skipped_row = true;
				skip_row = 1;
			}
		}
		if(pass_skipped_row) i++;


		sprintf(SY, "I%d", fr+i);
		sprintf(S_epsilon, "J%d", fr+i);
		sprintf(F_epsilon, "=I%d/H", fr+i);
		sprintf(S_d_e, "K%d", fr+i);
		sprintf(F_d_e, "=(1+E0%s)*J%d", S_E0_suffix, fr+i);
		sprintf(S_e, "L%d", fr+i);
		sprintf(F_e, "=E0%s-(1+E0%s)*J%d", S_E0_suffix, S_E0_suffix, fr+i);
		sprintf(S_m0, "M%d", fr+i);
		sprintf(F_m0, "=(L%d-L%d)/(A%d-A%d)", fr+i-1-skip_row, fr+i, fr+i, fr+i-1-skip_row);
		
		sprintf(S_E, "N%d", fr+i);
		sprintf(F_E, "=BETTA_W*(A%d-A%d)/(J%d-J%d)", fr+i, fr+i-1-skip_row, fr+i, fr+i-1-skip_row);


		ExcelRange_SetValue(m_excel, SY, COleVariant(y), true);									
		ExcelRange_SetValue(m_excel, S_epsilon, COleVariant(F_epsilon), true);							
		ExcelRange_SetValue(m_excel, S_d_e, COleVariant(F_d_e), true);							
		ExcelRange_SetValue(m_excel, S_e, COleVariant(F_e), true);		
		


		if (!first_zero_pressure || (i && first_zero_pressure))
		{
			ExcelRange_SetValue(m_excel, S_m0, COleVariant(F_m0), true);				
			ExcelRange_SetValue(m_excel, S_E, COleVariant(F_E), true);	
		}

	}


}
void Gurvich::Passport_Table1(MyExcel & m_excel, int fr, double & max_x, double & delta_x)
{
	max_x = -DBL_MAX;
	double x,y;
	char SX[32], SY[32];
	char S_dpdS[32], F_dpdS[64];
	char S_E[32], F_E[128];
	char S_Kp[32];
	char S_E_Kp[32], F_E_Kp[128];
	bool water = false;
	for (int i = 0; i < this->shtamp_vx.size(); i++)
	{
		y = this->shtamp_vy[i].v;
		x = this->shtamp_vx[i].x;

		if (i && x != this->shtamp_vx[i-1].x)
		{
			delta_x = x - this->shtamp_vx[i-1].x;
		}

		if (max_x < x)
			max_x = x;

		bool zamach = i && this->shtamp_vx[i].x == this->shtamp_vx[i-1].x;
		if (zamach)
			water = true;

		sprintf(SX, "A%d", fr+i);
		sprintf(SY, "B%d", fr+i);

		ExcelRange_SetValue(m_excel, SX, COleVariant(x), true);									
		ExcelRange_SetValue(m_excel, SY, COleVariant(y), true);	

		int skip_row = 0;
		
		sprintf(S_dpdS, "C%d", fr+i);
		sprintf(F_dpdS, "=(A%d-A%d)/(B%d-B%d)", fr+i, fr+i-1-skip_row, fr+i, fr+i-1-skip_row);
		ExcelRange_SetValue(m_excel, S_dpdS, COleVariant(F_dpdS), true);		

		sprintf(S_E, "D%d", fr+i);
		if (water)
			sprintf(F_E, "= 10. * (1.0 - PUASSON_W * PUASSON_W) * 0.79 * %f * %s", Gurvich::shtamp_diameter, S_dpdS);
		else
			sprintf(F_E, "= 10. * (1.0 - PUASSON * PUASSON) * 0.79 * %f * %s", Gurvich::shtamp_diameter, S_dpdS);
		ExcelRange_SetValue(m_excel, S_E, COleVariant(F_E), true);		

		sprintf(S_Kp, "E%d", fr);
		ExcelRange_SetValue(m_excel, S_Kp, COleVariant(Kp.v), true);		

		sprintf(S_E_Kp, "F%d", fr+i);
		sprintf(F_E_Kp, "= %s * %s", S_Kp, S_E);
		ExcelRange_SetValue(m_excel, S_E_Kp, COleVariant(F_E_Kp), true);		
	}
}

void Gurvich::Passport_Table2(MyExcel & m_excel, int fr)
{
	double x,y;
	char SX[32], SY[32];
	char S_dpdS[32], F_dpdS[64];
	char S_E[32], F_E[128];
	char S_Kp[32];
	char S_E_Kp[32], F_E_Kp[128];
	char S_Pr[32], F_Pr[128];
	for (int i = 0; i < this->shtamp_vx.size(); i++)
	{
		y = this->shtamp_vy[i].v;
		x = this->shtamp_vx[i].x;

		sprintf(SX, "A%d", fr+i);
		sprintf(SY, "G%d", fr+i);

		ExcelRange_SetValue(m_excel, SX, COleVariant(x), true);									
		ExcelRange_SetValue(m_excel, SY, COleVariant(y), true);		
		
		int skip_row = 0;
		
		sprintf(S_dpdS, "H%d", fr+i);
		sprintf(F_dpdS, "=(A%d-A%d)/(G%d-G%d)", fr+i, fr+i-1-skip_row, fr+i, fr+i-1-skip_row);
		ExcelRange_SetValue(m_excel, S_dpdS, COleVariant(F_dpdS), true);		

		sprintf(S_E, "I%d", fr+i);
		sprintf(F_E, "=10. * (1.0 - PUASSON_W * PUASSON_W) * 0.79 * %f * %s", Gurvich::shtamp_diameter, S_dpdS);
		ExcelRange_SetValue(m_excel, S_E, COleVariant(F_E), true);		

		sprintf(S_Kp, "J%d", fr);
		ExcelRange_SetValue(m_excel, S_Kp, COleVariant(Kp.v), true);		

		sprintf(S_E_Kp, "K%d", fr+i);
		sprintf(F_E_Kp, "= %s * %s", S_Kp, S_E);
		ExcelRange_SetValue(m_excel, S_E_Kp, COleVariant(F_E_Kp), true);

		sprintf(S_Pr, "L%d", fr+i);
		sprintf(F_Pr, "=G%d - B%d", fr+i, fr+i);
		ExcelRange_SetValue(m_excel, S_E_Kp, COleVariant(F_E_Kp), true);		
	}
}

void Passport_GurvichShtamp(MyExcel & m_excel, Gurvich * res, int & r, const char * desc)
{
	char str[1024]; 
	char SX[32], SY[32];
		

		char s1[1024];
		char s2[1024];
		char sE[1024];

		if (res->shtamp_deformation_module_in_01_02_interval.f)
		{
			sprintf(s1, "%f", res->shtamp_deformation_module_01_02_pressure_interval[0]);
			sprintf(s2, "%f", res->shtamp_deformation_module_01_02_pressure_interval[1]);
			sprintf(sE, "%f", res->shtamp_deformation_module_in_01_02_interval.v);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			DeleteEndZeros(sE);
			sprintf(str, "Модуль деформации (под штампом) %s[%s - %s], МПа\0", desc, s1, s2);

			Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
			ExcelRange_SetValue(m_excel, SX, COleVariant(str));
			ExcelRange_SetValue(m_excel, SY, COleVariant(sE));
			r++;
		}
		if (res->Sy_shtamp_lin_in_01_02_interval.f)
		{
			sprintf(sE, "%f", res->Sy_shtamp_lin_in_01_02_interval.v);
			DeleteEndZeros(sE);
			sprintf(str, "Ср.кв.откл.усадки(штамп).от лин.ф-ции %s[%s - %s], мм", desc, s1, s2);
		
			Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
			ExcelRange_SetValue(m_excel, SX, COleVariant(str));
			ExcelRange_SetValue(m_excel, SY, COleVariant(sE));
			r++;
		}
		if (res->shtamp_deformation_module_in_defined_interval.f)
		{
			sprintf(s1, "%f", res->shtamp_deformation_module_defined_pressure_interval[0]);
			sprintf(s2, "%f", res->shtamp_deformation_module_defined_pressure_interval[1]);
			sprintf(sE, "%f", res->shtamp_deformation_module_in_defined_interval.v);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			DeleteEndZeros(sE);
			sprintf(str, "Модуль деформации (под штампом) %s[%s - %s], МПа\0", desc, s1, s2);

			Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
			ExcelRange_SetValue(m_excel, SX, COleVariant(str));
			ExcelRange_SetValue(m_excel, SY, COleVariant(sE));
			r++;
		}
		if (res->Sy_shtamp_lin_in_defined_interval.f)
		{
			sprintf(sE, "%f", res->Sy_shtamp_lin_in_defined_interval.v);
			DeleteEndZeros(sE);
			sprintf(str, "Ср.кв.откл.усадки(штамп).от лин.ф-ции %s[%s - %s], мм", desc, s1, s2);

 			Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
			ExcelRange_SetValue(m_excel, SX, COleVariant(str));
			ExcelRange_SetValue(m_excel, SY, COleVariant(sE));
			r++;
		}
		if (res->Kp.f)
		{		
			sprintf(str, "Kp\0", res->Kp.v);
			DeleteEndZeros(str);

			Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
			ExcelRange_SetValue(m_excel, SX, COleVariant(str));
			ExcelRange_SetValue(m_excel, SY, COleVariant(res->Kp.v));
			r++;
		}
		if (res->shtamp_deformation_module_in_01_02_interval_Kp.f)
		{
			sprintf(s1, "%f", res->shtamp_deformation_module_01_02_pressure_interval[0]);
			sprintf(s2, "%f", res->shtamp_deformation_module_01_02_pressure_interval[1]);
			sprintf(sE, "%f", res->shtamp_deformation_module_in_01_02_interval_Kp.v);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			DeleteEndZeros(sE);
			sprintf(str, "Модуль деформации (под штампом) %s[%s - %s] * Kp, МПа\0", desc, s1, s2, sE);

			Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
			ExcelRange_SetValue(m_excel, SX, COleVariant(str));
			ExcelRange_SetValue(m_excel, SY, COleVariant(sE));
			r++;
		}
		if (res->shtamp_deformation_module_in_defined_interval_Kp.f)
		{

			sprintf(s1, "%f", res->shtamp_deformation_module_defined_pressure_interval[0]);
			sprintf(s2, "%f", res->shtamp_deformation_module_defined_pressure_interval[1]);
			sprintf(sE, "%f", res->shtamp_deformation_module_in_defined_interval_Kp.v);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);
			DeleteEndZeros(sE);
			sprintf(str, "Модуль деформации (под штампом) %s[%s - %s] * Kp, МПа\0", desc, s1, s2, sE);

 			Prepare_CompressionLabTrialResults3_Pasport_Row(m_excel, SX, SY, r);
			ExcelRange_SetValue(m_excel, SX, COleVariant(str));
			ExcelRange_SetValue(m_excel, SY, COleVariant(sE));
			r++;
		}


		//if (text) text->push_back(fmtstr(str, &res->shtamp_deformation_module_in_defined_interval_Kp.f, true, true));
}


void Passport_GurvichShtamp(MyExcel & m_excel, Gurvich * res, const char * suffix)	
{
	char S[64];
	//if (comp_result)
	{
	//	if(!comp_result->calculed)
	//		comp_result->CalcProperties();

		if (res->shtamp_deformation_module_01_02_pressure_interval[0])
		{
			sprintf(S, "Z_ES_L1%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(res->shtamp_deformation_module_01_02_pressure_interval[0]));
		}	

		if (res->shtamp_deformation_module_01_02_pressure_interval[1])
		{
			sprintf(S, "Z_ES_R1%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(res->shtamp_deformation_module_01_02_pressure_interval[1]));
		}	
	
		/*if (comp_result->a_in_01_02_interval.f)
		{
			sprintf(S, "Z_m01%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(comp_result->a_in_01_02_interval.v));
		}*/
	
		if (res->shtamp_deformation_module_in_01_02_interval.f)
		{
			sprintf(S, "Z_E1%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(res->shtamp_deformation_module_in_01_02_interval.v));
		}	

		if (res->shtamp_deformation_module_defined_pressure_interval[0])
		{
			sprintf(S, "Z_ES_L2%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(res->shtamp_deformation_module_defined_pressure_interval[0]));
		}	

		if (res->shtamp_deformation_module_defined_pressure_interval[1])
		{
			sprintf(S, "Z_ES_R2%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(res->shtamp_deformation_module_defined_pressure_interval[1]));
		}

		/*if (comp_result->a_in_defined_interval.f)
		{
			sprintf(S, "Z_m02%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(comp_result->a_in_defined_interval.v));
		}*/
	
		if (res->shtamp_deformation_module_in_defined_interval.f)
		{
			sprintf(S, "Z_E2%s", suffix);
			ExcelRange_SetValue(m_excel, S, COleVariant(res->shtamp_deformation_module_in_defined_interval.v));
		}
	}	
}

void Passport_Prosadochnost2(MyExcel & m_excel, CompressionLabTrialResults3 * comp_result3, int ftr, char col)
{
	char SY[32];
	double y;
	if (comp_result3)
	{
		for (size_t i = 0; i < comp_result3->x_prosadka_po_dvum_krivym.size(); i++)
		{
			sprintf(SY, "%c%d", col, ftr+i);
			y = comp_result3->otnosit_prosadochnost_po_dvum_krivym[i].v;
			ExcelRange_SetValue(m_excel, SY, COleVariant(y), true);	
		}
	}
}
void Passport_Prosadochnost1(MyExcel & m_excel, CompressionLabTrialResults3 * comp_result3, int ftr, char col)
{
	char SY[32];
	double y;
	if (comp_result3)
	{
		for (size_t i = 0; i < comp_result3->x_prosadka_po_odnoj_krivoj.size(); i++)
		{
			sprintf(SY, "%c%d", col, ftr+i);
			y = comp_result3->otnosit_prosadochnost_po_odnoj_krivoj[i].v;
			ExcelRange_SetValue(m_excel, SY, COleVariant(y), true);	
		}
	}
}
void Passport_Prosadochnost2_Gurvich(MyExcel & m_excel, CompressionLabTrialResults3 * comp_result3, int ftr, char col)
{
	char SY[32];
	double y;
	if (comp_result3)
	{
		for (size_t i = 0; i < comp_result3->x_gurvich_shtamp_prosadka_po_dvum_krivym.size(); i++)
		{
			sprintf(SY, "%c%d", col, ftr+i);
			y = comp_result3->gurvich_shtamp_otnosit_prosadochnost_po_dvum_krivym[i].v;
			ExcelRange_SetValue(m_excel, SY, COleVariant(y), true);	
		}
	}
}
void Passport_Prosadochnost1_Gurvich(MyExcel & m_excel, CompressionLabTrialResults3 * comp_result3, int ftr, char col)
{
	char SY[32];
	double y;
	if (comp_result3)
	{
		for (size_t i = 0; i < comp_result3->x_gurvich_shtamp_prosadka_po_odnoj_krivoj.size(); i++)
		{
			sprintf(SY, "%c%d", col, ftr+i);
			y = comp_result3->gurvich_shtamp_otnosit_prosadochnost_po_odnoj_krivoj[i].v;
			ExcelRange_SetValue(m_excel, SY, COleVariant(y), true);	
		}
	}
}
void CompressionLabTrial3::Passport_2_as_diff_vyprob(bool otnosit_def_on_graph, const char * fn)
{
	char file[4098];
	char file0[4098];

	if (otnosit_def_on_graph)
	{
		switch (BaseLab::PassportLanguage)
		{
		case BaseLab::language::russian:
			{
				sprintf(file, "%s_Pasport_Comp_2R2.xls", fn);
				sprintf(file0, "%s\\Pasport_Comp_2R2.xls", Laboratory::FormsDir.c_str());
			}
			break;
		case BaseLab::language::ukrainian:
			{
				sprintf(file, "%s_Pasport_Comp_22.xls", fn);
				sprintf(file0, "%s\\Pasport_Comp_22.xls", Laboratory::FormsDir.c_str());
			}
			break;
		}
	}
	else
	{
		switch (BaseLab::PassportLanguage)
		{
		case BaseLab::language::russian:
			{
				sprintf(file, "%s_Pasport_Comp2R2.xls", fn);
				sprintf(file0, "%s\\Pasport_Comp2R2.xls", Laboratory::FormsDir.c_str());
			}
			break;
		case BaseLab::language::ukrainian:
			{
				sprintf(file, "%s_Pasport_Comp22.xls", fn);
				sprintf(file0, "%s\\Pasport_Comp22.xls", Laboratory::FormsDir.c_str());
			}
			break;
		}
	}
	CopyFile(file0, file, FALSE);

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);

			Passport_LabNumber(m_excel, this->lab_number, "");
			Passport_LabNumber(m_excel, this->lab_number, "_2");

			trial_value e0_m;					
			trial_value e0_1;					
			trial_value e0_2;					

			if(this->p_trial_1 && this->p_trial_2)
			{
				PhysicalLabTrial * phys_trial_m = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));

				PhysicalLabTrial * phys_trial_1 = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, this->p_trial_1->id_phys_vyprob));
				if(!phys_trial_1)
					phys_trial_1 = phys_trial_m;
				
				PhysicalLabTrial * phys_trial_2 = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, this->p_trial_2->id_phys_vyprob));
				if(!phys_trial_2)
					phys_trial_2 = phys_trial_m;

				Passport_Phys(m_excel, phys_trial_1, e0_1, "", false);
				Passport_Phys(m_excel, phys_trial_2, e0_2, "_W", false);
				Passport_PhysMean(m_excel, phys_trial_1, phys_trial_2, "_M");

				ExcelRange_SetValue(m_excel, "D", COleVariant(this->p_trial_1->hoop_diameter));
				ExcelRange_SetValue(m_excel, "H", COleVariant(this->p_trial_1->hoop_height));

				ExcelRange_SetValue(m_excel, "D_2", COleVariant(this->p_trial_1->hoop_diameter));
				ExcelRange_SetValue(m_excel, "H_2", COleVariant(this->p_trial_1->hoop_height));


				// массив результатов опытов

				bool first_zero_pressure = false;
				if (this->p_trial_1->n_pressures && this->p_trial_1->pressures[0] == 0.0)
					first_zero_pressure = true;

				int ftr = 28;
				
				int fr = ftr+1;
				if (first_zero_pressure) fr = ftr;

				double max_x;
				double delta_x;
				Passport_Table1(m_excel, this->p_trial_1, fr, first_zero_pressure, "", max_x, delta_x);
				Passport_Table2(m_excel, this->p_trial_2, fr, first_zero_pressure, "_W");
	
				char S[64];
				sprintf(S, "A%d:P%d", ftr, ftr-1 + p_trial_1->n_pressures);
				ExcelRange_SetThinContinuousBorders(m_excel, S);

				CompressionLabTrialResults3 * comp_result3 = dynamic_cast<CompressionLabTrialResults3 *>(this->results);
				Passport_Prosadochnost2(m_excel, comp_result3, ftr, 'O');


				CompressionLabTrialResults * comp_result_1 = 
					dynamic_cast<CompressionLabTrialResults *>(this->p_trial_1->results);
				Passport_CompressionBetaPuasson(m_excel, comp_result_1);
				Passport_CompressionLabTrialResults(m_excel, comp_result_1, "");
				
				CompressionLabTrialResults * comp_result_2 = 
					dynamic_cast<CompressionLabTrialResults *>(this->p_trial_2->results);                
				Passport_CompressionLabTrialResults(m_excel, comp_result_2, "_W");

				bool use_table = false;				
				Passport_Graph(m_excel, comp_result3, this->p_trial_1, otnosit_def_on_graph, e0_1, use_table, ftr, fr, max_x, delta_x, 3, comp_result_1->m_gurvich, 84);

				bool gurvich_calculed = comp_result_1->m_gurvich.shtamp_vx.size() > 0;
				if (gurvich_calculed)
				{
					fr = 85;
					comp_result_1->m_gurvich.Passport_Table1(m_excel, fr, max_x, delta_x);
					comp_result_2->m_gurvich.Passport_Table2(m_excel, fr);
					Passport_Prosadochnost2_Gurvich(m_excel, comp_result3, fr, 'N');
					
					int r = 106;
					CompressionLabTrialResults3_ToPasport(comp_result3, m_excel, r);
					Passport_GurvichShtamp(m_excel, &comp_result_1->m_gurvich, r, "");
					Passport_GurvichShtamp(m_excel, &comp_result_2->m_gurvich, r, "(водонас.) ");
				}
				else
				{
					ExcelRange_Delete_xlUp(m_excel, "A80:P120");

					int r = 80;
					CompressionLabTrialResults3_ToPasport(comp_result3, m_excel, r);
				}
			}
			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
		printf("!!!!! m_excel.IsApplicationDispatch()\n");
}
void CompressionLabTrial3::Passport_2_as_mean(bool otnosit_def_on_graph, const char * fn)
{
	char file[4098];
	char file0[4098];

	if (otnosit_def_on_graph)
	{
		switch (BaseLab::PassportLanguage)
		{
		case BaseLab::language::russian:
			{
				sprintf(file, "%s_Pasport_Comp_2R2.xls", fn);
				sprintf(file0, "%s\\Pasport_Comp_2R2.xls", Laboratory::FormsDir.c_str());
			}
			break;
		case BaseLab::language::ukrainian:
			{
				sprintf(file, "%s_Pasport_Comp_22.xls", fn);
				sprintf(file0, "%s\\Pasport_Comp_22.xls", Laboratory::FormsDir.c_str());
			}
			break;
		}
	}
	else
	{
		switch (BaseLab::PassportLanguage)
		{
		case BaseLab::language::russian:
			{
				sprintf(file, "%s_Pasport_Comp2R2.xls", fn);
				sprintf(file0, "%s\\Pasport_Comp2R2.xls", Laboratory::FormsDir.c_str());
			}
			break;
		case BaseLab::language::ukrainian:
			{
				sprintf(file, "%s_Pasport_Comp22.xls", fn);
				sprintf(file0, "%s\\Pasport_Comp22.xls", Laboratory::FormsDir.c_str());
			}
			break;
		}
	}
	CopyFile(file0, file, FALSE);

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);

			Passport_LabNumber(m_excel, this->lab_number, "");
			Passport_LabNumber(m_excel, this->lab_number, "_2");

			trial_value e0_m;					
			trial_value e0_1;					
			trial_value e0_2;					

			if(this->p_trial_1 && this->p_trial_2)
			{
				PhysicalLabTrial * phys_trial_m = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));

				PhysicalLabTrial * phys_trial_1 = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, this->p_trial_1->id_phys_vyprob));
				if(!phys_trial_1)
					phys_trial_1 = phys_trial_m;
				
				PhysicalLabTrial * phys_trial_2 = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, this->p_trial_2->id_phys_vyprob));
				if(!phys_trial_2)
					phys_trial_2 = phys_trial_m;

				Passport_Phys(m_excel, phys_trial_1, e0_1, "", false);
				Passport_Phys(m_excel, phys_trial_2, e0_2, "_W", false);
				Passport_PhysMean(m_excel, phys_trial_1, phys_trial_2, "_M");

				ExcelRange_SetValue(m_excel, "D", COleVariant(this->p_trial_1->hoop_diameter));
				ExcelRange_SetValue(m_excel, "H", COleVariant(this->p_trial_1->hoop_height));

				ExcelRange_SetValue(m_excel, "D_2", COleVariant(this->p_trial_1->hoop_diameter));
				ExcelRange_SetValue(m_excel, "H_2", COleVariant(this->p_trial_1->hoop_height));


				// массив результатов опытов

				bool first_zero_pressure = false;
				if (this->p_trial_1->n_pressures && this->p_trial_1->pressures[0] == 0.0)
					first_zero_pressure = true;

				int ftr = 28;
				
				int fr = ftr+1;
				if (first_zero_pressure) fr = ftr;

				double max_x;
				double delta_x;
				Passport_Table1(m_excel, this->p_trial_1, fr, first_zero_pressure, "_M", max_x, delta_x);
				Passport_Table2(m_excel, this->p_trial_2, fr, first_zero_pressure, "_M");

				char S[64];
				sprintf(S, "A%d:P%d", ftr, ftr-1 + p_trial_1->n_pressures);
				ExcelRange_SetThinContinuousBorders(m_excel, S);
	
				CompressionLabTrialResults3 * comp_result3 = dynamic_cast<CompressionLabTrialResults3 *>(this->results);
				Passport_Prosadochnost2(m_excel, comp_result3, ftr, 'O');


				CompressionLabTrialResults * comp_result_1 = 
					dynamic_cast<CompressionLabTrialResults *>(this->p_trial_1->results);
				Passport_CompressionBetaPuasson(m_excel, comp_result_1);
				Passport_CompressionLabTrialResults(m_excel, comp_result_1, "");
				
				CompressionLabTrialResults * comp_result_2 = 
					dynamic_cast<CompressionLabTrialResults *>(this->p_trial_2->results);                
				Passport_CompressionLabTrialResults(m_excel, comp_result_2, "_W");	
				
				bool use_table = true;				
				Passport_Graph(m_excel, comp_result3, this->p_trial_1, otnosit_def_on_graph, e0_1, use_table, ftr, fr, max_x, delta_x, 3, comp_result_1->m_gurvich, 84);
				
				bool gurvich_calculed = comp_result_1->m_gurvich.shtamp_vx.size() > 0;
				if (gurvich_calculed)
				{
					fr = 85;
					comp_result_1->m_gurvich.Passport_Table1(m_excel, fr, max_x, delta_x);
					comp_result_2->m_gurvich.Passport_Table2(m_excel, fr);
					Passport_Prosadochnost2_Gurvich(m_excel, comp_result3, fr, 'N');
					
					int r = 106;
					CompressionLabTrialResults3_ToPasport(comp_result3, m_excel, r);
					Passport_GurvichShtamp(m_excel, &comp_result_1->m_gurvich, r, "");
					Passport_GurvichShtamp(m_excel, &comp_result_2->m_gurvich, r, "(водонас.) ");
				}
				else
				{
					ExcelRange_Delete_xlUp(m_excel, "A80:P120");
					int r = 80;
					CompressionLabTrialResults3_ToPasport(comp_result3, m_excel, r);
				}
			}
			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
		printf("!!!!! m_excel.IsApplicationDispatch()\n");
}
void CompressionLabTrial3::Passport_1_new(bool otnosit_def_on_graph, const char * fn, bool ws)
{
	char file0[4098];
	char file[4098];

	if (otnosit_def_on_graph)
	{
		switch (BaseLab::PassportLanguage)
		{
		case BaseLab::language::russian:
			{
				sprintf(file, "%s_Pasport_Comp_%dR2.xls", fn, ws?4:1);
				sprintf(file0, "%s\\Pasport_Comp_1R2.xls", Laboratory::FormsDir.c_str());
			}
			break;
		case BaseLab::language::ukrainian:
			{
				sprintf(file, "%s_Pasport_Comp_%d2.xls", fn, ws?4:1);
				sprintf(file0, "%s\\Pasport_Comp_12.xls", Laboratory::FormsDir.c_str());
			}
			break;
		}
	}
	else
	{
		switch (BaseLab::PassportLanguage)
		{
		case BaseLab::language::russian:
			{
				sprintf(file, "%s_Pasport_Comp%dR2.xls", fn, ws?4:1);
				sprintf(file0, "%s\\Pasport_Comp1R2.xls", Laboratory::FormsDir.c_str());
			}
			break;
		case BaseLab::language::ukrainian:
			{
				sprintf(file, "%s_Pasport_Comp%d2.xls", fn, ws?4:1);
				sprintf(file0, "%s\\Pasport_Comp12.xls", Laboratory::FormsDir.c_str());
			}
			break;
		}
	}
	CopyFile(file0, file, FALSE);


	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);
			Passport_LabNumber(m_excel, this->lab_number, "");
			Passport_LabNumber(m_excel, this->lab_number, "_2");

			//trial_value e0_m;					
			trial_value e0_1;					
			//trial_value e0_2;					
					
			CompressionLabTrial * p_trial = ws ? this->p_trial_2 : this->p_trial_1;

			if(p_trial)
			{
				PhysicalLabTrial * phys_trial_m = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));

				PhysicalLabTrial * phys_trial = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, p_trial->id_phys_vyprob));
				if(!phys_trial)
					phys_trial = phys_trial_m;	
	

				Passport_Phys(m_excel, phys_trial, e0_1, "", false);
				//Passport_Phys(m_excel, phys_trial_2, e0_2, "_W");
				//Passport_PhysMean(m_excel, phys_trial_1, phys_trial_2, "_M");

				ExcelRange_SetValue(m_excel, "D", COleVariant(p_trial->hoop_diameter));
				ExcelRange_SetValue(m_excel, "H", COleVariant(p_trial->hoop_height));

				ExcelRange_SetValue(m_excel, "D_2", COleVariant(p_trial->hoop_diameter));
				ExcelRange_SetValue(m_excel, "H_2", COleVariant(p_trial->hoop_height));


				// массив результатов опытов
				bool first_zero_pressure = false;
				if (p_trial->n_pressures && p_trial->pressures[0] == 0.0)
					first_zero_pressure = true;

				int ftr = 28;
				char S[64];
				sprintf(S, "E%d", ftr);
				ExcelRange_SetValue(m_excel, S, COleVariant(e0_1.v));
				
				int fr = ftr+1;
				if (first_zero_pressure) fr = ftr;

				double max_x;
				double delta_x;
				Passport_Table1(m_excel, p_trial, fr, first_zero_pressure, "", max_x, delta_x);

				sprintf(S, "A%d:I%d", ftr, ftr-1 + p_trial->n_pressures);
				ExcelRange_SetThinContinuousBorders(m_excel, S);
	
				CompressionLabTrialResults3 * comp_result3 = dynamic_cast<CompressionLabTrialResults3 *>(this->results);
				Passport_Prosadochnost1(m_excel, comp_result3, ftr, 'H');


				CompressionLabTrialResults * comp_result = 
					dynamic_cast<CompressionLabTrialResults *>(p_trial->results);
				Passport_CompressionBetaPuasson(m_excel, comp_result);
				Passport_CompressionLabTrialResults(m_excel, comp_result, "");

				
				bool use_table = true;				
				Passport_Graph(m_excel, comp_result3, p_trial, otnosit_def_on_graph, e0_1, use_table, ftr, fr, max_x, delta_x, 2, comp_result->m_gurvich, 84);
				
				bool gurvich_calculed = comp_result->m_gurvich.shtamp_vx.size() > 0;
				if (gurvich_calculed)
				{
					fr = 85;
					comp_result->m_gurvich.Passport_Table1(m_excel, fr, max_x, delta_x);
					Passport_Prosadochnost1_Gurvich(m_excel, comp_result3, fr, 'G');
					
					int r = 106;
					CompressionLabTrialResults3_ToPasport(comp_result3, m_excel, r);
					Passport_GurvichShtamp(m_excel, &comp_result->m_gurvich, r, "");
				}
				else
				{
					ExcelRange_Delete_xlUp(m_excel, "A80:P120");

					int r = 80;
					CompressionLabTrialResults3_ToPasport(comp_result3, m_excel, r);
				}

				//Passport_GurvichShtamp(m_excel, &comp_result->m_gurvich, "_G");

			}
			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
		printf("!!!!! m_excel.IsApplicationDispatch()\n");
}
void CompressionLabTrial3::Passport_3(const char * fn)
{
	char file0[4098];
	char file[4098];

	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			sprintf(file, "%s_Pasport_Comp3R.xls", fn);
			sprintf(file0, "%s\\Pasport_Comp3R.xls", Laboratory::FormsDir.c_str());
		}
		break;
	case BaseLab::language::ukrainian:
		{
			sprintf(file, "%s_Pasport_Comp3.xls", fn);
			sprintf(file0, "%s\\Pasport_Comp3.xls", Laboratory::FormsDir.c_str());
		}
		break;
	}
	CopyFile(file0, file, FALSE);


	LPDISPATCH pRange; 
	Range10    m_range;

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);

			if (this->lab_number)
			{
				char str[1024];

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(this->lab_number->depth));
				m_range.ReleaseDispatch();	

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("KT")));
				m_range.AttachDispatch(pRange);
				sprintf(str, "%s\0", this->lab_number->mine_working_number.c_str());
				if ISNUM(str)
				{
					switch(this->lab_number->m_mine_working_type)
					{
					case LabNumber::mine_working_type::hole:
						{
							sprintf(str, "Шурф № %s", this->lab_number->mine_working_number.c_str());
						}
						break;
					case LabNumber::mine_working_type::well:
						{
							// номер выработки
							sprintf(str, "Скв. № %s", this->lab_number->mine_working_number.c_str());
						}
						break;
					}
				}
				m_range.SetValue(COleVariant(str));
				m_range.ReleaseDispatch();	

				/*VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("H9")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(_GetKodProbyGrunta(this->lab_number->id_kodprob)));
				m_range.ReleaseDispatch();	*/

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("GRUNT")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(this->lab_number->GetSoilDescription(this->lab_number->get_soil_description_from_db).c_str()));
				m_range.ReleaseDispatch();	

				LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
				if (lablayer)
				{
					Laboratory * lab = (Laboratory *)lablayer->GetLaboratory();

					if (lab)
					{
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("CONTRACT")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(lab->contract.c_str()));
						m_range.ReleaseDispatch();


						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("OBJECT")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(lab->object_name.c_str()));
						m_range.ReleaseDispatch();	
					}

					
					if(this->p_trial_1)
					{
						PhysicalLabTrial * phys_trial = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, this->p_trial_1->id_phys_vyprob));
						if (!phys_trial)
							phys_trial = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
						if (phys_trial)
						{


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("W")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial->moisture_of_nature_large_exchange.v));
							m_range.ReleaseDispatch();	


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("WL")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial->moisture_on_fluidity_border.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("WP")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial->moisture_on_plasticity_border.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("RO")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial->density_of_ground.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("ROS")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(phys_trial->density_of_ground_particles.v));
							m_range.ReleaseDispatch();	

							/*PhysicalLabTrialResults * phys_result = dynamic_cast<PhysicalLabTrialResults *>(phys_trial->results);
							if (phys_result)
							{
								if (!phys_result->calculed)
									phys_result->CalcProperties();

								;

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("E0")));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(phys_result->e.v));
								m_range.ReleaseDispatch();	

							}*/

						}


						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("D")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(this->p_trial_1->hoop_diameter));
						m_range.ReleaseDispatch();									


						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("H")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(this->p_trial_1->hoop_height));
						m_range.ReleaseDispatch();	

						double x,y;
						char SX[32], SY[32], 
							S_epsilon[32], F_epsilon[32], 
							S_d_e[32], F_d_e[32], 
							S_e[32], F_e[32], 
							S_m0[32], F_m0[32], 
							S_E[32], F_E[32];

						bool first_zero_pressure = this->p_trial_1->n_pressures && this->p_trial_1->pressures[0] == 0.0;
						int fr = first_zero_pressure ? 22 : 23;

						// массив результатов опытов
						double max_x = -DBL_MAX;
						bool water = false;
						bool zamach = false;
						for (int i = 0; i < this->p_trial_1->n_pressures; i++)
						{
							y = this->p_trial_1->absolute_deformations[i].v;
							x = this->p_trial_1->pressures[i];

							if (i && this->p_trial_1->pressures[i-1] == this->p_trial_1->pressures[i])
							{
								water = true;
								zamach = true;
							}
							else
							{
								zamach = false;
							}

							if (max_x < x)
								max_x = x;

							if (!water)
							{
								fr = first_zero_pressure ? 22 : 23;

								sprintf(SX, "A%d", fr+i);
								sprintf(SY, "B%d", fr+i);
								sprintf(S_epsilon, "C%d", fr+i);
								sprintf(F_epsilon, "=B%d/H", fr+i);
								sprintf(S_d_e, "D%d", fr+i);
								sprintf(F_d_e, "=(1+E0)*C%d", fr+i);
								sprintf(S_e, "E%d", fr+i);
								sprintf(F_e, "=E0-(1+E0)*C%d", fr+i);
								sprintf(S_m0, "F%d", fr+i);
								sprintf(F_m0, "=(E%d-E%d)/(A%d-A%d)", fr+i-1, fr+i, fr+i, fr+i-1);							
								sprintf(S_E, "G%d", fr+i);
								sprintf(F_E, "=BETTA*(A%d-A%d)/(C%d-C%d)", fr+i, fr+i-1, fr+i, fr+i-1);
							}
							else
							{
								fr = first_zero_pressure ? 21 : 22;
	
								sprintf(SX, "A%d", fr+i);
								sprintf(SY, "H%d", fr+i);
								sprintf(S_epsilon, "I%d", fr+i);
								sprintf(F_epsilon, "=H%d/H", fr+i);
								sprintf(S_d_e, "J%d", fr+i);
								sprintf(F_d_e, "=(1+E0)*I%d", fr+i);
								sprintf(S_e, "K%d", fr+i);
								sprintf(F_e, "=E0-(1+E0)*I%d", fr+i);
								sprintf(S_m0, "L%d", fr+i);
								sprintf(F_m0, "=(K%d-K%d)/(A%d-A%d)", fr+i-1, fr+i, fr+i, fr+i-1);							
								sprintf(S_E, "M%d", fr+i);
								sprintf(F_E, "=BETTA_W*(A%d-A%d)/(I%d-I%d)", fr+i, fr+i-1, fr+i, fr+i-1);
							}


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(x));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();									
							
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
							m_range.AttachDispatch(pRange);			   
							if (y) m_range.SetValue(COleVariant(y));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_epsilon)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(F_epsilon));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_d_e)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(F_d_e));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_e)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(F_e));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							if(!zamach)
							{
								if (!first_zero_pressure || (i && first_zero_pressure))
								{
									VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_m0)));
									m_range.AttachDispatch(pRange);			   
									m_range.SetValue(COleVariant(F_m0));
									m_range.BorderAround(COleVariant(long(1)), 2, -4105);
									m_range.ReleaseDispatch();	

									VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_E)));
									m_range.AttachDispatch(pRange);			   
									m_range.SetValue(COleVariant(F_E));
									m_range.BorderAround(COleVariant(long(1)), 2, -4105);
									m_range.ReleaseDispatch();
								}
							}
							else
							{
								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("C44")));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(x));
								m_range.ReleaseDispatch();

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("C45")));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(x));
								m_range.ReleaseDispatch();

								sprintf(SY, "=E%d", fr+i);

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("D44")));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(SY));
								m_range.ReleaseDispatch();

								sprintf(SY, "=K%d", fr+i);

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("D45")));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(SY));
								m_range.ReleaseDispatch();

							}
						}
		
						CompressionLabTrialResults3 * comp_result3 = dynamic_cast<CompressionLabTrialResults3 *>(this->results);
						if (comp_result3)
						{
							//for (size_t i = 0; i < comp_result3->x_prosadka_po_odnoj_krivoj.size(); i++)
							size_t i = comp_result3->x_prosadka_po_odnoj_krivoj.size() - 1;
							{
								sprintf(SY, "N%d", 22+i);
								y = comp_result3->otnosit_prosadochnost_po_odnoj_krivoj[i].v;

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
								m_range.AttachDispatch(pRange);			   
								if (y) m_range.SetValue(COleVariant(y));
								m_range.BorderAround(COleVariant(long(1)), 2, -4105);
								m_range.ReleaseDispatch();	
							}
						}



						fr = 22;
						int ni = first_zero_pressure ? this->p_trial_1->n_pressures - 1 : this->p_trial_1->n_pressures;

						for (int i = 1; i < ni; i++)
						{
							for (char ch = 'A'; ch <= 'N'; ch++)
							{
								sprintf(SX, "%c%d", ch, fr+i);	
								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
								m_range.AttachDispatch(pRange);			   
								m_range.BorderAround(COleVariant(long(1)), 2, -4105);
								m_range.ReleaseDispatch();	
							}
						}

						CompressionLabTrialResults * comp_result = dynamic_cast<CompressionLabTrialResults *>(this->p_trial_1->results);
						
						if (comp_result)
						{
							if(!comp_result->calculed)
								comp_result->CalcProperties();

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("BETTA")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->beta_tab.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("BETTA_W")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->beta_tab_ws.v));
							m_range.ReleaseDispatch();	


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("PUASSON")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->nju_tab.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("PUASSON_W")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->nju_tab_ws.v));
							m_range.ReleaseDispatch();	



							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_ES_L1")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->def_module_01_02_pressure_interval[0]));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_ES_R1")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->def_module_01_02_pressure_interval[1]));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_m01")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->a_in_01_02_interval.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_E1")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->deformation_module_e_in_01_02_interval.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_ES_L2")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->def_module_defined_pressure_interval[0]));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_ES_R2")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->def_module_defined_pressure_interval[1]));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_m02")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->a_in_defined_interval.v));
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_E2")));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(comp_result->deformation_module_e_in_defined_interval.v));
							m_range.ReleaseDispatch();	
						}

						if (true)			
						{							
							LPDISPATCH pShapes; 
							Shapes10    m_shapes;
								
							VERIFY(pShapes = m_excel.m_worksheet.GetShapes());				
							m_shapes.AttachDispatch(pShapes);	

							long shapes_count = m_shapes.GetCount();
							printf("shapes_count = %d\n", shapes_count);

							//for (long ish = 1; ish <= shapes_count; ish++)
							for (long ish = 1; ish <= 1; ish++)
							{
								LPDISPATCH pShape; 
								Shape10    m_shape;

								VERIFY(pShape = m_shapes.Item(COleVariant(long(ish))));				
								m_shape.AttachDispatch(pShape);	

								CString shape_name = m_shape.GetName();
								printf("%s\n", (LPCTSTR)shape_name);

								LPDISPATCH pChartObject; 
								ChartObject10    m_chart_object;

								VERIFY(pChartObject = m_excel.m_worksheet.ChartObjects(COleVariant(shape_name)));				
								m_chart_object.AttachDispatch(pChartObject);

								LPDISPATCH pChart;
								_Chart10    m_chart;

								VERIFY(pChart = m_chart_object.GetChart());
								m_chart.AttachDispatch(pChart);             


								char sdataX[64];
								sprintf(sdataX, "=Лист1!R22C1:R%dC1", 22 + this->p_trial_1->n_pressures-1-first_zero_pressure);
								char sdataY[64];
								for (long isc = 1; isc <= 3; isc++)
								{
									switch (isc)
									{
									case 1:
										{
											sprintf(sdataY, "=Лист1!R22C5:R%dC5", 22+this->p_trial_1->n_pressures-1-first_zero_pressure);
										}
										break;
									case 2:
										{
											sprintf(sdataY, "=Лист1!R22C11:R%dC11", 22+this->p_trial_1->n_pressures-1-first_zero_pressure);
										}
										break;
									case 3:
										{
											sprintf(sdataX, "=Лист1!R44C3:R45C3");
											sprintf(sdataY, "=Лист1!R44C4:R45C4");
										}
										break;
									}

									LPDISPATCH pSeries;
									Series10    m_series;
									VERIFY(pSeries = m_chart.SeriesCollection(COleVariant(long(isc))));
									m_series.AttachDispatch(pSeries);
									m_series.SetValues(COleVariant(sdataY));
									m_series.SetXValues(COleVariant(sdataX));
									m_series.ReleaseDispatch();
								}
#if 0

								/*LPDISPATCH pAxes;
								VERIFY(pAxes = m_chart.Axes(COleVariant(long (1)), 1));//axis X - [AxisGroup As XlAxisGroup = xlPrimary];
								Axis10    m_axis;
								m_axis.AttachDispatch(pAxes);
								m_axis.SetMinimumScale(0.0);
								m_axis.SetMaximumScale(max_x);
								m_axis.ReleaseDispatch();*/		

								sprintf(sdataY, "K%d", 21+this->p_trial_1->n_pressures);

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(sdataY)));
								m_range.AttachDispatch(pRange);			   
								VARIANT mine = m_range.GetValue();
								m_range.ReleaseDispatch();	


								double min_e = 0.0;
								if (mine.vt == VT_R8)
								{
									min_e = mine.dblVal;
								}
								else if (mine.vt == (VT_R8 | VT_BYREF))
								{
									min_e = *mine.pdblVal;
								}

								min_e = double (0.0001 * int(10000 * min_e) );	

								
								LPDISPATCH pAxes;
								VERIFY(pAxes = m_chart.Axes(COleVariant(long (2)), 1));//axis Y - [AxisGroup As XlAxisGroup = xlPrimary];
								Axis10    m_axis;
								m_axis.AttachDispatch(pAxes);
								m_axis.SetMinimumScale(min_e);
								m_axis.ReleaseDispatch();
#endif
								m_chart.ReleaseDispatch();
								m_chart_object.ReleaseDispatch();				
								m_shape.ReleaseDispatch();

							}

							m_shapes.ReleaseDispatch();				
						}	
					}
					if(this->p_trial_1)
					{

						/*VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("D")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(this->p_trial_1->hoop_diameter));
						m_range.ReleaseDispatch();									


						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("H")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(this->p_trial_1->hoop_height));
						m_range.ReleaseDispatch();	*/

						double x,y;
						char SX[32], SY[32], 
							S_epsilon[32], F_epsilon[32], 
							S_d_e[32], F_d_e[32], 
							S_e[32], F_e[32], 
							S_m0[32], F_m0[32], 
							S_E[32], F_E[32];

						bool first_zero_pressure = this->p_trial_1->n_pressures && this->p_trial_1->pressures[0] == 0.0;
						// массив результатов опытов
						double max_x = -DBL_MAX;
						int fr;
						bool water = false;
						bool zamach = false;
						for (int i = 0; i < this->p_trial_1->n_pressures; i++)
						{
							y = this->p_trial_1->absolute_deformations[i].v;
							x = this->p_trial_1->pressures[i];

							if (i && this->p_trial_1->pressures[i-1] == this->p_trial_1->pressures[i])
							{
								water = true;
								zamach = true;
							}
							else
							{
								zamach = false;
							}

							if (max_x < x)
								max_x = x;

							if (!water)
							{
								fr = 59;
								fr = first_zero_pressure ? 58 : 59;

								sprintf(SX, "A%d", fr+i);
								sprintf(SY, "B%d", fr+i);
								sprintf(S_epsilon, "C%d", fr+i);
								sprintf(F_epsilon, "=B%d/H", fr+i);
								sprintf(S_d_e, "D%d", fr+i);
								sprintf(F_d_e, "=(1+E0)*C%d", fr+i);
								sprintf(S_e, "E%d", fr+i);
								sprintf(F_e, "=E0-(1+E0)*C%d", fr+i);
								sprintf(S_m0, "F%d", fr+i);
								sprintf(F_m0, "=(E%d-E%d)/(A%d-A%d)", fr+i-1, fr+i, fr+i, fr+i-1);							
								sprintf(S_E, "G%d", fr+i);
								sprintf(F_E, "=BETTA*(A%d-A%d)/(C%d-C%d)", fr+i, fr+i-1, fr+i, fr+i-1);
							}
							else
							{
								fr = 58;
								fr = first_zero_pressure ? 57 : 58;
	
								sprintf(SX, "A%d", fr+i);
								sprintf(SY, "H%d", fr+i);
								sprintf(S_epsilon, "I%d", fr+i);
								sprintf(F_epsilon, "=H%d/H", fr+i);
								sprintf(S_d_e, "J%d", fr+i);
								sprintf(F_d_e, "=(1+E0)*I%d", fr+i);
								sprintf(S_e, "K%d", fr+i);
								sprintf(F_e, "=E0-(1+E0)*I%d", fr+i);
								sprintf(S_m0, "L%d", fr+i);
								sprintf(F_m0, "=(K%d-K%d)/(A%d-A%d)", fr+i-1, fr+i, fr+i, fr+i-1);							
								sprintf(S_E, "M%d", fr+i);
								sprintf(F_E, "=BETTA_W*(A%d-A%d)/(I%d-I%d)", fr+i, fr+i-1, fr+i, fr+i-1);
							}


							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(x));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();									
							
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
							m_range.AttachDispatch(pRange);			   
							if (y) m_range.SetValue(COleVariant(y));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_epsilon)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(F_epsilon));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_d_e)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(F_d_e));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_e)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant(F_e));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							if(!zamach)
							{
								if (!first_zero_pressure || (i && first_zero_pressure))
								{
									VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_m0)));
									m_range.AttachDispatch(pRange);			   
									m_range.SetValue(COleVariant(F_m0));
									m_range.BorderAround(COleVariant(long(1)), 2, -4105);
									m_range.ReleaseDispatch();	

									VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(S_E)));
									m_range.AttachDispatch(pRange);			   
									m_range.SetValue(COleVariant(F_E));
									m_range.BorderAround(COleVariant(long(1)), 2, -4105);
									m_range.ReleaseDispatch();
								}
							}
							else
							{
								/*VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("C44")));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(x));
								m_range.ReleaseDispatch();

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("C45")));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(x));
								m_range.ReleaseDispatch();

								sprintf(SY, "=E%d", fr+i);

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("D44")));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(SY));
								m_range.ReleaseDispatch();

								sprintf(SY, "=K%d", fr+i);

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("D45")));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(SY));
								m_range.ReleaseDispatch();*/

							}
						}
		
						CompressionLabTrialResults3 * comp_result3 = dynamic_cast<CompressionLabTrialResults3 *>(this->results);
						if (comp_result3)
						{
							for (size_t i = 0; i < comp_result3->x_prosadka_po_odnoj_krivoj.size(); i++)
							{
								sprintf(SY, "N%d", 58+i);
								y = comp_result3->otnosit_prosadochnost_po_odnoj_krivoj[i].v;

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
								m_range.AttachDispatch(pRange);			   
								m_range.SetValue(COleVariant(y));
								m_range.BorderAround(COleVariant(long(1)), 2, -4105);
								m_range.ReleaseDispatch();	
							}
						}



						fr = 58;
						int ni = first_zero_pressure ? this->p_trial_1->n_pressures - 1 : this->p_trial_1->n_pressures;

						for (int i = 1; i < ni; i++)
						{
							for (char ch = 'A'; ch <= 'N'; ch++)
							{
								sprintf(SX, "%c%d", ch, fr+i);	
								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
								m_range.AttachDispatch(pRange);			   
								m_range.BorderAround(COleVariant(long(1)), 2, -4105);
								m_range.ReleaseDispatch();	
							}
						}

						if (true)			
						{							
							LPDISPATCH pShapes; 
							Shapes10    m_shapes;
								
							VERIFY(pShapes = m_excel.m_worksheet.GetShapes());				
							m_shapes.AttachDispatch(pShapes);	

							long shapes_count = m_shapes.GetCount();
							printf("shapes_count = %d\n", shapes_count);

							for (long ish = 2; ish <= 2; ish++)
							{
								LPDISPATCH pShape; 
								Shape10    m_shape;

								VERIFY(pShape = m_shapes.Item(COleVariant(long(ish))));				
								m_shape.AttachDispatch(pShape);	

								CString shape_name = m_shape.GetName();
								printf("%s\n", (LPCTSTR)shape_name);

								LPDISPATCH pChartObject; 
								ChartObject10    m_chart_object;

								VERIFY(pChartObject = m_excel.m_worksheet.ChartObjects(COleVariant(shape_name)));				
								m_chart_object.AttachDispatch(pChartObject);

								LPDISPATCH pChart;
								_Chart10    m_chart;

								VERIFY(pChart = m_chart_object.GetChart());
								m_chart.AttachDispatch(pChart);             


								char sdataX[64];
								sprintf(sdataX, "=Лист1!R58C1:R%dC1", 57 + this->p_trial_1->n_pressures-first_zero_pressure);
								char sdataY[64];
								for (long isc = 1; isc <= 3; isc++)
								{
									switch (isc)
									{
									case 1:
										{
											sprintf(sdataY, "=Лист1!R58C5:R%dC5", 57+this->p_trial_1->n_pressures-first_zero_pressure);
										}
										break;
									case 2:
										{
											sprintf(sdataY, "=Лист1!R58C11:R%dC11", 57+this->p_trial_1->n_pressures-first_zero_pressure);
										}
										break;
									case 3:
										{
											sprintf(sdataY, "=Лист1!R58C14:R%dC14", 57+this->p_trial_1->n_pressures-first_zero_pressure);
										}
										break;
									}

									LPDISPATCH pSeries;
									Series10    m_series;
									VERIFY(pSeries = m_chart.SeriesCollection(COleVariant(long(isc))));
									m_series.AttachDispatch(pSeries);
									m_series.SetValues(COleVariant(sdataY));
									m_series.SetXValues(COleVariant(sdataX));
									m_series.ReleaseDispatch();
								}
#if 1
								/*LPDISPATCH pAxes;
								VERIFY(pAxes = m_chart.Axes(COleVariant(long (1)), 1));//axis X - [AxisGroup As XlAxisGroup = xlPrimary];
								Axis10    m_axis;
								m_axis.AttachDispatch(pAxes);
								m_axis.SetMinimumScale(0.0);
								m_axis.SetMaximumScale(max_x);
								m_axis.ReleaseDispatch();*/		

								sprintf(sdataY, "K%d", 21+this->p_trial_1->n_pressures-first_zero_pressure);

								VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(sdataY)));
								m_range.AttachDispatch(pRange);			   
								VARIANT mine = m_range.GetValue();
								m_range.ReleaseDispatch();	


								double min_e = 0.0;
								if (mine.vt == VT_R8)
								{
									min_e = mine.dblVal;
								}
								else if (mine.vt == (VT_R8 | VT_BYREF))
								{
									min_e = *mine.pdblVal;
								}

								min_e = double (0.01 * int(100 * min_e) );	

								
								LPDISPATCH pAxes;
								VERIFY(pAxes = m_chart.Axes(COleVariant(long (2)), 1));//axis Y - [AxisGroup As XlAxisGroup = xlPrimary];
								Axis10    m_axis;
								m_axis.AttachDispatch(pAxes);
								m_axis.SetMinimumScale(min_e);
								m_axis.ReleaseDispatch();
#endif
								m_chart.ReleaseDispatch();
								m_chart_object.ReleaseDispatch();				
								m_shape.ReleaseDispatch();

							}

							m_shapes.ReleaseDispatch();				
						}	
					}
				}			



				CompressionLabTrialResults3 * comp_result_3 = dynamic_cast<CompressionLabTrialResults3 *>(this->results);
				int r = 99;
				CompressionLabTrialResults3_ToPasport(comp_result_3, m_excel, r);
			}

			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
		printf("!!!!! m_excel.IsApplicationDispatch()\n");
}

void CutLabTrial::Passport(const char * fn)
{
	switch(this->cut_passport_type)
	{
	case 0:
		{
			this->Passport_0(fn);
		}
		break;
	case 1:
		{
			this->Passport_1(fn);
		}
		break;
	}
}
void CutLabTrial::Passport_0(const char * fn)
{
	char file[4098];
	char file0[4098];

	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			sprintf(file, "%s_Pasport_ZrizR.xls", fn);
			sprintf(file0, "%s\\Pasport_ZrizR.xls", Laboratory::FormsDir.c_str());
		}
		break;
	case BaseLab::language::ukrainian:
		{
			sprintf(file, "%s_Pasport_Zriz.xls", fn);
			sprintf(file0, "%s\\Pasport_Zriz.xls", Laboratory::FormsDir.c_str());
		}
		break;
	}
	CopyFile(file0, file, FALSE);
 
	LPDISPATCH pRange; 
	Range10    m_range;

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);

			if (this->lab_number)
			{
				char str[1024];

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(this->lab_number->depth));
				m_range.ReleaseDispatch();	

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("KT")));
				m_range.AttachDispatch(pRange);
				sprintf(str, "%s\0", this->lab_number->mine_working_number.c_str());
				if ISNUM(str)
				{
					switch(this->lab_number->m_mine_working_type)
					{
					case LabNumber::mine_working_type::hole:
						{
							sprintf(str, "Шурф № %s", this->lab_number->mine_working_number.c_str());
						}
						break;
					case LabNumber::mine_working_type::well:
						{
							// номер выработки
							sprintf(str, "Скв. № %s", this->lab_number->mine_working_number.c_str());
						}
						break;
					}
				}
				m_range.SetValue(COleVariant(str));
				m_range.ReleaseDispatch();	

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("KODPROBGR")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(_GetKodProbyGrunta(this->lab_number->id_kodprob)));
				m_range.ReleaseDispatch();	

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("GRUNT")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(this->lab_number->GetSoilDescription(this->lab_number->get_soil_description_from_db).c_str()));
				m_range.ReleaseDispatch();	
				LabLayer * lablayer = (LabLayer *) this->lab_number->GetLabLayer();
				if (lablayer)
				{
					Laboratory * lab = (Laboratory *)lablayer->GetLaboratory();
					if (lab)
					{
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("CONTRACT")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(lab->contract.c_str()));
						m_range.ReleaseDispatch();


						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("OBJECT")));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant(lab->object_name.c_str()));
						m_range.ReleaseDispatch();	
					}
				}			


				PhysicalLabTrial * phys_trial = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));
				if (phys_trial)
				{
/*					PhysicalLabTrialResults * phys_result = dynamic_cast<PhysicalLabTrialResults *>(phys_trial->results);
					if (phys_result)
					{
						if (!phys_result->calculed)
							phys_result->CalcProperties();

						phys_result->e.v;
					}*/

					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("W")));
					m_range.AttachDispatch(pRange);			   
					m_range.SetValue(COleVariant(phys_trial->moisture_of_nature_large_exchange.v));
					m_range.ReleaseDispatch();	


					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("B19")));
					m_range.AttachDispatch(pRange);			   
					m_range.SetValue(COleVariant(phys_trial->moisture_on_fluidity_border.v));
					m_range.ReleaseDispatch();	

					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("C19")));
					m_range.AttachDispatch(pRange);			   
					m_range.SetValue(COleVariant(phys_trial->moisture_on_plasticity_border.v));
					m_range.ReleaseDispatch();	

					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("F19")));
					m_range.AttachDispatch(pRange);			   
					m_range.SetValue(COleVariant(phys_trial->density_of_ground.v));
					m_range.ReleaseDispatch();	

					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("H19")));
					m_range.AttachDispatch(pRange);			   
					m_range.SetValue(COleVariant(phys_trial->density_of_ground_particles.v));
					m_range.ReleaseDispatch();	

				}
			}
			if(true)
			{
				double x,y;
//						char sx1[32], sx2[32];
				char SX[32], SY[32], SW_do[32], SRo_do[32], SW_pos[32], SRo_pos[32];
				// массив результатов опытов
				for (int i = 0; i < this->n_pressures; i++)
				{
					y = this->cut_resistances[i].v;
					x = pressures[i];

					sprintf(SX, "H%d", 29+i);
					sprintf(SY, "I%d", 29+i);
					sprintf(SW_do, "J%d", 29+i);
					sprintf(SRo_do, "K%d", 29+i);
					sprintf(SW_pos, "L%d", 29+i);
					sprintf(SRo_pos, "M%d", 29+i);

					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
					m_range.AttachDispatch(pRange);			   
					m_range.SetValue(COleVariant(x));
					m_range.BorderAround(COleVariant(long(1)), 2, -4105);
					m_range.ReleaseDispatch();									
					
					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SY)));
					m_range.AttachDispatch(pRange);			   
					if (y) m_range.SetValue(COleVariant(y));
					m_range.BorderAround(COleVariant(long(1)), 2, -4105);
					m_range.ReleaseDispatch();	

					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SW_do)));
					m_range.AttachDispatch(pRange);			   
					//m_range.SetValue(COleVariant(w_do));
					m_range.BorderAround(COleVariant(long(1)), 2, -4105);
					m_range.ReleaseDispatch();	

					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SRo_do)));
					m_range.AttachDispatch(pRange);			   
					//m_range.SetValue(COleVariant(ro_do));
					m_range.BorderAround(COleVariant(long(1)), 2, -4105);
					m_range.ReleaseDispatch();	

					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SW_pos)));
					m_range.AttachDispatch(pRange);			   
					//m_range.SetValue(COleVariant(w_pos));
					m_range.BorderAround(COleVariant(long(1)), 2, -4105);
					m_range.ReleaseDispatch();	

					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SRo_pos)));
					m_range.AttachDispatch(pRange);			   
					//m_range.SetValue(COleVariant(ro_pos));
					m_range.BorderAround(COleVariant(long(1)), 2, -4105);
					m_range.ReleaseDispatch();	
				}

				if (true)			
				{							
					LPDISPATCH pShapes; 
					Shapes10    m_shapes;
						
					VERIFY(pShapes = m_excel.m_worksheet.GetShapes());				
					m_shapes.AttachDispatch(pShapes);	

					long shapes_count = m_shapes.GetCount();
					printf("shapes_count = %d\n", shapes_count);

					for (long ish = 1; ish <= shapes_count; ish++)
					{
						LPDISPATCH pShape; 
						Shape10    m_shape;

						VERIFY(pShape = m_shapes.Item(COleVariant(long(ish))));				
						m_shape.AttachDispatch(pShape);	

						CString shape_name = m_shape.GetName();
						printf("%s\n", (LPCTSTR)shape_name);

						LPDISPATCH pChartObject; 
						ChartObject10    m_chart_object;

						VERIFY(pChartObject = m_excel.m_worksheet.ChartObjects(COleVariant(shape_name)));				
						m_chart_object.AttachDispatch(pChartObject);

						LPDISPATCH pChart;
						_Chart10    m_chart;

						VERIFY(pChart = m_chart_object.GetChart());
						m_chart.AttachDispatch(pChart);
		#if 0
						LPDISPATCH pRange2; 
						VERIFY(pRange2 = m_excel.m_worksheet.GetRange(COleVariant("A22:B30")));
						m_chart.SetSourceData(pRange2, COleVariant("xlColomn"));    
		#else               
					
						int len = this->n_pressures;

						double* pMyOriginalArrayX = new double[this->n_pressures];
						double* pMyOriginalArrayY = new double[this->n_pressures];

						double max_x = -DBL_MAX;

						for (int i = 0; i < this->n_pressures; i++)
						{
							y = this->cut_resistances[i].v;
#if USE_LAB_LAYER_CUT_PRESSURES
							switch(cut_type)				
							{
							case CutLabTrial::type::nature_condition:
								{
									x = cut->pressures_in_nature_condition[i];
								}
								break;
							case CutLabTrial::type::task_condition:
								{
									x = cut->pressures_in_task_condition[i];
								}
								break;
							}
#else
							x = pressures[i];
#endif

							pMyOriginalArrayX[i] = x;
							pMyOriginalArrayY[i] = y;	

							if (max_x < x)
								max_x = x;
						}

						LPDISPATCH pAxes;
						VERIFY(pAxes = m_chart.Axes(COleVariant(long (1)), 1));//axis X - [AxisGroup As XlAxisGroup = xlPrimary];

						//LPDISPATCH pAxis; 
						Axis10    m_axis;
						m_axis.AttachDispatch(pAxes);

						m_axis.SetMinimumScale(0.0);
						double max_x_scale = m_axis.GetMaximumScale();
						if (max_x_scale < max_x)
						{
							max_x_scale = max_x;
							m_axis.SetMaximumScale(max_x_scale);								
						}

						/*//Create and fill an array.
						double* pData;
						for(int count = 0; count < len; count++) 
							pMyOriginalArray[count] = count+1;//*/
				        
						//Put it into a safe array.
						COleSafeArray myOleSafeArrayX;
						COleSafeArray myOleSafeArrayY;
						myOleSafeArrayX.CreateOneDim(VT_R8, len, pMyOriginalArrayX); 
						myOleSafeArrayY.CreateOneDim(VT_R8, len, pMyOriginalArrayY); 
						// create one dimension array of 8-byte values
						// 100 entries w/data from pMyOriginalArray.
						
						// Access that safe array.
						//Get a pointer to the Data.
						//myOleSafeArray.AccessData((void**)&pData); 
						//verify all of the data.
						//for(count = 0; count < 10; count++) 
						//	ASSERT(pData[count] == pMyOriginalArray[count]);
						//myOleSafeArray.UnaccessData();
						
						//clean up.
						delete[] pMyOriginalArrayX;	
						delete[] pMyOriginalArrayY;	

						//ActiveChart.SeriesCollection(1).XValues = "={0.001,0.01}"
						//ActiveChart.SeriesCollection(1).Values = "={0.001,0.02}"

						LPDISPATCH pSeries;
						Series10    m_series;
						VERIFY(pSeries = m_chart.SeriesCollection(COleVariant(long(1))));
						m_series.AttachDispatch(pSeries);
						m_series.SetValues(myOleSafeArrayY);
						m_series.SetXValues(myOleSafeArrayX);
						m_series.ReleaseDispatch();

						CutLabTrialResults * cut_result = dynamic_cast<CutLabTrialResults *>(this->results);
						if (cut_result)
						{
							if(!cut_result->calculed)
								cut_result->CalcProperties();

							double* pMyOriginalArrayX2 = new double[2];
							double* pMyOriginalArrayY2 = new double[2];

							pMyOriginalArrayX2[0] = 0.0;
							pMyOriginalArrayY2[0] = cut_result->c.v;					

							pMyOriginalArrayX2[1] = max_x_scale;
							pMyOriginalArrayY2[1] = cut_result->c.v + cut_result->tgfi.v * max_x_scale;

							//Put it into a safe array.
							COleSafeArray myOleSafeArrayX2;
							COleSafeArray myOleSafeArrayY2;
							myOleSafeArrayX2.CreateOneDim(VT_R8, 2, pMyOriginalArrayX2); 
							myOleSafeArrayY2.CreateOneDim(VT_R8, 2, pMyOriginalArrayY2); 

							delete[] pMyOriginalArrayX2;	
							delete[] pMyOriginalArrayY2;	

							LPDISPATCH pSeries2;
							Series10    m_series2;
							VERIFY(pSeries2 = m_chart.SeriesCollection(COleVariant(long(2))));
							m_series2.AttachDispatch(pSeries2);
							m_series2.SetValues(myOleSafeArrayY2);
							m_series2.SetXValues(myOleSafeArrayX2);
							m_series2.ReleaseDispatch();
						}

						m_axis.ReleaseDispatch();
		#endif
						m_chart.ReleaseDispatch();
						m_chart_object.ReleaseDispatch();				
						m_shape.ReleaseDispatch();

					}

					m_shapes.ReleaseDispatch();				
				}	
			}

			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("Z_STAN")));
			m_range.AttachDispatch(pRange);			   
			m_range.SetValue(COleVariant(GetZrizStan(this->id_stan)));
			m_range.ReleaseDispatch();	

			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("ZZ_HID")));
			m_range.AttachDispatch(pRange);			   
			m_range.SetValue(COleVariant(GetZrizHid(this->id_hid)));
			m_range.ReleaseDispatch();	

			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("SHEMA")));
			m_range.AttachDispatch(pRange);			   
			m_range.SetValue(COleVariant(GetZrizShema(this->id_shema)));
			m_range.ReleaseDispatch();	

			CutLabTrialResults * cut_result = dynamic_cast<CutLabTrialResults *>(this->results);
			if (cut_result)
			{
				if(!cut_result->calculed)
					cut_result->CalcProperties();

				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("TGFI")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(cut_result->tgfi.v));
				m_range.ReleaseDispatch();	


				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("FI")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(cut_result->fi));
				m_range.ReleaseDispatch();	


				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant("CC")));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant(cut_result->c.v));
				m_range.ReleaseDispatch();	

			}				

			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
		printf("!!!!! m_excel.IsApplicationDispatch()\n");
}
void CutLabTrial::Passport_1(const char * fn)
{
	char file[4098];
	char file0[4098];

	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			sprintf(file, "%s_Pasport_Zriz2R2.xls", fn);
			sprintf(file0, "%s\\Pasport_Zriz2R2.xls", Laboratory::FormsDir.c_str());
		}
		break;
	case BaseLab::language::ukrainian:
		{
			sprintf(file, "%s_Pasport_Zriz22.xls", fn);
			sprintf(file0, "%s\\Pasport_Zriz22.xls", Laboratory::FormsDir.c_str());
		}
		break;
	}
	CopyFile(file0, file, FALSE);

	char S[64];
	char F[128];
 

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);
			Passport_LabNumber(m_excel, this->lab_number, "");


			CutLabTrial * p_trial = this;
					

			if(p_trial)
			{
				PhysicalLabTrial * phys_trial_m = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB));

				if (this->zriz_kolca0.size())
				{
					vector<ZrizVyprobData1>::iterator itk1;
					vector<ZrizVyprobData0>::iterator itk0;
					for (
						itk0 = this->zriz_kolca0.begin(), itk1 = this->zriz_kolca1.begin();
						itk0 != this->zriz_kolca0.end() && itk1 != this->zriz_kolca1.end(); 
						itk0++, itk1++)
					{
						long id_kolca = (*itk1).id_kolca;

						sprintf(S, "KOLCO_%d", id_kolca);
						sprintf(F, "%d-е", id_kolca);
						ExcelRange_SetValue(m_excel, S, COleVariant(F));
						
						double h_kolca = (*itk0).h;
						double d_kolca = (*itk0).d;
						double s_kolca = 0.01 * 0.25 * PI * d_kolca * d_kolca;
						double v_kolca = 0.1 * s_kolca * h_kolca;

						PhysicalLabTrial * phys_trial = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, (*itk0).id_phys_vyprob));
						if(!phys_trial)
							phys_trial = phys_trial_m;

						trial_value e0;					

						char suffix[32];
						sprintf(suffix, "_%d", id_kolca);
						Passport_Phys(m_excel, phys_trial, e0, suffix, true);

						sprintf(S, "W_do_%d", id_kolca);
						ExcelRange_SetValue(m_excel, S, COleVariant((*itk1).w_do));
						sprintf(S, "RO_do_%d", id_kolca);
						ExcelRange_SetValue(m_excel, S, COleVariant((*itk1).ro_do));

						sprintf(S, "W_po_%d", id_kolca);
						ExcelRange_SetValue(m_excel, S, COleVariant((*itk1).w_after));
						sprintf(S, "RO_po_%d", id_kolca);
						ExcelRange_SetValue(m_excel, S, COleVariant((*itk1).ro_after));

						sprintf(S, "W_po_upl_%d", id_kolca);
						ExcelRange_SetValue(m_excel, S, COleVariant((*itk1).w_po_upl));
						sprintf(S, "RO_po_upl_%d", id_kolca);
						ExcelRange_SetValue(m_excel, S, COleVariant((*itk1).ro_po_upl));

						if ((*itk1).w_po_upl && (*itk1).ro_po_upl)
						{
							sprintf(S, "E_po_upl_%d", id_kolca);
							sprintf(F, "=(1+W_po_upl_%d)*ROS_%d/RO_po_upl_%d-1", id_kolca, id_kolca, id_kolca);
							ExcelRange_SetValue(m_excel, S, COleVariant(F));
						}
						else if (!(*itk1).w_po_upl && (*itk1).ro_po_upl)
						{
							sprintf(S, "E_po_upl_%d", id_kolca);
							sprintf(F, "=(1+W_do_%d)*ROS_%d/RO_po_upl_%d-1", id_kolca, id_kolca, id_kolca);
							ExcelRange_SetValue(m_excel, S, COleVariant(F));
						}
						
					}

				}
				else
				{

					PhysicalLabTrial * phys_trial = NULL;//dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, (*itk0).id_phys_vyprob));
					if(!phys_trial)
						phys_trial = phys_trial_m;

					trial_value e0;					

					char suffix[32];
					sprintf(suffix, "_%d", 1);
					Passport_Phys(m_excel, phys_trial, e0, suffix, true);

					for (char letter = 'D'; letter <= 'N'; letter++)
					{
						char SM[32];
						sprintf(SM, "%c%d:%c%d", letter, 23, letter, 25);
						ExcelRange_SetMerge(m_excel, SM, false);
						ExcelRange_CenterVerticalAlignment(m_excel, SM);
						ExcelRange_CenterHorizontalAlignment(m_excel, SM);
					}

					vector<ZrizVyprobData1>::iterator itk1;
					for (
						itk1 = this->zriz_kolca1.begin();
						itk1 != this->zriz_kolca1.end(); 
						itk1++)
					{
						long id_kolca = (*itk1).id_kolca;

						sprintf(S, "KOLCO_%d", id_kolca);
						sprintf(F, "%d-е", id_kolca);
						ExcelRange_SetValue(m_excel, S, COleVariant(F));					


						sprintf(S, "W_do_%d", id_kolca);
						ExcelRange_SetValue(m_excel, S, COleVariant((*itk1).w_do));
						sprintf(S, "RO_do_%d", id_kolca);
						ExcelRange_SetValue(m_excel, S, COleVariant((*itk1).ro_do));

						sprintf(S, "W_po_%d", id_kolca);
						ExcelRange_SetValue(m_excel, S, COleVariant((*itk1).w_after));
						sprintf(S, "RO_po_%d", id_kolca);
						ExcelRange_SetValue(m_excel, S, COleVariant((*itk1).ro_after));

						sprintf(S, "W_po_upl_%d", id_kolca);
						ExcelRange_SetValue(m_excel, S, COleVariant((*itk1).w_po_upl));
						sprintf(S, "RO_po_upl_%d", id_kolca);
						ExcelRange_SetValue(m_excel, S, COleVariant((*itk1).ro_po_upl));

						if ((*itk1).w_po_upl && (*itk1).ro_po_upl)
						{
							sprintf(S, "E_po_upl_%d", id_kolca);
							sprintf(F, "=(1+W_po_upl_%d)*ROS_%d/RO_po_upl_%d-1", id_kolca, 1, id_kolca);
							ExcelRange_SetValue(m_excel, S, COleVariant(F));
						}
						else if (!(*itk1).w_po_upl && (*itk1).ro_po_upl)
						{
							sprintf(S, "E_po_upl_%d", id_kolca);
							sprintf(F, "=(1+W_do_%d)*ROS_%d/RO_po_upl_%d-1", id_kolca, 1, id_kolca);
							ExcelRange_SetValue(m_excel, S, COleVariant(F));
						}

						
					}

				}
				//Заполняем влажность, плотность до и после опыта исходя из масс грунта
				if (false)
				{
					for (vector<ZrizVyprobData0>::iterator itk = this->zriz_kolca0.begin();
						itk != this->zriz_kolca0.end(); itk++)
					{
						long id_kolca = (*itk).id_kolca;
						//(*itk).id_phys_vyprob;

						double h_kolca = (*itk).h;
						double d_kolca = (*itk).d;
						double s_kolca = 0.01 * 0.25 * PI * d_kolca * d_kolca;
						double v_kolca = 0.1 * s_kolca * h_kolca;

						PhysicalLabTrial * phys_trial = dynamic_cast<PhysicalLabTrial *>(this->lab_number->FindLabTrial(LabTrial::indication::physical, (*itk).id_phys_vyprob));
						if(!phys_trial)
							phys_trial = phys_trial_m;

						trial_value e0;					

						char suffix[32];
						sprintf(suffix, "_%d", (*itk).id_kolca);
						Passport_Phys(m_excel, phys_trial, e0, suffix, true);

						if (false)
						{
							double wlazhnost_do = 0.0;
							double plotnost_do = 0.0;

							double wlazhnost_zamoch = 0.0;
							double plotnost_zamoch = 0.0;

							double wlazhnost_posle = 0.0;
							double plotnost_posle = 0.0;

							double wlazhnost_posle_uplot = 0.0;
							double plotnost_posle_uplot = 0.0;

							switch(this->id_stan)
							{
							case 1:
								{
									//ExcelRange_SetValue(m_excel, "STAN", COleVariant("При естественной влажности"));
									if ((*itk).m_grunta && (*itk).m_grunta_vysush)
									{
										wlazhnost_do = ((*itk).m_grunta - (*itk).m_grunta_vysush) / (*itk).m_grunta_vysush;
										sprintf(S, "W_do_%d", id_kolca);
										ExcelRange_SetValue(m_excel, S, COleVariant(wlazhnost_do));
									}

									if ((*itk).m_grunta && v_kolca && h_kolca)
									{
										double epsilon_ik = 0.0;

										plotnost_do = (*itk).m_grunta / (v_kolca * (1.0 - epsilon_ik));
										sprintf(S, "RO_do_%d", id_kolca);
										ExcelRange_SetValue(m_excel, S, COleVariant(plotnost_do));
									}
								}
								break;
							case 2:
								{
									//ExcelRange_SetValue(m_excel, "STAN", COleVariant("В водонасыщенном состоянии"));
									if ((*itk).m_grunta_zamoch && (*itk).m_grunta_vysush)
									{
										wlazhnost_zamoch = ((*itk).m_grunta_zamoch - (*itk).m_grunta_vysush) / (*itk).m_grunta_vysush;
										sprintf(S, "W_do_%d", id_kolca);
										ExcelRange_SetValue(m_excel, S, COleVariant(wlazhnost_zamoch));
									}

									if ((*itk).m_grunta_zamoch && v_kolca && h_kolca)
									{
										double epsilon_ik = 0.0;//m_dh_zamoch[ik] / h_kolca;

										plotnost_zamoch = (*itk).m_grunta_zamoch / (v_kolca * (1.0 - epsilon_ik));
										sprintf(S, "RO_do_%d", id_kolca);
										ExcelRange_SetValue(m_excel, S, COleVariant(plotnost_zamoch));
									}
								}
								break;
							}



							if ((*itk).m_grunta_posle && (*itk).m_grunta_vysush)
							{
								wlazhnost_posle = ((*itk).m_grunta_posle - (*itk).m_grunta_vysush) / (*itk).m_grunta_vysush;
								sprintf(S, "W_po_%d", id_kolca);
								ExcelRange_SetValue(m_excel, S, COleVariant(wlazhnost_posle));
							}

							if ((*itk).m_grunta_posle && v_kolca && h_kolca)
							{
								double epsilon_ik = (*itk).dh_po_upl / h_kolca;

								plotnost_posle = (*itk).m_grunta_posle / (v_kolca * (1.0 - epsilon_ik));
								sprintf(S, "RO_po_%d", id_kolca);
								ExcelRange_SetValue(m_excel, S, COleVariant(plotnost_posle));
							}

							if ((*itk).m_grunta_posle_uplot && (*itk).m_grunta_vysush)
							{
								wlazhnost_posle_uplot = ((*itk).m_grunta_posle_uplot - (*itk).m_grunta_vysush) / (*itk).m_grunta_vysush;
								sprintf(S, "W_po_upl_%d", id_kolca);
								ExcelRange_SetValue(m_excel, S, COleVariant(wlazhnost_posle_uplot));
							}

							if ((*itk).m_grunta_posle_uplot && v_kolca && h_kolca)
							{
								double epsilon_ik = (*itk).dh_po_upl / h_kolca;

								plotnost_posle_uplot = (*itk).m_grunta_posle_uplot / (v_kolca * (1.0 - epsilon_ik));
								sprintf(S, "RO_po_upl_%d", id_kolca);
								ExcelRange_SetValue(m_excel, S, COleVariant(plotnost_posle_uplot));
							}
						}
					}

				}




				char S[64];
				int ftr = 23;
				sprintf(S, "A%d:N%d", ftr, ftr-1 + p_trial->n_pressures);
				ExcelRange_SetThinContinuousBorders(m_excel, S);
				ftr = 37;
				sprintf(S, "A%d:N%d", ftr, ftr-1 + p_trial->n_pressures);
				ExcelRange_SetThinContinuousBorders(m_excel, S);
	
			}
	
			Passport_Graph(m_excel, this);
			

			string zriz_usl = "";
#if 0
			zriz_usl += "Ход: ";
			zriz_usl += GetZrizHid(this->id_hid);
			zriz_usl += ", схема: ";
			zriz_usl += GetZrizShema(this->id_shema);
			zriz_usl += ", состояние: ";
			zriz_usl += GetZrizStan(this->id_stan);
#else
			CGround::s_Gender = CGround::Gender::male;
			zriz_usl = "";
			zriz_usl += GetZrizHid(this->id_hid);
			zriz_usl += " ";
			zriz_usl += GetZrizShema(this->id_shema);
			zriz_usl += " при ";
			zriz_usl += Pri_GetZrizStan(this->id_stan);
#endif
			ExcelRange_SetValue(m_excel, "ZRIZ_USL", COleVariant(zriz_usl.c_str()), true);

			CutLabTrialResults * cut_result = dynamic_cast<CutLabTrialResults *>(this->results);
			if (cut_result)
			{
				if(!cut_result->calculed)
					cut_result->CalcProperties();

				ExcelRange_SetValue(m_excel, "TGFI", COleVariant(cut_result->tgfi.v), true);
				ExcelRange_SetValue(m_excel, "FI", COleVariant(cut_result->fi), true);
				ExcelRange_SetValue(m_excel, "CC", COleVariant(cut_result->c.v), true);

				char SM[32];

				sprintf(SM, "%c%d:%c%d", 'J', 37, 'J', 37+this->n_pressures-1);
				ExcelRange_SetMerge(m_excel, SM, false);
				ExcelRange_CenterVerticalAlignment(m_excel, SM);
				ExcelRange_CenterHorizontalAlignment(m_excel, SM);

				sprintf(SM, "%c%d:%c%d", 'K', 37, 'K', 37+this->n_pressures-1);
				ExcelRange_SetMerge(m_excel, SM, false);
				ExcelRange_CenterVerticalAlignment(m_excel, SM);
				ExcelRange_CenterHorizontalAlignment(m_excel, SM);

				sprintf(SM, "%c%d:%c%d", 'L', 37, 'L', 37+this->n_pressures-1);
				ExcelRange_SetMerge(m_excel, SM, false);
				ExcelRange_CenterVerticalAlignment(m_excel, SM);
				ExcelRange_CenterHorizontalAlignment(m_excel, SM);
			}				

			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
		printf("!!!!! m_excel.IsApplicationDispatch()\n");
}
string CutLabTrial::GetSoilDescription()
{
	return "";
}
void CutLabTrial::GetSoilDescription(SoilDescription & sd)
{
	CutLabTrialResults * cut_lab_trial_res = dynamic_cast<CutLabTrialResults *>(this->results);

	if (cut_lab_trial_res)
	{
		if(!cut_lab_trial_res->calculed)
			cut_lab_trial_res->CalcProperties();	

		sd.c = cut_lab_trial_res->c;
		sd.fi = cut_lab_trial_res->fi;
		sd.tgfi = cut_lab_trial_res->tgfi;
	}
}
void FiltrationLabTrial::Passport(const char * fn)
{
}
string FiltrationLabTrial::GetSoilDescription()
{
	return "";
}
void FiltrationLabTrial::GetSoilDescription(SoilDescription & sd)
{
}
void PressingLabTrial::Passport(const char * fn)
{
}
string PressingLabTrial::GetSoilDescription()
{
	return "";
}
void PressingLabTrial::GetSoilDescription(SoilDescription & sd)
{
}
void LabLayer::HowManyIDs(LabTrialValueType & vt, map<long,long> &freq)
{
	char str[4098];
	trial_got_value v;
	vector<trial_got_value> vv;

	sprintf (str, "%s:", vt.GetValueTypeString());

	bool got = false;
	for (vector<LabNumber*>::iterator it = this->lab_numbers.begin();
		it != this->lab_numbers.end(); it++)
	{
		if (*it)
		{
			if ((*it)->GetValue(vt, v))
			{
				v.lab_number = (*it);
				vv.push_back(v);
				got = true;	
			}
		}
	}

	for (vector<trial_got_value>::iterator it = vv.begin();	it != vv.end(); it++)
	{
		long id = (long)(*it).v;
		if (freq.find(id) == freq.end())
		{
			freq.insert(map<long,long>::value_type(id, 1));
		}
		else
		{
			freq[id]++;
		}
	}

	long n = 0, id = -1;
	for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
	{
		n = (*mit).second;
		id = (*mit).first;
	}
}
bool LabLayer::HaveNormative(LabTrial::indication ind)
{
	for (map<LabTrialValueType, normative_value>::iterator 
		it = this->lab_normatives->values.begin();
		it != this->lab_normatives->values.end(); it++)
	{
		if ((*it).first.m_indication == ind)
		{
			return true;
		}
	}
	return false;
}
void LabLayer::Passport_normatives(const char * fn)
{
	this->Normatives(NULL, NULL);
	this->excluded_list_filled = true;

	this->PassportFiz(fn);
	//this->PassportZriz(fn);
	if (this->HaveNormative(LabTrial::indication::cut_resistance_nature_condition))
	{
		this->PassportZriz(fn, LabTrial::indication::cut_resistance_nature_condition);
		this->PassportZriz2(fn, LabTrial::indication::cut_resistance_nature_condition);
	}
	if (this->HaveNormative(LabTrial::indication::cut_resistance_task_condition))
	{
		this->PassportZriz(fn, LabTrial::indication::cut_resistance_task_condition);
		this->PassportZriz2(fn, LabTrial::indication::cut_resistance_task_condition);
	}
	//this->PassportComp(fn);
	this->PassportComp0(fn, true);
	this->PassportComp0(fn, false);
}
void LabLayer::Passport_chastnye_or_normatives(int flag, const char * fn)
{

	char file[4098];
	char file0[4098];

	switch (flag)
	{
	case 0://chastnye
		{
			switch (BaseLab::PassportLanguage)
			{
			case BaseLab::language::russian:
				{
					sprintf(file, "%s_ChastnyeR.xls", fn);
					sprintf(file0, "%s\\Chastnye.xls", Laboratory::FormsDir.c_str());
				}
				break;
			case BaseLab::language::ukrainian:
				{
					sprintf(file, "%s_Chastnye.xls", fn);
					sprintf(file0, "%s\\Chastnye.xls", Laboratory::FormsDir.c_str());
				}
				break;
			}
		}
		break;
	default://normatives
		{
			switch (BaseLab::PassportLanguage)
			{
			case BaseLab::language::russian:
				{
					sprintf(file, "%s_NormativnyeR_%d.xls", fn, flag);
					sprintf(file0, "%s\\Normativnye.xls", Laboratory::FormsDir.c_str());
				}
				break;
			case BaseLab::language::ukrainian:
				{
					sprintf(file, "%s_Normativnye_%d.xls", fn, flag);
					sprintf(file0, "%s\\Normativnye.xls", Laboratory::FormsDir.c_str());
				}
				break;
			}
		}
		break;
	}

	CopyFile(file0, file, FALSE);


	int fr = 7;
	int r = fr;
	char SX[32];
 
	LPDISPATCH pRange; 
	Range10    m_range;

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);


			//IGE
			if (true)
			{
				sprintf(SX, "A3");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a3_val = m_range.GetValue();
				CString a3;
				if (a3_val.vt == VT_BSTR)
				{
					a3 = a3_val.bstrVal;

					char s[128];
					sprintf(s, "%s\0", this->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
					OemToChar(s,s);	
#endif
					a3 += " ";
					a3 += s;
					m_range.SetValue(COleVariant(a3));
				}

				m_range.ReleaseDispatch();
			}

			//Grunt
			for (map<LabTrialValueType, normative_value>::iterator 
				it = this->lab_normatives->values.begin();
				it != this->lab_normatives->values.end(); it++)
			{
				if ((*it).first.m_indication == LabTrial::indication::physical)
				{
					if ((*it).first.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_ground_type)
					{					
						sprintf(SX, "A4");
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	

						VARIANT a4_val = m_range.GetValue();
						CString a4;
						if (a4_val.vt == VT_BSTR)
						{
							a4 = a4_val.bstrVal;
							CGround::ground_type gt = (CGround::ground_type)(long)(*it).second.v_n.v;
							CGround::s_Quantity = CGround::Quantity::singular;
							a4 += " ";
							a4 += CGround::GrountTypeToStringRus(gt);
							m_range.SetValue(COleVariant(a4));
						}

						m_range.ReleaseDispatch();
					}
				}
			}





			vector<fmtstr> text;

			//Laboratory::context_with_plot

			bool context_with_results_was = LabNumber::context_with_results;
			bool context_with_lab_number_trial_list_was = LabLayer::context_with_lab_number_trial_list;
			bool context_with_normatives_was = LabLayer::context_with_normatives;
			bool context_with_normatives_by_all_experiences_was = LabLayer::context_with_normatives_by_all_experiences;
			bool context_with_korrelation_was = LabLayer::context_with_korrelation;

			switch(flag)
			{
			case 0:
				{
					LabNumber::context_with_results = true;
					LabLayer::context_with_lab_number_trial_list = true;
					LabLayer::context_with_normatives = false;
					LabLayer::context_with_normatives_by_all_experiences = false;
					LabLayer::context_with_korrelation = false;
				}
				break;
			case 1:
				{
					LabNumber::context_with_results = true;
					LabLayer::context_with_lab_number_trial_list = false;
					LabLayer::context_with_normatives = true;
					LabLayer::context_with_normatives_by_all_experiences = true;
					LabLayer::context_with_korrelation = false;
				}
				break;
			case 2:
				{
					LabNumber::context_with_results = true;
					LabLayer::context_with_lab_number_trial_list = false;
					LabLayer::context_with_normatives = true;
					LabLayer::context_with_normatives_by_all_experiences = false;
					LabLayer::context_with_korrelation = false;
				}
				break;
			case 3:
				{
					LabNumber::context_with_results = true;
					LabLayer::context_with_lab_number_trial_list = false;
					LabLayer::context_with_normatives = false;
					LabLayer::context_with_normatives_by_all_experiences = true;
					LabLayer::context_with_korrelation = false;
				}
				break;
			}

			this->PrintfProperties(text);

			LabNumber::context_with_results                      = context_with_results_was;
			LabLayer::context_with_normatives                    = context_with_normatives_was;
			LabLayer::context_with_lab_number_trial_list         = context_with_lab_number_trial_list_was;
			LabLayer::context_with_normatives_by_all_experiences = context_with_normatives_by_all_experiences_was;
			LabLayer::context_with_korrelation                   = context_with_korrelation_was;





			bool nl = true;

			int col = 0, cols = 0;
			int row = 0, rows = 0;
					


		


			col = 0;
			row = -1;
			//row = 5;
			nl = true;

			ExcelColChar ecc('A');


			for (vector<fmtstr>::iterator it = text.begin();
				it != text.end(); it++)
			{		
							

				if (nl)
				{
					col = 0;
					row++;
				}
				else
				{
					col++;
				}

				//if (row > 0) // skip first line
				//{
					sprintf(SX, "%s%d", ecc.Get(col), row+5);
					VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
					m_range.AttachDispatch(pRange);	
					m_range.SetValue(COleVariant((*it).String().c_str()));
					m_range.BorderAround(COleVariant(long(1)), 2, -4105);
					m_range.ReleaseDispatch();
					ExcelRange_SetFont(m_excel, SX, (*it).GetFont(), (*it).GetColor());
				//}


#if 0
				if (vSy[row] < sz.cy)
					vSy[row] = sz.cy;

				if ((*it).AsTab())
				{
					if (vSx[col] < sz.cx)
						vSx[col] = sz.cx;
				}
				else
				{
					if (nl)
					{
						Szcx = sz.cx + interval_x;
					}
					else
					{
						Szcx += sz.cx + interval_x;
					}	

					if ((*it).NewLine())
					{
						if (Szcx > non_tab_cx) non_tab_cx = Szcx;
					}
				}
#endif
				if ((*it).NewLine())
				{
					nl = true;
				}
				else
				{
					nl = false;
				}
			}


			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
		printf("!!!!! m_excel.IsApplicationDispatch()\n");

}
void LabLayer::PassportZriz2(const char * fn, LabTrial::indication ind)
{
	char file[4098];
	char file0[4098];

	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			sprintf(file, "%s_Normatyv_Zriz2R.xls", fn);
			sprintf(file0, "%s\\Normatyv_Zriz2R.xls", Laboratory::FormsDir.c_str());
		}
		break;
	case BaseLab::language::ukrainian:
		{
			sprintf(file, "%s_Normatyv_Zriz2.xls", fn);
			sprintf(file0, "%s\\Normatyv_Zriz2.xls", Laboratory::FormsDir.c_str());
		}
		break;
	}
	CopyFile(file0, file, FALSE);

	int fr = 13;
	int r = fr;
	char SX[32];
 
	LPDISPATCH pRange; 
	Range10    m_range;

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);

			if (true)
			{
				sprintf(SX, "A4");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a5_val = m_range.GetValue();
				CString a5;
				if (a5_val.vt == VT_BSTR)
				{
					a5 = a5_val.bstrVal;

					CString s;
					if (true)
					{
						LabTrialValueType vt;
						vt.is_result = false;
						vt.vt_CutLabTrial = CutLabTrial::value_type::vt_hid;
						
						map<long,long> freq;
						freq.clear();

						vt.m_indication = ind;
						HowManyIDs(vt, freq);

						if (freq.size() == 1)
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								s.Format(" %s", GetZrizHid((*mit).first) );
								a5 += s;
							}
						}
						else
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								switch (BaseLab::PassportLanguage)
								{
								case BaseLab::language::russian:
									{				
										s.Format(" %s (%d испытаний)", GetZrizHid((*mit).first), (*mit).second);
									}
									break;
								case BaseLab::language::ukrainian:
									{
										s.Format(" %s (%d випробувань)", GetZrizHid((*mit).first), (*mit).second);
									}
									break;
								}
								a5 += s;
							}
						}
					}
					m_range.SetValue(COleVariant(a5));
				}

				m_range.ReleaseDispatch();
			}



			if (true)
			{
				sprintf(SX, "A5");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a6_val = m_range.GetValue();
				CString a6;
				if (a6_val.vt == VT_BSTR)
				{
					a6 = a6_val.bstrVal;

					CString s;
					if (true)
					{
						LabTrialValueType vt;
						vt.is_result = false;
						vt.vt_CutLabTrial = CutLabTrial::value_type::vt_shema;
						
						map<long,long> freq;
						freq.clear();

						vt.m_indication = ind;
						HowManyIDs(vt, freq);

						if (freq.size() == 1)
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								s.Format(" %s", GetZrizShema((*mit).first) );
								a6 += s;
							}
						}
						else
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								switch (BaseLab::PassportLanguage)
								{
								case BaseLab::language::russian:
									{				
										s.Format(" %s (%d испытаний)", GetZrizShema((*mit).first), (*mit).second);
									}
									break;
								case BaseLab::language::ukrainian:
									{
										s.Format(" %s (%d випробувань)", GetZrizShema((*mit).first), (*mit).second);
									}
									break;
								}
								a6 += s;
							}
						}
					}
					m_range.SetValue(COleVariant(a6));
				}

				m_range.ReleaseDispatch();
			}



			if (true)
			{
				sprintf(SX, "A6");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a7_val = m_range.GetValue();
				CString a7;
				if (a7_val.vt == VT_BSTR)
				{
					a7 = a7_val.bstrVal;

					CString s;
					if (true)
					{
						LabTrialValueType vt;
						vt.is_result = false;
						vt.vt_CutLabTrial = CutLabTrial::value_type::vt_stan;
						
						map<long,long> freq;
						freq.clear();

						vt.m_indication = ind;
						HowManyIDs(vt, freq);

						if (freq.size() == 1)
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								s.Format(" %s", GetZrizStan((*mit).first) );
								a7 += s;
							}
						}
						else
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								switch (BaseLab::PassportLanguage)
								{
								case BaseLab::language::russian:
									{				
										s.Format(" %s (%d испытаний)", GetZrizStan((*mit).first), (*mit).second);
									}
									break;
								case BaseLab::language::ukrainian:
									{
										s.Format(" %s (%d випробувань)", GetZrizStan((*mit).first), (*mit).second);
									}
									break;
								}
								a7 += s;
							}
						}
					}
					m_range.SetValue(COleVariant(a7));
				}

				m_range.ReleaseDispatch();
			}



			if (true)
			{
				sprintf(SX, "A2");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a3_val = m_range.GetValue();
				CString a3;
				if (a3_val.vt == VT_BSTR)
				{
					a3 = a3_val.bstrVal;

					char s[128];
					sprintf(s, "%s\0", this->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
					OemToChar(s,s);	
#endif
					a3 += " ";
					a3 += s;
					m_range.SetValue(COleVariant(a3));
				}

				m_range.ReleaseDispatch();
			}




			for (map<LabTrialValueType, normative_value>::iterator 
				it = this->lab_normatives->values.begin();
				it != this->lab_normatives->values.end(); it++)
			{
				if ((*it).first.m_indication == LabTrial::indication::physical)
				{
					if ((*it).first.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_ground_type)
					{					
						sprintf(SX, "A3");
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	

						VARIANT a4_val = m_range.GetValue();
						CString a4;
						if (a4_val.vt == VT_BSTR)
						{
							a4 = a4_val.bstrVal;
							CGround::ground_type gt = (CGround::ground_type)(long)(*it).second.v_n.v;
							CGround::s_Quantity = CGround::Quantity::singular;
							a4 += " ";
							a4 += CGround::GrountTypeToStringRus(gt);
							m_range.SetValue(COleVariant(a4));
						}

						m_range.ReleaseDispatch();
					}
				}

				if ((*it).first.m_indication == ind
					&&
					!(*it).first.every_cut_experiment)

				{
					if ((*it).first.vt_CutLabTrialResults == CutLabTrialResults::value_type::vt_fi)
					{
						if ((*it).second.v_n.f)
						{
							sprintf(SX, "A12");
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);	
							m_range.SetValue(COleVariant((long)(*it).second.n));
							m_range.ReleaseDispatch();

							sprintf(SX, "B12");
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);	
							m_range.SetValue(COleVariant((*it).second.v_n.v));
							m_range.ReleaseDispatch();
						}
					}
					else if ((*it).first.vt_CutLabTrialResults == CutLabTrialResults::value_type::vt_tgfi)
					{
						if ((*it).second.v_n.f)
						{
							sprintf(SX, "C12");
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);	
							m_range.SetValue(COleVariant((*it).second.v_n.v));
							m_range.ReleaseDispatch();
						}

						if ((*it).second.v_95.f)
						{
							sprintf(SX, "G12");
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);	
							m_range.SetValue(COleVariant((*it).second.v_95.v));
							m_range.ReleaseDispatch();
						}
						if ((*it).second.gamma_g_tgfi_c.f)
						{
							sprintf(SX, "F12");
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);	
							m_range.SetValue(COleVariant((*it).second.gamma_g_tgfi_c.v));
							m_range.ReleaseDispatch();
						}
						if ((*it).second.sigma_min.f)
						{
							sprintf(SX, "C9");
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);	
							m_range.SetValue(COleVariant((*it).second.sigma_min.v));
							m_range.ReleaseDispatch();
						}
						if ((*it).second.sigma_max.f)
						{
							sprintf(SX, "E9");
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);	
							m_range.SetValue(COleVariant((*it).second.sigma_max.v));
							m_range.ReleaseDispatch();
						}
					}
					else if ((*it).first.vt_CutLabTrialResults == CutLabTrialResults::value_type::vt_c)
					{
						if ((*it).second.v_n.f)
						{
							sprintf(SX, "D12");
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);	
							m_range.SetValue(COleVariant((*it).second.v_n.v));
							m_range.ReleaseDispatch();

							sprintf(SX, "H12");
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);	
							m_range.SetValue(COleVariant((*it).second.v_95.v));
							m_range.ReleaseDispatch();
						}
					}
					else if ((*it).first.vt_CutLabTrialResults == CutLabTrialResults::value_type::vt_Stau)
					{
						if ((*it).second.v_n.f)
						{
							sprintf(SX, "E12");
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);	
							m_range.SetValue(COleVariant((*it).second.v_n.v));
							m_range.ReleaseDispatch();
						}
					}

					if (false)
					{
						sprintf(SX, "A%d", r);
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	
						LabTrialValueType vt = (*it).first;
						m_range.SetValue(COleVariant(vt.GetValueTypeString()));
						m_range.ReleaseDispatch();

						sprintf(SX, "B%d", r);
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	
						m_range.SetValue(COleVariant((long)(*it).second.n));
						m_range.ReleaseDispatch();

						if ((*it).second.v_n.f)
						{
							sprintf(SX, "C%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant((*it).second.v_n.v));
							m_range.ReleaseDispatch();
						}

						if ((*it).second.v_S.f)
						{
							sprintf(SX, "D%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant((*it).second.v_S.v));
							m_range.ReleaseDispatch();	
						}

						if ((*it).second.v_V.f)
						{
							sprintf(SX, "E%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant((*it).second.v_V.v));
							m_range.ReleaseDispatch();
						}

						/*if ((*it).second.ro_a.f)
						{
							sprintf(SX, "E%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant((*it).second.ro_a.v));
							m_range.ReleaseDispatch();
						}*/

						if ((*it).second.v_85.f)
						{
							sprintf(SX, "G%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant((*it).second.v_85.v));
							m_range.ReleaseDispatch();
						}

						if ((*it).second.v_95.f)
						{
							sprintf(SX, "H%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant((*it).second.v_95.v));
							m_range.ReleaseDispatch();
						}

						if ((*it).second.v_99.f)
						{
							sprintf(SX, "I%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant((*it).second.v_99.v));
							m_range.ReleaseDispatch();	
						}

						r++;
					}
				}
			}
			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
		printf("!!!!! m_excel.IsApplicationDispatch()\n");

}
void LabLayer::PassportZriz(const char * fn, LabTrial::indication ind)
{
	char file[4098];
	char file0[4098];

	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			sprintf(file, "%s_Normatyv_ZrizR.xls", fn);
			sprintf(file0, "%s\\Normatyv_ZrizR.xls", Laboratory::FormsDir.c_str());
		}
		break;
	case BaseLab::language::ukrainian:
		{
			sprintf(file, "%s_Normatyv_Zriz.xls", fn);
			sprintf(file0, "%s\\Normatyv_Zriz.xls", Laboratory::FormsDir.c_str());
		}
		break;
	}
	CopyFile(file0, file, FALSE);

	int fr = 10;
	int r = fr;
	char SX[32];
 
	LPDISPATCH pRange; 
	Range10    m_range;

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);



			if (true)
			{
				sprintf(SX, "A5");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a5_val = m_range.GetValue();
				CString a5;
				if (a5_val.vt == VT_BSTR)
				{
					a5 = a5_val.bstrVal;

					CString s;
					if (true)
					{
						LabTrialValueType vt;
						vt.is_result = false;
						vt.vt_CutLabTrial = CutLabTrial::value_type::vt_hid;
						
						map<long,long> freq;
						freq.clear();

						vt.m_indication = ind;
						HowManyIDs(vt, freq);

						if (freq.size() == 1)
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								s.Format(" %s", GetZrizHid((*mit).first) );
								a5 += s;
							}
						}
						else
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								switch (BaseLab::PassportLanguage)
								{
								case BaseLab::language::russian:
									{				
										s.Format(" %s (%d испытаний)", GetZrizHid((*mit).first), (*mit).second);
									}
									break;
								case BaseLab::language::ukrainian:
									{
										s.Format(" %s (%d випробувань)", GetZrizHid((*mit).first), (*mit).second);
									}
									break;
								}
								a5 += s;
							}
						}
					}
					m_range.SetValue(COleVariant(a5));
				}

				m_range.ReleaseDispatch();
			}



			if (true)
			{
				sprintf(SX, "A6");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a6_val = m_range.GetValue();
				CString a6;
				if (a6_val.vt == VT_BSTR)
				{
					a6 = a6_val.bstrVal;

					CString s;
					if (true)
					{
						LabTrialValueType vt;
						vt.is_result = false;
						vt.vt_CutLabTrial = CutLabTrial::value_type::vt_shema;
						
						map<long,long> freq;
						freq.clear();

						vt.m_indication = ind;
						HowManyIDs(vt, freq);

						if (freq.size() == 1)
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								s.Format(" %s", GetZrizShema((*mit).first) );
								a6 += s;
							}
						}
						else
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								switch (BaseLab::PassportLanguage)
								{
								case BaseLab::language::russian:
									{				
										s.Format(" %s (%d испытаний)", GetZrizShema((*mit).first), (*mit).second);
									}
									break;
								case BaseLab::language::ukrainian:
									{
										s.Format(" %s (%d випробувань)", GetZrizShema((*mit).first), (*mit).second);
									}
									break;
								}
								a6 += s;
							}
						}
					}
					m_range.SetValue(COleVariant(a6));
				}

				m_range.ReleaseDispatch();
			}



			if (true)
			{
				sprintf(SX, "A7");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a7_val = m_range.GetValue();
				CString a7;
				if (a7_val.vt == VT_BSTR)
				{
					a7 = a7_val.bstrVal;

					CString s;
					if (true)
					{
						LabTrialValueType vt;
						vt.is_result = false;
						vt.vt_CutLabTrial = CutLabTrial::value_type::vt_stan;
						
						map<long,long> freq;
						freq.clear();

						vt.m_indication = ind;
						HowManyIDs(vt, freq);

						if (freq.size() == 1)
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								s.Format(" %s", GetZrizStan((*mit).first) );
								a7 += s;
							}
						}
						else
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{											
								switch (BaseLab::PassportLanguage)
								{
								case BaseLab::language::russian:
									{				
										s.Format(" %s (%d испытаний)", GetZrizStan((*mit).first), (*mit).second);
									}
									break;
								case BaseLab::language::ukrainian:
									{
										s.Format(" %s (%d випробувань)", GetZrizStan((*mit).first), (*mit).second);
									}
									break;
								}
								a7 += s;
							}
						}
					}
					m_range.SetValue(COleVariant(a7));
				}

				m_range.ReleaseDispatch();
			}



			if (true)
			{
				sprintf(SX, "A3");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a3_val = m_range.GetValue();
				CString a3;
				if (a3_val.vt == VT_BSTR)
				{
					a3 = a3_val.bstrVal;

					char s[128];
					sprintf(s, "%s\0", this->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
					OemToChar(s,s);	
#endif
					a3 += " ";
					a3 += s;
					m_range.SetValue(COleVariant(a3));
				}

				m_range.ReleaseDispatch();
			}


			//bool natural_conditions_headered = false;
			//bool task_conditions_headered = false;


			for (map<LabTrialValueType, normative_value>::iterator 
				it = this->lab_normatives->values.begin();
				it != this->lab_normatives->values.end(); it++)
			{
				if ((*it).first.m_indication == LabTrial::indication::physical)
				{
					if ((*it).first.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_ground_type)
					{					
						sprintf(SX, "A4");
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	

						VARIANT a4_val = m_range.GetValue();
						CString a4;
						if (a4_val.vt == VT_BSTR)
						{
							a4 = a4_val.bstrVal;
							CGround::ground_type gt = (CGround::ground_type)(long)(*it).second.v_n.v;
							CGround::s_Quantity = CGround::Quantity::singular;
							a4 += " ";
							a4 += CGround::GrountTypeToStringRus(gt);
							m_range.SetValue(COleVariant(a4));
						}

						m_range.ReleaseDispatch();
					}
				}

				if ((*it).first.m_indication == ind
					&&
					(*it).first.every_cut_experiment)

				{
					//if ((*it).first.is_result)
					{
						sprintf(SX, "A%d", r);
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	
						LabTrialValueType vt = (*it).first;
						m_range.SetValue(COleVariant(vt.GetValueTypeString()));
						m_range.BorderAround(COleVariant(long(1)), 2, -4105);
						m_range.ReleaseDispatch();

						sprintf(SX, "B%d", r);
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	
						m_range.SetValue(COleVariant((long)(*it).second.n));
						m_range.BorderAround(COleVariant(long(1)), 2, -4105);
						m_range.ReleaseDispatch();

						
						{
							sprintf(SX, "C%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_n.f)
								m_range.SetValue(COleVariant((*it).second.v_n.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "D%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_S.f)
								m_range.SetValue(COleVariant((*it).second.v_S.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	
						}

						
						{
							sprintf(SX, "E%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_V.f)
								m_range.SetValue(COleVariant((*it).second.v_V.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "F%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.ro_85.f)
								m_range.SetValue(COleVariant((*it).second.ro_85.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "G%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.ro_95.f)
								m_range.SetValue(COleVariant((*it).second.ro_95.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "H%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.ro_99.f)
								m_range.SetValue(COleVariant((*it).second.ro_99.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "I%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_85.f)
								m_range.SetValue(COleVariant((*it).second.v_85.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "J%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_95.f)
								m_range.SetValue(COleVariant((*it).second.v_95.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "K%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_99.f)
								m_range.SetValue(COleVariant((*it).second.v_99.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	
						}

						r++;
					}
				}
			}
			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
		printf("!!!!! m_excel.IsApplicationDispatch()\n");

}
void LabLayer::PassportZriz(const char * fn)
{
	char file[4098];
	char file0[4098];

	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			sprintf(file, "%s_Normatyv_ZrizR.xls", fn);
			sprintf(file0, "%s\\Normatyv_ZrizR.xls", Laboratory::FormsDir.c_str());
		}
		break;
	case BaseLab::language::ukrainian:
		{
			sprintf(file, "%s_Normatyv_Zriz.xls", fn);
			sprintf(file0, "%s\\Normatyv_Zriz.xls", Laboratory::FormsDir.c_str());
		}
		break;
	}
	CopyFile(file0, file, FALSE);

	int fr = 10;
	int r = fr;
	char SX[32];
 
	LPDISPATCH pRange; 
	Range10    m_range;

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);



			if (true)
			{
				sprintf(SX, "A5");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a5_val = m_range.GetValue();
				CString a5;
				if (a5_val.vt == VT_BSTR)
				{
					a5 = a5_val.bstrVal;

					CString s;
					if (true)
					{
						LabTrialValueType vt;
						vt.is_result = false;
						vt.vt_CutLabTrial = CutLabTrial::value_type::vt_hid;
						
						map<long,long> freq;
						freq.clear();

						vt.m_indication = LabTrial::indication::cut_resistance_nature_condition;
						HowManyIDs(vt, freq);
						vt.m_indication = LabTrial::indication::cut_resistance_task_condition;
						HowManyIDs(vt, freq);

						if (freq.size() == 1)
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								s.Format(" %s", GetZrizHid((*mit).first) );
								a5 += s;
							}
						}
						else
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								switch (BaseLab::PassportLanguage)
								{
								case BaseLab::language::russian:
									{				
										s.Format(" %s (%d испытаний)", GetZrizHid((*mit).first), (*mit).second);
									}
									break;
								case BaseLab::language::ukrainian:
									{
										s.Format(" %s (%d випробувань)", GetZrizHid((*mit).first), (*mit).second);
									}
									break;
								}
								a5 += s;
							}
						}
					}
					m_range.SetValue(COleVariant(a5));
				}

				m_range.ReleaseDispatch();
			}



			if (true)
			{
				sprintf(SX, "A6");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a6_val = m_range.GetValue();
				CString a6;
				if (a6_val.vt == VT_BSTR)
				{
					a6 = a6_val.bstrVal;

					CString s;
					if (true)
					{
						LabTrialValueType vt;
						vt.is_result = false;
						vt.vt_CutLabTrial = CutLabTrial::value_type::vt_shema;
						
						map<long,long> freq;
						freq.clear();

						vt.m_indication = LabTrial::indication::cut_resistance_nature_condition;
						HowManyIDs(vt, freq);
						vt.m_indication = LabTrial::indication::cut_resistance_task_condition;
						HowManyIDs(vt, freq);

						if (freq.size() == 1)
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								s.Format(" %s", GetZrizShema((*mit).first) );
								a6 += s;
							}
						}
						else
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								switch (BaseLab::PassportLanguage)
								{
								case BaseLab::language::russian:
									{				
										s.Format(" %s (%d испытаний)", GetZrizShema((*mit).first), (*mit).second);
									}
									break;
								case BaseLab::language::ukrainian:
									{
										s.Format(" %s (%d випробувань)", GetZrizShema((*mit).first), (*mit).second);
									}
									break;
								}
								a6 += s;
							}
						}
					}
					m_range.SetValue(COleVariant(a6));
				}

				m_range.ReleaseDispatch();
			}



			if (true)
			{
				sprintf(SX, "A7");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a7_val = m_range.GetValue();
				CString a7;
				if (a7_val.vt == VT_BSTR)
				{
					a7 = a7_val.bstrVal;

					CString s;
					if (true)
					{
						LabTrialValueType vt;
						vt.is_result = false;
						vt.vt_CutLabTrial = CutLabTrial::value_type::vt_stan;
						
						map<long,long> freq;
						freq.clear();

						vt.m_indication = LabTrial::indication::cut_resistance_nature_condition;
						HowManyIDs(vt, freq);
						vt.m_indication = LabTrial::indication::cut_resistance_task_condition;
						HowManyIDs(vt, freq);

						if (freq.size() == 1)
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{
								s.Format(" %s", GetZrizStan((*mit).first) );
								a7 += s;
							}
						}
						else
						{
							for (map<long,long>::iterator mit = freq.begin(); mit != freq.end(); mit++)
							{											
								switch (BaseLab::PassportLanguage)
								{
								case BaseLab::language::russian:
									{				
										s.Format(" %s (%d испытаний)", GetZrizStan((*mit).first), (*mit).second);
									}
									break;
								case BaseLab::language::ukrainian:
									{
										s.Format(" %s (%d випробувань)", GetZrizStan((*mit).first), (*mit).second);
									}
									break;
								}
								a7 += s;
							}
						}
					}
					m_range.SetValue(COleVariant(a7));
				}

				m_range.ReleaseDispatch();
			}



			if (true)
			{
				sprintf(SX, "A3");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a3_val = m_range.GetValue();
				CString a3;
				if (a3_val.vt == VT_BSTR)
				{
					a3 = a3_val.bstrVal;

					char s[128];
					sprintf(s, "%s\0", this->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
					OemToChar(s,s);	
#endif
					a3 += " ";
					a3 += s;
					m_range.SetValue(COleVariant(a3));
				}

				m_range.ReleaseDispatch();
			}


			bool natural_conditions_headered = false;
			bool task_conditions_headered = false;


			for (map<LabTrialValueType, normative_value>::iterator 
				it = this->lab_normatives->values.begin();
				it != this->lab_normatives->values.end(); it++)
			{
				if ((*it).first.m_indication == LabTrial::indication::physical)
				{
					if ((*it).first.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_ground_type)
					{					
						sprintf(SX, "A4");
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	

						VARIANT a4_val = m_range.GetValue();
						CString a4;
						if (a4_val.vt == VT_BSTR)
						{
							a4 = a4_val.bstrVal;
							CGround::ground_type gt = (CGround::ground_type)(long)(*it).second.v_n.v;
							CGround::s_Quantity = CGround::Quantity::singular;
							a4 += " ";
							a4 += CGround::GrountTypeToStringRus(gt);
							m_range.SetValue(COleVariant(a4));
						}

						m_range.ReleaseDispatch();
					}
				}

				if ((
					(*it).first.m_indication == LabTrial::indication::cut_resistance_nature_condition
					||
					(*it).first.m_indication == LabTrial::indication::cut_resistance_task_condition)
					&&
					(*it).first.every_cut_experiment)

				{
					if (!natural_conditions_headered 
						&&
						(*it).first.m_indication == LabTrial::indication::cut_resistance_nature_condition)
					{
						sprintf(SX, "A%d", r);
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	
						LabTrialValueType vt = (*it).first;
						m_range.SetValue(COleVariant("В природном состоянии:"));
						m_range.ReleaseDispatch();

						natural_conditions_headered = true;
						r++;
					}

					if (!task_conditions_headered 
						&&
						(*it).first.m_indication == LabTrial::indication::cut_resistance_task_condition)
					{
						sprintf(SX, "A%d", r);
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	
						LabTrialValueType vt = (*it).first;
						m_range.SetValue(COleVariant("В водонасыщенном состоянии:"));
						m_range.ReleaseDispatch();

						task_conditions_headered = true;
						r++;
					}



					//if ((*it).first.is_result)
					{
						sprintf(SX, "A%d", r);
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	
						LabTrialValueType vt = (*it).first;
						m_range.SetValue(COleVariant(vt.GetValueTypeString()));
						m_range.BorderAround(COleVariant(long(1)), 2, -4105);
						m_range.ReleaseDispatch();

						sprintf(SX, "B%d", r);
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	
						m_range.SetValue(COleVariant((long)(*it).second.n));
						m_range.BorderAround(COleVariant(long(1)), 2, -4105);
						m_range.ReleaseDispatch();

						
						{
							sprintf(SX, "C%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_n.f)
								m_range.SetValue(COleVariant((*it).second.v_n.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "D%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_S.f)
								m_range.SetValue(COleVariant((*it).second.v_S.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	
						}

						
						{
							sprintf(SX, "E%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_V.f)
								m_range.SetValue(COleVariant((*it).second.v_V.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "F%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.ro_85.f)
								m_range.SetValue(COleVariant((*it).second.ro_85.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "G%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.ro_95.f)
								m_range.SetValue(COleVariant((*it).second.ro_95.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "H%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.ro_99.f)
								m_range.SetValue(COleVariant((*it).second.ro_99.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "I%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_85.f)
								m_range.SetValue(COleVariant((*it).second.v_85.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "J%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_95.f)
								m_range.SetValue(COleVariant((*it).second.v_95.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "K%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_99.f)
								m_range.SetValue(COleVariant((*it).second.v_99.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	
						}

						r++;
					}
				}
			}
			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
		printf("!!!!! m_excel.IsApplicationDispatch()\n");

}

void LabLayer_Pasport_TrialValue(MyExcel & m_excel, map<LabTrialValueType, normative_value>::iterator & it, int & r)
{
	LPDISPATCH pRange; 
	Range10    m_range;
	char SX[32];

	sprintf(SX, "A%d", r);
	VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
	m_range.AttachDispatch(pRange);	
	LabTrialValueType vt = (*it).first;
	m_range.SetValue(COleVariant(vt.GetValueTypeString()));
	m_range.BorderAround(COleVariant(long(1)), 2, -4105);
	m_range.ReleaseDispatch();

	sprintf(SX, "B%d", r);
	VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
	m_range.AttachDispatch(pRange);			   
	m_range.SetValue(COleVariant((long)(*it).second.n));
	m_range.BorderAround(COleVariant(long(1)), 2, -4105);
	m_range.ReleaseDispatch();	

	
	{
		sprintf(SX, "C%d", r);
		VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
		m_range.AttachDispatch(pRange);			   
		if ((*it).second.v_n.f)
			m_range.SetValue(COleVariant((*it).second.v_n.v));
		m_range.BorderAround(COleVariant(long(1)), 2, -4105);
		m_range.ReleaseDispatch();
	}


	
	{
		sprintf(SX, "D%d", r);
		VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
		m_range.AttachDispatch(pRange);			   
		if ((*it).second.v_S.f)
			m_range.SetValue(COleVariant((*it).second.v_S.v));
		m_range.BorderAround(COleVariant(long(1)), 2, -4105);
		m_range.ReleaseDispatch();
	}

	
	{
		sprintf(SX, "E%d", r);
		VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
		m_range.AttachDispatch(pRange);			   
		if ((*it).second.v_V.f)
			m_range.SetValue(COleVariant((*it).second.v_V.v));
		m_range.BorderAround(COleVariant(long(1)), 2, -4105);
		m_range.ReleaseDispatch();
	}


	
	{
		sprintf(SX, "F%d", r);
		VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
		m_range.AttachDispatch(pRange);			   
		if ((*it).second.v_85.f)
			m_range.SetValue(COleVariant((*it).second.v_85.v));
		m_range.BorderAround(COleVariant(long(1)), 2, -4105);
		m_range.ReleaseDispatch();	
	}

	
	{
		sprintf(SX, "G%d", r);
		VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
		m_range.AttachDispatch(pRange);			   
		if ((*it).second.v_95.f)
			m_range.SetValue(COleVariant((*it).second.v_95.v));
		m_range.BorderAround(COleVariant(long(1)), 2, -4105);
		m_range.ReleaseDispatch();	
	}

	
	{
		sprintf(SX, "H%d", r);
		VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
		m_range.AttachDispatch(pRange);			   
		if ((*it).second.v_99.f)
			m_range.SetValue(COleVariant((*it).second.v_99.v));
		m_range.BorderAround(COleVariant(long(1)), 2, -4105);
		m_range.ReleaseDispatch();
	}

	/*if ((*it).second.ro_a.f)
	{
		sprintf(SX, "J%d", r);
		VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
		m_range.AttachDispatch(pRange);			   
		m_range.SetValue(COleVariant((*it).second.ro_a.v));
		m_range.BorderAround(COleVariant(long(1)), 2, -4105);
		m_range.ReleaseDispatch();
	}*/

	r++;


}


void LabLayer_PassportFiz_or_Him(MyExcel & m_excel, map<LabTrialValueType, normative_value>::iterator & it, int & r, LabTrial::indication ind)
{
	LPDISPATCH pRange; 
	Range10    m_range;
	char SX[32];

	if ((*it).first.m_indication == ind)
	{
		if ((*it).first.m_indication == LabTrial::indication::physical
			&& 
			(*it).first.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_ground_type)
		{
			if (false)
			{
				sprintf(SX, "A%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	
				LabTrialValueType vt = (*it).first;
				m_range.SetValue(COleVariant(vt.GetValueTypeString()));
				m_range.BorderAround(COleVariant(long(1)), 2, -4105);
				m_range.ReleaseDispatch();

				sprintf(SX, "C%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
					CGround::ground_type gt = (CGround::ground_type)(long)(*it).second.v_n.v;
					CGround::s_Quantity = CGround::Quantity::singular;
				m_range.SetValue(COleVariant(CGround::GrountTypeToStringRus(gt)));
				m_range.BorderAround(COleVariant(long(1)), 2, -4105);
				m_range.ReleaseDispatch();	

				r++;
			}
			else
			{
				sprintf(SX, "A4");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a4_val = m_range.GetValue();
				CString a4;
				if (a4_val.vt == VT_BSTR)
				{
					a4 = a4_val.bstrVal;
					CGround::ground_type gt = (CGround::ground_type)(long)(*it).second.v_n.v;
					CGround::s_Quantity = CGround::Quantity::singular;
					a4 += " ";
					a4 += CGround::GrountTypeToStringRus(gt);
					m_range.SetValue(COleVariant(a4));
				}

				m_range.ReleaseDispatch();

			}
		}
		else if ((*it).first.m_indication == LabTrial::indication::physical
			&& 
			(*it).first.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_vlazhnost)
		{
			sprintf(SX, "A%d", r);
			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
			m_range.AttachDispatch(pRange);	
			LabTrialValueType vt = (*it).first;
			m_range.SetValue(COleVariant(vt.GetValueTypeString()));
			m_range.BorderAround(COleVariant(long(1)), 2, -4105);
			m_range.ReleaseDispatch();

			sprintf(SX, "B%d", r);
			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
			m_range.AttachDispatch(pRange);			   
			m_range.BorderAround(COleVariant(long(1)), 2, -4105);
			m_range.ReleaseDispatch();	

			sprintf(SX, "C%d", r);
			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
			m_range.AttachDispatch(pRange);			   
			PhysicalLabTrialResults::SandVlazhnost vzh = (PhysicalLabTrialResults::SandVlazhnost)(long)(*it).second.v_n.v;
			m_range.SetValue(COleVariant(PhysicalLabTrialResults::SandVlazhnostToString(vzh)));
			//m_range.BorderAround(COleVariant(long(1)), 2, -4105);
			m_range.ReleaseDispatch();

			sprintf(SX, "C%d:H%d", r, r);
			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
			m_range.AttachDispatch(pRange);			   
			m_range.BorderAround(COleVariant(long(1)), 2, -4105);
			m_range.ReleaseDispatch();	

			r++;
		}
		else if ((*it).first.m_indication == LabTrial::indication::physical
			&& 
			(*it).first.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_Consistencia_nature)
		{
			sprintf(SX, "A%d", r);
			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
			m_range.AttachDispatch(pRange);	
			LabTrialValueType vt = (*it).first;
			m_range.SetValue(COleVariant(vt.GetValueTypeString()));
			m_range.BorderAround(COleVariant(long(1)), 2, -4105);
			m_range.ReleaseDispatch();

			sprintf(SX, "B%d", r);
			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
			m_range.AttachDispatch(pRange);			   
			m_range.BorderAround(COleVariant(long(1)), 2, -4105);
			m_range.ReleaseDispatch();	

			sprintf(SX, "C%d", r);
			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
			m_range.AttachDispatch(pRange);			   
			PhysicalLabTrialResults::Consistencia con = (PhysicalLabTrialResults::Consistencia)(long)(*it).second.v_n.v;
			m_range.SetValue(COleVariant(PhysicalLabTrialResults::ConsistenciaToString(con)));
			//m_range.BorderAround(COleVariant(long(1)), 2, -4105);
			m_range.ReleaseDispatch();	

			sprintf(SX, "C%d:H%d", r, r);
			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
			m_range.AttachDispatch(pRange);			   
			m_range.BorderAround(COleVariant(long(1)), 2, -4105);
			m_range.ReleaseDispatch();	

			r++;
		}				
		else if ((*it).first.m_indication == LabTrial::indication::physical
			&& 
			(*it).first.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_Consistencia_water_saturated)
		{
			sprintf(SX, "A%d", r);
			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
			m_range.AttachDispatch(pRange);	
			LabTrialValueType vt = (*it).first;
			m_range.SetValue(COleVariant(vt.GetValueTypeString()));
			m_range.BorderAround(COleVariant(long(1)), 2, -4105);
			m_range.ReleaseDispatch();
						
			sprintf(SX, "B%d", r);
			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
			m_range.AttachDispatch(pRange);			   
			m_range.BorderAround(COleVariant(long(1)), 2, -4105);
			m_range.ReleaseDispatch();	

			sprintf(SX, "C%d", r);
			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
			m_range.AttachDispatch(pRange);			   
			PhysicalLabTrialResults::Consistencia con = (PhysicalLabTrialResults::Consistencia)(long)(*it).second.v_n.v;
			m_range.SetValue(COleVariant(PhysicalLabTrialResults::ConsistenciaToString(con)));
			//m_range.BorderAround(COleVariant(long(1)), 2, -4105);
			m_range.ReleaseDispatch();

			sprintf(SX, "C%d:H%d", r, r);
			VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
			m_range.AttachDispatch(pRange);			   
			m_range.BorderAround(COleVariant(long(1)), 2, -4105);
			m_range.ReleaseDispatch();	

			r++;
		}
		else //if ((*it).second.n)// чтобы исключить такие параметры как тип грунта и консистенция
		{
			LabLayer_Pasport_TrialValue(m_excel, it, r);
		}

	}


}
void LabLayer_PassportFractions(MyExcel & m_excel, map<LabTrialValueType, normative_value>::iterator & it, int & r)
{
	LPDISPATCH pRange; 
	Range10    m_range;
	char SX[32];

	if ((*it).first.m_indication == LabTrial::indication::fractions)
	{
		if ((*it).first.is_result)
		{
			if ((*it).first.vt_FractionsLabTrialResults == FractionsLabTrialResults::value_type::vt_sand_soil_class)
			{
				sprintf(SX, "A%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	
				LabTrialValueType vt = (*it).first;
				m_range.SetValue(COleVariant(vt.GetValueTypeString()));
				m_range.BorderAround(COleVariant(long(1)), 2, -4105);
				m_range.ReleaseDispatch();

				sprintf(SX, "B%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	
				m_range.SetValue(COleVariant((long)(*it).second.n));
				m_range.BorderAround(COleVariant(long(1)), 2, -4105);
				m_range.ReleaseDispatch();
	
				sprintf(SX, "C%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			  
				short f = (*it).second.v_n.f;
				long v = (long)(*it).second.v_n.v;
				try
				{
					FractionsLabTrialResults::SandSoilsClass sand_soil_class = (FractionsLabTrialResults::SandSoilsClass)v;
					m_range.SetValue(COleVariant(FractionsLabTrialResults::SandSoilsClassToStringSmall(sand_soil_class)));
				}
				catch(...)
				{
				}
				m_range.ReleaseDispatch();

				r++;
			}
			else if ((*it).first.vt_FractionsLabTrialResults == FractionsLabTrialResults::value_type::vt_neodnorodnost)
			{
				sprintf(SX, "A%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	
				LabTrialValueType vt = (*it).first;
				m_range.SetValue(COleVariant(vt.GetValueTypeString()));
				m_range.BorderAround(COleVariant(long(1)), 2, -4105);
				m_range.ReleaseDispatch();
	
				sprintf(SX, "B%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	
				m_range.SetValue(COleVariant((long)(*it).second.n));
				m_range.BorderAround(COleVariant(long(1)), 2, -4105);
				m_range.ReleaseDispatch();

				sprintf(SX, "C%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
				short f = (*it).second.v_n.f;
				long v = (long)(*it).second.v_n.v;
				try
				{
					FractionsLabTrialResults::Neodnorodnost no = (FractionsLabTrialResults::Neodnorodnost)v;
					m_range.SetValue(COleVariant(FractionsLabTrialResults::NeodnorodnostToString(no)));
				}
				catch(...)
				{
				}
				m_range.ReleaseDispatch();

				r++;
			}
	
			else if ((*it).first.vt_FractionsLabTrialResults == FractionsLabTrialResults::value_type::vt_clay_soil_class)
			{
				sprintf(SX, "A%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	
				LabTrialValueType vt = (*it).first;
				m_range.SetValue(COleVariant(vt.GetValueTypeString()));
				m_range.BorderAround(COleVariant(long(1)), 2, -4105);
				m_range.ReleaseDispatch();
	
				sprintf(SX, "B%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	
				m_range.SetValue(COleVariant((long)(*it).second.n));
				m_range.BorderAround(COleVariant(long(1)), 2, -4105);
				m_range.ReleaseDispatch();

				sprintf(SX, "C%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
				short f = (*it).second.v_n.f;
				long v = (long)(*it).second.v_n.v;
				try
				{
					FractionsLabTrialResults::ClaySoilsClass clay_soil_class = (FractionsLabTrialResults::ClaySoilsClass)v;
					m_range.SetValue(COleVariant(FractionsLabTrialResults::ClaySoilsClassToStringSmall(clay_soil_class)));
				}
				catch(...)
				{
				}
				m_range.ReleaseDispatch();

				r++;
			}
			else
			{
				LabLayer_Pasport_TrialValue(m_excel, it, r);
			}
		}
	}
}

void LabLayer::PassportFiz(const char * fn)
{
	char file[4098];
	char file0[4098];

	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			sprintf(file, "%s_Normatyv_FizR.xls", fn);
			sprintf(file0, "%s\\Normatyv_FizR.xls", Laboratory::FormsDir.c_str());
		}
		break;
	case BaseLab::language::ukrainian:
		{
			sprintf(file, "%s_Normatyv_Fiz.xls", fn);
			sprintf(file0, "%s\\Normatyv_Fiz.xls", Laboratory::FormsDir.c_str());
		}
		break;
	}
	CopyFile(file0, file, FALSE);

	int fr = 7;
	int r = fr;
	char SX[32];
 
	LPDISPATCH pRange; 
	Range10    m_range;

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);

			if (true)
			{
				sprintf(SX, "A3");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a3_val = m_range.GetValue();
				CString a3;
				if (a3_val.vt == VT_BSTR)
				{
					a3 = a3_val.bstrVal;

					char s[128];
					sprintf(s, "%s\0", this->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
					OemToChar(s,s);	
#endif
					a3 += " ";
					a3 += s;
					m_range.SetValue(COleVariant(a3));
				}

				m_range.ReleaseDispatch();
			}

			for (map<LabTrialValueType, normative_value>::iterator 
				it = this->lab_normatives->values.begin();
				it != this->lab_normatives->values.end(); it++)
			{
				LabLayer_PassportFiz_or_Him(m_excel, it, r, LabTrial::indication::physical);
			}

			for (map<LabTrialValueType, normative_value>::iterator 
				it = this->lab_normatives->values.begin();
				it != this->lab_normatives->values.end(); it++)
			{
				LabLayer_PassportFiz_or_Him(m_excel, it, r, LabTrial::indication::chemical);
			}			
			
			for (map<LabTrialValueType, normative_value>::iterator 
				it = this->lab_normatives->values.begin();
				it != this->lab_normatives->values.end(); it++)
			{
				LabLayer_PassportFractions(m_excel, it, r);
			}

			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
		printf("!!!!! m_excel.IsApplicationDispatch()\n");

}
//
void LabLayer::PassportComp0(const char * fn, bool every)
{
	char file[4098];
	char file0[4098];

	if (every)
	{
		switch (BaseLab::PassportLanguage)
		{
		case BaseLab::language::russian:
			{
				sprintf(file, "%s_Normatyv_CompListR.xls", fn);
				sprintf(file0, "%s\\Normatyv_CompListR.xls", Laboratory::FormsDir.c_str());
			}
			break;
		case BaseLab::language::ukrainian:
			{
				sprintf(file, "%s_Normatyv_CompList.xls", fn);
				sprintf(file0, "%s\\Normatyv_CompList.xls", Laboratory::FormsDir.c_str());
			}
			break;
		}
	}
	else
	{
		switch (BaseLab::PassportLanguage)
		{
		case BaseLab::language::russian:
			{
				sprintf(file, "%s_Normatyv_CompListAllR.xls", fn);
				sprintf(file0, "%s\\Normatyv_CompListR.xls", Laboratory::FormsDir.c_str());
			}
			break;
		case BaseLab::language::ukrainian:
			{
				sprintf(file, "%s_Normatyv_CompListAll.xls", fn);
				sprintf(file0, "%s\\Normatyv_CompList.xls", Laboratory::FormsDir.c_str());
			}
			break;
		}
	}
	CopyFile(file0, file, FALSE);

	int fr = 7;
	int r = fr;
	char SX[32];

	CompressionLabTrial::type com_type = CompressionLabTrial::type::undefined;
 
	LPDISPATCH pRange; 
	Range10    m_range;

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);

			if (true)
			{
				sprintf(SX, "A3");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a3_val = m_range.GetValue();
				CString a3;
				if (a3_val.vt == VT_BSTR)
				{
					a3 = a3_val.bstrVal;

					char s[128];
					sprintf(s, "%s\0", this->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
					OemToChar(s,s);	
#endif
					a3 += " ";
					a3 += s;
					m_range.SetValue(COleVariant(a3));
				}

				m_range.ReleaseDispatch();
			}

			for (map<LabTrialValueType, normative_value>::iterator 
				it = this->lab_normatives->values.begin();
				it != this->lab_normatives->values.end(); it++)
			{
				if ((*it).first.m_indication == LabTrial::indication::physical)
				{
					if ((*it).first.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_ground_type)
					{
						if (false)
						{
							sprintf(SX, "A%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);	
							LabTrialValueType vt = (*it).first;
							m_range.SetValue(COleVariant(vt.GetValueTypeString()));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();

							sprintf(SX, "C%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
								CGround::ground_type gt = (CGround::ground_type)(long)(*it).second.v_n.v;
								CGround::s_Quantity = CGround::Quantity::singular;
							m_range.SetValue(COleVariant(CGround::GrountTypeToStringRus(gt)));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	

							r++;
						}
						else
						{
							sprintf(SX, "A4");
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);	

							VARIANT a4_val = m_range.GetValue();
							CString a4;
							if (a4_val.vt == VT_BSTR)
							{
								a4 = a4_val.bstrVal;
								CGround::ground_type gt = (CGround::ground_type)(long)(*it).second.v_n.v;
								CGround::s_Quantity = CGround::Quantity::singular;
								a4 += " ";
								a4 += CGround::GrountTypeToStringRus(gt);
								m_range.SetValue(COleVariant(a4));
							}

							m_range.ReleaseDispatch();

						}
					}
				}
				if ((*it).first.m_indication == LabTrial::indication::compression_3)
				{
					LabTrialValueType vt = (*it).first;
					bool to_fill;
					if (every)
					{
						to_fill = vt.IsEvery() == every 
							|| 
							vt.vt_Compression_3.Get_n_compression_value_type() == 0;
					}
					else
					{
						//по всей совокупности опытов
						to_fill = vt.IsEvery() == every;
					}
					if (to_fill)
					{

						if (vt.vt_Compression_3.com_type != com_type)
						{

							sprintf(SX, "A%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);	
							m_range.SetValue(COleVariant(CompressionLabTrial::CompressionLabTrialTypeToStringRus(vt.vt_Compression_3.com_type)));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();

							com_type = vt.vt_Compression_3.com_type;
							r++;
						}


						sprintf(SX, "A%d", r);
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	
						m_range.SetValue(COleVariant(vt.GetValueTypeString()));
						m_range.BorderAround(COleVariant(long(1)), 2, -4105);
						m_range.ReleaseDispatch();

						sprintf(SX, "B%d", r);
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);			   
						m_range.SetValue(COleVariant((long)(*it).second.n));
						m_range.BorderAround(COleVariant(long(1)), 2, -4105);
						m_range.ReleaseDispatch();	

						
						{
							sprintf(SX, "C%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_n.f)
								m_range.SetValue(COleVariant((*it).second.v_n.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "D%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_S.f)
								m_range.SetValue(COleVariant((*it).second.v_S.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						
						{
							sprintf(SX, "E%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_V.f)
								m_range.SetValue(COleVariant((*it).second.v_V.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}


						
						{
							sprintf(SX, "F%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_85.f)
								m_range.SetValue(COleVariant((*it).second.v_85.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	
						}

						
						{
							sprintf(SX, "G%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_95.f)
								m_range.SetValue(COleVariant((*it).second.v_95.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	
						}

						
						{
							sprintf(SX, "H%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							if ((*it).second.v_99.f)
								m_range.SetValue(COleVariant((*it).second.v_99.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						/*if ((*it).second.ro_a.f)
						{
							sprintf(SX, "J%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant((*it).second.ro_a.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}*/

						r++;
					}

				}
			}
			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
		printf("!!!!! m_excel.IsApplicationDispatch()\n");

}

void FillCompRow(MyExcel & m_excel, Range10 & m_range, map<LabTrialValueType, normative_value>::iterator & it, int r, LabNormatives::type t)
{
	LPDISPATCH pRange; 
	

	char SX[32];

	sprintf(SX, "C%d", r);
	VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
	m_range.AttachDispatch(pRange);	
	m_range.SetValue(COleVariant((long)(*it).second.n));
	m_range.ReleaseDispatch();

	if ((*it).second.v_n.f)
	{
		sprintf(SX, "D%d", r);
		VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
		m_range.AttachDispatch(pRange);			   
		m_range.SetValue(COleVariant((*it).second.v_n.v));
		m_range.ReleaseDispatch();
	}
	if ((*it).second.v_S.f)
	{
		sprintf(SX, "E%d", r);
		VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
		m_range.AttachDispatch(pRange);			   
		m_range.SetValue(COleVariant((*it).second.v_S.v));
		m_range.ReleaseDispatch();	
	}
	if ((*it).second.v_V.f)
	{
		sprintf(SX, "F%d", r);
		VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
		m_range.AttachDispatch(pRange);			   
		m_range.SetValue(COleVariant((*it).second.v_V.v));
		m_range.ReleaseDispatch();
	}

	switch(t)
	{
	case LabNormatives::type::raschotn_85:
		{
			if ((*it).second.ro_85.f)
			{
				sprintf(SX, "G%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant((*it).second.ro_85.v));
				m_range.ReleaseDispatch();
			}

			if ((*it).second.v_85.f)
			{
				sprintf(SX, "H%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant((*it).second.v_85.v));
				m_range.ReleaseDispatch();
			}
		}
		break;
	case LabNormatives::type::raschotn_95:
		{
			if ((*it).second.ro_95.f)
			{
				sprintf(SX, "G%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant((*it).second.ro_95.v));
				m_range.ReleaseDispatch();
			}
			if ((*it).second.v_95.f)
			{
				sprintf(SX, "H%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant((*it).second.v_95.v));
				m_range.ReleaseDispatch();
			}
		}
		break;
	case LabNormatives::type::raschotn_99:
		{
			if ((*it).second.ro_99.f)
			{
				sprintf(SX, "G%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant((*it).second.ro_99.v));
				m_range.ReleaseDispatch();
			}
			if ((*it).second.v_99.f)
			{
				sprintf(SX, "H%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant((*it).second.v_99.v));
				m_range.ReleaseDispatch();	
			}
		}
		break;
	}

}

void FillCompRow2(MyExcel & m_excel, Range10 & m_range, map<LabTrialValueType, normative_value>::iterator & it, int r, LabNormatives::type t)
{
	LPDISPATCH pRange; 
	

	char SX[32];

	sprintf(SX, "I%d", r);
	VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
	m_range.AttachDispatch(pRange);	
	m_range.SetValue(COleVariant((long)(*it).second.n));
	m_range.ReleaseDispatch();

	if ((*it).second.v_n.f)
	{
		sprintf(SX, "J%d", r);
		VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
		m_range.AttachDispatch(pRange);			   
		m_range.SetValue(COleVariant((*it).second.v_n.v));
		m_range.ReleaseDispatch();
	}
	if ((*it).second.v_S.f)
	{
		sprintf(SX, "K%d", r);
		VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
		m_range.AttachDispatch(pRange);			   
		m_range.SetValue(COleVariant((*it).second.v_S.v));
		m_range.ReleaseDispatch();	
	}
	if ((*it).second.v_V.f)
	{
		sprintf(SX, "L%d", r);
		VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
		m_range.AttachDispatch(pRange);			   
		m_range.SetValue(COleVariant((*it).second.v_V.v));
		m_range.ReleaseDispatch();
	}

	switch(t)
	{
	case LabNormatives::type::raschotn_85:
		{
			if ((*it).second.ro_85.f)
			{
				sprintf(SX, "M%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant((*it).second.ro_85.v));
				m_range.ReleaseDispatch();
			}

			if ((*it).second.v_85.f)
			{
				sprintf(SX, "N%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant((*it).second.v_85.v));
				m_range.ReleaseDispatch();
			}
		}
		break;
	case LabNormatives::type::raschotn_95:
		{
			if ((*it).second.ro_95.f)
			{
				sprintf(SX, "M%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant((*it).second.ro_95.v));
				m_range.ReleaseDispatch();
			}
			if ((*it).second.v_95.f)
			{
				sprintf(SX, "N%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant((*it).second.v_95.v));
				m_range.ReleaseDispatch();
			}
		}
		break;
	case LabNormatives::type::raschotn_99:
		{
			if ((*it).second.ro_99.f)
			{
				sprintf(SX, "M%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant((*it).second.ro_99.v));
				m_range.ReleaseDispatch();
			}
			if ((*it).second.v_99.f)
			{
				sprintf(SX, "N%d", r);
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);			   
				m_range.SetValue(COleVariant((*it).second.v_99.v));
				m_range.ReleaseDispatch();	
			}
		}
		break;
	}

}

void LabLayer::PassportComp(const char * fn)
{

	LabNormatives::type t = LabNormatives::type::raschotn_95;

	char file[4098];
	char file0[4098];

	switch (BaseLab::PassportLanguage)
	{
	case BaseLab::language::russian:
		{
			sprintf(file, "%s_Normatyv_CompR.xls", fn);
			sprintf(file0, "%s\\Normatyv_CompR.xls", Laboratory::FormsDir.c_str());
		}
		break;
	case BaseLab::language::ukrainian:
		{
			sprintf(file, "%s_Normatyv_Comp.xls", fn);
			sprintf(file0, "%s\\Normatyv_Comp.xls", Laboratory::FormsDir.c_str());
		}
		break;
	}
	CopyFile(file0, file, FALSE);

	int fr = 14;
	int r = fr;
	char SX[32];
 
	LPDISPATCH pRange; 
	Range10    m_range;

	MyExcel m_excel;
	m_excel.ExcelOleLoad();
	if (m_excel.IsApplicationDispatch())
	{
		try
		{
			m_excel.ExcelOleExecute(file);



			if (true)
			{
				sprintf(SX, "A3");
				VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
				m_range.AttachDispatch(pRange);	

				VARIANT a3_val = m_range.GetValue();
				CString a3;
				if (a3_val.vt == VT_BSTR)
				{
					a3 = a3_val.bstrVal;

					char s[128];
					sprintf(s, "%s\0", this->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
					OemToChar(s,s);	
#endif
					a3 += " ";
					a3 += s;
					m_range.SetValue(COleVariant(a3));
				}

				m_range.ReleaseDispatch();
			}


			//bool natural_conditions_headered = false;
			//bool task_conditions_headered = false;


			for (map<LabTrialValueType, normative_value>::iterator 
				it = this->lab_normatives->values.begin();
				it != this->lab_normatives->values.end(); it++)
			{
				if ((*it).first.m_indication == LabTrial::indication::physical)
				{
					if ((*it).first.vt_PhysicalLabTrialResults == PhysicalLabTrialResults::value_type::vt_ground_type)
					{					
						sprintf(SX, "A4");
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	

						VARIANT a4_val = m_range.GetValue();
						CString a4;
						if (a4_val.vt == VT_BSTR)
						{
							a4 = a4_val.bstrVal;
							CGround::ground_type gt = (CGround::ground_type)(long)(*it).second.v_n.v;
							CGround::s_Quantity = CGround::Quantity::singular;
							a4 += " ";
							a4 += CGround::GrountTypeToStringRus(gt);
							m_range.SetValue(COleVariant(a4));
						}

						m_range.ReleaseDispatch();
					}
				}

				if ((*it).first.m_indication == LabTrial::indication::compression_3)
				{
					LabTrialValueType vt = (*it).first;
					if ((*it).first.is_result && vt.IsEvery() == 1)
					{	
						switch((*it).first.vt_Compression_3.com_type)
						{
						case CompressionLabTrial::type::nature_condition:
							{
								switch((*it).first.vt_Compression_3.vt_Compression_nature.n_compression_value_type)
								{
								case 0:
									{
										switch((*it).first.vt_Compression_3.vt_Compression_nature.vt_CompressionLabTrialResults_0)
										{
										}
									}
									break;
#if USE_COMPR_PO_OTN_DEF
								case 1:
									{
										switch((*it).first.vt_Compression_3.vt_Compression_nature.vt_CompressionLabTrialResults_1)
										{
										case CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_01_02_interval:
											{
												FillCompRow(m_excel, m_range, it, 9, t);
											}
											break;
										case CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_defined_interval:
											{																								
												FillCompRow(m_excel, m_range, it, 10, t);
											}
											break;
										case CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_01_02_interval_mk:
											{
												FillCompRow(m_excel, m_range, it, 11, t);
											}
											break;
										}
									}
									break;
#endif
								case 2:
									{
										switch((*it).first.vt_Compression_3.vt_Compression_nature.vt_CompressionLabTrialResults_2)
										{
										case CompressionLabTrialResults::value_type_2::vt_a_in_01_02_interval:
											{
												FillCompRow(m_excel, m_range, it, 7, t);
											}
											break;
										case CompressionLabTrialResults::value_type_2::vt_a_in_defined_interval:
											{
												FillCompRow(m_excel, m_range, it, 8, t);
											}
											break;
										}
									}
									break;
								case 3:
									{
										switch((*it).first.vt_Compression_3.vt_Compression_nature.vt_CompressionLabTrialResults_3)
										{
										}
									}
									break;
								}
							}
							break;
						case CompressionLabTrial::type::task_condition:
							{
								switch((*it).first.vt_Compression_3.vt_Compression_task.n_compression_value_type)
								{
								case 0:
									{
										switch((*it).first.vt_Compression_3.vt_Compression_task.vt_CompressionLabTrialResults_0)
										{
										}
									}
									break;
#if USE_COMPR_PO_OTN_DEF
								case 1:
									{
										switch((*it).first.vt_Compression_3.vt_Compression_task.vt_CompressionLabTrialResults_1)
										{
										case CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_01_02_interval:
											{
												FillCompRow2(m_excel, m_range, it, 9, t);
											}
											break;
										case CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_defined_interval:
											{																								
												FillCompRow2(m_excel, m_range, it, 10, t);
											}
											break;
										case CompressionLabTrialResults::value_type_1::vt_deformation_module_y_in_01_02_interval_mk:
											{
												FillCompRow2(m_excel, m_range, it, 11, t);
											}
											break;
										}
									}
									break;
#endif
								case 2:
									{
										switch((*it).first.vt_Compression_3.vt_Compression_task.vt_CompressionLabTrialResults_2)
										{
										case CompressionLabTrialResults::value_type_2::vt_a_in_01_02_interval:
											{
												FillCompRow(m_excel, m_range, it, 7, t);
											}
											break;
										case CompressionLabTrialResults::value_type_2::vt_a_in_defined_interval:
											{
												FillCompRow(m_excel, m_range, it, 8, t);
											}
											break;
										}
									}
									break;
								case 3:
									{
										switch((*it).first.vt_Compression_3.vt_Compression_task.vt_CompressionLabTrialResults_3)
										{
										}
									}
									break;
								}
							}
							break;
						case CompressionLabTrial::type::shrinkage:
							{
							}
							break;
						}
					}
#if 0

					if (vt.IsEvery() == 1 || vt.vt_Compression_3.Get_n_compression_value_type() == 0)
					{
						sprintf(SX, "A%d", r);
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	
						m_range.SetValue(COleVariant(vt.GetValueTypeString()));
						m_range.ReleaseDispatch();

						sprintf(SX, "B%d", r);
						VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
						m_range.AttachDispatch(pRange);	
						m_range.SetValue(COleVariant((long)(*it).second.n));
						m_range.BorderAround(COleVariant(long(1)), 2, -4105);
						m_range.ReleaseDispatch();

						if ((*it).second.v_n.f)
						{
							sprintf(SX, "C%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant((*it).second.v_n.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						if ((*it).second.v_S.f)
						{
							sprintf(SX, "D%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant((*it).second.v_S.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	
						}

						if ((*it).second.v_V.f)
						{
							sprintf(SX, "E%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant((*it).second.v_V.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						/*if ((*it).second.ro_a.f)
						{
							sprintf(SX, "E%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant((*it).second.ro_a.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}*/

						if ((*it).second.v_85.f)
						{
							sprintf(SX, "G%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant((*it).second.v_85.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						if ((*it).second.v_95.f)
						{
							sprintf(SX, "H%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant((*it).second.v_95.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();
						}

						if ((*it).second.v_99.f)
						{
							sprintf(SX, "I%d", r);
							VERIFY(pRange = m_excel.m_worksheet.GetRange(COleVariant(SX)));
							m_range.AttachDispatch(pRange);			   
							m_range.SetValue(COleVariant((*it).second.v_99.v));
							m_range.BorderAround(COleVariant(long(1)), 2, -4105);
							m_range.ReleaseDispatch();	
						}

						r++;
					}
#endif
				}
			}
			m_excel.m_workbook.Save();
		}
		catch (CException* pe)
		{
			// catch errors from WinINet 
			TCHAR szErr[4098]; 
			pe->GetErrorMessage(szErr, 4098); 
			AfxMessageBox(szErr);
			pe->Delete();
		}
		m_excel.ExcelOleRelease();
	}
	else
		printf("!!!!! m_excel.IsApplicationDispatch()\n");

}

HTREEITEM LabNumber::AddItem_ToTree(HWND hwndTV, HTREEITEM h1)
{
	LabObject * lab_object = dynamic_cast<LabObject *>(this);

    char szItemText[1024]; // label text of tree-view item 

	const char * sh = "шурф";							
	const char * sw = "скв.";							
	const char * s;	

	switch(m_mine_working_type)
	{
	case LabNumber::mine_working_type::hole:
		{
			//sprintf(s,"шурф\0");
			s = "шурф";
		}
		break;
	case LabNumber::mine_working_type::well:
		{
			//sprintf(s,"скв.\0");
			s = "скв.";
		}
		break;
	default:
			s = "выработка";
			break;

	}
	sprintf(szItemText, "лаб № %s %s № %s глубина %f\0", this->ID.c_str(), s, mine_working_number.c_str(), depth);
	DeleteEndZeros(szItemText);
	HTREEITEM h2 = AddItemToTree(hwndTV, szItemText, lab_object, h1); 
	return h2; 
}
void PhysicalLabParametersInitial::AddInitialParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<PhysicalLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
			sprintf(szItemText, "%s\0", PhysicalLabTrial::ValueTypeToString((*it).first));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}
void PhysicalLabParametersResults::AddResultParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<PhysicalLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
			sprintf(szItemText, "%s\0", PhysicalLabTrialResults::ValueTypeToString((*it).first));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}



void ChemicalLabParametersInitial::AddInitialParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<ChemicalLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
			sprintf(szItemText, "%s\0", ChemicalLabTrial::ValueTypeToString((*it).first));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}
void ChemicalLabParametersResults::AddResultParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<ChemicalLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
			sprintf(szItemText, "__\0");
//			sprintf(szItemText, "%s\0", ChemicalLabTrialResults::ValueTypeToString((*it).first));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}


void FractionsLabParametersInitial::AddInitialParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
#if FRACTION_LAB_PARAM_INITIAL_MAP
	for (map<FractionsLabTrial::value_type, LabParameter*>::iterator mit = m_params.begin(); 
		mit != m_params.end(); mit++)
	{
		if ((*mit).first == FractionsLabTrial::value_type::vt_fractions_content)
		{
			for (vector<fraction_lab_param>::iterator vit = m_fractions_content.begin(); 
				vit != m_fractions_content.end(); vit++)
			{
				if ((*vit).lab_param)
				{
					LabParam * lab_param = dynamic_cast<LabParam *>((*vit).lab_param);
					//sprintf(szItemText, "%s диам. %f\0", "Содержание фракций", (*it).fraction_diameter);

					char shigh[4096];
					char slow[4096];
					sprintf(shigh, "%f", (*vit).fraction_diameter_high);
					sprintf(slow,  "%f", (*vit).fraction_diameter_low);
					DeleteEndZeros(shigh);
					DeleteEndZeros(slow);	
					
					if ((*vit).fraction_diameter_high == DBL_MAX)
					{
						sprintf(szItemText, "%s диам. > %s", "Содержание фракций", slow);
					}
					else if ((*vit).fraction_diameter_low == -DBL_MAX)
					{
						sprintf(szItemText, "%s диам. < %s", "Содержание фракций", shigh);
					}
					else
					{
						sprintf(szItemText, "%s диам. %s - %s", "Содержание фракций", shigh, slow);
					}

					HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
				}
			}
		}
		else
		{
			if ((*mit).second)
			{
				LabParam * lab_param = dynamic_cast<LabParam *>((*mit).second);
				sprintf(szItemText, "%s\0", FractionsLabTrial::ValueTypeToString((*mit).first));
				HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
			}
		}
	}
#endif
}
void FractionsLabParametersResults::AddResultParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<FractionsLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
			sprintf(szItemText, "%s\0", FractionsLabTrialResults::ValueTypeToString((*it).first));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}


void CompressionLabParametersInitial::AddInitialParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 

	for (vector<compression_lab_param>::iterator it = m_absolute_deformations.begin(); 
		it != m_absolute_deformations.end(); it++)
	{
		if ((*it).lab_param)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).lab_param);
			sprintf(szItemText, "%s давл. %f\0", "Абсолютная деформация", (*it).compression_pressure);
			DeleteEndZeros(szItemText);
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}
void CompressionLabParametersResults::AddResultParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<CompressionLabTrialResults::value_type_0, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
			sprintf(szItemText, "%s\0", CompressionLabTrialResults::ValueTypeToString((*it).first, this->lab_parameters ? this->lab_parameters->lab_layer : NULL));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}
#if USE_COMPR_PO_OTN_DEF	
void CompressionLabParametersResults1::AddResultParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<CompressionLabTrialResults::value_type_1, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
			sprintf(szItemText, "%s\0", CompressionLabTrialResults::ValueTypeToString((*it).first, this->lab_parameters ? this->lab_parameters->lab_layer : NULL, this->every));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}
#endif
void CompressionLabParametersResults2::AddResultParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<CompressionLabTrialResults::value_type_2, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
			sprintf(szItemText, "%s\0", CompressionLabTrialResults::ValueTypeToString((*it).first, this->lab_parameters ? this->lab_parameters->lab_layer : NULL, this->every));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}

void CompressionLabParametersResults3::AddResultParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<CompressionLabTrialResults::value_type_3, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
			sprintf(szItemText, "%s\0", CompressionLabTrialResults::ValueTypeToString((*it).first, this->lab_parameters ? this->lab_parameters->lab_layer : NULL, this->every));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}

void CompressionLabParametersResult_tri::AddResultParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<CompressionLabTrialResults3::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
			sprintf(szItemText, "%s\0", CompressionLabTrialResults3::ValueTypeToString((*it).first));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}
void CutLabParametersInitial::AddInitialParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
#if CUT_LAB_PARAM_INITIAL_MAP
	for (map<CutLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
			sprintf(szItemText, "%s\0", CutLabTrial::ValueTypeToString((*it).first));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
#endif
	for (vector<cut_lab_param>::iterator it = m_cut_resistance.begin(); 
		it != m_cut_resistance.end(); it++)
	{
		if ((*it).lab_param)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).lab_param);
			sprintf(szItemText, "%s давл. %f\0", "Сопротивление срезу", (*it).cut_pressure);
			DeleteEndZeros(szItemText);
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}
void CutLabParametersResults::AddResultParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<CutLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
			sprintf(szItemText, "%s\0", CutLabTrialResults::ValueTypeToString((*it).first, true));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}
void CutLabParametersResults_common::AddResultParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<CutLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
			sprintf(szItemText, "%s\0", CutLabTrialResults::ValueTypeToString((*it).first, false));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}

void PressingLabParametersInitial::AddInitialParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<PressingLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
//			sprintf(szItemText, "%s\0", PressingLabTrial::ValueTypeToString((*it).first));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}
void PressingLabParametersResults::AddResultParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<PressingLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
//			sprintf(szItemText, "%s\0", PressingLabTrialResults::ValueTypeToString((*it).first));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}


void FiltrationLabParametersInitial::AddInitialParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<FiltrationLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
//			sprintf(szItemText, "%s\0", FiltrationLabTrial::ValueTypeToString((*it).first));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}
void FiltrationLabParametersResults::AddResultParams_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	for (map<FiltrationLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
		{
			LabParam * lab_param = dynamic_cast<LabParam *>((*it).second);
//			sprintf(szItemText, "%s\0", FiltrationLabTrialResults::ValueTypeToString((*it).first));
			HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		}
	}
}

HTREEITEM CutLabParametersResults_common::AddParam_ToTree(HWND hwndTV, HTREEITEM h1)
{
	LabParam * lab_param = dynamic_cast<LabParam *>(this);
    char szItemText[1024]; // label text of tree-view item 
	sprintf(szItemText, "по общей совокупности опытов \0");
	HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		
	this->AddResultParams_ToTree(hwndTV, h2);

	return h2; 
}
#if USE_COMPR_PO_OTN_DEF	
HTREEITEM CompressionLabParametersResults1::AddParam_ToTree(HWND hwndTV, HTREEITEM h1)
{
	LabParam * lab_param = dynamic_cast<LabParam *>(this);
    char szItemText[1024]; // label text of tree-view item 
	if (this->every)
        sprintf(szItemText, "по относительной деформации\0");
	else
        sprintf(szItemText, "по общей совокупности опытов по относительной деформации\0");
	HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		
	this->AddResultParams_ToTree(hwndTV, h2);

	return h2; 
}
#endif
HTREEITEM CompressionLabParametersResults2::AddParam_ToTree(HWND hwndTV, HTREEITEM h1)
{
	LabParam * lab_param = dynamic_cast<LabParam *>(this);
    char szItemText[1024]; // label text of tree-view item 
	if (this->every)
        sprintf(szItemText, "по компрессионной кривой\0");
	else
        sprintf(szItemText, "по общей совокупности опытов по компрессионной кривой\0");
	HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		
	this->AddResultParams_ToTree(hwndTV, h2);

	return h2; 
}
HTREEITEM CompressionLabParametersResults3::AddParam_ToTree(HWND hwndTV, HTREEITEM h1)
{
	LabParam * lab_param = dynamic_cast<LabParam *>(this);
    char szItemText[1024]; // label text of tree-view item 
	if (this->every)
        sprintf(szItemText, "прогноз штампа по Гурвичу\0");
	else
        sprintf(szItemText, "по общей совокупности опытов прогноз штампа по Гурвичу\0");

	HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		
	this->AddResultParams_ToTree(hwndTV, h2);

	return h2; 
}

HTREEITEM CompressionLabParametersResult_tri::AddParam_ToTree(HWND hwndTV, HTREEITEM h1)
{
	LabParam * lab_param = dynamic_cast<LabParam *>(this);
    char szItemText[1024]; // label text of tree-view item 
        
	sprintf(szItemText, "Параметры просадочности\0");

	HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		
	this->AddResultParams_ToTree(hwndTV, h2);

	return h2; 
}

HTREEITEM LabParametersResults::AddParam_ToTree(HWND hwndTV, HTREEITEM h1)
{
	LabParam * lab_param = dynamic_cast<LabParam *>(this);
    char szItemText[1024]; // label text of tree-view item 
	sprintf(szItemText, "рассчитанные по каждому опыту\0");
	HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 

	//call virtual		
	this->AddResultParams_ToTree(hwndTV, h2);

	return h2; 
}

HTREEITEM LabParametersInitial::AddParam_ToTree(HWND hwndTV, HTREEITEM h1)
{
	LabParam * lab_param = dynamic_cast<LabParam *>(this);
    char szItemText[1024]; // label text of tree-view item 
	sprintf(szItemText, "исходные данные\0");
	HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
		
	//call virtual		
	this->AddInitialParams_ToTree(hwndTV, h2);

	return h2; 
}
HTREEITEM LabParameters::AddParam_ToTree(HWND hwndTV, HTREEITEM h1)
{
	LabParam * lab_param = dynamic_cast<LabParam *>(this);
    char szItemText[1024]; // label text of tree-view item 

	sprintf(szItemText, "%s\0", LabTrial::LabTrialTypeToStringRus(this->m_indication));
	HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 
	
	if (this->parameters_initial)
	{
		HTREEITEM h3_1 = this->parameters_initial->AddParam_ToTree(hwndTV, h2);
	}
	if (this->parameters_results)
	{
		HTREEITEM h3_2 = this->parameters_results->AddParam_ToTree(hwndTV, h2);
	}
	return h2; 
}
HTREEITEM CompressionLabParameters3::AddParam_ToTree(HWND hwndTV, HTREEITEM h1)
{
	LabParam * lab_param = dynamic_cast<LabParam *>(this);
    char szItemText[1024]; // label text of tree-view item 

	sprintf(szItemText, "%s\0", LabTrial::LabTrialTypeToStringRus(this->m_indication));
	HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param, h1); 

	this->params_nature.AddParam_ToTree(hwndTV, h2);
	this->params_task.AddParam_ToTree(hwndTV, h2);
	this->params_shrinkage.AddParam_ToTree(hwndTV, h2);
	this->params_tri.AddParam_ToTree(hwndTV, h2);

	return h2; 
}

HTREEITEM CompressionLabParameters::AddParam_ToTree(HWND hwndTV, HTREEITEM h1)
{

	HTREEITEM h2 = this->LabParameters::AddParam_ToTree(hwndTV, h1);

#if USE_COMPR_PO_OTN_DEF	
	if (this->parameters_results1_every)
	{
		HTREEITEM h3_3 = this->parameters_results1_every->AddParam_ToTree(hwndTV, h2);
	}	
	if (this->parameters_results1_common)
	{
		HTREEITEM h3_3 = this->parameters_results1_common->AddParam_ToTree(hwndTV, h2);
	}
#endif
	if (this->parameters_results2_every)
	{
		HTREEITEM h3_3 = this->parameters_results2_every->AddParam_ToTree(hwndTV, h2);
	}
	if (this->parameters_results2_common)
	{
		HTREEITEM h3_3 = this->parameters_results2_common->AddParam_ToTree(hwndTV, h2);
	}
	if (this->parameters_results3_every)
	{
		HTREEITEM h3_4 = this->parameters_results3_every->AddParam_ToTree(hwndTV, h2);
	}
	if (this->parameters_results3_common)
	{
		HTREEITEM h3_4 = this->parameters_results3_common->AddParam_ToTree(hwndTV, h2);
	}
	return h2; 
}
HTREEITEM CutLabParameters::AddParam_ToTree(HWND hwndTV, HTREEITEM h1)
{

	HTREEITEM h2 = this->LabParameters::AddParam_ToTree(hwndTV, h1);

	if (this->parameters_results_common)
	{
		HTREEITEM h3_3 = this->parameters_results_common->AddParam_ToTree(hwndTV, h2);
	}
	return h2; 
}
HTREEITEM LabLayer::AddParam_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	char s[128];
	sprintf(s, "%s\0", this->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
	OemToChar(s,s);	
#endif
	sprintf(szItemText, "лаб.слой %s, анализов %u, имя файла %s", s, lab_numbers.size(), this->filename.c_str());
	LabParam * lab_param = dynamic_cast<LabParam *>(this);
	HTREEITEM h2 = AddParamToTree(hwndTV, szItemText, lab_param); 

	if (lab_parameter_depth)
	{
//		lab_parameter_depth->AddParam_ToTree(hwndTV, h2);
		LabParam * lab_param = dynamic_cast<LabParam *>(lab_parameter_depth);
		sprintf(szItemText, "Глубина\0");
		HTREEITEM h3 = AddParamToTree(hwndTV, szItemText, lab_param, h2); 
	}
	
	for (map<LabTrial::indication, LabParameters*>::iterator it = lab_parameters.begin(); 
		it != lab_parameters.end(); it++)
	{
		if ((*it).second)
			(*it).second->AddParam_ToTree(hwndTV, h2);
	}
	return h2; 
	//=============================================================
}
#if LABORATORY_WITH_SURFDOC
Laboratory::Laboratory(SurfDoc * doc, double _pressure_interval_01_02_0)
#else
Laboratory::Laboratory(void * doc, double _pressure_interval_01_02_0)
#endif
{
	m_doc = doc; 
	hwndTV = NULL;
	hwndTV2 = NULL;

	this->hContextWindow = NULL;

	Init(_pressure_interval_01_02_0);
}
void Laboratory::Init(double _pressure_interval_01_02_0)
{
	CompressionLabTrialResults::deformation_module_01_02_pressure_interval[0] = _pressure_interval_01_02_0;
	CompressionLabTrialResults::deformation_module_01_02_pressure_interval[1] = 0.2;

//	CompressionLabTrialResults::deformation_module_defined_pressure_interval[0] = 0.2;
//	CompressionLabTrialResults::deformation_module_defined_pressure_interval[1] = 0.3;
}
HTREEITEM LabLayer::AddItem_ToTree(HWND hwndTV, HTREEITEM h1)
{
    char szItemText[1024]; // label text of tree-view item 
	char s[128];
	sprintf(s, "%s\0", this->layer_number.c_str());
#if !CHAR_LAYER_NUMBER_ID
	OemToChar(s,s);	
#endif
	sprintf(szItemText, "лаб.слой %s, анализов %u, имя файла %s", s, lab_numbers.size(), this->filename.c_str());
	LabObject * lab_object = dynamic_cast<LabObject *>(this);
	HTREEITEM h2 = AddItemToTree(hwndTV, szItemText, lab_object); 
	for (vector<LabNumber*>::iterator it = lab_numbers.begin(); 
		it != lab_numbers.end(); it++)
	{
		if ((*it))
		{
			(*it)->AddItem_ToTree(hwndTV, h2);
		}
	}
	return h2; 
	//=============================================================
}

HTREEITEM Laboratory::AddItem_ToTree(HWND hwndTV, HTREEITEM h1)
{
	HTREEITEM h2 = NULL;
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			h2 = (*it)->AddItem_ToTree(hwndTV,	h1);
		}
	}
	return h2;
	//=============================================================
}

HTREEITEM Laboratory::AddParam_ToTree(HWND hwndTV, HTREEITEM h1)
{
	HTREEITEM h2 = NULL;
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			h2 = (*it)->AddParam_ToTree(hwndTV,	h1);
		}
	}
	return h2;
	//=============================================================
}
bool LabLayer::IsLabObject(const LabObject * p1)
{
	if (this == p1)
		return true;

	for (vector<LabNumber*>::iterator it = lab_numbers.begin(); 
		it != lab_numbers.end(); it++)
	{
		if ((*it) == p1)
		{
			return true;
		}
	}

	return false;
}
LabParameter * PhysicalLabParametersInitial::FindLabParameter(PhysicalLabTrial::value_type t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}
LabParameter * PhysicalLabParametersResults::FindLabParameter(PhysicalLabTrialResults::value_type t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}

LabParameter * ChemicalLabParametersInitial::FindLabParameter(ChemicalLabTrial::value_type t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}
LabParameter * ChemicalLabParametersResults::FindLabParameter(ChemicalLabTrialResults::value_type t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}
#if FRACTION_LAB_PARAM_INITIAL_MAP
LabParameter * FractionsLabParametersInitial::FindLabParameter(FractionsLabTrial::value_type t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}
#endif
LabParameter * FractionsLabParametersInitial::FindLabParameter(LabTrialValueType & vt)
{
	for (vector<fraction_lab_param>::iterator it = m_fractions_content.begin();
		it != m_fractions_content.end(); it++)
	{
#if USE_FRACTION_DIAMETERS_INTERVAL
		if (
			(*it).fraction_diameter_low == vt.fraction_diameter_low
			&&
			(*it).fraction_diameter_high == vt.fraction_diameter_high
			&&
			(*it).i_fraction == vt.i_fraction
			)
		{
			return (*it).lab_param;
		}
#else
		if ((*it).fraction_diameter == vt.fraction_diameter
			&&
			(*it).i_fraction == vt.i_fraction
			)
		{
			return (*it).lab_param;
		}
#endif
	}
	return NULL;
}
LabParameter * FractionsLabParametersResults::FindLabParameter(FractionsLabTrialResults::value_type t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}


LabParameter * CompressionLabParametersInitial::FindLabParameter(LabTrialValueType & vt)
{
//	printf("CompressionLabParametersInitial::FindLabParameter vt.m_indication = %d\n", vt.m_indication);

	double compression_pressure = 0.0;
	int i_compression_pressure = -1;

	switch(vt.m_indication)
	{
	case LabTrial::indication::compression_nature_condition_absolute_deformation:
	case LabTrial::indication::compression_task_condition_absolute_deformation:
	case LabTrial::indication::compression_shrinkage_absolute_deformation:
		compression_pressure = vt.vt_Compression.compression_pressure;
		i_compression_pressure = vt.vt_Compression.i_compression_pressure;
		break;
	case LabTrial::indication::compression_3:
		{
			switch (vt.vt_Compression_3.com_type)
			{
			case CompressionLabTrial::type::nature_condition:
				compression_pressure = vt.vt_Compression_3.vt_Compression_nature.compression_pressure;
				i_compression_pressure = vt.vt_Compression_3.vt_Compression_nature.i_compression_pressure;
				break;
			case CompressionLabTrial::type::task_condition:
				compression_pressure = vt.vt_Compression_3.vt_Compression_task.compression_pressure;
				i_compression_pressure = vt.vt_Compression_3.vt_Compression_task.i_compression_pressure;
				break;
			case CompressionLabTrial::type::shrinkage:
				compression_pressure = vt.vt_Compression_3.vt_Compression_shrinkage.compression_pressure;
				i_compression_pressure = vt.vt_Compression_3.vt_Compression_shrinkage.i_compression_pressure;
				break;
			}
		}
		break;
	default:
		return NULL;
	}
	//printf("CompressionLabParametersInitial::FindLabParameter compression_pressure = %f\n", compression_pressure);
	//printf("CompressionLabParametersInitial::FindLabParameter i_compression_pressure = %d\n", i_compression_pressure);

	for (vector<compression_lab_param>::iterator it = m_absolute_deformations.begin();
		it != m_absolute_deformations.end(); it++)
	{
//printf("compression_pressure = %f\n", (*it).compression_pressure);
//printf("i_compression_pressure = %d\n", (*it).i_compression_pressure);
		if ((*it).compression_pressure == compression_pressure
			&&
			(*it).i_compression_pressure == i_compression_pressure

			)
		{
			return (*it).lab_param;
		}
	}


//printf("CompressionLabParametersInitial::FindLabParameter return NULL;\n");
	return NULL;
}
LabParameter * CompressionLabParametersResults::FindLabParameter(CompressionLabTrialResults::value_type_0 t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}
#if USE_COMPR_PO_OTN_DEF	
LabParameter * CompressionLabParametersResults1::FindLabParameter(CompressionLabTrialResults::value_type_1 t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}
#endif
LabParameter * CompressionLabParametersResults2::FindLabParameter(CompressionLabTrialResults::value_type_2 t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}
LabParameter * CompressionLabParametersResults3::FindLabParameter(CompressionLabTrialResults::value_type_3 t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}
LabParameter * CompressionLabParametersResult_tri::FindLabParameter(CompressionLabTrialResults3::value_type t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}
#if CUT_LAB_PARAM_INITIAL_MAP
LabParameter * CutLabParametersInitial::FindLabParameter(CutLabTrial::value_type t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}
#endif
LabParameter * CutLabParametersInitial::FindLabParameter(LabTrialValueType & vt)
{
	for (vector<cut_lab_param>::iterator it = m_cut_resistance.begin();
		it != m_cut_resistance.end(); it++)
	{
		if ((*it).cut_pressure == vt.cut_pressure
			&&
			(*it).i_cut_pressure == vt.i_cut_pressure
			)
		{
			return (*it).lab_param;
		}
	}
	return NULL;
}
LabParameter * CutLabParametersResults::FindLabParameter(CutLabTrialResults::value_type t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}
LabParameter * CutLabParametersResults_common::FindLabParameter(CutLabTrialResults::value_type t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}

LabParameter * PressingLabParametersInitial::FindLabParameter(PressingLabTrial::value_type t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}
LabParameter * PressingLabParametersResults::FindLabParameter(PressingLabTrialResults::value_type t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}

LabParameter * FiltrationLabParametersInitial::FindLabParameter(FiltrationLabTrial::value_type t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}
LabParameter * FiltrationLabParametersResults::FindLabParameter(FiltrationLabTrialResults::value_type t)
{
	if(this->m_params.find(t) != this->m_params.end())
		return this->m_params[t];

	return NULL;
}


bool PhysicalLabParametersInitial::IsLabParam(const LabParam * p1)
{
	for (map<PhysicalLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;
}
bool PhysicalLabParametersResults::IsLabParam(const LabParam * p1)
{
	for (map<PhysicalLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;
}



bool ChemicalLabParametersInitial::IsLabParam(const LabParam * p1)
{
	for (map<ChemicalLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;
}
bool ChemicalLabParametersResults::IsLabParam(const LabParam * p1)
{
	for (map<ChemicalLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;
}


bool FractionsLabParametersInitial::IsLabParam(const LabParam * p1)
{
#if FRACTION_LAB_PARAM_INITIAL_MAP
	for (map<FractionsLabTrial::value_type, LabParameter*>::iterator mit = m_params.begin(); 
		mit != m_params.end(); mit++)
	{
		if ((*mit).first == FractionsLabTrial::value_type::vt_fractions_content)
		{
			for (vector<fraction_lab_param>::iterator vit = m_fractions_content.begin(); 
				vit != m_fractions_content.end(); vit++)
			{
				if ((*vit).lab_param == p1)
				{
					return true;
				}
			}
		}
		else
		{
			if ((*mit).second == p1)
			{
				return true;
			}
		}
	}
#endif

	return false;
}
bool FractionsLabParametersResults::IsLabParam(const LabParam * p1)
{
	for (map<FractionsLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;
}


bool CompressionLabParametersInitial::IsLabParam(const LabParam * p1)
{
		
	for (vector<compression_lab_param>::iterator it = m_absolute_deformations.begin(); 
		it != m_absolute_deformations.end(); it++)
	{
		if ((*it).lab_param == p1)
		{
			return true;
		}
	}
	return false;

}
bool CompressionLabParametersResults::IsLabParam(const LabParam * p1)
{
	for (map<CompressionLabTrialResults::value_type_0, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;

}
#if USE_COMPR_PO_OTN_DEF	
bool CompressionLabParametersResults1::IsLabParam(const LabParam * p1)
{
	for (map<CompressionLabTrialResults::value_type_1, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;
}
#endif
bool CompressionLabParametersResults2::IsLabParam(const LabParam * p1)
{
	for (map<CompressionLabTrialResults::value_type_2, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;
}

bool CompressionLabParametersResults3::IsLabParam(const LabParam * p1)
{
	for (map<CompressionLabTrialResults::value_type_3, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;
}


bool CompressionLabParametersResult_tri::IsLabParam(const LabParam * p1)
{
	for (map<CompressionLabTrialResults3::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;
}

bool CutLabParametersInitial::IsLabParam(const LabParam * p1)
{
#if CUT_LAB_PARAM_INITIAL_MAP
	for (map<CutLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
#endif
	for (vector<cut_lab_param>::iterator it = m_cut_resistance.begin(); 
		it != m_cut_resistance.end(); it++)
	{
		if ((*it).lab_param == p1)
		{
			return true;
		}
	}

	return false;

}
bool CutLabParametersResults::IsLabParam(const LabParam * p1)
{
	for (map<CutLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;
}
bool CutLabParametersResults_common::IsLabParam(const LabParam * p1)
{
	for (map<CutLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;
}

bool PressingLabParametersInitial::IsLabParam(const LabParam * p1)
{
	for (map<PressingLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;
}
bool PressingLabParametersResults::IsLabParam(const LabParam * p1)
{
	for (map<PressingLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;

}


bool FiltrationLabParametersInitial::IsLabParam(const LabParam * p1)
{
	for (map<FiltrationLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;
}
bool FiltrationLabParametersResults::IsLabParam(const LabParam * p1)
{
	for (map<FiltrationLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
	}
	return false;

}

void PhysicalLabParametersInitial::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<PhysicalLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;
			vt.vt_PhysicalLabTrial = (*it).first;
			vvt.push_back(vt);
		}
	}
}
void PhysicalLabParametersResults::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<PhysicalLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;
			vt.vt_PhysicalLabTrialResults = (*it).first;
			vvt.push_back(vt);
		}
	}
}



void ChemicalLabParametersInitial::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<ChemicalLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;
			vt.vt_ChemicalLabTrial = (*it).first;
			vvt.push_back(vt);
		}
	}
}
void ChemicalLabParametersResults::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<ChemicalLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;
			vt.vt_ChemicalLabTrialResults = (*it).first;
			vvt.push_back(vt);
		}
	}
}


void FractionsLabParametersInitial::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
#if FRACTION_LAB_PARAM_INITIAL_MAP
	for (map<FractionsLabTrial::value_type, LabParameter*>::iterator mit = m_params.begin(); 
		mit != m_params.end(); mit++)
	{
		if ((*mit).first == FractionsLabTrial::value_type::vt_fractions_content)
		{
			for (vector<fraction_lab_param>::iterator vit = m_fractions_content.begin(); 
				vit != m_fractions_content.end(); vit++)
			{
				if ((*vit).lab_param && (*vit).lab_param->GetCheckedLabParam())
				{
					LabTrialValueType vt;
					vt.clear();
					vt.m_indication = t;
					vt.is_result = is_result;
					vt.vt_FractionsLabTrial = FractionsLabTrial::value_type::vt_fractions_content;
#if !USE_FRACTION_DIAMETERS_INTERVAL
					vt.fraction_diameter = (*vit).fraction_diameter;
#endif
					vt.fraction_diameter_high = (*vit).fraction_diameter_high;
					vt.fraction_diameter_low = (*vit).fraction_diameter_low;
					vt.n_fractions = (*vit).n_fractions;
					vt.i_fraction = (*vit).i_fraction;

					vvt.push_back(vt);
				}
			}
		}
		else
		{
			if ((*mit).second && (*mit).second->GetCheckedLabParam())
			{
				LabTrialValueType vt;
				vt.clear();
				vt.m_indication = t;
				vt.is_result = is_result;
				vt.vt_FractionsLabTrial = (*mit).first;
				vvt.push_back(vt);
			}
		}
	}
#endif

}
void FractionsLabParametersResults::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<FractionsLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;
			vt.vt_FractionsLabTrialResults = (*it).first;
			vvt.push_back(vt);
		}
	}
}


void CompressionLabParametersInitial::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
			
	for (vector<compression_lab_param>::iterator it = m_absolute_deformations.begin(); 
		it != m_absolute_deformations.end(); it++)
	{
		if ((*it).lab_param && (*it).lab_param->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;

			vt.vt_Compression.vt_CompressionLabTrial = CompressionLabTrial::value_type::vt_absolute_deformation;
			vt.vt_Compression.compression_pressure = (*it).compression_pressure;
			vt.vt_Compression.n_compression_pressures = (*it).n_compression_pressures;
			vt.vt_Compression.i_compression_pressure = (*it).i_compression_pressure;
			vt.vt_Compression.compression_zamachivanie = (*it).zamachivanie;

			//printf("vt.n_compression_pressures = %d\n", vt.n_compression_pressures);
			//printf("vt.i_compression_pressure = %d\n", vt.i_compression_pressure);
			//printf("vt.compression_pressure = %f\n", vt.compression_pressure);
			//printf("vt.compression_zamachivanie = %d\n", vt.compression_zamachivanie);


			vvt.push_back(vt);
		}
	}
}
void CompressionLabParametersResults::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<CompressionLabTrialResults::value_type_0, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.vt_Compression.n_compression_value_type = 0;
			vt.vt_Compression.vt_CompressionLabTrialResults_0 = (*it).first;

			vt.is_result = is_result;
			vvt.push_back(vt);
		}
	}
}
#if USE_COMPR_PO_OTN_DEF	
void CompressionLabParametersResults1::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<CompressionLabTrialResults::value_type_1, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.vt_Compression.n_compression_value_type = 1;
			vt.vt_Compression.every_compression_experiment = this->every;
			vt.vt_Compression.vt_CompressionLabTrialResults_1 = (*it).first;
			vt.is_result = is_result;
			vvt.push_back(vt);
		}
	}
}
#endif
void CompressionLabParametersResults2::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<CompressionLabTrialResults::value_type_2, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.vt_Compression.n_compression_value_type = 2;
			vt.vt_Compression.every_compression_experiment = this->every;
			vt.vt_Compression.vt_CompressionLabTrialResults_2 = (*it).first;
			vt.is_result = is_result;
			vvt.push_back(vt);
		}
	}
}
void CompressionLabParametersResults3::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<CompressionLabTrialResults::value_type_3, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;
			vt.vt_Compression.n_compression_value_type = 3;
			vt.vt_Compression.vt_CompressionLabTrialResults_3 = (*it).first;
			vt.vt_Compression.every_compression_experiment = this->every;
			vt.vt_Compression.n_compression_value_type = 3;
			vvt.push_back(vt);
		}
	}
}

void CompressionLabParametersResult_tri::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<CompressionLabTrialResults3::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;
			vt.vt_Compression_3.vt_CompressionLabTrialResults3 = (*it).first;
			vvt.push_back(vt);
		}
	}
}


void CutLabParametersInitial::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
#if CUT_LAB_PARAM_INITIAL_MAP
	for (map<CutLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->m_bChecked)
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;
			vt.vt_CutLabTrial = (*it).first;
			vvt.push_back(vt);
		}
	}
#endif
	for (vector<cut_lab_param>::iterator it = m_cut_resistance.begin(); 
		it != m_cut_resistance.end(); it++)
	{
		if ((*it).lab_param && (*it).lab_param->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;
			vt.vt_CutLabTrial = CutLabTrial::value_type::vt_cut_resistance;
			vt.cut_pressure = (*it).cut_pressure;
			vt.n_cut_pressures = (*it).n_cut_pressures;
			vt.i_cut_pressure = (*it).i_cut_pressure;

			//printf("vt.n_compression_pressures = %d\n", vt.n_compression_pressures);
			//printf("vt.i_compression_pressure = %d\n", vt.i_compression_pressure);
			//printf("vt.compression_pressure = %f\n", vt.compression_pressure);
			//printf("vt.compression_zamachivanie = %d\n", vt.compression_zamachivanie);


			vvt.push_back(vt);
		}
	}
}
void CutLabParametersResults::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<CutLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;
			vt.every_cut_experiment = true;
			vt.vt_CutLabTrialResults = (*it).first;
			vvt.push_back(vt);
		}
	}
}
void CutLabParametersResults_common::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<CutLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;
			vt.every_cut_experiment = false;
			vt.vt_CutLabTrialResults = (*it).first;
			vvt.push_back(vt);
		}
	}
}

void PressingLabParametersInitial::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<PressingLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;
			vt.vt_PressingLabTrial = (*it).first;
			vvt.push_back(vt);
		}
	}
}
void PressingLabParametersResults::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<PressingLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;
			vt.vt_PressingLabTrialResults = (*it).first;
			vvt.push_back(vt);
		}
	}
}


void FiltrationLabParametersInitial::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<FiltrationLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;
			vt.vt_FiltrationLabTrial = (*it).first;
			vvt.push_back(vt);
		}
	}
}
void FiltrationLabParametersResults::GetCheckedVirtual(vector<LabTrialValueType> & vvt, LabTrial::indication t, bool is_result)
{
	for (map<FiltrationLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second && (*it).second->GetCheckedLabParam())
		{
			LabTrialValueType vt;
			vt.clear();
			vt.m_indication = t;
			vt.is_result = is_result;
			vt.vt_FiltrationLabTrialResults = (*it).first;
			vvt.push_back(vt);
		}
	}
}


void PhysicalLabParametersInitial::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<PhysicalLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}
void PhysicalLabParametersResults::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<PhysicalLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}



void ChemicalLabParametersInitial::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<ChemicalLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}
void ChemicalLabParametersResults::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<ChemicalLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}


void FractionsLabParametersInitial::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

#if FRACTION_LAB_PARAM_INITIAL_MAP
	for (map<FractionsLabTrial::value_type, LabParameter*>::iterator mit = m_params.begin(); 
		mit != m_params.end(); mit++)
	{
		if ((*mit).first == FractionsLabTrial::value_type::vt_fractions_content)
		{
			for (vector<fraction_lab_param>::iterator vit = m_fractions_content.begin(); 
				vit != m_fractions_content.end(); vit++)
			{
				if ((*vit).lab_param)
					(*vit).lab_param->Check(hwndTV);
			}
		}
		else
		{
			if ((*mit).second)
				(*mit).second->Check(hwndTV);
		}
	}
#endif

}
void FractionsLabParametersResults::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<FractionsLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}


void CompressionLabParametersInitial::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (vector<compression_lab_param>::iterator it = m_absolute_deformations.begin(); 
		it != m_absolute_deformations.end(); it++)
	{
		if ((*it).lab_param)
			(*it).lab_param->Check(hwndTV);
	}
}
void CompressionLabParametersResults::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<CompressionLabTrialResults::value_type_0, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}
#if USE_COMPR_PO_OTN_DEF	
void CompressionLabParametersResults1::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<CompressionLabTrialResults::value_type_1, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}
#endif
void CompressionLabParametersResults2::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<CompressionLabTrialResults::value_type_2, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}
void CompressionLabParametersResults3::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<CompressionLabTrialResults::value_type_3, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}
void CompressionLabParametersResult_tri::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<CompressionLabTrialResults3::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}


void CutLabParametersInitial::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

#if CUT_LAB_PARAM_INITIAL_MAP
	for (map<CutLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
#endif
	for (vector<cut_lab_param>::iterator it = m_cut_resistance.begin(); 
		it != m_cut_resistance.end(); it++)
	{
		if ((*it).lab_param)
			(*it).lab_param->Check(hwndTV);
	}
}
void CutLabParametersResults::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<CutLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}
void CutLabParametersResults_common::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<CutLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}

void PressingLabParametersInitial::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<PressingLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}
void PressingLabParametersResults::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<PressingLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}


void FiltrationLabParametersInitial::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<FiltrationLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}
void FiltrationLabParametersResults::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	for (map<FiltrationLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->Check(hwndTV);
	}
}


void PhysicalLabParametersInitial::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<PhysicalLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
}
void PhysicalLabParametersResults::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<PhysicalLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
}



void ChemicalLabParametersInitial::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<ChemicalLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}

}
void ChemicalLabParametersResults::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<ChemicalLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
}


void FractionsLabParametersInitial::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

#if FRACTION_LAB_PARAM_INITIAL_MAP
	for (map<FractionsLabTrial::value_type, LabParameter*>::iterator mit = m_params.begin(); 
		mit != m_params.end(); mit++)
	{
		if ((*mit).first == FractionsLabTrial::value_type::vt_fractions_content)
		{
			for (vector<fraction_lab_param>::iterator vit = m_fractions_content.begin(); 
				vit != m_fractions_content.end(); vit++)
			{
				if ((*vit).lab_param)
					(*vit).lab_param->UnCheck(hwndTV);
			}
		}
		else
		{
			if ((*mit).second)
				(*mit).second->UnCheck(hwndTV);
		}
	}
#endif

}
void FractionsLabParametersResults::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<FractionsLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
}


void CompressionLabParametersInitial::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (vector<compression_lab_param>::iterator it = m_absolute_deformations.begin(); 
		it != m_absolute_deformations.end(); it++)
	{
		if ((*it).lab_param)
			(*it).lab_param->UnCheck(hwndTV);
	}
}
void CompressionLabParametersResults::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<CompressionLabTrialResults::value_type_0, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
}
#if USE_COMPR_PO_OTN_DEF	
void CompressionLabParametersResults1::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<CompressionLabTrialResults::value_type_1, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
}
#endif
void CompressionLabParametersResults2::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<CompressionLabTrialResults::value_type_2, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
}
void CompressionLabParametersResults3::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<CompressionLabTrialResults::value_type_3, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
}
void CompressionLabParametersResult_tri::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<CompressionLabTrialResults3::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
}
void CutLabParametersInitial::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

#if CUT_LAB_PARAM_INITIAL_MAP
	for (map<CutLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
#endif
	for (vector<cut_lab_param>::iterator it = m_cut_resistance.begin(); 
		it != m_cut_resistance.end(); it++)
	{
		if ((*it).lab_param)
			(*it).lab_param->UnCheck(hwndTV);
	}
}
void CutLabParametersResults::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<CutLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
}
void CutLabParametersResults_common::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<CutLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
}

void PressingLabParametersInitial::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<PressingLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
}
void PressingLabParametersResults::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<PressingLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
}


void FiltrationLabParametersInitial::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<FiltrationLabTrial::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
}
void FiltrationLabParametersResults::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	for (map<FiltrationLabTrialResults::value_type, LabParameter*>::iterator it = m_params.begin(); 
		it != m_params.end(); it++)
	{
		if ((*it).second)
			(*it).second->UnCheck(hwndTV);
	}
}
void LabParameter::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);
}
void LabParameter::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);
}
/*void LabParameter::AddCube()
{
	MessageBox(0, this->m_vt.GetValueTypeString(), "", 0);
}*/

void LabParametersInitial::GetChecked(vector<LabTrialValueType> & vvt)
{
	if (this->GetCheckedLabParam())
	{
		if (this->lab_parameters)
			this->GetCheckedVirtual(vvt, this->lab_parameters->m_indication, false);
	}
}
void LabParametersResults::GetChecked(vector<LabTrialValueType> & vvt)
{
	if (this->GetCheckedLabParam())
	{
		if (this->lab_parameters)
			this->GetCheckedVirtual(vvt, this->lab_parameters->m_indication, true);
	}
}
void LabParameters::GetChecked(vector<LabTrialValueType> & vvt)
{
	if (this->GetCheckedLabParam())
	{
		if (parameters_initial) 
		{
			if (parameters_initial->GetCheckedLabParam())
				parameters_initial->GetChecked(vvt);
		}

		if (parameters_results) 
		{
			if (parameters_results->GetCheckedLabParam())
				parameters_results->GetChecked(vvt);
		}
	}
}
void CompressionLabParameters3::GetChecked(vector<LabTrialValueType> & vvt)
{
	this->params_nature.GetChecked(vvt);
	this->params_task.GetChecked(vvt);
	this->params_shrinkage.GetChecked(vvt);
	this->params_tri.GetChecked(vvt);
}
void CompressionLabParameters::GetChecked(vector<LabTrialValueType> & vvt)
{
	if (this->GetCheckedLabParam())
	{
		this->LabParameters::GetChecked(vvt);
#if USE_COMPR_PO_OTN_DEF	
		if (parameters_results1_every) 
		{
			if (parameters_results1_every->GetCheckedLabParam())
				parameters_results1_every->GetChecked(vvt);
		}

		if (parameters_results1_common) 
		{
			if (parameters_results1_common->GetCheckedLabParam())
				parameters_results1_common->GetChecked(vvt);
		}
#endif
		if (parameters_results2_every) 
		{
			if (parameters_results2_every->GetCheckedLabParam())
				parameters_results2_every->GetChecked(vvt);
		}
		
		if (parameters_results2_common) 
		{
			if (parameters_results2_common->GetCheckedLabParam())
				parameters_results2_common->GetChecked(vvt);
		}
		
		if (parameters_results3_every) 
		{
			if (parameters_results3_every->GetCheckedLabParam())
				parameters_results3_every->GetChecked(vvt);
		}	

		if (parameters_results3_common) 
		{
			if (parameters_results3_common->GetCheckedLabParam())
				parameters_results3_common->GetChecked(vvt);
		}
	}
}
void CutLabParameters::GetChecked(vector<LabTrialValueType> & vvt)
{
	if (this->GetCheckedLabParam())
	{	
		this->LabParameters::GetChecked(vvt);
	
		if (parameters_results_common) 
		{
			if (parameters_results_common->GetCheckedLabParam())
				parameters_results_common->GetChecked(vvt);
		}
	}
}


void LabParameters::FillLabParameters()
{
	if (parameters_initial) 
	{
		parameters_initial->FillLabParameters();
	}
	if (parameters_results) 
	{
		parameters_results->FillLabParameters();
	}
}

void CompressionLabParameters3::FillLabParameters()
{
	this->params_nature.FillLabParameters();
	this->params_task.FillLabParameters();
	this->params_shrinkage.FillLabParameters();	
	this->params_tri.FillLabParameters();
}

void CompressionLabParameters::FillLabParameters()
{
	this->LabParameters::FillLabParameters();
#if USE_COMPR_PO_OTN_DEF	
	if (parameters_results1_every) 
	{
		parameters_results1_every->FillLabParameters();
	}
	
	if (parameters_results1_common) 
	{
		parameters_results1_common->FillLabParameters();
	}
#endif	
	if (parameters_results2_every) 
	{
		parameters_results2_every->FillLabParameters();
	}
	
	if (parameters_results2_common) 
	{
		parameters_results2_common->FillLabParameters();
	}
	
	if (parameters_results3_every) 
	{
		parameters_results3_every->FillLabParameters();
	}

	if (parameters_results3_common) 
	{
		parameters_results3_common->FillLabParameters();
	}
}
void CutLabParameters::FillLabParameters()
{
	this->LabParameters::FillLabParameters();
	
	if (parameters_results_common) 
	{
		parameters_results_common->FillLabParameters();
	}
}



void LabParameters::ParamCheck(HWND hwndTV)
{
	this->Check(hwndTV);

	if (parameters_initial) 
	{
		parameters_initial->Check(hwndTV);
		parameters_initial->ParamCheck(hwndTV);
	}

	if (parameters_results) 
	{
		parameters_results->Check(hwndTV);
		parameters_results->ParamCheck(hwndTV);
	}
}

void LabParameters::ParamUnCheck(HWND hwndTV)
{
	this->UnCheck(hwndTV);

	if (parameters_initial) 
	{
		parameters_initial->UnCheck(hwndTV);
		parameters_initial->ParamUnCheck(hwndTV);
	}

	if (parameters_results) 
	{
		parameters_results->UnCheck(hwndTV);
		parameters_results->ParamUnCheck(hwndTV);
	}
}

bool LabParameters::IsLabParam(const LabParam * p1)
{
	if (this == p1)
		return true;
	
	if (parameters_results == p1)
		return true;
	
	if (parameters_initial == p1)
		return true;
	
	if (parameters_results && parameters_results->IsLabParam(p1))
		return true;

	if (parameters_results && parameters_initial->IsLabParam(p1))
		return true;

	return false;
}


bool CompressionLabParameters3::IsLabParam(const LabParam * p1)
{
	if (this->LabParameters::IsLabParam(p1))
		return true;
	
	if (this->params_nature.IsLabParam(p1))
		return true;
	
	if (this->params_task.IsLabParam(p1))
		return true;
	
	if (this->params_shrinkage.IsLabParam(p1))
		return true;
	
	if (this->params_tri.IsLabParam(p1))
		return true;
	
	return false;

}
bool CompressionLabParameters::IsLabParam(const LabParam * p1)
{
	if (this->LabParameters::IsLabParam(p1))
		return true;
	
#if USE_COMPR_PO_OTN_DEF	
	if (parameters_results1_every == p1)
		return true;

	if (parameters_results1_common == p1)
		return true;
#endif
	if (parameters_results2_every == p1)
		return true;
	
	if (parameters_results2_common == p1)
		return true;
	
	if (parameters_results3_every == p1)
		return true;
	
	if (parameters_results3_common == p1)
		return true;

#if USE_COMPR_PO_OTN_DEF	
	if (parameters_results1_every && parameters_results1_every->IsLabParam(p1))
		return true;

	if (parameters_results1_common && parameters_results1_common->IsLabParam(p1))
		return true;
#endif

	if (parameters_results2_every && parameters_results2_every->IsLabParam(p1))
		return true;

	if (parameters_results2_common && parameters_results2_common->IsLabParam(p1))
		return true;

	if (parameters_results3_every && parameters_results3_every->IsLabParam(p1))
		return true;

	if (parameters_results3_common && parameters_results3_common->IsLabParam(p1))
		return true;

	return false;
}
bool CutLabParameters::IsLabParam(const LabParam * p1)
{
	if (this->LabParameters::IsLabParam(p1))
		return true;
	
	if (parameters_results_common == p1)
		return true;
	
	if (parameters_results_common && parameters_results_common->IsLabParam(p1))
		return true;

	return false;

}

void CompressionLabParameters3::ParamCheck(HWND hwndTV)
{
	this->params_nature.ParamCheck(hwndTV);
	this->params_task.ParamCheck(hwndTV);
	this->params_shrinkage.ParamCheck(hwndTV);
	this->params_tri.ParamCheck(hwndTV);
}

void CompressionLabParameters::ParamCheck(HWND hwndTV)
{
	this->LabParameters::ParamCheck(hwndTV);
	
#if USE_COMPR_PO_OTN_DEF	
	if (parameters_results1_every) 
	{
		parameters_results1_every->Check(hwndTV);
		parameters_results1_every->ParamCheck(hwndTV);
	}	
	if (parameters_results1_common) 
	{
		parameters_results1_common->Check(hwndTV);
		parameters_results1_common->ParamCheck(hwndTV);
	}
#endif
	
	if (parameters_results2_every) 
	{
		parameters_results2_every->Check(hwndTV);
		parameters_results2_every->ParamCheck(hwndTV);
	}	
	if (parameters_results2_common) 
	{
		parameters_results2_common->Check(hwndTV);
		parameters_results2_common->ParamCheck(hwndTV);
	}
	
	if (parameters_results3_every) 
	{
		parameters_results3_every->Check(hwndTV);
		parameters_results3_every->ParamCheck(hwndTV);
	}	
	if (parameters_results3_common) 
	{
		parameters_results3_common->Check(hwndTV);
		parameters_results3_common->ParamCheck(hwndTV);
	}
}
void CutLabParameters::ParamCheck(HWND hwndTV)
{
	this->LabParameters::ParamCheck(hwndTV);
	
	if (parameters_results_common) 
	{
		parameters_results_common->Check(hwndTV);
		parameters_results_common->ParamCheck(hwndTV);
	}
}


void CompressionLabParameters3::ParamUnCheck(HWND hwndTV)
{
	this->params_nature.ParamUnCheck(hwndTV);
	this->params_task.ParamUnCheck(hwndTV);
	this->params_shrinkage.ParamUnCheck(hwndTV);	
	this->params_tri.ParamUnCheck(hwndTV);	
}
void CompressionLabParameters::ParamUnCheck(HWND hwndTV)
{
	this->LabParameters::ParamUnCheck(hwndTV);
	
#if USE_COMPR_PO_OTN_DEF	
	if (parameters_results1_every) 
	{
		parameters_results1_every->UnCheck(hwndTV);
		parameters_results1_every->ParamUnCheck(hwndTV);
	}
	
	if (parameters_results1_common) 
	{
		parameters_results1_common->UnCheck(hwndTV);
		parameters_results1_common->ParamUnCheck(hwndTV);
	}
#endif
	
	if (parameters_results2_every) 
	{
		parameters_results2_every->UnCheck(hwndTV);
		parameters_results2_every->ParamUnCheck(hwndTV);
	}
	
	if (parameters_results2_common) 
	{
		parameters_results2_common->UnCheck(hwndTV);
		parameters_results2_common->ParamUnCheck(hwndTV);
	}
	
	if (parameters_results3_every) 
	{
		parameters_results3_every->UnCheck(hwndTV);
		parameters_results3_every->ParamUnCheck(hwndTV);
	}
	
	if (parameters_results3_common) 
	{
		parameters_results3_common->UnCheck(hwndTV);
		parameters_results3_common->ParamUnCheck(hwndTV);
	}
}
void CutLabParameters::ParamUnCheck(HWND hwndTV)
{
	this->LabParameters::ParamUnCheck(hwndTV);
	
	if (parameters_results_common) 
	{
		parameters_results_common->UnCheck(hwndTV);
		parameters_results_common->ParamUnCheck(hwndTV);
	}
}


void LabLayer::FillLabParameters()
{
	if(this->lab_parameter_depth)
	{
		//this->lab_parameter_depth->FillLabParameters();
	}

	for (map<LabTrial::indication, LabParameters*>::iterator it = lab_parameters.begin(); 
		it != lab_parameters.end(); it++)
	{
		if ((*it).second)
			(*it).second->FillLabParameters();
	}
}


void LabLayer::GetChecked(vector<LabTrialValueType> & vvt)
{
	vvt.clear();

	if(this->lab_parameter_depth && this->lab_parameter_depth->GetCheckedLabParam())
	{
		LabTrialValueType vt;
		vt.clear();
		vt.m_indication = LabTrial::indication::undefined_lab_trial_indication;
		vt.is_result = false;
		vt.vt_common_type = LabTrialValueType::common_types::depth;
		vvt.push_back(vt);
	}

	for (map<LabTrial::indication, LabParameters*>::iterator it = lab_parameters.begin(); 
		it != lab_parameters.end(); it++)
	{
		if ((*it).second)
			(*it).second->GetChecked(vvt);
	}
}

void LabLayer::ParamCheck(HWND hwndTV)
{
	if(this->lab_parameter_depth)
	{
		this->lab_parameter_depth->ParamCheck(hwndTV);
	}

	for (map<LabTrial::indication, LabParameters*>::iterator it = lab_parameters.begin(); 
		it != lab_parameters.end(); it++)
	{
		if ((*it).second)
			(*it).second->ParamCheck(hwndTV);
	}
}

void LabLayer::ParamUnCheck(HWND hwndTV)
{
	if(this->lab_parameter_depth)
	{
		this->lab_parameter_depth->ParamUnCheck(hwndTV);
	}

	for (map<LabTrial::indication, LabParameters*>::iterator it = lab_parameters.begin(); 
		it != lab_parameters.end(); it++)
	{
		if ((*it).second)
			(*it).second->ParamUnCheck(hwndTV);
	}
}

bool LabLayer::IsLabParam(const LabParam * p1)
{
	//if (this == p1)
	//	return true;

	if(this->lab_parameter_depth == p1)
		return true;

	for (map<LabTrial::indication, LabParameters*>::iterator it = lab_parameters.begin(); 
		it != lab_parameters.end(); it++)
	{
		if ((*it).second == p1)
		{
			return true;
		}
		if ((*it).second && (*it).second->IsLabParam(p1))
			return true;
	}

	return false;
}
bool Laboratory::IsLabObject(const LabObject * p1)
{
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			if ((*it)->IsLabObject(p1))
				return true;
		}
	}	
	return false;
}

bool Laboratory::IsLabParam(const LabParam * p1)
{
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			if ((*it)->IsLabParam(p1))
				return true;
		}
	}	
	return false;
}

void Laboratory::ParamCheck(HWND hwndTV)
{
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			(*it)->ParamCheck(hwndTV);
		}
	}	
			
	this->ReCreateContextWindow();

}

void Laboratory::ParamUnCheck(HWND hwndTV)
{
	for (vector<LabLayer *>::iterator it = m_layers.begin(); 
		it != m_layers.end(); it++)
	{
		if ((*it))
		{
			(*it)->ParamUnCheck(hwndTV);
		}
	}
			
	this->ReCreateContextWindow();

}

bool Laboratory::SelectLabObject(const LabObject * p1)
{
	/*if (!IsWellElement(p1))
		return false;*/
	if (!IsLabObject(p1))
		return false;
	
	LabObject * sel_lab_object = (LabObject *)p1;

	if (sel_lab_object)
	{
		switch(sel_lab_object->lab_object_type)
		{
		case LabObject::type::laboratory_number:
			{
				LabNumber * labnumber = dynamic_cast<LabNumber *>(sel_lab_object);
				if(labnumber)
				{
					vector<fmtstr> text;
					text.clear();
					labnumber->PrintfProperties(text);
					for (vector<fmtstr>::iterator it = text.begin();
						it != text.end(); it++)
					{
						setlocale( LC_ALL, "Russian" );
						char * buff =  _strdup((*it).String().c_str());
						setlocale( LC_ALL, "English" );
						CharToOem(buff,buff);						
						printf("%s", buff);
						if ((*it).NewLine())
							printf("\n", buff);
						if (buff) free(buff);
					}
					printf("\n");
				}
			}
			break;
		}
	}	
	return true;
}
bool Laboratory::SelectLabObject(const LabObject * p1, HWND hwndTV, HTREEITEM hTreeItem)
{
	if (!IsLabObject(p1))
		return false;
	
	LabObject * sel_lab_object = (LabObject *)p1;

	if (sel_lab_object)
	{
		sel_lab_object->m_bChecked_LabObject = !TreeView_GetCheckState3(hwndTV, hTreeItem);
		
		switch(sel_lab_object->lab_object_type)
		{
		case LabObject::type::laboratory_number:
			{
				this->ReCreateContextWindow();
			}
			break;
		}
	}	
	return true;
}

bool Laboratory::SelectLabParam(const LabParam * p1, HWND hwndTV, HTREEITEM hTreeItem)
{
	if (!IsLabParam(p1))
		return false;
	
	LabParam * sel_lab_param = (LabParam *)p1;

	if (sel_lab_param)
	{
		sel_lab_param->m_bChecked_LabParam = !TreeView_GetCheckState3(hwndTV, hTreeItem);

		this->ReCreateContextWindow();
		
/*		switch(sel_lab_param->lab_param_type)
		{
		}*/
	}	
	return true;
}
tagPOINT Laboratory::context_window_pt;


LRESULT CALLBACK ContextWndProc_1( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
	PAINTSTRUCT ps;
	HDC hdc;
	static HWND hwndButton;

	static vector<fmtstr> text;
	static SIZE text_size;

	static RECT margin; 


	static bool		m_bCaptured;		// Признак захвата мыши
	static tagPOINT		m_pt;				// Текущая позиция мыши

	switch (message) 
	{
	case WM_CREATE :
		{
			text.clear();
			text_size.cx = 0;
			text_size.cy = 0;
			//##################################################
			margin.left = 10;
			margin.right = 10;
			margin.top = 10;
			margin.bottom = 10;
			//##################################################
			CREATESTRUCT *pcs = (CREATESTRUCT *)lParam;
			SetWindowLong(hWnd,	GWL_USERDATA,(LONG)pcs->lpCreateParams);
			//##################################################
			//##################################################
			LabObject * selected_lab_object = (LabObject *)GetWindowLong(hWnd, GWL_USERDATA);
			if (selected_lab_object)
				selected_lab_object->PrintfProperties(text);
			hdc = GetWindowDC(hWnd);
			if (selected_lab_object)
				selected_lab_object->Paint(text, hWnd, hdc, margin, text_size, true);
			if (1)
			{
				RECT rect;
				GetWindowRect(hWnd, &rect);
				hwndButton = CreateWindow( 
					"BUTTON",   // predefined class 
					"X",       // button text 
					WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,  // styles 				 
					// Size and position values are given explicitly, because 
					// the CW_USEDEFAULT constant gives zero values for buttons. 
					rect.right - rect.left - 15,         // starting x position 
					3,         // starting y position 
					10,        // button width 
					10,        // button height 
					hWnd,       // parent window 
					(HMENU)IDCANCEL,       // menu 
					hInst,//(HINSTANCE) GetWindowLong(hWnd, GWL_HINSTANCE), 
					NULL);      // pointer not needed 

			   ShowWindow( hwndButton, SW_SHOW );
			}
		}
		break;

		case WM_PAINT:
			{
				hdc = BeginPaint(hWnd, &ps);
				LabObject * selected_lab_object = (LabObject *)GetWindowLong(hWnd, GWL_USERDATA);
				if (selected_lab_object)
					selected_lab_object->Paint(text, hWnd, hdc, margin, text_size, false);
				EndPaint(hWnd, &ps);
			}
			break;
		case WM_LBUTTONDOWN :
			{
				GetCursorPos(&m_pt);
				ScreenToClient(hWnd, &m_pt);

				//====== Захватываем сообщения мыши,
				//====== направляя их в свое окно
				SetCapture(hWnd);
				//====== Запоминаем факт захвата
				m_bCaptured = true;
				//====== Запоминаем координаты курсора
				SetFocus(hWnd);
			}
			break;
		case WM_LBUTTONUP :
			{
				if (m_bCaptured)
				{
					//====== Снимаем флаг захвата мыши
					m_bCaptured = false;
					//====== Отпускаем сообщения мыши
					ReleaseCapture();
				}
			}
			break;
//#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
		case WM_MOUSEWHEEL :
			{
				float yDelta = (float)(int) wParam; // wheel rotation 
				yDelta /= 300000.f;

				RECT rect;
				GetWindowRect(hWnd,&rect);

				rect.top -= (long)yDelta;

				SetWindowPos(hWnd, HWND_TOP, 
					rect.left, 
					rect.top, 
					0, 0, SWP_NOSIZE);

				//GetClientRect(hWnd,&rect);
				//InvalidateRect(hWnd,&rect, true);
			}
			break;
//#endif
		case WM_MOUSEMOVE :
			{
				if( wParam &  MK_LBUTTON)
				{
					if (m_bCaptured)		// Если был захват,
					{
						POINT pt;
						GetCursorPos(&pt);	

						Laboratory::context_window_pt.x = pt.x - m_pt.x;
						Laboratory::context_window_pt.y = pt.y - m_pt.y - 1;

						SetWindowPos(hWnd, HWND_TOP, 
							Laboratory::context_window_pt.x, 
							Laboratory::context_window_pt.y, 
							0, 0, SWP_NOSIZE);

						//RECT rect;
						//GetClientRect(hWnd,&rect);
						//InvalidateRect(hWnd,&rect, true);
					}
				}
			}
			break;
		case WM_RBUTTONDOWN:
			{
				LabObject * selected_lab_object = (LabObject *)GetWindowLong(hWnd, GWL_USERDATA);
				if (selected_lab_object)
					selected_lab_object->CreateMyPopupMenu(hWnd);
			}
			break;
		case WM_CHAR :
			{
				if (wParam == 27)//Esc
				{
					LabObject * selected_lab_object = (LabObject *)GetWindowLong(hWnd, GWL_USERDATA);
					if (selected_lab_object)
						selected_lab_object->DestroyContextWindow();
				}
			}
			break;
		case WM_COMMAND :
			{
				switch( LOWORD( wParam ) )
				{
				case IDCANCEL :
					{
						LabObject * selected_lab_object = (LabObject *)GetWindowLong(hWnd, GWL_USERDATA);
						if (selected_lab_object)
							selected_lab_object->DestroyContextWindow();
					}
					break;
				default:
					SendMessage(::GetParent(hWnd), message, wParam, lParam);
				}
			}
			break;
		case WM_DESTROY:
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}
LRESULT CALLBACK ContextWndProc_2( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
	PAINTSTRUCT ps;
	HDC hdc;
	static HWND hwndButton;

	static vector<LabData> labdata;
	static SIZE text_size;
	static bool text_size_do_not_determined;

	static RECT margin;  

	static bool		m_bCaptured;		// Признак захвата мыши
	static tagPOINT		m_pt;				// Текущая позиция мыши

	switch (message) 
	{
	case WM_CREATE :
		{
			labdata.clear();
			text_size.cx = 0;
			text_size.cy = 0;
			text_size_do_not_determined = true;
			//##################################################
			margin.left = 10;
			margin.right = 10;
			margin.top = 10;
			margin.bottom = 10;
			//##################################################
			CREATESTRUCT *pcs = (CREATESTRUCT *)lParam;
			SetWindowLong(hWnd,	GWL_USERDATA,(LONG)pcs->lpCreateParams);
			//##################################################
			//##################################################
			LabObject * selected_lab_object = (LabObject *)GetWindowLong(hWnd, GWL_USERDATA);
			if (selected_lab_object)
				selected_lab_object->PrintfProperties(labdata);

			hdc = GetWindowDC(hWnd);
			if (selected_lab_object)
				selected_lab_object->Paint(labdata, hWnd, hdc, margin, text_size, true);
			if (1)
			{
				RECT rect;
				GetWindowRect(hWnd, &rect);
				hwndButton = CreateWindow( 
					"BUTTON",   // predefined class 
					"X",       // button text 
					WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,  // styles 				 
					// Size and position values are given explicitly, because 
					// the CW_USEDEFAULT constant gives zero values for buttons. 
					rect.right - rect.left - 15,         // starting x position 
					3,         // starting y position 
					10,        // button width 
					10,        // button height 
					hWnd,       // parent window 
					(HMENU)IDCANCEL,       // menu 
					hInst,//(HINSTANCE) GetWindowLong(hWnd, GWL_HINSTANCE), 
					NULL);      // pointer not needed 

			   ShowWindow( hwndButton, SW_SHOW );
			}
		}
		break;

		case WM_PAINT:
			{
				hdc = BeginPaint(hWnd, &ps);
				LabObject * selected_lab_object = (LabObject *)GetWindowLong(hWnd, GWL_USERDATA);
				if (selected_lab_object)
					selected_lab_object->Paint(labdata, hWnd, hdc, margin, text_size, false);
				EndPaint(hWnd, &ps);
			}
			break;
		case WM_LBUTTONDOWN :
			{
				GetCursorPos(&m_pt);
				ScreenToClient(hWnd, &m_pt);
				//====== Захватываем сообщения мыши,
				//====== направляя их в свое окно
				SetCapture(hWnd);
				//====== Запоминаем факт захвата
				m_bCaptured = true;
				//====== Запоминаем координаты курсора
				SetFocus(hWnd);
			}
			break;
		case WM_LBUTTONUP :
			{
				if (m_bCaptured)
				{
					//====== Снимаем флаг захвата мыши
					m_bCaptured = false;
					//====== Отпускаем сообщения мыши
					ReleaseCapture();
				}
			}
			break;
//#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
		case WM_MOUSEWHEEL :
			{
				float yDelta = (float)(int) wParam; // wheel rotation 
				yDelta /= 300000.f;

				RECT rect;
				GetWindowRect(hWnd,&rect);

				rect.top -= (long)yDelta;

				SetWindowPos(hWnd, HWND_TOP, 
					rect.left, 
					rect.top, 
					0, 0, SWP_NOSIZE);

				//GetClientRect(hWnd,&rect);
				//InvalidateRect(hWnd,&rect, true);
			}
			break;
//#endif
		case WM_MOUSEMOVE :
			{
				if( wParam &  MK_LBUTTON)
				{
					if (m_bCaptured)		// Если был захват,
					{
						POINT pt;
						GetCursorPos(&pt);				
					
						Laboratory::context_window_pt.x = pt.x - m_pt.x;
						Laboratory::context_window_pt.y = pt.y - m_pt.y - 1;

						SetWindowPos(hWnd, HWND_TOP, 
							Laboratory::context_window_pt.x, 
							Laboratory::context_window_pt.y,  
							0, 0, SWP_NOSIZE);

						//RECT rect;
						//GetClientRect(hWnd,&rect);
						//InvalidateRect(hWnd,&rect, true);
					}
				}
			}
			break;

		case WM_RBUTTONDOWN:
			{
				LabObject * selected_lab_object = (LabObject *)GetWindowLong(hWnd, GWL_USERDATA);
				if (selected_lab_object)
					selected_lab_object->CreateMyPopupMenu(hWnd);
			}
			break;
		case WM_CHAR :
			{
				if (wParam == 27)//Esc
				{
					LabObject * selected_lab_object = (LabObject *)GetWindowLong(hWnd, GWL_USERDATA);
					if (selected_lab_object)
						selected_lab_object->DestroyContextWindow();
				}
			}
			break;
		case WM_COMMAND :
			{
				switch( LOWORD( wParam ) )
				{
				case IDCANCEL :
					{
						LabObject * selected_lab_object = (LabObject *)GetWindowLong(hWnd, GWL_USERDATA);
						if (selected_lab_object)
							selected_lab_object->DestroyContextWindow();
					}
					break;
				default:
					SendMessage(::GetParent(hWnd), message, wParam, lParam);
				}
			}
			break;
		case WM_DESTROY:
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}
LPCTSTR lpszContextWindow_1   = "ContextWindow_1";
LPCTSTR lpszContextWindow_2   = "ContextWindow_2";
bool RegisterContextWindowClass2(int type)
{
	WNDCLASSEX wc;
	// Регистрация класса главного окна приложения.
	//............................................
	wc.style         = CS_HREDRAW | CS_VREDRAW;
	switch(type)
	{
	case 1:
		{
			wc.lpfnWndProc   = (WNDPROC)ContextWndProc_1;
			wc.lpszClassName = lpszContextWindow_1;
		}
		break;
	case 2:
		{
			wc.lpfnWndProc   = (WNDPROC)ContextWndProc_2;
			wc.lpszClassName = lpszContextWindow_2;
		}
		break;
	}
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = hInst;
	wc.hIcon         = NULL;//LoadIcon( hInst, lpszWinGeoidName );
	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
	wc.lpszMenuName  = NULL;
	wc.cbSize        = sizeof(WNDCLASSEX);
	wc.hIconSm       = NULL;

	if ( !RegisterClassEx( &wc ) )
	{
		if(1410 != GetLastError())// класс уже существует
		{
			MessageBox(0,"!RegisterClassEx","ContextWindow",0);
			return( FALSE );
		}
	}
	return true;
}
bool Laboratory::SelectLabObject(long& x, long& y, const LabObject * p1, HWND hWndParent)
{
	if (!IsLabObject(p1))
		return false;
						
//	printf("x = %d, y = %d\n", x, y);

	if (x < 0)	x = 0;
	if (y < 0)	y = 0;


	selected_lab_object = (LabObject *)p1;
	selected_lab_object_x = x;
	selected_lab_object_y = y;

	if (selected_lab_object)
	{
		switch(selected_lab_object->lab_object_type)
		{
		case LabObject::type::laboratory_layer:
		case LabObject::type::laboratory_number:
			{
				if (!hContextWindow)
				{
					//printf("ContextWindow, x = %d, y = %d\n", x, y);

					hContextWindow = CreateWindow(Laboratory::context_with_plot ? lpszContextWindow_2 : lpszContextWindow_1,
						"",//    LPCTSTR lpWindowName,
						WS_POPUP | WS_BORDER,
						x,y,
						1,//int nWidth,
						1,//   int nHeight,
						hWndParent,
						NULL,//    HMENU hMenu,
						hInst,//HINSTANCE hInstance,
						LPVOID(p1)//LPVOID lpParam
						);

					if (!hContextWindow)
					{
						ErrorExit("CreateWindow", false);
					}

					ShowWindow(hContextWindow, SW_SHOW);
				}
			}
			break;
		}
	}	


	return true;
}
void Laboratory::DestroyContextWindow()
{
	DestroyWindow(hContextWindow);
	hContextWindow = NULL; 
	selected_lab_object = NULL;
}

bool Laboratory::LabWellElementProp()
{
	if (this->selected_lab_object)
	{
		this->selected_lab_object->Properties();
	}	
	return true;
}

bool Laboratory::LabWellElementPropSave()
{
	if (this->selected_lab_object)
	{
		this->selected_lab_object->PropSave(Laboratory::context_with_plot);
	}	
	return true;
}


bool Laboratory::LabWellElementPassport()
{
	if (this->selected_lab_object)
	{
		this->selected_lab_object->Passport();
	}	
	return true;
}


bool Laboratory::LabWellElementPropFont(int wmId)
{
	if (this->selected_lab_object)
	{
		CHOOSEFONT cf;            // common dialog box structure					  
		// Initialize CHOOSEFONT
		ZeroMemory(&cf, sizeof(cf));
		cf.lStructSize = sizeof (cf);
		//cf.hwndOwner = hWnd;
		cf.hwndOwner = this->hContextWindow;
		cf.hDC = GetDC(this->hContextWindow);
		
		switch (wmId)
		{                    
		case ID_TREE_LAB_WELLELEMENTCONTEXTFONT:
			cf.lpLogFont = &Well_Laboratory_Analize::lf_Label;
			break;
		case ID_TREE_LAB_WELLELEMENTCONTEXTFONT0:
			cf.lpLogFont = &fmtstr::LogFont0;
			break;
		case ID_TREE_LAB_WELLELEMENTCONTEXTFONT1:
			cf.lpLogFont = &fmtstr::LogFont1;
			break;
		case ID_TREE_LAB_WELLELEMENTCONTEXTFONT2:
			cf.lpLogFont = &fmtstr::LogFont2;
			break;
		case ID_TREE_LAB_WELLELEMENTCONTEXTFONT3:
			cf.lpLogFont = &fmtstr::LogFont3;
			break;
		case ID_TREE_LAB_WELLELEMENTCONTEXTFONT_PLOT_TITLE:
			cf.lpLogFont = &PlotData::TitleFont;
			break;
		case ID_TREE_LAB_WELLELEMENTCONTEXTFONT_PLOT_XLABEL:
			cf.lpLogFont = &PlotData::XLabelFont;
			break;
		case ID_TREE_LAB_WELLELEMENTCONTEXTFONT_PLOT_YLABEL:
			cf.lpLogFont = &PlotData::YLabelFont;
			break;
		case ID_TREE_LAB_WELLELEMENTCONTEXTFONT_PLOT_XAXES:
			cf.lpLogFont = &PlotData::XAxesFont;
			break;
		case ID_TREE_LAB_WELLELEMENTCONTEXTFONT_PLOT_YAXES:
			cf.lpLogFont = &PlotData::YAxesFont;
			break;		
		
		}
				
		cf.rgbColors = 0;
		cf.Flags = CF_BOTH | CF_EFFECTS | CF_TTONLY | CF_INITTOLOGFONTSTRUCT ;
		
		if (ChooseFont(&cf)==TRUE) 
		{
			if (ID_TREE_LAB_WELLELEMENTCONTEXTFONT_PLOT_YLABEL == wmId)
			{
				PlotData::YLabelFont.lfEscapement = 900;
			}
			ReCreateContextWindow();
			return true;
		}			
	}	
	return false;
}
void Laboratory::TestSelectedLabObject()
{
	if (this->selected_lab_object)
	{
		if (!this->IsLabObject(selected_lab_object))
		{
			this->selected_lab_object = NULL;
		}
	}
}
void Laboratory::ReCreateContextWindow()
{
	TestSelectedLabObject();

	if (this->selected_lab_object && hContextWindow)
	{
		HWND hWndParent = ::GetParent(hContextWindow);
		RECT rect;
		GetWindowRect(hContextWindow, &rect);

		DestroyWindow(hContextWindow);
		hContextWindow = CreateWindow(Laboratory::context_with_plot ? lpszContextWindow_2 : lpszContextWindow_1,
			"",//    LPCTSTR lpWindowName,
			WS_POPUP | WS_BORDER, //DWORD dwStyle,
			rect.left,
			rect.top,
			1,//int nWidth,
			1,//   int nHeight,
			hWndParent,//this->hSurfWnd,//HWND hWndParent,
			NULL,//    HMENU hMenu,
			hInst,//HINSTANCE hInstance,
			LPVOID(selected_lab_object)//LPVOID lpParam
			);

		ShowWindow(hContextWindow, 1);
	}
}

void Laboratory::ReDrawContextWindow()
{
	//TestSelectedLabObject();

//	if (hContextWindow)
	{
		//HWND hWndParent = ::GetParent(hContextWindow);
		RECT rect;
		GetClientRect(hContextWindow, &rect);
		InvalidateRect(hContextWindow, &rect, true);
		UpdateWindow(hContextWindow);
	}
}

bool Laboratory::LabWellElementPropPlotHeight()
{
	if (this->selected_lab_object)
	{
		static char command[1024] = "";
		sprintf(command, "%d\0", PlotData::plot_height);
		lab_cmd_dlg * cmnd_dlg = new lab_cmd_dlg(command, false);
		if (cmnd_dlg) strcpy (command, cmnd_dlg->command);

		if (cmnd_dlg && cmnd_dlg->WasOk())
		{
			PlotData::plot_height = atoi(command);;
		}

		if (cmnd_dlg)
		{
			delete cmnd_dlg;
			cmnd_dlg = NULL;
		}

		ReCreateContextWindow();
	}	
	return true;
}
bool Laboratory::LabGurvichYSecondDerivativeLimit()
{
	if (this->selected_lab_object)
	{

		//LabNumber * lab_number = dynamic_cast<LabNumber *>(this->selected_lab_object);

		//LabLayer * lab_layer = NULL;
		
		//if (lab_number) lab_layer = (LabLayer *)lab_number->GetLabLayer();
		//else lab_layer = dynamic_cast<LabLayer *>(this->selected_lab_object);

		//if (lab_layer)
		{
			char s1[1024];
			sprintf(s1, "%f", Gurvich::y_SecondDerivativeLimit);
			DeleteEndZeros(s1);

			static char command[1024] = "";
			sprintf(command, "%s\0", s1);
			lab_cmd_dlg * cmnd_dlg = new lab_cmd_dlg(command, false);
			if (cmnd_dlg) strcpy (command, cmnd_dlg->command);

			if (cmnd_dlg && cmnd_dlg->WasOk())
			{
				istrstream istr(command);

				char kw0[32]; istr >> kw0;

				printf("%s\n", kw0);

				if (
					strlen(kw0) > 0
					)
				{
					Gurvich::y_SecondDerivativeLimit = atof(kw0);

					this->ReCalcProperties(false, true);
					ReCreateContextWindow();
				}
			}

			if (cmnd_dlg)
			{
				delete cmnd_dlg;
				cmnd_dlg = NULL;
			}
		
		}
	}	
	return true;
}
bool Laboratory::LabCompressionESecondDerivativeLimit()
{
	if (this->selected_lab_object)
	{

		//LabNumber * lab_number = dynamic_cast<LabNumber *>(this->selected_lab_object);

		//LabLayer * lab_layer = NULL;
		
		//if (lab_number) lab_layer = (LabLayer *)lab_number->GetLabLayer();
		//else lab_layer = dynamic_cast<LabLayer *>(this->selected_lab_object);

		//if (lab_layer)
		{
			char s1[1024];
			sprintf(s1, "%f", CompressionLabTrialResults::e_SecondDerivativeLimit);
			DeleteEndZeros(s1);

			static char command[1024] = "";
			sprintf(command, "%s\0", s1);
			lab_cmd_dlg * cmnd_dlg = new lab_cmd_dlg(command, false);
			if (cmnd_dlg) strcpy (command, cmnd_dlg->command);

			if (cmnd_dlg && cmnd_dlg->WasOk())
			{
				istrstream istr(command);

				char kw0[32]; istr >> kw0;

				printf("%s\n", kw0);

				if (
					strlen(kw0) > 0
					)
				{
					CompressionLabTrialResults::e_SecondDerivativeLimit = atof(kw0);

					this->ReCalcProperties(false, true);
					ReCreateContextWindow();
				}
			}

			if (cmnd_dlg)
			{
				delete cmnd_dlg;
				cmnd_dlg = NULL;
			}
		
		}
	}	
	return true;
}
bool Laboratory::LabCompressionPressure()
{
	if (this->selected_lab_object)
	{

		LabNumber * lab_number = dynamic_cast<LabNumber *>(this->selected_lab_object);

		LabLayer * lab_layer = NULL;
		
		if (lab_number) lab_layer = (LabLayer *)lab_number->GetLabLayer();
		else lab_layer = dynamic_cast<LabLayer *>(this->selected_lab_object);

		if (lab_layer)
		{
			char s1[1024];
			sprintf(s1, "%f", lab_layer->deformation_module_defined_pressure);
			DeleteEndZeros(s1);

			static char command[1024] = "";
			sprintf(command, "%s\0", s1);
			lab_cmd_dlg * cmnd_dlg = new lab_cmd_dlg(command, false);
			if (cmnd_dlg) strcpy (command, cmnd_dlg->command);

			if (cmnd_dlg && cmnd_dlg->WasOk())
			{
				istrstream istr(command);

				char kw0[32]; istr >> kw0;

				printf("%s\n", kw0);

				if (
					strlen(kw0) > 0
					)
				{
					lab_layer->deformation_module_defined_pressure = atof(kw0);

					lab_layer->ReCalcProperties(false, false);
					ReCreateContextWindow();
				}
			}

			if (cmnd_dlg)
			{
				delete cmnd_dlg;
				cmnd_dlg = NULL;
			}
		
		}
	}	
	return true;
}
bool Laboratory::LabCompressionPressureInterval()
{
	if (this->selected_lab_object)
	{

		LabNumber * lab_number = dynamic_cast<LabNumber *>(this->selected_lab_object);

		LabLayer * lab_layer = NULL;
		
		if (lab_number) lab_layer = (LabLayer *)lab_number->GetLabLayer();
		else lab_layer = dynamic_cast<LabLayer *>(this->selected_lab_object);

		if (lab_layer)
		{
			char s1[1024];
			char s2[1024];
			sprintf(s1, "%f", lab_layer->deformation_module_defined_pressure_interval[0]);
			sprintf(s2, "%f", lab_layer->deformation_module_defined_pressure_interval[1]);
			DeleteEndZeros(s1);
			DeleteEndZeros(s2);

			static char command[1024] = "";
			sprintf(command, "%s %s\0", s1, s2);
			lab_cmd_dlg * cmnd_dlg = new lab_cmd_dlg(command, false);
			if (cmnd_dlg) strcpy (command, cmnd_dlg->command);

			if (cmnd_dlg && cmnd_dlg->WasOk())
			{
				istrstream istr(command);

				char kw0[32]; istr >> kw0;
				char kw1[32]; istr >> kw1;

				printf("%s\n", kw0);
				printf("%s\n", kw1);

				if (
					strlen(kw0) > 0 &&
					strlen(kw1) > 0 
					)
				{
					lab_layer->deformation_module_defined_pressure_interval[0] = atof(kw0);
					lab_layer->deformation_module_defined_pressure_interval[1] = atof(kw1);

					lab_layer->ReCalcProperties(false, false);
					ReCreateContextWindow();
				}
			}

			if (cmnd_dlg)
			{
				delete cmnd_dlg;
				cmnd_dlg = NULL;
			}
		
		}
	}	
	return true;
}
bool Laboratory::LabWaterSaturatedPartOfFullWaterCapacity()
{
	if (this->selected_lab_object)
	{
		static char command[1024] = "";
		sprintf(command, "%f\0", PhysicalLabTrialResults::water_saturated_part_of_full_water_capacity);
		DeleteEndZeros(command);

		lab_cmd_dlg * cmnd_dlg = new lab_cmd_dlg(command, false);
		if (cmnd_dlg) strcpy (command, cmnd_dlg->command);

		if (cmnd_dlg && cmnd_dlg->WasOk())
		{
			PhysicalLabTrialResults::water_saturated_part_of_full_water_capacity = atof(command);;
		}

		if (cmnd_dlg)
		{
			delete cmnd_dlg;
			cmnd_dlg = NULL;
		}
						
		this->ReCalcProperties(false,false);

		ReCreateContextWindow();
	}	
	return true;
}

int Laboratory::ParseLabInputFileLine(char* szBuff, int & type_line, const char * fn, bool use_compression3)
{
	//printf("ParseLabInputFileLine(szBuff = \"%s\", type_line = %d)\)\n", szBuff, type_line);

	/*

г.Харьков
2008
2
3,3,11000,
лит,56.00,20.,од.,водонас.,0.,0.,6.,0.,
0.05,0.10,0.15,0.2,0.25,0.3,
лит,56.,20.,консолид,водонас.,0.0,0.,3.,0.05,0.1,0.15,
414,скв.,1003,1.3,1,2,5,8,0,
0.35,0.22,0.33,0.,0.,0.,2.50,1.70,
0,0,0.02,0,0,0.07,0,0,0,
0.38,0.67,1.00,1.24,2.56,2.85,
0.030,0.050,0.065,
415,скв.,1003,2.0,1,2,5,8,0,
0.43,0.28,0.34,0.,0.,0.,2.37,1.76,
0,0,0.04,0,0,0.06,0,0,0,
0.49,0.94,1.53,2.01,2.33,2.65,
0.045,0.080,0.105,
416,скв.,1003,3.0,1,2,5,8,0,
0.45,0.28,0.44,0.,0.,0.,2.25,1.58,
0,0,0.06,0,0,0.13,0,0,0,
0.64,1.43,2.04,2.64,2.95,3.66,
0.040,0.070,0.100,
417,скв.,1011,1.5,1,2,5,8,0,
0.32,0.15,0.23,0.,0.,0.,2.54,1.90,
0,0,0.04,0,0,0.03,0,0,0,
0.49,0.94,1.53,2.01,2.33,2.65,
0.031,0.050,0.065,
418,скв.,1011,2.0,1,2,5,8,0,
0.42,0.29,0.33,0.,0.,0.,2.60,1.94,
0,0,0.07,0,0,0.04,0,0,0,
0.45,0.65,0.97,1.29,1.35,1.40,
0.035,0.055,0.075,
419,скв.,1011,3.0,1,2,5,8,0,
0.23,0.16,0.20,0.,0.,0.,2.56,1.98,
0,0,0.08,0,0,0.04,0,0,0,
0.06,0.12,0.21,0.37,0.43,0.68,
0.032,0.053,0.072,
420,скв.,1013,1.5,1,2,5,8,0,
0.38,0.27,0.35,0.,0.,0.,2.58,1.82,
0,0,0.07,0,0,0.07,0,0,0,
0.64,1.43,2.04,2.64,2.95,3.64,
0.037,0.070,0.095,
421,скв.,1013,2.5,1,2,5,8,0,
0.43,0.28,0.34,0.,0.,0.,2.40,1.78,
0,0,0.04,0,0,0.05,0,0,0,
0.62,1.07,1.86,2.21,2.56,2.92,
0.040,0.070,0.100,
422,скв.,1013,3.0,1,2,5,8,0,
0.35,0.22,0.33,0.,0.,0.,2.45,1.93,
0,0,0.09,0,0,0.04,0,0,0,
0.40,1.12,1.59,2.02,2.30,2.75,
0.050,0.080,0.105,
423,скв.,1040,1.5,1,2,5,8,0,
0.41,0.25,0.36,0.,0.,0.,2.50,1.77,
0,0,0.07,0,0,0.09,0,0,0,
0.60,1.40,2.00,2.60,2.90,3.61,
0.044,0.079,0.104,
**
3,6,11000,
лит,56.00,20.,од.,водонас.,0.,0.,7.,0.,
0.1,0.15,0.2,0.25,0.3,0.35,0.40,
лит,56.,20.,консолид,водонас.,0.0,0.,3.,0.1,0.2,0.3,
381,скв.,1001,7.1,1,5,8,0,
0.65,0.42,0.38,0.,0.,0.,2.65,1.80,
0.34,0.57,0.76,0.92,1.07,1.22,1.36,
0.105,0.150,0.195,
382,скв.,1001,7.8,1,5,8,0,
0.61,0.40,0.34,0.,0.,0.,2.65,1.86,
0.10,0.27,0.40,0.52,0.64,0.76,0.87,
0.095,0.145,0.195,
383,скв.,1013,8.2,1,5,8,0,
0.42,0.24,0.23,0.,0.,0.,2.66,1.95,
0.18,0.34,0.48,0.60,0.71,0.82,0.92,
0.115,0.160,0.205,
384,скв.,1013,9.3,1,5,8,0,
0.28,0.17,0.18,0.,0.,0.,2.66,1.97,
0.24,0.40,0.53,0.66,0.77,0.88,0.95,
0.105,0.165,0.205,
403,скв.,1025,6.0,1,5,8,0,
0.63,0.40,0.36,0.,0.,0.,2.65,1.79,
0.20,0.45,0.65,0.81,0.99,1.02,1.18,
0.100,0.140,0.185,
404,скв.,1025,7.0,1,5,8,0,
0.60,0.39,0.30,0.,0.,0.,2.65,1.84,
0.15,0.32,0.45,0.57,0.69,0.81,0.92,
0.097,0.147,0.197,
405,скв.,1025,8.0,1,5,8,0,
0.42,0.24,0.25,0.,0.,0.,2.66,1.96,
0.17,0.33,0.47,0.59,0.70,0.81,0.91,
0.100,0.145,0.190,
406,скв.,1025,9.0,1,5,8,0,
0.35,0.18,0.21,0.,0.,0.,2.66,1.98,
0.25,0.41,0.54,0.67,0.78,0.89,0.96,
0.110,0.170,0.210,
407,скв.,1023,6.0,1,5,8,0,
0.39,0.21,0.23,0.,0.,0.,2.66,1.96,
0.24,0.40,0.53,0.66,0.77,0.88,0.95,
0.105,0.165,0.205,
408,скв.,1023,7.0,1,5,8,0,
0.61,0.34,0.36,0.,0.,0.,2.65,1.81,
0.28,0.41,0.49,0.59,0.70,0.80,0.89,
0.083,0.138,0.195,
409,скв.,1023,8.0,1,5,8,0,
0.63,0.36,0.38,0.,0.,0.,2.65,1.86,
0.25,0.34,0.42,0.51,0.65,0.73,0.85,
0.095,0.135,0.185,
410,скв.,1023,9.0,1,5,8,0,
0.43,0.24,0.25,0.,0.,0.,2.65,1.91,
0.20,0.45,0.64,0.80,1.11,1.22,1.32,
0.100,0.150,0.190,
411,скв.,1023,10.0,1,5,8,0,
0.64,0.36,0.34,0.,0.,0.,2.66,1.84,
0.14,0.31,0.44,0.56,0.68,0.79,0.90,
0.105,0.150,0.195,
412,скв.,1027,7.0,1,5,8,0,
0.60,0.36,0.36,0.,0.,0.,2.65,1.87,
0.21,0.37,0.51,0.63,0.74,0.85,0.92,
0.090,0.135,0.175,
413,скв.,1027,8.0,1,5,8,0,
0.56,0.28,0.30,0.,0.,0.,2.66,1.90,
0.20,0.45,0.65,0.80,1.11,1.33,1.40,
0.105,0.155,0.200,
**
1,8,11000,
лит,56.00,20.,од.,водонас.,0.,0.,6.,0.,
0.1,0.2,0.3,0.4,0.5,0.6,
лит,56.,20.,консолид,водонас.,0.0,0.,3.,0.1,0.3,0.5,
388,скв.,1001,22.6,1,5,8,0,
0.47,0.26,0.25,0.,0.,0.,2.65,1.90,
0.19,0.40,0.57,0.71,0.83,0.93,
0.101,0.196,0.286,
389,скв.,1001,23.0,1,5,8,0,
0.42,0.24,0.25,0.,0.,0.,2.65,1.91,
0.14,0.35,0.53,0.69,0.81,0.91,
0.115,0.205,0.295,
390,скв.,1001,22.5,1,5,8,0,
0.42,0.24,0.24,0.,0.,0.,2.65,1.92,
0.18,0.39,0.56,0.70,0.82,0.92,
0.100,0.195,0.285,
391,скв.,1022,19.0,1,5,8,0,
0.33,0.20,0.27,0.,0.,0.,2.66,1.96,
0.16,0.33,0.49,0.65,0.81,0.96,
0.102,0.197,0.293,
392,скв.,1022,20.0,1,5,8,0,
0.36,0.21,0.26,0.,0.,0.,2.66,1.91,
0.29,0.54,0.75,0.92,1.08,1.20,
0.105,0.205,0.300,
393,скв.,1022,20.5,1,5,8,0,
0.36,0.21,0.28,0.,0.,0.,2.65,1.93,
0.20,0.42,0.61,0.76,0.90,1.01,
0.105,0.200,0.295,
394,скв.,1013,22.5,1,5,8,0,
0.38,0.22,0.26,0.,0.,0.,2.65,1.91,
0.15,0.36,0.54,0.70,0.82,0.93,
0.115,0.205,0.295,
395,скв.,1035,21.0,1,5,8,0,
0.34,0.20,0.28,0.,0.,0.,2.65,1.90,
0.23,0.51,0.74,0.92,1.09,1.22,
0.085,0.165,0.240,
396,скв.,1035,21.5,1,5,8,0,
0.35,0.21,0.25,0.,0.,0.,2.66,1.93,
0.27,0.48,0.69,0.84,0.98,1.09,
0.115,0.220,0.325,
397,скв.,1035,22.0,1,5,8,0,
0.36,0.21,0.26,0.,0.,0.,2.65,1.90,
0.29,0.53,0.75,0.93,1.10,1.24,
0.095,0.180,0.270,
398,скв.,1013,23.0,1,5,8,0,
0.49,0.28,0.28,0.,0.,0.,2.66,1.90,
0.17,0.38,0.55,0.69,0.81,0.91,
0.102,0.197,0.287,
399,скв.,1013,24.0,1,5,8,0,
0.43,0.25,0.26,0.,0.,0.,2.66,1.92,
0.18,0.35,0.51,0.67,0.79,0.89,
0.110,0.200,0.290,
400,скв.,1013,25.0,1,5,8,0,
0.42,0.24,0.25,0.,0.,0.,2.66,1.91,
0.19,0.40,0.57,0.71,0.83,0.93,
0.100,0.195,0.285,
401,скв.,1028,23.0,1,5,8,0,
0.41,0.23,0.25,0.,0.,0.,2.66,1.94,
0.18,0.39,0.56,0.70,0.82,0.92,
0.100,0.195,0.285,
402,скв.,1028,24.0,1,5,8,0,
0.46,0.24,0.26,0.,0.,0.,2.66,1.90,
0.17,0.36,0.53,0.68,0.82,0.94,
0.100,0.195,0.285,
**
***

*/

	printf(szBuff);
	char * p = szBuff;
	char out[1024];

	while (true)
	{
		if (type_line == 5)
		{	
			if (this->m_lablayer->is_compression)
				break;
			else
				type_line = 9;
		}		
		if (type_line == 6)
		{	
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);
			if (compression)
			{
#if USE_LAB_LAYER_PRESSURES
				if (compression->n_pressures_in_nature_condition)
#else
				if (compression->lab_layer_n_pressures_in_nature_condition)
#endif
					break;
				else
					type_line = 7;
			}
			else
				return -2;
		}
		if (type_line == 7)
		{	
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);
			if (compression)
			{
#if USE_LAB_LAYER_PRESSURES
				if (compression->n_pressures_in_task_condition)
#else
				if (compression->lab_layer_n_pressures_in_task_condition)
#endif
					break;
				else
					type_line = 8;
			}
			else
				return -2;
		}
		if (type_line == 8)
		{	
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);
			if (compression)
			{
#if USE_LAB_LAYER_PRESSURES
				if (compression->n_pressures_on_shrinkage)
#else
				if (compression->lab_layer_n_pressures_on_shrinkage)
#endif
					break;
				else
					type_line = 9;
			}
			else
				return -2;
		}
		else if(type_line == 9)
		{
			if (this->m_lablayer->is_cut)
				break;
			else
				type_line = 10;
		}
		else if(type_line == 10)
		{
			if (this->m_lablayer->is_filtracion)
				break;
			else
				type_line = 11;
		}
		else if(type_line == 11)
		{
			if (this->m_lablayer->is_pressing)
				break;
			else
				type_line = 12;
		}
		else if(type_line == 12)
		{
			if (this->m_lablayer->is_fractions)
				break;
			else
				type_line = 13;
		}
		else if(type_line == 14)
		{
			if (m_lab_number)
			{
				if (this->m_lab_number->is_trial_indication_1)
					break;
				else
					type_line = 15;
			}
			else return -3;
		}
		else if(type_line == 15)
		{
			if (m_lab_number)
			{
				if (this->m_lab_number->is_trial_indication_2)
					break;
				else
					type_line = 16;
			}
			else return -3;
		}
		else if(type_line == 16)
		{
			if (m_lab_number)
			{
				if (this->m_lab_number->is_trial_indication_3)
					break;
				else
					type_line = 18;
			}
			else return -3;
		}
		else if(type_line == 18)
		{
			if (m_lab_number)
			{
				if (this->m_lab_number->is_trial_indication_4)
					break;
				else
					type_line = 19;
			}
			else return -3;
		}
		else if(type_line == 19)
		{
			if (m_lab_number)
			{
				if (this->m_lab_number->is_trial_indication_5)
					break;
				else
					type_line = 20;
			}
			else return -3;
		}
		else if(type_line == 20)
		{
			if (m_lab_number)
			{
				if (this->m_lab_number->is_trial_indication_6)
					break;
				else
					type_line = 21;
			}
			else return -3;
		}
		else if(type_line == 21)
		{
			if (m_lab_number)
			{
				if (this->m_lab_number->is_trial_indication_7)
					break;
				else
					type_line = 22;
			}
			else return -3;
		}
		else if(type_line == 22)
		{
			if (m_lab_number)
			{
				if (this->m_lab_number->is_trial_indication_8)
					break;
				else
					type_line = 23;
			}
			else return -3;
		}
		else if(type_line == 23)
		{
			if (m_lab_number)
			{
				if (this->m_lab_number->is_trial_indication_9)
					break;
				else
					type_line = 24;
			}
			else return -3;
		}
		else if(type_line == 24)
		{
			if (m_lab_number)
			{
				if (this->m_lab_number->is_trial_indication_10)
					break;
				else
					type_line = 25;
			}
			else return -3;
		}
		else if(type_line == 25)
		{
			if (m_lab_number)
			{
				if (this->m_lab_number->is_trial_indication_11)
					break;
				else
					type_line = 26;
			}
			else return -3;
		}
		else if(type_line == 26)
		{
			type_line = 13;
		}
		else
			break;
	}

	if (!strncmp(p, "***", 3))
	{
		printf("(!strcmp(p, \"***\"))\n");
		return 3;
	}

	if (!strncmp(p, "**", 2))
	{
		type_line = 4;
		printf("(!strcmp(p, \"**\"))\n");
		return 0;
	}


	printf("type_line = %d\n", type_line);
	switch(type_line)
	{
	case 1:
		{
			// г.Харьков
			// наименование объекта
			OemToChar(p, p);
			char * pp = strchr(p,'\n'); if(pp) *pp = '\0';
			object_name = p;
			return -1;
		}
		break;
	case 2:
		{
			// 2008
			// наименование договора
			OemToChar(p, p);
			char * pp = strchr(p,'\n'); if(pp) *pp = '\0';
			contract = p;
			return -1;
		}
		break;
	case 3:
		{
			// 2
			// архивный номер
			id_obj = atoi(p);
			return -1;
		}
		break;
	case 4:
		{
			//3,3,11000,
			//идентификационный номер, номер слоя, схема испытания
			m_lablayer = new LabLayer(this, fn);
			this->m_layers.push_back(m_lablayer);

			p = ParsingLabInputFileLine(p, out); 
			if (p){ m_lablayer->ID = out;}
            printf("m_lablayer->ID = %s\n", m_lablayer->ID.c_str());
			p = ParsingLabInputFileLine(p, out); 
#if CHAR_LAYER_NUMBER_ID
			OemToChar(out,out);	
#endif
			if (p){ m_lablayer->layer_number = out;}
			printf("m_lablayer->layer_number = %s\n", m_lablayer->layer_number.c_str());
			p = ParsingLabInputFileLine(p, out); 
			if (p)
			{
				m_lablayer->experiments_scheme = out;
				m_lablayer->ParseExperimentsScheme();
				m_lablayer->PrintfProperties();
			}
			return 1;
		}
		break;
	case 5:
		{
			// Компрессия 
			// лит,56.00,20.,од.,водонас.,0.,0.,6.,0.,
			// тип прибора,	диаметр кольца, высота кольца, метод испытания, заданная влажность, заданная плотность, количество давлений в природном состоянии, количество давлений в заданном состоянии, количество давлений на усадку
			m_lab_experiment = m_lablayer->AddNewLabExperiment(LabExperiment::type::compression);
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);

			if (compression)
			{
				p = ParsingLabInputFileLine(p, out); 
				if (p) compression->apparatus_type = out;
				printf("compression->apparatus_type = %s\n", compression->apparatus_type.c_str());
				
				p = ParsingLabInputFileLine(p, out); 
#if USE_LAB_LAYER_HOOP
				if (p) compression->hoop_diameter = atof(out);
				printf("compression->hoop_diameter = %f\n", compression->hoop_diameter);
#else
				if (p) compression->lab_layer_hoop_diameter = atof(out);
				printf("compression->lab_layer_hoop_diameter = %f\n", compression->lab_layer_hoop_diameter);
#endif
				
				p = ParsingLabInputFileLine(p, out); 
#if USE_LAB_LAYER_HOOP
				if (p) compression->hoop_height = atof(out);
				printf("compression->hoop_height = %f\n", compression->hoop_height);
#else
				if (p)
				{
					compression->lab_layer_hoop_height = atof(out);
					compression->lab_layer_hoop_defined = true;
				}
				printf("compression->lab_layer_hoop_height = %f\n", compression->lab_layer_hoop_height);
#endif
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) compression->trial_method = out;
				printf("compression->trial_method = %s\n", compression->trial_method.c_str());
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) compression->task_moisture = out;
				if (p) compression->ParseTaskMoisture();
				printf("compression->task_moisture = %s\n", compression->task_moisture.c_str());
				printf("compression->task_moisture = %f\n", compression->task_moisture_v);
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) compression->task_density = atof(out);
				printf("compression->task_density = %f\n", compression->task_density);
				
#if USE_LAB_LAYER_PRESSURES
				p = ParsingLabInputFileLine(p, out); 
				if (p) compression->n_pressures_in_nature_condition = atoi(out);
				printf("compression->n_pressures_in_nature_condition = %d\n", compression->n_pressures_in_nature_condition);
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) compression->n_pressures_in_task_condition = atoi(out);
				printf("compression->n_pressures_in_task_condition = %d\n", compression->n_pressures_in_task_condition);
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) compression->n_pressures_on_shrinkage = atoi(out);
				printf("compression->n_pressures_on_shrinkage = %d\n", compression->n_pressures_on_shrinkage);
#else
				p = ParsingLabInputFileLine(p, out); 
				if (p) compression->lab_layer_n_pressures_in_nature_condition = atoi(out);
				printf("compression->lab_layer_n_pressures_in_nature_condition = %d\n", compression->lab_layer_n_pressures_in_nature_condition);
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) compression->lab_layer_n_pressures_in_task_condition = atoi(out);
				printf("compression->lab_layer_n_pressures_in_task_condition = %d\n", compression->lab_layer_n_pressures_in_task_condition);
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) compression->lab_layer_n_pressures_on_shrinkage = atoi(out);
				printf("compression->lab_layer_n_pressures_on_shrinkage = %d\n", compression->lab_layer_n_pressures_on_shrinkage);
#endif
			}
			return 1;

		}
		break;
	case 6:
		{
			// 0.05,0.10,0.15,0.2,0.25,0.3,
			// массив давлений природного состояния
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);
			if (compression)
			{
#if USE_LAB_LAYER_PRESSURES
				compression->pressures_in_nature_condition = new double[compression->n_pressures_in_nature_condition];
				for (int i = 0; i < compression->n_pressures_in_nature_condition; i++)
				{
					p = ParsingLabInputFileLine(p, out); 
					if (p) compression->pressures_in_nature_condition[i] = atof(out);
					printf("compression->pressures_in_nature_condition[%d] = %f\n", i, compression->pressures_in_nature_condition[i]);
				}
#else
				compression->lab_layer_pressures_in_nature_condition = new double[compression->lab_layer_n_pressures_in_nature_condition];
				for (int i = 0; i < compression->lab_layer_n_pressures_in_nature_condition; i++)
				{
					p = ParsingLabInputFileLine(p, out); 
					if (p) compression->lab_layer_pressures_in_nature_condition[i] = atof(out);
					printf("compression->lab_layer_pressures_in_nature_condition[%d] = %f\n", i, compression->lab_layer_pressures_in_nature_condition[i]);
				}
#endif
			}
			return 1;
		}
		break;
	case 7:
		{
			// 0.05,0.10,0.15,0.2,0.25,0.3,
			// массив давлений заданного состояния
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);
			if (compression)
			{
#if USE_LAB_LAYER_PRESSURES
				compression->pressures_in_task_condition = new double[compression->n_pressures_in_task_condition];
				for (int i = 0; i < compression->n_pressures_in_task_condition; i++)
				{
					p = ParsingLabInputFileLine(p, out); 
					if (p) compression->pressures_in_task_condition[i] = atof(out);
					printf("compression->pressures_in_task_condition[%d] = %f\n", i, compression->pressures_in_task_condition[i]);
				}
#else
				compression->lab_layer_pressures_in_task_condition = new double[compression->lab_layer_n_pressures_in_task_condition];
				for (int i = 0; i < compression->lab_layer_n_pressures_in_task_condition; i++)
				{
					p = ParsingLabInputFileLine(p, out); 
					if (p) compression->lab_layer_pressures_in_task_condition[i] = atof(out);
					printf("compression->lab_layer_pressures_in_task_condition[%d] = %f\n", i, compression->lab_layer_pressures_in_task_condition[i]);
				}
#endif
			}
			return 1;
		}
		break;
	case 8:
		{
			// 0.05,0.10,0.15,0.2,0.25,0.3,
			// массив давлений на усадку
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);
			if (compression)
			{
#if USE_LAB_LAYER_PRESSURES
				compression->pressures_on_shrinkage = new double[compression->n_pressures_on_shrinkage];
				for (int i = 0; i < compression->n_pressures_on_shrinkage; i++)
				{
					p = ParsingLabInputFileLine(p, out); 
					if (p) compression->pressures_on_shrinkage[i] = atof(out);
					printf("compression->pressures_on_shrinkage[%d] = %f\n", i, compression->pressures_on_shrinkage[i]);
				}
#else
				compression->lab_layer_pressures_on_shrinkage = new double[compression->lab_layer_n_pressures_on_shrinkage];
				for (int i = 0; i < compression->lab_layer_n_pressures_on_shrinkage; i++)
				{
					p = ParsingLabInputFileLine(p, out); 
					if (p) compression->lab_layer_pressures_on_shrinkage[i] = atof(out);
					printf("compression->lab_layer_pressures_on_shrinkage[%d] = %f\n", i, compression->lab_layer_pressures_on_shrinkage[i]);
				}
#endif
			}
			return 1;
		}
		break;
	case 9:
		{
			// лит,56.,20.,консолид,водонас.,0.0,0.,3.,0.05,0.1,0.15,
			// СРЕЗ
			// тип прибора, диаметр кольцаб высота кольца метод испытания, заданная влажность, заданная плотность, колич. давлений природного состояния, кол. давл. в зад. сост., массив давлений природного состояния, массив давлений заданного состояния
			// 
			m_lab_experiment = m_lablayer->AddNewLabExperiment(LabExperiment::type::cut);
			CutLabExperiment * cut = dynamic_cast<CutLabExperiment *>(m_lab_experiment);

			if (cut)
			{
				p = ParsingLabInputFileLine(p, out); 
				if (p) cut->apparatus_type = out;
				printf("cut->apparatus_type = %s\n", cut->apparatus_type.c_str());
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) cut->hoop_diameter = atof(out);
				printf("cut->hoop_diameter = %f\n", cut->hoop_diameter);
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) cut->hoop_height = atof(out);
				printf("cut->hoop_height = %f\n", cut->hoop_height);
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) cut->trial_method = out;
				printf("cut->trial_method = %s\n", cut->trial_method.c_str());
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) cut->task_moisture = out;
				if (p) cut->ParseTaskMoisture();
				printf("cut->task_moisture = %s\n", cut->task_moisture.c_str());
				printf("cut->task_moisture = %f\n", cut->task_moisture_v);
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) cut->task_density = atof(out);
				printf("cut->task_density = %f\n", cut->task_density);
				
#if USE_LAB_LAYER_CUT_PRESSURES
				p = ParsingLabInputFileLine(p, out); 
				if (p) cut->n_pressures_in_nature_condition = atoi(out);
				printf("cut->n_pressures_in_nature_condition = %d\n", cut->n_pressures_in_nature_condition);
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) cut->n_pressures_in_task_condition = atoi(out);
				printf("cut->n_pressures_in_task_condition = %d\n", cut->n_pressures_in_task_condition);
#else
				p = ParsingLabInputFileLine(p, out); 
				if (p) cut->lab_layer_n_pressures_in_nature_condition = atoi(out);
				printf("cut->lab_layer_n_pressures_in_nature_condition = %d\n", cut->lab_layer_n_pressures_in_nature_condition);
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) cut->lab_layer_n_pressures_in_task_condition = atoi(out);
				printf("cut->lab_layer_n_pressures_in_task_condition = %d\n", cut->lab_layer_n_pressures_in_task_condition);
#endif
				
#if USE_LAB_LAYER_CUT_PRESSURES
				if (cut->n_pressures_in_nature_condition)
				{
					cut->pressures_in_nature_condition = new double[cut->n_pressures_in_nature_condition];
					for (int i = 0; i < cut->n_pressures_in_nature_condition; i++)
					{
						p = ParsingLabInputFileLine(p, out); 
						if (p) cut->pressures_in_nature_condition[i] = atof(out);
						printf("cut->pressures_in_nature_condition[%d] = %f\n", i, cut->pressures_in_nature_condition[i]);
					}
				}

				if (cut->n_pressures_in_task_condition)
				{
					cut->pressures_in_task_condition = new double[cut->n_pressures_in_task_condition];
					for (int i = 0; i < cut->n_pressures_in_task_condition; i++)
					{
						p = ParsingLabInputFileLine(p, out); 
						if (p) cut->pressures_in_task_condition[i] = atof(out);
						printf("cut->pressures_in_task_condition[%d] = %f\n", i, cut->pressures_in_task_condition[i]);
					}
				}
#else
				if (cut->lab_layer_n_pressures_in_nature_condition)
				{
					cut->lab_layer_pressures_in_nature_condition = new double[cut->lab_layer_n_pressures_in_nature_condition];
					for (int i = 0; i < cut->lab_layer_n_pressures_in_nature_condition; i++)
					{
						p = ParsingLabInputFileLine(p, out); 
						if (p) cut->lab_layer_pressures_in_nature_condition[i] = atof(out);
						printf("cut->lab_layer_pressures_in_nature_condition[%d] = %f\n", i, cut->lab_layer_pressures_in_nature_condition[i]);
					}
				}

				if (cut->lab_layer_n_pressures_in_task_condition)
				{
					cut->lab_layer_pressures_in_task_condition = new double[cut->lab_layer_n_pressures_in_task_condition];
					for (int i = 0; i < cut->lab_layer_n_pressures_in_task_condition; i++)
					{
						p = ParsingLabInputFileLine(p, out); 
						if (p) cut->lab_layer_pressures_in_task_condition[i] = atof(out);
						printf("cut->lab_layer_pressures_in_task_condition[%d] = %f\n", i, cut->lab_layer_pressures_in_task_condition[i]);
					}
				}
#endif

			}

			return 1;
		}
		break;
	case 10:
		{
			m_lab_experiment = m_lablayer->AddNewLabExperiment(LabExperiment::type::filtration);
			FiltrationLabExperiment * filtration = dynamic_cast<FiltrationLabExperiment *>(m_lab_experiment);

			if (filtration)
			{
				p = ParsingLabInputFileLine(p, out); 
				if (p) filtration->apparatus_type = out;
				printf("filtration->apparatus_type = %s\n", filtration->apparatus_type.c_str());
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) filtration->tube_diameter = atof(out);
				printf("filtration->tube_diameter = %f\n", filtration->tube_diameter);
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) filtration->tube_lenght = atof(out);
				printf("filtration->tube_lenght = %f\n", filtration->tube_lenght);
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) filtration->liquid_force_height = atof(out);
				printf("filtration->liquid_force_height = %f\n", filtration->liquid_force_height);
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) filtration->task_density = atof(out);
				printf("filtration->task_density = %f\n", filtration->task_density);
								
				for (int i = 0; i < 3; i++)
				{
					p = ParsingLabInputFileLine(p, out); 
					if (p) filtration->pressures[i] = atof(out);
					printf("filtration->pressures[%d] = %f\n", i, filtration->pressures[i]);
				}
			}			
			return 1;
		}
		break;
	case 11:
		{
			m_lab_experiment = m_lablayer->AddNewLabExperiment(LabExperiment::type::pressing);
			PressingLabExperiment * pressing = dynamic_cast<PressingLabExperiment *>(m_lab_experiment);

			if (pressing)
			{
				p = ParsingLabInputFileLine(p, out); 
				if (p) pressing->apparatus_type = out;
				printf("pressing->apparatus_type = %s\n", pressing->apparatus_type.c_str());
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) pressing->task_moisture = out;
				if (p) pressing->ParseTaskMoisture();
				printf("pressing->task_moisture = %s\n", pressing->task_moisture.c_str());
				printf("pressing->task_moisture = %f\n", pressing->task_moisture_v);

				p = ParsingLabInputFileLine(p, out); 
				if (p) pressing->density = atof(out);
				printf("pressing->density = %f\n", pressing->density);
			}
			return 1;
		}
		break;
	case 12:
		{
			m_lab_experiment = m_lablayer->AddNewLabExperiment(LabExperiment::type::fractions);
			FractionsLabExperiment * fractions = dynamic_cast<FractionsLabExperiment *>(m_lab_experiment);

#if USE_LAB_LAYER_FRACTIONS
			if(fractions)
			{
				p = ParsingLabInputFileLine(p, out); 
				if (p) fractions->n_fractions = atoi(out);
				printf("fractions->n_fractions = %d\n", fractions->n_fractions);
				
				if (fractions->n_fractions)
				{
					fractions->fractions_diameters = new double[fractions->n_fractions];
					for (int i = 0; i < fractions->n_fractions; i++)
					{
						p = ParsingLabInputFileLine(p, out); 
						if (p) fractions->fractions_diameters[i] = atof(out);
						printf("fractions->fractions_diameters[%d] = %f\n", i, fractions->fractions_diameters[i]);
					}
				}
			}
#else
			if(fractions)
			{
				p = ParsingLabInputFileLine(p, out); 
				if (p) fractions->lab_layer_n_fractions = atoi(out);
				printf("fractions->lab_layer_n_fractions = %d\n", fractions->lab_layer_n_fractions);
				
				if (fractions->lab_layer_n_fractions)
				{
#if USE_FRACTION_DIAMETERS_INTERVAL
					fractions->lab_layer_fractions_diameters = new fraction_diameters_interval[fractions->lab_layer_n_fractions];
#else
					fractions->lab_layer_fractions_diameters = new double[fractions->lab_layer_n_fractions];
#endif
					for (int i = 0; i < fractions->lab_layer_n_fractions; i++)
					{
						p = ParsingLabInputFileLine(p, out); 
#if USE_FRACTION_DIAMETERS_INTERVAL
						if (p) fractions->lab_layer_fractions_diameters[i].low = atof(out);
						if (i) //TODO test this if need
						{
							fractions->lab_layer_fractions_diameters[i].high = 
								fractions->lab_layer_fractions_diameters[i-1].low;
						}
#else
						if (p) fractions->lab_layer_fractions_diameters[i] = atof(out);
#endif
						printf("fractions->lab_layer_fractions_diameters[%d] = %f\n", i, fractions->lab_layer_fractions_diameters[i]);
					}
				}
			}
#endif
			return 1;
		}
		break;
	case 13:// 1
		{
			// заголовок данных по лабораторному номеру
			// 414,скв.,1003,1.3,1,2,5,8,0,
			// лабораторный идентификационный номер, наименование выработки, номер выработки, глубина пробы, признаки испытания
			m_lab_number = this->m_lablayer->AddNewLabNumber();

			if (m_lab_number)
			{
				printf("m_lab_number = %x\n", m_lab_number);

				p = ParsingLabInputFileLine(p, out); 
				if (p) m_lab_number->ID = out;
				printf("m_lab_number->ID = %s\n", m_lab_number->ID.c_str());

				p = ParsingLabInputFileLine(p, out); 
				if (p) m_lab_number->s_mine_working_type = out;
				printf("m_lab_number->s_mine_working_type = %s\n", m_lab_number->s_mine_working_type.c_str());
				m_lab_number->ParseMineWorkingType();
				printf("m_lab_number->m_mine_working_type = %d\n", int(m_lab_number->m_mine_working_type));

				p = ParsingLabInputFileLine(p, out); 
#if CHAR_MINE_WORKING_NUMBER
				OemToChar(out,out);
#endif
				if (p) m_lab_number->mine_working_number = out;
				printf("m_lab_number->mine_working_number = %s\n", m_lab_number->mine_working_number.c_str());
				
				p = ParsingLabInputFileLine(p, out); 
				if (p) m_lab_number->depth = atof(out);
				printf("m_lab_number->depth = %f\n", m_lab_number->depth);

				LabTrial::indication indication;
				while (true)
				{
					p = ParsingLabInputFileLine(p, out); 
					if (p)
					{
						indication = (LabTrial::indication) (atoi(out));
						if (indication == LabTrial::indication::undefined_lab_trial_indication)
							break;
						printf("indication = %d\n", int(indication));
						m_lab_number->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));
					}
					else
						break;
				}

				if (!m_lab_number->ParseTrialIndications())
				{
					// Ошибка в таком-то лабораторном номере отсутствуют признаки испытаний
					char str[4098];
					sprintf(str, "Ошибка в лабораторном номере %s отсутствуют признаки испытаний", m_lab_number->ID.c_str());
					MessageBox(0, str, "Ошибка", 0);
					return 3;
				}
			}
			return 1;
		}
		break;
	case 14://2 - 1 признак - физические характеристики
		{
			m_lab_trial = m_lab_number->AddNewLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB);
			PhysicalLabTrial * physical_trial = dynamic_cast<PhysicalLabTrial *>(m_lab_trial);

			if (physical_trial)
			{
				p = ParsingLabInputFileLine(p, out); 
				if (p) physical_trial->moisture_on_fluidity_border = atof(out);
				printf("physical_trial->moisture_on_fluidity_border = %f\n", physical_trial->moisture_on_fluidity_border.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) physical_trial->moisture_on_plasticity_border = atof(out);
				printf("physical_trial->moisture_on_plasticity_border = %f\n", physical_trial->moisture_on_plasticity_border.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) physical_trial->moisture_of_nature_large_exchange = atof(out);
				printf("physical_trial->moisture_of_nature_large_exchange = %f\n", physical_trial->moisture_of_nature_large_exchange.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) physical_trial->moisture_of_aggregate_sample = atof(out);
				printf("physical_trial->moisture_of_aggregate_sample = %f\n", physical_trial->moisture_of_aggregate_sample.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) physical_trial->hygroscopic_moisture = atof(out);
				printf("physical_trial->hygroscopic_moisture = %f\n", physical_trial->hygroscopic_moisture.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) physical_trial->maximal_molecular_moisture_capacity = atof(out);
				printf("physical_trial->maximal_molecular_moisture_capacity = %f\n", physical_trial->maximal_molecular_moisture_capacity.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) physical_trial->density_of_ground_particles = atof(out);
				printf("physical_trial->density_of_ground_particles = %f\n", physical_trial->density_of_ground_particles.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) physical_trial->density_of_ground = atof(out);
				printf("physical_trial->density_of_ground = %f\n", physical_trial->density_of_ground.v);
			
			}
			return 1;
		}
		break;
	case 15://3 - 2 признак - химические характеристики
		{
			m_lab_trial = m_lab_number->AddNewLabTrial(LabTrial::indication::chemical, MEAN_VYPROB);
			ChemicalLabTrial * chemical_trial = dynamic_cast<ChemicalLabTrial *>(m_lab_trial);

			if (chemical_trial)
			{
				p = ParsingLabInputFileLine(p, out); 
				if (p) chemical_trial->common_salts_content = atof(out);
				printf("chemical_trial->common_salts_content = %f\n", chemical_trial->common_salts_content.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) chemical_trial->well_solutable_salts = atof(out);
				printf("chemical_trial->well_solutable_salts = %f\n", chemical_trial->well_solutable_salts.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) chemical_trial->vegetable_remains_content = atof(out);
				printf("chemical_trial->vegetable_remains_content = %f\n", chemical_trial->vegetable_remains_content.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) chemical_trial->organic_matters = atof(out);
				printf("chemical_trial->organic_matters = %f\n", chemical_trial->organic_matters.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) chemical_trial->pH = atof(out);
				printf("chemical_trial->pH = %f\n", chemical_trial->pH.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) chemical_trial->steel_mass_loss = atof(out);
				printf("chemical_trial->steel_mass_loss = %f\n", chemical_trial->steel_mass_loss.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) chemical_trial->nitrogenic_matters = atof(out);
				printf("chemical_trial->nitrogenic_matters = %f\n", chemical_trial->nitrogenic_matters.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) chemical_trial->Cl_ion = atof(out);
				printf("chemical_trial->Cl_ion = %f\n", chemical_trial->Cl_ion.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) chemical_trial->Fe_ion = atof(out);
				printf("chemical_trial->Fe_ion = %f\n", chemical_trial->Fe_ion.v);			
			}
			return 1;
		}
		break;
	case 16://4 - 3 признак - фракции 
		{
			m_lab_trial = m_lab_number->AddNewLabTrial(LabTrial::indication::fractions, MEAN_VYPROB);
			FractionsLabTrial * fractions_trial = dynamic_cast<FractionsLabTrial *>(m_lab_trial);
			LabLayer * lablayer = (LabLayer *) m_lab_number->GetLabLayer();
			if (lablayer)
			{
				m_lab_experiment = lablayer->FindLabExperiment(LabExperiment::type::fractions);
				FractionsLabExperiment * fractions = dynamic_cast<FractionsLabExperiment *>(m_lab_experiment);

				if(fractions_trial && fractions)
				{
#if USE_LAB_LAYER_FRACTIONS
					fractions_trial->n_fractions = fractions->n_fractions;
#else
					fractions_trial->n_fractions = fractions->lab_layer_n_fractions;
#endif
					if (fractions_trial->n_fractions)
					{
#if USE_LAB_LAYER_FRACTIONS
#else
#if USE_FRACTION_DIAMETERS_INTERVAL
						fractions_trial->fractions_diameters = new fraction_diameters_interval[fractions_trial->n_fractions];
#else
						fractions_trial->fractions_diameters = new double[fractions_trial->n_fractions];
#endif
#endif
						fractions_trial->fractions_content = new trial_value[fractions_trial->n_fractions];
						for (int i = 0; i < fractions_trial->n_fractions; i++)
						{
							p = ParsingLabInputFileLine(p, out); 
							if (p)
							{
								fractions_trial->fractions_content[i] = atof(out);
								fractions_trial->fractions_content[i].f = TRIAL_VALUE_DEFINED_CANNOT_EXCLUDED;
#if USE_LAB_LAYER_FRACTIONS
#else
								fractions_trial->fractions_diameters[i] = fractions->lab_layer_fractions_diameters[i];
#endif
							}
							printf("fractions_trial->fractions_content[%d] = %f\n", i, fractions_trial->fractions_content[i].v);
						}
					}
				}
			}
			return 1;
		}
		break;
	case 17://5 - 3 признак - фракции продолжение
		{
			FractionsLabTrial * fractions_trial = dynamic_cast<FractionsLabTrial *>(m_lab_trial);
			if(fractions_trial)
			{
				p = ParsingLabInputFileLine(p, out); 
				if (p) fractions_trial->fractions_content_in_aggregate_sample = atof(out);
				printf("fractions_trial->fractions_content_in_aggregate_sample = %f\n", fractions_trial->fractions_content_in_aggregate_sample.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) fractions_trial->particles_content_of_diameter_more_2 = atof(out);
				printf("fractions_trial->particles_content_of_diameter_more_2 = %f\n", fractions_trial->particles_content_of_diameter_more_2.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) fractions_trial->particles_content_of_diameter_less_1 = atof(out);
				printf("fractions_trial->particles_content_of_diameter_less_1 = %f\n", fractions_trial->particles_content_of_diameter_less_1.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) fractions_trial->pourness = atof(out);
				printf("fractions_trial->pourness = %f\n", fractions_trial->pourness.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) fractions_trial->slope_angle_of_dry_ground = atof(out);
				printf("fractions_trial->slope_angle_of_dry_ground = %f\n", fractions_trial->slope_angle_of_dry_ground.v);
			
				p = ParsingLabInputFileLine(p, out); 
				if (p) fractions_trial->slope_angle_under_water = atof(out);
				printf("fractions_trial->slope_angle_under_water = %f\n", fractions_trial->slope_angle_under_water.v);
			}
			return 1;
		}
		break;
	case 18://6 - 4 признак - компрессия в природном состоянии
		{
			if (use_compression3)
			{
				LabLayer * lablayer = (LabLayer *) m_lab_number->GetLabLayer();

				m_lab_trial = m_lab_number->FindLabTrial(LabTrial::indication::compression_3, -1);
				if (!m_lab_trial)
					m_lab_trial = m_lab_number->AddNewLabTrial(LabTrial::indication::compression_3, MEAN_VYPROB);
				CompressionLabTrial3 * compression_trial_3 = dynamic_cast<CompressionLabTrial3 *>(m_lab_trial);
				if (compression_trial_3)
				{
					compression_trial_3->SetLabNumber();
					CompressionLabTrial * compression_trial = dynamic_cast<CompressionLabTrial *>(compression_trial_3->p_trial_1);
					if (lablayer)
					{
						m_lab_experiment = lablayer->FindLabExperiment(LabExperiment::type::compression);
						CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);

						if(compression_trial && compression)
						{
#if USE_LAB_LAYER_HOOP
#else
							compression_trial->hoop_height = compression->lab_layer_hoop_height;
							compression_trial->hoop_diameter = compression->lab_layer_hoop_diameter;
#endif

#if USE_LAB_LAYER_PRESSURES
							compression_trial->n_pressures = compression->n_pressures_in_nature_condition;
#else
							compression_trial->n_pressures = compression->lab_layer_n_pressures_in_nature_condition;
#endif
							if (compression_trial->n_pressures)
							{
#if USE_LAB_LAYER_PRESSURES
#else
								compression_trial->pressures = new double[compression_trial->n_pressures];
#endif
								compression_trial->absolute_deformations = new trial_value[compression_trial->n_pressures];
								for (int i = 0; i < compression_trial->n_pressures; i++)
								{
#if USE_LAB_LAYER_PRESSURES
#else
									compression_trial->pressures[i] = compression->lab_layer_pressures_in_nature_condition[i];
									if (i && compression_trial->pressures[i] == compression_trial->pressures[i-1])
										compression_trial_3->zamach = true;

#endif
									p = ParsingLabInputFileLine(p, out); 
									if (p) compression_trial->absolute_deformations[i] = atof(out);
									printf("compression_nature_condition_trial->absolute_deformations[%d] = %f\n", i, compression_trial->absolute_deformations[i].v);
								}
							}
							if (compression_trial_3->zamach)
							{
								compression_trial_3->id_method = 3;
							}
							else if (compression->lab_layer_n_pressures_in_nature_condition 
								&& compression->lab_layer_n_pressures_in_task_condition)	
							{
								compression_trial_3->id_method = 2;
							}
							else if (compression->lab_layer_n_pressures_in_nature_condition 
								&& !compression->lab_layer_n_pressures_in_task_condition)
							{
								compression_trial_3->id_method = 1;
							}
						}
					}
				}
			}
			else
			{
				m_lab_trial = m_lab_number->AddNewLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, MEAN_VYPROB);
				CompressionLabTrial * compression_trial = dynamic_cast<CompressionLabTrial *>(m_lab_trial);
				LabLayer * lablayer = (LabLayer *) m_lab_number->GetLabLayer();
				if (lablayer)
				{
					m_lab_experiment = lablayer->FindLabExperiment(LabExperiment::type::compression);
					CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);

					if(compression_trial && compression)
					{
#if USE_LAB_LAYER_HOOP
#else
						compression_trial->hoop_height = compression->lab_layer_hoop_height;
						compression_trial->hoop_diameter = compression->lab_layer_hoop_diameter;
#endif

#if USE_LAB_LAYER_PRESSURES
						compression_trial->n_pressures = compression->n_pressures_in_nature_condition;
#else
						compression_trial->n_pressures = compression->lab_layer_n_pressures_in_nature_condition;
#endif
						if (compression_trial->n_pressures)
						{
#if USE_LAB_LAYER_PRESSURES
#else
							compression_trial->pressures = new double[compression_trial->n_pressures];
#endif
							compression_trial->absolute_deformations = new trial_value[compression_trial->n_pressures];
							for (int i = 0; i < compression_trial->n_pressures; i++)
							{
#if USE_LAB_LAYER_PRESSURES
#else
								compression_trial->pressures[i] = compression->lab_layer_pressures_in_nature_condition[i];
#endif
								p = ParsingLabInputFileLine(p, out); 
								if (p) compression_trial->absolute_deformations[i] = atof(out);
								printf("compression_nature_condition_trial->absolute_deformations[%d] = %f\n", i, compression_trial->absolute_deformations[i].v);
							}
						}
					}
				}
			}
			return 1;
		}
		break;
	case 19://7 - 5 признак - компрессия в заданном состоянии
		{
			if (use_compression3)
			{
				LabLayer * lablayer = (LabLayer *) m_lab_number->GetLabLayer();

				m_lab_trial = m_lab_number->FindLabTrial(LabTrial::indication::compression_3, -1);
				if (!m_lab_trial)
					m_lab_trial = m_lab_number->AddNewLabTrial(LabTrial::indication::compression_3, 1);
				CompressionLabTrial3 * compression_trial_3 = dynamic_cast<CompressionLabTrial3 *>(m_lab_trial);
				if (compression_trial_3)
				{
					compression_trial_3->SetLabNumber();

					CompressionLabTrial * compression_trial = dynamic_cast<CompressionLabTrial *>(compression_trial_3->p_trial_2);
					if (lablayer)
					{
						m_lab_experiment = lablayer->FindLabExperiment(LabExperiment::type::compression);
						CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);

						if(compression_trial && compression)
						{
#if USE_LAB_LAYER_HOOP
#else
							compression_trial->hoop_height = compression->lab_layer_hoop_height;
							compression_trial->hoop_diameter = compression->lab_layer_hoop_diameter;
#endif
#if USE_LAB_LAYER_PRESSURES
							compression_trial->n_pressures = compression->n_pressures_in_task_condition;
#else
							compression_trial->n_pressures = compression->lab_layer_n_pressures_in_task_condition;
#endif
							if (compression_trial->n_pressures)
							{
#if USE_LAB_LAYER_PRESSURES
#else
								compression_trial->pressures = new double[compression_trial->n_pressures];
#endif
								compression_trial->absolute_deformations = new trial_value[compression_trial->n_pressures];
								for (int i = 0; i < compression_trial->n_pressures; i++)
								{
#if USE_LAB_LAYER_PRESSURES
#else
									compression_trial->pressures[i] = compression->lab_layer_pressures_in_task_condition[i];
#endif
									p = ParsingLabInputFileLine(p, out); 
									if (p) compression_trial->absolute_deformations[i] = atof(out);
									printf("compression_task_condition_trial->absolute_deformations[%d] = %f\n", i, compression_trial->absolute_deformations[i].v);
								}
							}
							if (compression->lab_layer_n_pressures_in_nature_condition 
								&& compression->lab_layer_n_pressures_in_task_condition)	
							{
								compression_trial_3->id_method = 2;
							}
							else if (!compression->lab_layer_n_pressures_in_nature_condition 
								&& compression->lab_layer_n_pressures_in_task_condition)
							{
								compression_trial_3->id_method = 1;
							}
						}
					}
				}
			}
			else
			{
				m_lab_trial = m_lab_number->AddNewLabTrial(LabTrial::indication::compression_task_condition_absolute_deformation, MEAN_VYPROB);
				CompressionLabTrial * compression_trial = dynamic_cast<CompressionLabTrial *>(m_lab_trial);
				LabLayer * lablayer = (LabLayer *) m_lab_number->GetLabLayer();
				if (lablayer)
				{
					m_lab_experiment = lablayer->FindLabExperiment(LabExperiment::type::compression);
					CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);

					if(compression_trial && compression)
					{
#if USE_LAB_LAYER_HOOP
#else
						compression_trial->hoop_height = compression->lab_layer_hoop_height;
						compression_trial->hoop_diameter = compression->lab_layer_hoop_diameter;
#endif

#if USE_LAB_LAYER_PRESSURES
						compression_trial->n_pressures = compression->n_pressures_in_task_condition;
#else
						compression_trial->n_pressures = compression->lab_layer_n_pressures_in_task_condition;
#endif
						if (compression_trial->n_pressures)
						{
#if USE_LAB_LAYER_PRESSURES
#else
							compression_trial->pressures = new double[compression_trial->n_pressures];
#endif
							compression_trial->absolute_deformations = new trial_value[compression_trial->n_pressures];
							for (int i = 0; i < compression_trial->n_pressures; i++)
							{
#if USE_LAB_LAYER_PRESSURES
#else
								compression_trial->pressures[i] = compression->lab_layer_pressures_in_task_condition[i];
#endif
								p = ParsingLabInputFileLine(p, out); 
								if (p) compression_trial->absolute_deformations[i] = atof(out);
								printf("compression_task_condition_trial->absolute_deformations[%d] = %f\n", i, compression_trial->absolute_deformations[i].v);
							}
						}
					}
				}
			}
			return 1;
		}
		break;

	case 20://8 - 6 признак - компрессия на усадку
		{
			if (use_compression3)
			{
				LabLayer * lablayer = (LabLayer *) m_lab_number->GetLabLayer();

				m_lab_trial = m_lab_number->FindLabTrial(LabTrial::indication::compression_3, -1);
				if (!m_lab_trial)
					m_lab_trial = m_lab_number->AddNewLabTrial(LabTrial::indication::compression_3, 1);
				CompressionLabTrial3 * compression_trial_3 = dynamic_cast<CompressionLabTrial3 *>(m_lab_trial);
				if (compression_trial_3)
				{
					compression_trial_3->SetLabNumber();

					CompressionLabTrial * compression_trial = dynamic_cast<CompressionLabTrial *>(compression_trial_3->p_trial_2);
					if (lablayer)
					{
						m_lab_experiment = lablayer->FindLabExperiment(LabExperiment::type::compression);
						CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);

						if(compression_trial && compression)
						{
#if USE_LAB_LAYER_HOOP
#else
							compression_trial->hoop_height = compression->lab_layer_hoop_height;
							compression_trial->hoop_diameter = compression->lab_layer_hoop_diameter;
#endif
#if USE_LAB_LAYER_PRESSURES
							compression_trial->n_pressures = compression->n_pressures_on_shrinkage;
#else
							compression_trial->n_pressures = compression->lab_layer_n_pressures_on_shrinkage;
#endif
							if (compression_trial->n_pressures)
							{
#if USE_LAB_LAYER_PRESSURES
#else
								compression_trial->pressures = new double[compression_trial->n_pressures];
#endif
								compression_trial->absolute_deformations = new trial_value[compression_trial->n_pressures];
								for (int i = 0; i < compression_trial->n_pressures; i++)
								{
#if USE_LAB_LAYER_PRESSURES
#else
									compression_trial->pressures[i] = compression->lab_layer_pressures_on_shrinkage[i];
#endif
									p = ParsingLabInputFileLine(p, out); 
									if (p) compression_trial->absolute_deformations[i] = atof(out);
									printf("compression_shrinkage_trial->absolute_deformations[%d] = %f\n", i, compression_trial->absolute_deformations[i].v);
								}
							}
						}
					}
				}
			}
			else
			{
				m_lab_trial = m_lab_number->AddNewLabTrial(LabTrial::indication::compression_shrinkage_absolute_deformation, MEAN_VYPROB);
				CompressionLabTrial * compression_trial = dynamic_cast<CompressionLabTrial *>(m_lab_trial);
				LabLayer * lablayer = (LabLayer *) m_lab_number->GetLabLayer();
				if (lablayer)
				{
					m_lab_experiment = lablayer->FindLabExperiment(LabExperiment::type::compression);
					CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);

					if(compression_trial && compression)
					{
#if USE_LAB_LAYER_HOOP
#else
						compression_trial->hoop_height = compression->lab_layer_hoop_height;
						compression_trial->hoop_diameter = compression->lab_layer_hoop_diameter;
#endif
#if USE_LAB_LAYER_PRESSURES
						compression_trial->n_pressures = compression->n_pressures_on_shrinkage;
#else
						compression_trial->n_pressures = compression->lab_layer_n_pressures_on_shrinkage;
#endif
						if (compression_trial->n_pressures)
						{
#if USE_LAB_LAYER_PRESSURES
#else
							compression_trial->pressures = new double[compression_trial->n_pressures];
#endif
							compression_trial->absolute_deformations = new trial_value[compression_trial->n_pressures];
							for (int i = 0; i < compression_trial->n_pressures; i++)
							{
#if USE_LAB_LAYER_PRESSURES
#else
								compression_trial->pressures[i] = compression->lab_layer_pressures_on_shrinkage[i];
#endif
								p = ParsingLabInputFileLine(p, out); 
								if (p) compression_trial->absolute_deformations[i] = atof(out);
								printf("compression_shrinkage_trial->absolute_deformations[%d] = %f\n", i, compression_trial->absolute_deformations[i].v);
							}
						}
					}
				}
			}
			return 1;
		}
		break;
	case 21://9 - 7 признак - сопротивление срезу в природном состоянии
		{
			m_lab_trial = m_lab_number->AddNewLabTrial(LabTrial::indication::cut_resistance_nature_condition, MEAN_VYPROB);
			CutLabTrial * cut_trial = dynamic_cast<CutLabTrial *>(m_lab_trial);
			LabLayer * lablayer = (LabLayer *) m_lab_number->GetLabLayer();
			if (lablayer)
			{
				m_lab_experiment = lablayer->FindLabExperiment(LabExperiment::type::cut);
				CutLabExperiment * cut = dynamic_cast<CutLabExperiment *>(m_lab_experiment);

				if(cut_trial && cut)
				{
#if USE_LAB_LAYER_CUT_PRESSURES
					cut_trial->n_pressures = cut->n_pressures_in_nature_condition;
#else
					cut_trial->n_pressures = cut->lab_layer_n_pressures_in_nature_condition;
#endif
					if (cut_trial->n_pressures)
					{
#if USE_LAB_LAYER_CUT_PRESSURES
#else
						cut_trial->pressures = new double[cut_trial->n_pressures];
#endif
						cut_trial->cut_resistances = new trial_value[cut_trial->n_pressures];
						for (int i = 0; i < cut_trial->n_pressures; i++)
						{
#if USE_LAB_LAYER_PRESSURES
#else
							cut_trial->pressures[i] = cut->lab_layer_pressures_in_nature_condition[i];
#endif
							p = ParsingLabInputFileLine(p, out); 
							if (p)
							{
								cut_trial->cut_resistances[i] = atof(out);
								cut_trial->cut_resistances[i].f = TRIAL_VALUE_DEFINED_CAN_EXCLUDED_ONLY_BY_MINSQLIN;
							}
							printf("cut_nature_condition_trial->cut_resistances[%d] = %f\n", i, cut_trial->cut_resistances[i].v);
						}
					}
				}
			}
			return 1;
		}
		break;
	case 22://10 - 8 признак - сопротивление срезу заданном состояним
		{
			m_lab_trial = m_lab_number->AddNewLabTrial(LabTrial::indication::cut_resistance_task_condition, MEAN_VYPROB);
			CutLabTrial * cut_trial = dynamic_cast<CutLabTrial *>(m_lab_trial);
			LabLayer * lablayer = (LabLayer *) m_lab_number->GetLabLayer();
			if (lablayer)
			{
				m_lab_experiment = lablayer->FindLabExperiment(LabExperiment::type::cut);
				CutLabExperiment * cut = dynamic_cast<CutLabExperiment *>(m_lab_experiment);

				if(cut_trial && cut)
				{
#if USE_LAB_LAYER_CUT_PRESSURES
					cut_trial->n_pressures = cut->n_pressures_in_task_condition;
#else
					cut_trial->n_pressures = cut->lab_layer_n_pressures_in_task_condition;
#endif
					if (cut_trial->n_pressures)
					{
#if USE_LAB_LAYER_CUT_PRESSURES
#else
						cut_trial->pressures = new double[cut_trial->n_pressures];
#endif
						cut_trial->cut_resistances = new trial_value[cut_trial->n_pressures];
						for (int i = 0; i < cut_trial->n_pressures; i++)
						{
#if USE_LAB_LAYER_PRESSURES
#else
							cut_trial->pressures[i] = cut->lab_layer_pressures_in_task_condition[i];
#endif
							p = ParsingLabInputFileLine(p, out); 
							if (p)
							{
								cut_trial->cut_resistances[i] = atof(out);
								cut_trial->cut_resistances[i].f = TRIAL_VALUE_DEFINED_CAN_EXCLUDED_ONLY_BY_MINSQLIN;
							}
							printf("cut_task_condition_trial->cut_resistances[%d] = %f\n", i, cut_trial->cut_resistances[i].v);
						}
					}
				}
			}
			return 1;
		}
		break;
	case 23://11 - 9 признак - одноосное сжатие
		{
			m_lab_trial = m_lab_number->AddNewLabTrial(LabTrial::indication::pressing, MEAN_VYPROB);
			PressingLabTrial * pressing_trial = dynamic_cast<PressingLabTrial *>(m_lab_trial);

			if (pressing_trial)
			{
				for (int i = 0; i < 3; i++)
				{
					p = ParsingLabInputFileLine(p, out); 
					if (p) pressing_trial->loads[i] = atof(out);
					printf("pressing_trial->loads[%d] = %f\n", i, pressing_trial->loads[i]);
				
					p = ParsingLabInputFileLine(p, out); 
					if (p) pressing_trial->sections[i] = atof(out);
					printf("pressing_trial->sections[%d] = %f\n", i, pressing_trial->sections[i]);
				}			
			}
			return 1;
		}
		break;
	case 24://12 - 10 признак - фильтрация при давлениях
		{
			m_lab_trial = m_lab_number->AddNewLabTrial(LabTrial::indication::filtration_coefficient_with_pressures, MEAN_VYPROB);
			FiltrationLabTrial * filtration_trial = dynamic_cast<FiltrationLabTrial *>(m_lab_trial);

			if (filtration_trial)
			{
				for (int i = 0; i < 3; i++)
				{
					p = ParsingLabInputFileLine(p, out); 
					if (p) filtration_trial->expenditures[i] = atof(out);
					printf("filtration_trial->expenditures[%d] = %f\n", i, filtration_trial->expenditures[i]);
				
					p = ParsingLabInputFileLine(p, out); 
					if (p) filtration_trial->densities[i] = atof(out);
					printf("filtration_trial->densities[%d] = %f\n", i, filtration_trial->densities[i]);
				}			
			}
			return 1;
		}
		break;
	case 25://12 - 11 признак - фильтрация при плотностях
		{
			m_lab_trial = m_lab_number->AddNewLabTrial(LabTrial::indication::filtration_coefficient_with_densities, MEAN_VYPROB);
			FiltrationLabTrial * filtration_trial = dynamic_cast<FiltrationLabTrial *>(m_lab_trial);

			if (filtration_trial)
			{
				for (int i = 0; i < 3; i++)
				{
					p = ParsingLabInputFileLine(p, out); 
					if (p) filtration_trial->expenditures[i] = atof(out);
					printf("filtration_trial->expenditures[%d] = %f\n", i, filtration_trial->expenditures[i]);
				
					p = ParsingLabInputFileLine(p, out); 
					if (p) filtration_trial->densities[i] = atof(out);
					printf("filtration_trial->densities[%d] = %f\n", i, filtration_trial->densities[i]);
				}			
			}
			return 1;
		}
		break;
	}
	return -1;
}

bool Laboratory::ReadLabInputFile(char *file)
{

	bool use_compression3 = false;
	//if (IDYES == MessageBox(0, "Вы хотите загрузить компрессионные испытания\n в природном и заданном состоянии\n на один график?", 
	//	"Загрузка файла LAB", MB_YESNO))
	//{
		use_compression3 = true;
	//}

	m_lablayer = NULL;
	m_lab_experiment = NULL;
	m_lab_number = NULL;
	m_lab_trial = NULL;


	printf("SurfDoc::ReadLabInputFile(\"%s\")\n",file);

	const int n=16384; // length of buffer string line
	char* szBuff; // buffer string line
	if ((szBuff = (char *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,n*sizeof(char))) == NULL)
	{
		MessageBox(0, "vX - Not enough memory",
			"ReadLabInputFile()", 0);
		return false;
	}

	FILE *stream;
	if ((stream = fopen(file,"rt")) == NULL)
	{
		char errstr[2048];
		sprintf(errstr, "SurfDoc::ReadZondFile:fopen(%s)", file);
		MessageBox(0, errstr,"ReadLabInputFile()", 0);
		return false;
	}

	char * ch;
//	size_t bytes_line;
	
	int type_line = 1;

	char name[4096];
	char * fn = SelectNameFromPath(file, name, 4096);


	while (!feof(stream))
	{
		ch = fgets(szBuff,n,stream);
		if( ch != NULL && strlen(szBuff) > 1)
		{
			int res = ParseLabInputFileLine(szBuff, type_line, fn, use_compression3);
			if (res == -1 || res == 1 || res == 2)
				type_line++;
			else if (res == 0)
			{
			}
			else if (res == 3)
			{
				break;
			}
		}
		else 
		{
			//printf("strlen(szBuff) = %u, type_line = %d\n", strlen(szBuff), type_line);
			//if (strlen(szBuff) <= 1 && type_line == 20)
			//type_line = 1;
		}
	}

	//printf("SurfDoc::ReadZondFile() end\n");

	fclose(stream);
	return true;
}

bool LabNumber::AddGranular(long id_gran, const char * gran_name, double val)
{
	this->gran_vyprob.AddGranular(id_gran, gran_name, val);
	return true;
}
void LabNumber::ApplyGranular()
{
	if (!this->gran_vyprob.data1.size())
	{
		return;
	}


	LabTrial::indication indication = LabTrial::fractions;						
	//if (FindLabTrial(indication, -1))
	//{
		this->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));
	//}

	std::sort(this->gran_vyprob.data1.begin(), this->gran_vyprob.data1.end());

	LabTrial * lab_trial = FindLabTrial(LabTrial::indication::fractions, -1);
	if(!lab_trial)
		lab_trial = this->AddNewLabTrial(LabTrial::indication::fractions, 1);
	FractionsLabTrial * fractions_trial = dynamic_cast<FractionsLabTrial *>(lab_trial);
	LabLayer * lablayer = (LabLayer *) this->GetLabLayer();
	
	if (lablayer)
	{
		LabExperiment * lab_experiment = lablayer->FindLabExperiment(LabExperiment::type::fractions);
		if(!lab_experiment)
			lab_experiment = lablayer->AddNewLabExperiment(LabExperiment::type::fractions);

		FractionsLabExperiment * fractions = dynamic_cast<FractionsLabExperiment *>(lab_experiment);

		if(fractions_trial && fractions)
		{
			fractions_trial->n_fractions = this->gran_vyprob.data1.size();
			if (fractions_trial->n_fractions)
			{
				if (!fractions_trial->fractions_content)
					fractions_trial->fractions_content = new trial_value[fractions_trial->n_fractions];
				if (!fractions_trial->fractions_diameters)
#if USE_FRACTION_DIAMETERS_INTERVAL
					fractions_trial->fractions_diameters = new fraction_diameters_interval[fractions_trial->n_fractions];
#else
					fractions_trial->fractions_diameters = new double[fractions_trial->n_fractions];
#endif
				
				int i = 0;
#if 0
				for (vector<GranVyprobData1>::iterator it = this->gran_vyprob.data1.begin();
					it != this->gran_vyprob.data1.end(); it++, i++)
#else
				for (vector<GranVyprobData1>::reverse_iterator it = this->gran_vyprob.data1.rbegin();
					it != this->gran_vyprob.data1.rend(); it++, i++)
#endif
				{
					(*it).id_gran;
#if USE_FRACTION_DIAMETERS_INTERVAL
					fractions_trial->fractions_diameters[i].low = (*it).min_d;
					fractions_trial->fractions_diameters[i].high = (*it).max_d;
#else
					fractions_trial->fractions_diameters[i] = (*it).min_d == -DBL_MAX ? (*it).max_d : (*it).min_d;
#endif
					fractions_trial->fractions_content[i] = (*it).val;
					fractions_trial->fractions_content[i].f = TRIAL_VALUE_DEFINED_CANNOT_EXCLUDED;
				}
				/*
				long i = id_gran - 1;
				if (i > -1 && i < fractions_trial->n_fractions)
				{
					fractions_trial->fractions_content[i] = val;
					fractions_trial->fractions_content[i].f = TRIAL_VALUE_DEFINED_CANNOT_EXCLUDED;
					return true;
				}
				else
					MessageBox(0,"!(i > -1 && i < fractions_trial->n_fractions)",str, 0);*/
			}
//			else
//				MessageBox(0,"!(fractions_trial->n_fractions)","LabNumber::ApplyGranular", 0);
		}
		else
			MessageBox(0,"!(fractions_trial && fractions)","LabNumber::ApplyGranular", 0);
	}
	else
	{
		//MessageBox(0,"!(lablayer)","LabNumber::ApplyGranular", 0);
		if(fractions_trial)
		{
			fractions_trial->n_fractions = this->gran_vyprob.data1.size();
			if (fractions_trial->n_fractions)
			{
				if (!fractions_trial->fractions_content)
					fractions_trial->fractions_content = new trial_value[fractions_trial->n_fractions];
				if (!fractions_trial->fractions_diameters)
#if USE_FRACTION_DIAMETERS_INTERVAL
					fractions_trial->fractions_diameters = new fraction_diameters_interval[fractions_trial->n_fractions];
#else
					fractions_trial->fractions_diameters = new double[fractions_trial->n_fractions];
#endif
				
				int i = 0;
#if 0
				for (vector<GranVyprobData1>::iterator it = this->gran_vyprob.data1.begin();
					it != this->gran_vyprob.data1.end(); it++, i++)
#else
				for (vector<GranVyprobData1>::reverse_iterator it = this->gran_vyprob.data1.rbegin();
					it != this->gran_vyprob.data1.rend(); it++, i++)
#endif
				{
					(*it).id_gran;
#if USE_FRACTION_DIAMETERS_INTERVAL
					fractions_trial->fractions_diameters[i].low = (*it).min_d;
					fractions_trial->fractions_diameters[i].high = (*it).max_d;
#else
					fractions_trial->fractions_diameters[i] = (*it).min_d == -DBL_MAX ? (*it).max_d : (*it).min_d;
#endif
					fractions_trial->fractions_content[i] = (*it).val;
					fractions_trial->fractions_content[i].f = TRIAL_VALUE_DEFINED_CANNOT_EXCLUDED;
				}
				/*
				long i = id_gran - 1;
				if (i > -1 && i < fractions_trial->n_fractions)
				{
					fractions_trial->fractions_content[i] = val;
					fractions_trial->fractions_content[i].f = TRIAL_VALUE_DEFINED_CANNOT_EXCLUDED;
					return true;
				}
				else
					MessageBox(0,"!(i > -1 && i < fractions_trial->n_fractions)",str, 0);*/
			}
//			else
//				MessageBox(0,"!(fractions_trial->n_fractions)","LabNumber::ApplyGranular", 0);
		}
		else
			MessageBox(0,"!(fractions_trial)","LabNumber::ApplyGranular", 0);
	}
}
LabTrial::indication LabNumber::SetParam(long id_param, double val, PhysicalLabTrial * physical_trial, ChemicalLabTrial * chemical_trial, FractionsLabTrial * fractions_trial)
{
	switch (id_param)
	{
	case 1:
		//Природная влажность грунта, д.е.		
		if (physical_trial) physical_trial->moisture_of_nature_large_exchange = val;
		return LabTrial::indication::physical;
	case 2:
		//Влажность на границе текучести, д.е
		if (physical_trial) physical_trial->moisture_on_fluidity_border = val;
		return LabTrial::indication::physical;
	case 3:
		//Влажность на границе пластичности, д.е
		if (physical_trial) physical_trial->moisture_on_plasticity_border = val;
		return LabTrial::indication::physical;
	case 4:
		//Число пластичности, д.е	
		break;
	case 5:
		//Показатель текучести	
		break;
	case 6:
		//Плотность грунта, г/см3	
		if (physical_trial) physical_trial->density_of_ground = val;
		return LabTrial::indication::physical;
	case 7:
		//Плотность  сухого (скелета) грунта, г/см3			
		break;
	case 8:
		//Плотность частиц грунта, г/см3	
		if (physical_trial) physical_trial->density_of_ground_particles = val;
		return LabTrial::indication::physical;
	case 9:
		//Пористость, д.е	
		break;
	case 10:
		//Коэффициент пористости, д.е
		break;
	case 11:
		//Степень влажности грунта, д.е	
		break;
	case 12:
		//Влажность при полном насыщении, д.е	
		break;
	case 13:
		// Влажность объемная, д.е		
		break;
	case 14:
		//Плотность грунта при полном насыщении, г/см3	
		break;
	case 15:
		//Плотность грунта под водой, г/см3	
		break;
	case 16:
		//Максимальная плотность грунта, г/см3			
		break;
	case 17:
		//Показатель тек./консистенции водонасыщения, д.е			
		break;
	case 18:
		//Коэффициент естественного уплотнения			
		break;
	case 19:
		//Коэффициент пористости на границе текучести			
		break;
	case 20:
		//Коэффициент пористости на границе пластичности
		break;
	case 21:
		//Оптимальная влажность грунта, д.е.			
		break;
	case 22:
		//Влажность на пределе усадки, д.е.			
		break;
	case 23:
		//Влажность гигроскопическая, д.е.			
		if (physical_trial) physical_trial->hygroscopic_moisture = val;
		return LabTrial::indication::physical;
	case 24:
		//Максимальная молекулярная влагоемкость, д.е	
		if (physical_trial) physical_trial->maximal_molecular_moisture_capacity = val;
		return LabTrial::indication::physical;
	case 25:
		//Плотность песка предельно плотного сложения, г/см3
		//physical_trial-
		break;
	case 26:
		//Плотность песка предельно рыхлого сложения, г/см3	
		//physical_trial-
		break;
	case 27:
		//Карбонатность, %	
		if (chemical_trial) chemical_trial->carbonats = val;
		return LabTrial::indication::chemical;
	case 28:
		//Относительное содержание орг. веществ, %	
		if (chemical_trial) chemical_trial->organic_matters = 0.01* val;
		return LabTrial::indication::chemical;
	case 29:
		//Относительное содержание гумуса, %			
		if (chemical_trial) chemical_trial->gumus = val;
		return LabTrial::indication::chemical;
	case 30:
		//Водорастворимые соли, %	
		if (chemical_trial) chemical_trial->well_solutable_salts = val;
		return LabTrial::indication::chemical;
	case 31:
		//Коэффициент фильтрации, м/сут			
		break;
	case 32:
		//Свободное набухание, см			
		break;
	case 33:
		//Усадка по высоте, см			
		break;
	case 34:
		//Усадка по диаметру, см			
		break;
	case 35:
		//Коррозия к стали, потеря массы, г		
		if (chemical_trial) chemical_trial->steel_mass_loss = val;
		return LabTrial::indication::chemical;
	case 36:
		//Коррозия к стали, плотность тока, а/м2			
		break;
	case 37:
		//Коэф.фильтрации плотного грунта, м/сут			
		break;
	case 38:
		//Коэф.фильтрации рыхлого грунта, м/сут			
		break;
	case 39:
		//Угол откоса сухого грунта, град	
		if (fractions_trial) fractions_trial->slope_angle_of_dry_ground = val;
		return LabTrial::indication::fractions;
	case 40:
		//Угол откоса грунта под водой, град.
		if (fractions_trial) fractions_trial->slope_angle_under_water = val;
		return LabTrial::indication::fractions;
	case 41:
		//Сопротивление пенетрации, кПа			
		break;
	case 42:
		//Предел прочности при одноосном сжатии грунта, Мпа			
		break;
	case 43:
		//Коэффициент размягчаемости в воде			
		break;
	case 44:
		//Степень растворимости в воде			
		break;
	case 45:
		//Температура грунта, град С			
		break;
	case 46:
		// Степень зольности торфа, д.е.			
		break;
	case 47:
		//Водородный показатель	
		if (chemical_trial) chemical_trial->pH = val;
		return LabTrial::indication::chemical;
	case 48:
		//Степень разложения торфа, %			
		break;
	case 49:
		//Потери при прокаливании, %			
		break;
	case 50:
		//Относительное содержание органического вещества, д.е.		
		if (chemical_trial) chemical_trial->organic_matters = val;
		return LabTrial::indication::chemical;
	case 51:
		//Время размокания	
		break;
	case 52:
		//Влажность пробы заполнителя, д.е.	
		if (physical_trial) physical_trial->moisture_of_aggregate_sample = val;
		return LabTrial::indication::physical;
	case 53:
		// Gips
		if (chemical_trial) chemical_trial->gips = val;
		return LabTrial::indication::chemical;
	default:
		{
			return LabTrial::indication::undefined_lab_trial_indication;
		}
	}
	return LabTrial::indication::undefined_lab_trial_indication;
}
void LabNumber::AddPrGrunt(long ID_OBJ, long ID_KT, const char * KT_NAME, long KT_IDTYP, long ID_PROB, double DEPTH,
						 long LAB_N, long ID_KODPROB, long ID_GR, const char * Soil_Name, const char * Grunt_Name,
						 long ID_IGE)
{

	char lab_number_ID[128]; 
	sprintf(lab_number_ID, "%ld", LAB_N);

	this->ID = lab_number_ID;
	this->kt_idtyp = KT_IDTYP;
	/*
	ID_TYP	TYP
	1	Свердловина розвідувальна
	2	Свердловина технічна
	3	Свердловина гідрологічна
	4	Шурф
	5	ТСЗ
	6	Точка випробування грунту
	*/
	switch(KT_IDTYP)
	{
	case 1:
	case 2:
	case 3:
		{
			this->m_mine_working_type = LabNumber::mine_working_type::well;
		}
		break;
	case 4:
		{
			this->m_mine_working_type = LabNumber::mine_working_type::hole;
		}
		break;
	case 5:
		{
			this->m_mine_working_type = LabNumber::mine_working_type::tsz;
		}
		break;
	case 6:
		{
			this->m_mine_working_type = LabNumber::mine_working_type::tpg;
		}
		break;
	}
	this->lab_n = LAB_N;

	this->mine_working_number = KT_NAME;
	
	this->depth = DEPTH;

	this->id_kodprob = ID_KODPROB;
	this->id_gr = ID_GR;

	this->id_kt = ID_KT;
	this->id_prob = ID_PROB;

	this->soil_name = Soil_Name;
	this->grunt_name = Grunt_Name;
	this->id_ige = ID_IGE;

	this->id_obj = ID_OBJ;


}


void LabNumber::AddProp(long id_vyprob, long id_param, const char * param_name, double val)
{
	map<long, PropValue>::iterator found = m_prop_values.find(id_param);

	if (found == m_prop_values.end())
	{
		m_prop_values.insert(map<long, PropValue>::value_type(id_param, PropValue(id_param, param_name, id_vyprob, val)));
	}
	else
	{
		(*found).second.AddPropValue(id_vyprob, val);
	}
}
struct PhysicalLabTrialItem
{
	PhysicalLabTrial * physical_trial;
	long id_vyprob;
	PhysicalLabTrialItem(long id)
	{
		PhysicalLabTrial * physical_trial = NULL;
		id_vyprob = id;
	}
};
void LabLayer::DestroyContextWindow()
{
	if (this->p_laboratory) 
	{
		DestroyWindow(this->p_laboratory->hContextWindow);
		this->p_laboratory->hContextWindow = NULL;
	}
}
void LabNumber::DestroyContextWindow()
{
	if (this->GetLabLayer() && ((LabLayer *)this->GetLabLayer())->GetLaboratory()) 
	{
		DestroyWindow(((LabLayer *)this->GetLabLayer())->GetLaboratory()->hContextWindow);
		((LabLayer *)this->GetLabLayer())->GetLaboratory()->hContextWindow = NULL;
	}
}

bool LabNumber::ApplyParams()
{
	bool use_physical = false;
	bool use_chemical = false;
	bool use_fraction = false;

	map<long, PhysicalLabTrialItem> PhysicalLabTrialItems;

	for (map<long, PropValue>::iterator it = m_prop_values.begin();
		it != m_prop_values.end(); it++)
	{

		LabTrial::indication ind = LabNumber::SetParam((*it).first, 0.0, NULL, NULL, NULL);
		if (ind == LabTrial::indication::physical)
		{
			use_physical = true;
			for (map<long, double>::iterator itv = (*it).second.vyprob.begin(); 
				itv != (*it).second.vyprob.end(); itv++)
			{
				long id_vyprob = (*itv).first;
				PhysicalLabTrialItems.insert(map<long, PhysicalLabTrialItem>::value_type(id_vyprob, PhysicalLabTrialItem(id_vyprob)));
			}		
		}
		if (ind == LabTrial::indication::chemical) use_chemical = true;
		if (ind == LabTrial::indication::fractions) use_fraction = true;
	}
//	PhysicalLabTrial * physical_trial = NULL;
	ChemicalLabTrial * chemical_trial = NULL;
	FractionsLabTrial * fractions_trial = NULL;

	if (use_physical)
	{
		for (map<long, PhysicalLabTrialItem>::iterator it_phlti = PhysicalLabTrialItems.begin();
			it_phlti != PhysicalLabTrialItems.end(); it_phlti++)
		{
			long id_vyprob = (*it_phlti).first;
			LabTrial * lab_trial = FindLabTrial(LabTrial::indication::physical, id_vyprob);
			if(!lab_trial)
				lab_trial = this->AddNewLabTrial(LabTrial::indication::physical, id_vyprob);
			(*it_phlti).second.physical_trial = dynamic_cast<PhysicalLabTrial *>(lab_trial);
		}

		LabTrial::indication indication = LabTrial::indication::physical;						
		this->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));
	}

	if (use_chemical)
	{
		LabTrial * lab_trial = FindLabTrial(LabTrial::indication::chemical, -1);
		if(!lab_trial)
			lab_trial = this->AddNewLabTrial(LabTrial::indication::chemical, MEAN_VYPROB);
		chemical_trial = dynamic_cast<ChemicalLabTrial *>(lab_trial);
		
		LabTrial::indication indication = LabTrial::indication::chemical;						
		this->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));
	}

	if (use_fraction)
	{
		if (this->trial_indications.find(LabTrial::indication::fractions) 
			!= this->trial_indications.end())
		{
		}
		else
			use_fraction = false;
	}

	if (use_fraction)
	{
		LabTrial * lab_trial = FindLabTrial(LabTrial::indication::fractions, -1);
		if(!lab_trial)
			lab_trial = this->AddNewLabTrial(LabTrial::indication::fractions, MEAN_VYPROB);
		fractions_trial = dynamic_cast<FractionsLabTrial *>(lab_trial);
		
		//LabTrial::indication indication = LabTrial::indication::fractions;						
		//this->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));
	}

	for (map<long, PropValue>::iterator it = m_prop_values.begin();
		it != m_prop_values.end(); it++)
	{
		LabTrial::indication ind = LabNumber::SetParam((*it).first, 0.0, NULL, NULL, NULL);
		if (ind == LabTrial::indication::physical)
		{
#if 1
			for (map<long, PhysicalLabTrialItem>::iterator it_phlti = PhysicalLabTrialItems.begin();
				it_phlti != PhysicalLabTrialItems.end(); it_phlti++)
			{
				if ((*it_phlti).second.physical_trial)
				{	
					long id_vyprob = (*it_phlti).first;	
					map<long, double>::iterator itv = (*it).second.vyprob.find(id_vyprob); 
					if (itv != (*it).second.vyprob.end())
					{
						LabNumber::SetParam((*it).first, (*itv).second, (*it_phlti).second.physical_trial, NULL, NULL);
					}
					else
					{
						map<long, double>::iterator itmphv = (*it).second.vyprob.find(MEAN_PHYS_VYPROB); 
						if (itmphv != (*it).second.vyprob.end())
						{
							LabNumber::SetParam((*it).first, (*itmphv).second, (*it_phlti).second.physical_trial, NULL, NULL);
						}
					}
				}
			}
#else
			for (map<long, double>::iterator itv = (*it).second.vyprob.begin(); 
				itv != (*it).second.vyprob.end(); itv++)
			{
				long id_vyprob = (*itv).first;
				map<long, PhysicalLabTrialItem>::iterator it_phlti = PhysicalLabTrialItems.find(id_vyprob);
				if (it_phlti != PhysicalLabTrialItems.end())
				{
					if ((*it_phlti).second.physical_trial)
					{
						LabNumber::SetParam((*it).first, val, (*it_phlti).second.physical_trial, NULL, NULL);
					}
				}
			}	
#endif
		}
		else
		{
			double val;
			if ((*it).second.GetValue_(val))
			{
				LabNumber::SetParam((*it).first, val, NULL, chemical_trial, fractions_trial);
			}
		}
	}

	/*for (map<long, PropValue>::iterator it = m_prop_values.begin();
		it != m_prop_values.end(); it++)
	{
		double val;
		if ((*it).second.GetValue(val))
		{
			LabNumber::SetParam((*it).first, val, physical_trial, chemical_trial, fractions_trial);
		}
	}*/
	return true;

	return false;
}
const char * LabNumber::GetPhysicalVyprobString(long id_phys_vyprob)
{
	char str[128];
	for (map<long, ZrizVyprob>::iterator it_cut_vyp = this->zriz.vyprob.begin();
		it_cut_vyp != this->zriz.vyprob.end(); it_cut_vyp++)
	{
		for (vector<ZrizVyprobData0>::iterator it = (*it_cut_vyp).second.data0.begin();
			it != (*it_cut_vyp).second.data0.end(); it++)
		{
			if ((*it).id_phys_vyprob == id_phys_vyprob)
			{
				sprintf(str, "%d-ое кольцо %d-го среза id_phys_vyprob = %d", (*it).id_kolca, (*it_cut_vyp).first, id_phys_vyprob);
				return _strdup( str );
			}
		}
	}		
	for (map<long, CompressVyprob>::iterator it_comp_vyp = this->compress.vyprob.begin();
		it_comp_vyp != this->compress.vyprob.end(); it_comp_vyp++)
	{
		for (vector<CompressVyprobData0>::iterator it = (*it_comp_vyp).second.data0.begin();
			it != (*it_comp_vyp).second.data0.end(); it++)
		{
			if ((*it).id_phys_vyprob == id_phys_vyprob)
			{
				sprintf(str, "%d-ое кольцо %d-й компр. id_phys_vyprob = %d", (*it).id_kolca, (*it_comp_vyp).first, id_phys_vyprob);
				return _strdup( str );
			}
		}
	}


	sprintf(str, "id_phys_vyprob = %d", id_phys_vyprob);
	return _strdup( str );
	return "";
}



long LabNumber::GetFizMehVyprobForCut(long id_cut_vyprob, long id_kolca)
{
	long id_phys_vyprob = -1;
	map<long, ZrizVyprob>::iterator found = this->zriz.vyprob.find(id_cut_vyprob);
	if (found != this->zriz.vyprob.end())
	{
		for (vector<ZrizVyprobData0>::iterator it = (*found).second.data0.begin();
			it != (*found).second.data0.end(); it++)
		{
			if ((*it).id_kolca == id_kolca)
			{
				id_phys_vyprob = (*it).id_phys_vyprob;
				break;
			}
		}
	}
	return id_phys_vyprob;
}

long LabNumber::GetFizMehVyprobForCompress(long id_compress_vyprob, long id_kolca)
{
	long id_phys_vyprob = -1;
	map<long, CompressVyprob>::iterator found = this->compress.vyprob.find(id_compress_vyprob);
	if (found != this->compress.vyprob.end())
	{
		for (vector<CompressVyprobData0>::iterator it = (*found).second.data0.begin();
			it != (*found).second.data0.end(); it++)
		{
			if ((*it).id_kolca == id_kolca)
			{
				id_phys_vyprob = (*it).id_phys_vyprob;
				break;
			}
		}
	}
	return id_phys_vyprob;
}

bool LabNumber::HaveEnoughFor_e0(long id_compress_vyprob)
{
	PhysicalLabTrial * physical_trial = NULL;

	long ID_VYPROB_1 = this->GetFizMehVyprobForCompress(id_compress_vyprob, 1);
	long ID_VYPROB_2 = this->GetFizMehVyprobForCompress(id_compress_vyprob, 2);

	LabTrial * lab_trial_0 = this->FindLabTrial(LabTrial::indication::physical, MEAN_PHYS_VYPROB);
	PhysicalLabTrial * phys_lab_trial_0 = dynamic_cast<PhysicalLabTrial *>(lab_trial_0);
	
	LabTrial * lab_trial_1 = this->FindLabTrial(LabTrial::indication::physical, ID_VYPROB_1);
	PhysicalLabTrial * phys_lab_trial_1 = dynamic_cast<PhysicalLabTrial *>(lab_trial_1);
	
	LabTrial * lab_trial_2 = this->FindLabTrial(LabTrial::indication::physical, ID_VYPROB_2);
	PhysicalLabTrial * phys_lab_trial_2 = dynamic_cast<PhysicalLabTrial *>(lab_trial_2);

	bool W_1 = false;
	bool W_2 = false;

	if (phys_lab_trial_1 && phys_lab_trial_1->moisture_of_nature_large_exchange.f)
	{
		W_1 = true;
	}
	else if (phys_lab_trial_0 && phys_lab_trial_0->moisture_of_nature_large_exchange.f)
	{
		W_1 = true;
	}

	if (phys_lab_trial_2 && phys_lab_trial_2->moisture_of_nature_large_exchange.f)
	{
		W_2 = true;
	}
	else if (phys_lab_trial_0 && phys_lab_trial_0->moisture_of_nature_large_exchange.f)
	{
		W_2 = true;
	}

	bool RO_1 = false;
	bool RO_2 = false;

	if (phys_lab_trial_1 && phys_lab_trial_1->density_of_ground.f)
	{
		RO_1 = true;
	}
	else if (phys_lab_trial_0 && phys_lab_trial_0->density_of_ground.f)
	{
		RO_1 = true;
	}

	if (phys_lab_trial_2 && phys_lab_trial_2->density_of_ground.f)
	{
		RO_2 = true;
	}
	else if (phys_lab_trial_0 && phys_lab_trial_0->density_of_ground.f)
	{
		RO_2 = true;
	}

	bool ROs_1 = false;
	bool ROs_2 = false;

	if (phys_lab_trial_1 && phys_lab_trial_1->density_of_ground_particles.f)
	{
		ROs_1 = true;
	}
	else if (phys_lab_trial_0 && phys_lab_trial_0->density_of_ground_particles.f)
	{
		ROs_1 = true;
	}

	if (phys_lab_trial_2 && phys_lab_trial_2->density_of_ground_particles.f)
	{
		ROs_2 = true;
	}
	else if (phys_lab_trial_0 && phys_lab_trial_0->density_of_ground_particles.f)
	{
		ROs_2 = true;
	}

	return W_1 && W_2 && RO_1 && RO_2 && ROs_1 && ROs_2;
/*
	LabTrial * lab_trial = FindLabTrial(LabTrial::indication::physical, id_vyprob);
	physical_trial = dynamic_cast<PhysicalLabTrial *>(lab_trial);
	if (physical_trial)
	{
		return (physical_trial->density_of_ground.f 
			&& physical_trial->density_of_ground_particles.f 
			&& physical_trial->moisture_of_nature_large_exchange.f);
	}
	return false;
*/
}
void LabNumber::AddZriz_tbl(long id_vyprob, long id_kolca, 
						double sigma, double tau, 
						double w_do, double ro_do, 
						double w_po_upl, double ro_po_upl, 
						double w_after, double ro_after, 
						unsigned char bStat)
{
	ZrizVyprobData1 data;
	data.id_kolca	= id_kolca;
	data.sigma		= sigma;
	data.tau		= tau;
	data.w_do		= w_do;
	data.ro_do		= ro_do;
	data.w_po_upl	= w_po_upl;
	data.ro_po_upl	= ro_po_upl;
	data.w_after	= w_after;
	data.ro_after	= ro_after;
	data.bStat		= bStat;

	this->zriz.Add(id_vyprob, data);
}
void LabNumber::AddZriz0(long id_vyprob, long id_kolca, long id_phys_vyprob,
	double h, double d, double dh_po_upl,
	double m_kolca,
	double m_grunta,
	double m_grunta_zamoch,
	double m_grunta_posle_uplot,
	double m_grunta_posle,
	double m_grunta_vysush)
{
	ZrizVyprobData0 data;
	data.id_kolca				= id_kolca;
	data.id_phys_vyprob			= id_phys_vyprob;
	data.h						= h;
	data.d						= d;
	data.dh_po_upl				= dh_po_upl;
	data.m_kolca				= m_kolca;
	data.m_grunta				= m_grunta;
	data.m_grunta_zamoch		= m_grunta_zamoch;
	data.m_grunta_posle_uplot	= m_grunta_posle_uplot;
	data.m_grunta_posle			= m_grunta_posle;
	data.m_grunta_vysush		= m_grunta_vysush;

	this->zriz.Add(id_vyprob, data);
}
void LabNumber::AddZriz(long id_vyprob, 
						long id_hid, long id_shema, long id_stan, double tgfi, double c, double d, double h, unsigned char bStat)
{
	ZrizVyprobData2 data;
	data.id_hid		= id_hid;
	data.id_shema	= id_shema;
	data.id_stan	= id_stan;
	data.tgfi		= tgfi;
	data.c			= c;
	data.d			= d;
	data.h			= h;
	data.bStat		= bStat;

	this->zriz.Add(id_vyprob, data);
}

void LabNumber::AddPtStZond(
	long id_ust,
	double glyb,
	const char * ust_name,
	long typ_zond, long n_shema,
	double Kg, double Kf, double Bg, double Bf, double shtanga_d)
{
	StatZondData2 data;
	data.id_ust = id_ust;
	data.glyb = glyb;

	data.ust_name = ust_name;
	data.typ_zond = typ_zond;
	data.n_shema = n_shema;

	data.Kg = Kg;
	data.Kf = Kf;
	data.Bg = Bg;
	data.Bf = Bf;

	data.shtanga_d = shtanga_d;

	this->m_stat_zond.Add(data);
}
void LabNumber::AddStZond(
	long npp, long typgr,
	double h, double q0, double f0, 
	double dh, double fsr, 
	unsigned char bStat,
	long id_ige, double pck
	)
{
	StatZondData1 data;
	data.npp = npp;
	data.typgr = typgr;
	data.h = h;
	data.q0 = q0;
	data.f0 = f0;
	data.dh = dh;
	data.fsr = fsr;
	data.bStat = bStat;
	data.id_ige = id_ige;
	data.pck = pck;

	this->m_stat_zond.Add(data);
}


void LabNumber::ApplyStZond()
{
	for (vector<StatZondData1>::iterator it = this->m_stat_zond.data1.begin();
		it != this->m_stat_zond.data1.end(); it++)
	{
		double q = (*it).GetPCK();
		double f = (*it).GetPCB();
	}

	if (this->m_stat_zond.data1.size())
	{
		if (this->m_stat_zond.data1.size() == 1)
		{
			double q = this->m_stat_zond.data1[0].GetPCK();
			double f = this->m_stat_zond.data1[0].GetPCB();

			this->pck = q;
			this->pcb = f;
		}
		if (this->m_stat_zond.data1.size() == 2)
		{
			double q0 = this->m_stat_zond.data1[0].GetPCK();
			double f0 = this->m_stat_zond.data1[0].GetPCB();
			double h0 = this->m_stat_zond.data1[0].h;

			double q1 = this->m_stat_zond.data1[1].GetPCK();
			double f1 = this->m_stat_zond.data1[1].GetPCB();
			double h1 = this->m_stat_zond.data1[1].h;

			double h = this->depth;

			double mu = (h-h0) / (h1-h0);

			double q = q0 + mu * (q1-q0);
			double f = f0 + mu * (f1-f0);

			this->pck = q;
			this->pcb = f;
		}
	}

	if (this->m_stat_zond.data2_filled)
	{
		this->zond_type = this->m_stat_zond.data2.typ_zond;
	}
}
bool LabNumber::ApplyZriz(int nCutItem)
{
	int nItem = 0;
	LabLayer * lablayer = (LabLayer *) this->GetLabLayer();
	if (lablayer)
	{
		for (map<long, ZrizVyprob>::iterator itz = this->zriz.vyprob.begin();
			itz != this->zriz.vyprob.end(); itz++, nItem++)
		{
			if (nItem == nCutItem && (*itz).second.data1_filled && (*itz).second.data2_filled)
			{						
				CutLabExperiment * cut = dynamic_cast<CutLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::cut));
				if (!cut)
					cut = dynamic_cast<CutLabExperiment *>(lablayer->AddNewLabExperiment(LabExperiment::type::cut));
				
				LabTrial * lab_trial = NULL;
				CutLabTrial * cut_trial = NULL;

				switch((*itz).second.data2.id_stan)
				{
				case 1:
					{
						LabTrial::indication indication;
						indication = LabTrial::indication::cut_resistance_nature_condition;						
						this->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));

						//Естественная влажность
						lab_trial = FindLabTrial(LabTrial::indication::cut_resistance_nature_condition, -1);
						if(!lab_trial)
							lab_trial = this->AddNewLabTrial(LabTrial::indication::cut_resistance_nature_condition, 
							(*itz).first
							//MEAN_VYPROB
							);
						cut_trial = dynamic_cast<CutLabTrial *>(lab_trial);
					}
					break;
				case 2:
					{
						LabTrial::indication indication;
						indication = LabTrial::indication::cut_resistance_task_condition;						
						this->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));

						//Водонасыщенный
						lab_trial = FindLabTrial(LabTrial::indication::cut_resistance_task_condition, -1);
						if(!lab_trial)
							lab_trial = this->AddNewLabTrial(LabTrial::indication::cut_resistance_task_condition, 
							(*itz).first
							//MEAN_VYPROB
							);
						cut_trial = dynamic_cast<CutLabTrial *>(lab_trial);
					}
					break;
				}	
				
				if (cut && cut_trial)
				{
					cut_trial->id_hid = (*itz).second.data2.id_hid;
					cut_trial->id_shema = (*itz).second.data2.id_shema;
					cut_trial->id_stan = (*itz).second.data2.id_stan;
			
					switch((*itz).second.data2.id_stan)
					{
					case 1:
						{
							if (!cut->lab_layer_n_pressures_in_nature_condition)
							{
								//Естественная влажность
								cut->lab_layer_n_pressures_in_nature_condition = (*itz).second.data1.size();
								if (!cut->lab_layer_pressures_in_nature_condition)
									cut->lab_layer_pressures_in_nature_condition = new double[cut->lab_layer_n_pressures_in_nature_condition];
							}

							cut_trial->pressures = new double[(*itz).second.data1.size()];
							cut_trial->cut_resistances = new trial_value[(*itz).second.data1.size()];
							cut_trial->n_pressures = (*itz).second.data1.size();
						}
						break;
					case 2:
						{
							//Водонасыщенный
							char szBuff[128];
							strcpy(szBuff, "водонас.");
							CharToOem(szBuff, szBuff);

							cut->task_moisture = szBuff;
							cut->task_density = 0.0;
							cut->ParseTaskMoisture();

							if (cut->lab_layer_n_pressures_in_task_condition)
							{
								cut->lab_layer_n_pressures_in_task_condition = (*itz).second.data1.size();
								if (!cut->lab_layer_pressures_in_task_condition)
									cut->lab_layer_pressures_in_task_condition = new double[cut->lab_layer_n_pressures_in_task_condition];
							}
							cut_trial->pressures = new double[(*itz).second.data1.size()];
							cut_trial->cut_resistances = new trial_value[(*itz).second.data1.size()];
							cut_trial->n_pressures = (*itz).second.data1.size();
						}
						break;
					}


					int i = 0;
					for (vector<ZrizVyprobData1>::iterator itd = (*itz).second.data1.begin();
						itd != (*itz).second.data1.end(); itd++)
					{
						cut_trial->cut_resistances[i] = (*itd).tau;
						cut_trial->pressures[i] = (*itd).sigma;

						switch((*itz).second.data2.id_stan)
						{
						case 1:
							{
								//Естественная влажность
								if (i < cut->lab_layer_n_pressures_in_nature_condition)
									cut->lab_layer_pressures_in_nature_condition[i] = (*itd).sigma;
							}
							break;
						case 2:
							{
								//Водонасыщенный
								if (i < cut->lab_layer_n_pressures_in_task_condition)
									cut->lab_layer_pressures_in_task_condition[i] = (*itd).sigma;
							}
							break;
						}

						i++;
					}


					(*itz).second.data2.d;
					(*itz).second.data2.h;

					for (vector<ZrizVyprobData0>::iterator it0 = (*itz).second.data0.begin();
						it0 != (*itz).second.data0.end(); it0++)
					{
						cut_trial->zriz_kolca0.push_back((*it0));			
					}
					for (vector<ZrizVyprobData1>::iterator it1 = (*itz).second.data1.begin();
						it1 != (*itz).second.data1.end(); it1++)
					{
						cut_trial->zriz_kolca1.push_back((*it1));			
					}
				}
			}
		}
	}

	return true;
}


void LabNumber::AddCompress(long id_vyprob, 
						double sigma, double dh1, double dh2, unsigned char voda, unsigned char bStat)
{
	CompressVyprobData1 data;
	data.sigma		= sigma;
	data.dh1		= dh1;
	data.dh2		= dh2;
	data.voda		= voda;
	data.bStat		= bStat;

	this->compress.Add(id_vyprob, data);
}

void LabNumber::AddCilce0(long id_vyprob, long id_kolca, long id_phys_vyprob,
	double h, double d,
	double m_kolca,
	double m_grunta,
	double m_grunta_zamoch,
	double m_grunta_posle,
	double m_grunta_vysush)
{
	CompressVyprobData0 data;
	data.id_kolca			= id_kolca;
	data.id_phys_vyprob		= id_phys_vyprob;
	data.h					= h;
	data.d					= d;
	data.m_kolca			= m_kolca;
	data.m_grunta			= m_grunta;
	data.m_grunta_zamoch	= m_grunta_zamoch;
	data.m_grunta_posle		= m_grunta_posle;
	data.m_grunta_vysush	= m_grunta_vysush;

	this->compress.Add(id_vyprob, data);
}

void LabNumber::AddCompress(
							long id_vyprob, 
							double h, double d, 
							double es_l1, double es_r1, double es_l2, double es_r2,
							double nju, double nju_z,
							double m01, double E1, double m02, double E2,
							double m01v, double E1v, double m02v, double E2v,
							unsigned char id_method, unsigned char bStat, unsigned char bStatV
						)
{
	CompressVyprobData2 data;
	data.h			= h;
	data.d			= d;
	data.es_l1		= es_l1;
	data.es_r1		= es_r1;
	data.es_l2		= es_l2;
	data.es_r2		= es_r2;
	data.nju		= nju;
	data.nju_z		= nju_z;
	data.m01		= m01;
	data.E1			= E1;
	data.m02		= m02;
	data.E2			= E2;
	data.m01v		= m01v;
	data.E1v		= E1v;
	data.m02v		= m02v;
	data.E2v		= E2v;
	data.id_method	= id_method;
	data.bStat		= bStat;
	data.bStatV		= bStatV;

	this->compress.Add(id_vyprob, data);
}

long LabNumber::GetCompressVyprobMaxID()
{
	long id_vyprob = 0;
	for (map<long, CompressVyprob>::iterator it = compress.vyprob.begin();
		it != compress.vyprob.end(); it++)
	{
		if ((*it).second.data0_filled && (*it).second.data1_filled && (*it).second.data2_filled)
		{
			if (id_vyprob < (*it).first)
				id_vyprob = (*it).first;
		}
	}
	return id_vyprob;
}

long LabNumber::GetCutVyprobMaxID()
{
	long id_vyprob = 0;
	for (map<long, ZrizVyprob>::iterator it = zriz.vyprob.begin();
		it != zriz.vyprob.end(); it++)
	{
		if ((*it).second.data0_filled && (*it).second.data1_filled && (*it).second.data2_filled)
		{
			if (id_vyprob < (*it).first)
				id_vyprob = (*it).first;
		}
	}
	return id_vyprob;
}
int LabNumber::GetCompressType(int nCompItem)
{
	LabTrial * labtrial = this->FindLabTrial(LabTrial::indication::compression_3, -1);
	CompressionLabTrial3 * comp3 = dynamic_cast<CompressionLabTrial3 *>(labtrial);
	if (comp3)
	{
		if (comp3->id_method == 2)
		{
			for (map<long, CompressVyprob>::iterator itm = this->compress.vyprob.begin();
				itm != this->compress.vyprob.end(); itm++)
			{
				if ((*itm).first == comp3->m_id_vyprob)
				{
					for (vector<CompressVyprobData0>::iterator itv = (*itm).second.data0.begin();
						itv != (*itm).second.data0.end(); itv++)
					{
						(*itv).id_kolca;
						if ((*itv).id_phys_vyprob > 1)
							return 3;
					}
				}
			}
			return 2;
		}
		else
			return 1;
	}
	return 0;

}
bool LabNumber::ApplyCompress(bool use_compression3, int nCompItem)
{
	if (use_compression3)
	{
		return this->ApplyCompress_3(nCompItem);
	}
	else
	{
		return this->ApplyCompress_1();
	}
	return false;
}
bool LabNumber::ApplyCompress_3(int nCompItem)
{
	int nItem = 0;
	LabLayer * lab_layer = (LabLayer *) this->GetLabLayer();
	for (map<long, CompressVyprob>::iterator itc = this->compress.vyprob.begin();
		itc != this->compress.vyprob.end(); itc++, nItem++)
	{
		if (nItem == nCompItem && (*itc).second.data1_filled
			// && (*itc).second.data2_filled
			)
		{	
			CompressionLabExperiment * compr = dynamic_cast<CompressionLabExperiment *>(lab_layer ? lab_layer->FindLabExperiment(LabExperiment::type::compression) : NULL);
			if (!compr && lab_layer)
				compr = dynamic_cast<CompressionLabExperiment *>(lab_layer->AddNewLabExperiment(LabExperiment::type::compression));
			LabTrial * lab_trial = NULL;
			CompressionLabTrial3 * compr_trial_3 = NULL;
			lab_trial = FindLabTrial(LabTrial::indication::compression_3, -1);
			if(!lab_trial)
				lab_trial = this->AddNewLabTrial(LabTrial::indication::compression_3, 
				(*itc).first
				//MEAN_VYPROB
				);
			compr_trial_3 = dynamic_cast<CompressionLabTrial3 *>(lab_trial);


			if (
#if USE_LAB_LAYER_HOOP
				compr && 
#endif
				compr_trial_3)
			{
				compr_trial_3->SetLabNumber();

				compr_trial_3->id_method = (*itc).second.data2.id_method;
				

				if ((*itc).second.data2_filled)
				{
#if USE_LAB_LAYER_HOOP
					compr->hoop_height = (*itc).second.data2.h;
					compr->hoop_diameter = (*itc).second.data2.d;
#else
					if (compr_trial_3->p_trial_1)
					{
						compr_trial_3->p_trial_1->hoop_height = (*itc).second.data2.h;
						compr_trial_3->p_trial_1->hoop_diameter = (*itc).second.data2.d;
					}
					if (compr_trial_3->p_trial_2)
					{
						compr_trial_3->p_trial_2->hoop_height = (*itc).second.data2.h;
						compr_trial_3->p_trial_2->hoop_diameter = (*itc).second.data2.d;
					}
					if (compr_trial_3->p_trial_3)
					{
						compr_trial_3->p_trial_3->hoop_height = (*itc).second.data2.h;
						compr_trial_3->p_trial_3->hoop_diameter = (*itc).second.data2.d;
					}
#endif
				}

				if ((*itc).second.data0_filled)
				{
					for (vector<CompressVyprobData0>::iterator it0 = (*itc).second.data0.begin();
						it0 != (*itc).second.data0.end(); it0++)
					{
						CompressionLabTrial * trial = NULL;
						switch((*it0).id_kolca)
						{
						case 1:
							trial = compr_trial_3->p_trial_1;
							break;						
						case 2:
							trial = compr_trial_3->p_trial_2;
							break;
						}
						if (trial)
						{
							trial->id_kolca			= (*it0).id_kolca;
							trial->id_phys_vyprob	= (*it0).id_phys_vyprob;
							
							if((*it0).m_grunta)
								trial->m_grunta			= (*it0).m_grunta;
							if ((*it0).m_grunta_zamoch)
								trial->m_grunta_zamoch	= (*it0).m_grunta_zamoch;
							if ((*it0).m_grunta_posle)
								trial->m_grunta_posle	= (*it0).m_grunta_posle;
							if ((*it0).m_grunta_vysush)
								trial->m_grunta_vysush	= (*it0).m_grunta_vysush;
						}
					}

				}
				switch ((*itc).second.data2.id_method)
				{
				case 1:
					{
						LabTrial::indication indication;
						indication = LabTrial::indication::compression_nature_condition_absolute_deformation;						
						this->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));

						int n_press_1 = 0;
						// метод одной кривой
						for (vector<CompressVyprobData1>::iterator itd = (*itc).second.data1.begin();
							itd != (*itc).second.data1.end(); itd++)
						{
							n_press_1++;
						}

						if (compr_trial_3->p_trial_1) compr_trial_3->p_trial_1->n_pressures = n_press_1;
						if (compr_trial_3->p_trial_1) compr_trial_3->p_trial_1->absolute_deformations = new trial_value[n_press_1];
						if (compr_trial_3->p_trial_1) compr_trial_3->p_trial_1->pressures = new double[n_press_1];
						
						int i = 0;
						double p_zamach, dh_zamach;
						bool has_zamach = false;
						for (vector<CompressVyprobData1>::iterator itd = (*itc).second.data1.begin();
							itd != (*itc).second.data1.end(); itd++)
						{
							if (compr_trial_3->p_trial_1)
							{
								if (i < n_press_1)
								{
									if ((*itd).sigma < 0.0)
									{
										p_zamach = -(*itd).sigma;
										dh_zamach = (*itd).dh1;
										has_zamach = true;
									}
									else
									{
										compr_trial_3->p_trial_1->absolute_deformations[i] = (*itd).dh1;
										compr_trial_3->p_trial_1->pressures[i] = (*itd).sigma;
										i++;
										if (has_zamach && p_zamach == (*itd).sigma)
										{
											compr_trial_3->p_trial_1->absolute_deformations[i] = dh_zamach;
											compr_trial_3->p_trial_1->pressures[i] = p_zamach;
											i++;
										}
									}
								}
							}							
						}
					}
					break;					
				case 2:
					{
						LabTrial::indication indication;
						indication = LabTrial::indication::compression_nature_condition_absolute_deformation;						
						this->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));
						indication = LabTrial::indication::compression_task_condition_absolute_deformation;						
						this->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));
						
						int n_press_1 = 0;
						int n_press_2 = 0;
						// метод двух кривых
						for (vector<CompressVyprobData1>::iterator itd = (*itc).second.data1.begin();
							itd != (*itc).second.data1.end(); itd++)
						{
							if ((*itd).sigma < 0.0)
							{
								n_press_1++;
							}
							else								
							{
								n_press_1++;
								n_press_2++;
							}
						}

						if (compr_trial_3->p_trial_1) compr_trial_3->p_trial_1->n_pressures = n_press_1;
						if (compr_trial_3->p_trial_1) compr_trial_3->p_trial_1->absolute_deformations = new trial_value[n_press_1];
						if (compr_trial_3->p_trial_1) compr_trial_3->p_trial_1->pressures = new double[n_press_1];

						if (compr_trial_3->p_trial_2) compr_trial_3->p_trial_2->n_pressures = n_press_2;
						if (compr_trial_3->p_trial_2) compr_trial_3->p_trial_2->absolute_deformations = new trial_value[n_press_2];
						if (compr_trial_3->p_trial_2) compr_trial_3->p_trial_2->pressures = new double[n_press_2];
						
						//Водонасыщенный
						char szBuff[128];
						strcpy(szBuff, "водонас.");
						CharToOem(szBuff, szBuff);

						if (compr)
						{
							compr->task_moisture = szBuff;
							compr->task_density = 0.0;
							compr->ParseTaskMoisture();
						}

						int i1 = 0;
						int i2 = 0;
						double p_zamach, dh_zamach;
						bool has_zamach = false;
						for (vector<CompressVyprobData1>::iterator itd = (*itc).second.data1.begin();
							itd != (*itc).second.data1.end(); itd++)
						{
							if ((*itd).sigma < 0.0)
							{
								p_zamach = -(*itd).sigma;
								dh_zamach = (*itd).dh1;
								has_zamach = true;
							}
							else
							{
								if (compr_trial_3->p_trial_1)
								{
									if (i1 < n_press_1)
									{
										compr_trial_3->p_trial_1->absolute_deformations[i1] = (*itd).dh1;
										compr_trial_3->p_trial_1->pressures[i1] = (*itd).sigma;
										i1++;
										if (has_zamach && p_zamach == (*itd).sigma)
										{
											compr_trial_3->p_trial_1->absolute_deformations[i1] = dh_zamach;
											compr_trial_3->p_trial_1->pressures[i1] = p_zamach;
											i1++;
										}
									}
								}
								if (compr_trial_3->p_trial_2) 
								{
									if (i2 < n_press_2)
									{
										compr_trial_3->p_trial_2->absolute_deformations[i2] = (*itd).dh2;
										compr_trial_3->p_trial_2->pressures[i2] = (*itd).sigma;
										i2++;
									}
								}
							}
						}
					}
					break;
				case 3:
					{
						LabTrial::indication indication;
						indication = LabTrial::indication::compression_nature_condition_absolute_deformation;						
						this->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));

						int n_press_1 = 0;
						bool zamach = false;
						// одна кривая с замачаванием
						for (vector<CompressVyprobData1>::iterator itd = (*itc).second.data1.begin();
							itd != (*itc).second.data1.end(); itd++)
						{
							if (!zamach)
							{
								if ((*itd).dh1 && (*itd).dh2)
								{
									n_press_1++;
									zamach = true;
									n_press_1++;
								}
								else /* if ((*itd).dh1 && !(*itd).dh2)*/
								{
									n_press_1++;
								}							
							}
							else
							{
								//if ((*itd).dh2)
								//{
									n_press_1++;
								//}
							}	
						}
						if (compr_trial_3->p_trial_1) compr_trial_3->p_trial_1->n_pressures = n_press_1;
						if (compr_trial_3->p_trial_1) compr_trial_3->p_trial_1->absolute_deformations = new trial_value[n_press_1];
						if (compr_trial_3->p_trial_1) compr_trial_3->p_trial_1->pressures = new double[n_press_1];
						
						int i = 0;
						zamach = false;
						for (vector<CompressVyprobData1>::iterator itd = (*itc).second.data1.begin();
							itd != (*itc).second.data1.end(); itd++)
						{
							if (!zamach)
							{
								if ((*itd).dh1 && (*itd).dh2)
								{
									if (compr_trial_3->p_trial_1)
									{
										if (i < n_press_1)
										{
											compr_trial_3->p_trial_1->absolute_deformations[i] = (*itd).dh1;
											compr_trial_3->p_trial_1->pressures[i] = (*itd).sigma;
										}
									}
									i++;
									zamach = true;
									if (compr_trial_3->p_trial_1)
									{
										if (i < n_press_1)
										{
											compr_trial_3->p_trial_1->absolute_deformations[i] = (*itd).dh2;
											compr_trial_3->p_trial_1->pressures[i] = (*itd).sigma;
										}
									}
									i++;
								}
								else/* if ((*itd).dh1 && !(*itd).dh2)*/
								{
									if (compr_trial_3->p_trial_1)
									{
										if (i < n_press_1)
										{
											compr_trial_3->p_trial_1->absolute_deformations[i] = (*itd).dh1;
											compr_trial_3->p_trial_1->pressures[i] = (*itd).sigma;
										}
									}
									i++;
								}
							}
							else
							{
								if ((*itd).dh2)
								{
									if (compr_trial_3->p_trial_1)
									{
										if (i < n_press_1)
										{
											compr_trial_3->p_trial_1->absolute_deformations[i] = (*itd).dh2;
											compr_trial_3->p_trial_1->pressures[i] = (*itd).sigma;
										}
									}
									i++;
								}
							}	
						}
					}
					break;
				case 4:
					{
						LabTrial::indication indication;
						indication = LabTrial::indication::compression_task_condition_absolute_deformation;						
						this->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));

						int n_press_2 = 0;
						// метод одной кривой
						for (vector<CompressVyprobData1>::iterator itd = (*itc).second.data1.begin();
							itd != (*itc).second.data1.end(); itd++)
						{
							/*if ((*itd).dh2)*/ n_press_2++;
						}

						if (compr_trial_3->p_trial_2) compr_trial_3->p_trial_2->n_pressures = n_press_2;
						if (compr_trial_3->p_trial_2) compr_trial_3->p_trial_2->absolute_deformations = new trial_value[n_press_2];
						if (compr_trial_3->p_trial_2) compr_trial_3->p_trial_2->pressures = new double[n_press_2];
						
						//Водонасыщенный
						char szBuff[128];
						strcpy(szBuff, "водонас.");
						CharToOem(szBuff, szBuff);

						if (compr)
						{
							compr->task_moisture = szBuff;
							compr->task_density = 0.0;
							compr->ParseTaskMoisture();
						}

						int i = 0;
						for (vector<CompressVyprobData1>::iterator itd = (*itc).second.data1.begin();
							itd != (*itc).second.data1.end(); itd++)
						{
							if (compr_trial_3->p_trial_2)
							{
								if (i < n_press_2)
								{
									compr_trial_3->p_trial_2->absolute_deformations[i] = (*itd).dh2;
									compr_trial_3->p_trial_2->pressures[i] = (*itd).sigma;
								}
							}
							i++;
						}
					}
					break;					
				}
			}
		}
	}


	return true;
}



bool LabNumber::ApplyCompress_1()
{
	LabLayer * lablayer = (LabLayer *) this->GetLabLayer();
	if (lablayer)
	{
		for (map<long, CompressVyprob>::iterator itc = this->compress.vyprob.begin();
			itc != this->compress.vyprob.end(); itc++)
		{
			if ((*itc).second.data1_filled
				&& (*itc).second.data2_filled
				)
			{						
				switch ((*itc).second.data2.id_method)
				{
				case 1:
					{
						LabTrial::indication indication;
						indication = LabTrial::indication::compression_nature_condition_absolute_deformation;						
						this->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));
						
						CompressionLabExperiment * compr = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
						if (!compr)
							compr = dynamic_cast<CompressionLabExperiment *>(lablayer->AddNewLabExperiment(LabExperiment::type::compression));
						
						LabTrial * lab_trial_1 = NULL;
						CompressionLabTrial * compr_trial_1 = NULL;
						
						//Естественная влажность
						lab_trial_1 = FindLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, -1);
						if(!lab_trial_1)
							lab_trial_1 = this->AddNewLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, MEAN_VYPROB);
						compr_trial_1 = dynamic_cast<CompressionLabTrial *>(lab_trial_1);
						
			
						
						if (compr && compr_trial_1)
						{
							if ((*itc).second.data2_filled)
							{

#if USE_LAB_LAYER_HOOP
								compr->hoop_height = (*itc).second.data2.h;
								compr->hoop_diameter = (*itc).second.data2.d;
#else
								compr_trial_1->hoop_height = (*itc).second.data2.h;
								compr_trial_1->hoop_diameter = (*itc).second.data2.d;
#endif
							}


							int n_press_1 = 0;
							for (vector<CompressVyprobData1>::iterator itd = (*itc).second.data1.begin();
								itd != (*itc).second.data1.end(); itd++)
							{
								if ((*itd).dh1) n_press_1++;
							}

							//Естественная влажность
							compr_trial_1->n_pressures = n_press_1;
							compr_trial_1->absolute_deformations = new trial_value[n_press_1];
							compr_trial_1->pressures = new double[n_press_1];


							int i = 0;
							for (vector<CompressVyprobData1>::iterator itd = (*itc).second.data1.begin();
								itd != (*itc).second.data1.end(); itd++)
							{
								if (i < n_press_1)
								{
									compr_trial_1->absolute_deformations[i] = (*itd).dh1;
									compr_trial_1->pressures[i] = (*itd).sigma;
								}
								i++;
							}
						}
					}
					break;
				case 2:
					{
						LabTrial::indication indication;
						indication = LabTrial::indication::compression_nature_condition_absolute_deformation;						
						this->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));
						indication = LabTrial::indication::compression_task_condition_absolute_deformation;						
						this->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));

						CompressionLabExperiment * compr = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
						if (!compr)
							compr = dynamic_cast<CompressionLabExperiment *>(lablayer->AddNewLabExperiment(LabExperiment::type::compression));
						
						LabTrial * lab_trial_1 = NULL;
						LabTrial * lab_trial_2 = NULL;
						CompressionLabTrial * compr_trial_1 = NULL;
						CompressionLabTrial * compr_trial_2 = NULL;
						
						//Естественная влажность
						lab_trial_1 = FindLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, -1);
						if(!lab_trial_1)
							lab_trial_1 = this->AddNewLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, MEAN_VYPROB);
						compr_trial_1 = dynamic_cast<CompressionLabTrial *>(lab_trial_1);
						
						//Водонасыщенный
						lab_trial_2 = FindLabTrial(LabTrial::indication::compression_task_condition_absolute_deformation, -1);
						if(!lab_trial_2)
							lab_trial_2 = this->AddNewLabTrial(LabTrial::indication::compression_task_condition_absolute_deformation, MEAN_VYPROB);
						compr_trial_2 = dynamic_cast<CompressionLabTrial *>(lab_trial_2);
			
						
						if (compr && compr_trial_1 && compr_trial_2)
						{
							if ((*itc).second.data2_filled)
							{

		#if USE_LAB_LAYER_HOOP
								compr->hoop_height = (*itc).second.data2.h;
								compr->hoop_diameter = (*itc).second.data2.d;
		#else
								compr_trial_1->hoop_height = (*itc).second.data2.h;
								compr_trial_1->hoop_diameter = (*itc).second.data2.d;

								compr_trial_2->hoop_height = (*itc).second.data2.h;
								compr_trial_2->hoop_diameter = (*itc).second.data2.d;		
		#endif
							}


							int n_press_1 = 0;
							int n_press_2 = 0;
							for (vector<CompressVyprobData1>::iterator itd = (*itc).second.data1.begin();
								itd != (*itc).second.data1.end(); itd++)
							{
								if ((*itd).dh1) n_press_1++;
								if ((*itd).dh2) n_press_2++;
							}

							//Естественная влажность
							compr_trial_1->n_pressures = n_press_1;
							compr_trial_1->absolute_deformations = new trial_value[n_press_1];
							compr_trial_1->pressures = new double[n_press_1];

							//Водонасыщенный
							char szBuff[128];
							strcpy(szBuff, "водонас.");
							CharToOem(szBuff, szBuff);

							compr->task_moisture = szBuff;
							compr->task_density = 0.0;
							compr->ParseTaskMoisture();				

							compr_trial_2->n_pressures = n_press_2;
							compr_trial_2->absolute_deformations = new trial_value[n_press_2];
							compr_trial_2->pressures = new double[n_press_2];

							int i = 0;
							for (vector<CompressVyprobData1>::iterator itd = (*itc).second.data1.begin();
								itd != (*itc).second.data1.end(); itd++)
							{
								if (i < n_press_1)
								{
									compr_trial_1->absolute_deformations[i] = (*itd).dh1;
									compr_trial_1->pressures[i] = (*itd).sigma;
								}

								if (i < n_press_2)
								{
									compr_trial_2->absolute_deformations[i] = (*itd).dh2;
									compr_trial_2->pressures[i] = (*itd).sigma;
								}

								i++;
							}
						}
					}
					break;
				case 3:
					{
						LabTrial::indication indication;
						indication = LabTrial::indication::compression_nature_condition_absolute_deformation;						
						this->trial_indications.insert(map <LabTrial::indication, LabTrial::indication>::value_type(indication, indication));

						CompressionLabExperiment * compr = dynamic_cast<CompressionLabExperiment *>(lablayer->FindLabExperiment(LabExperiment::type::compression));
						if (!compr)
							compr = dynamic_cast<CompressionLabExperiment *>(lablayer->AddNewLabExperiment(LabExperiment::type::compression));
						
						LabTrial * lab_trial_1 = NULL;
						CompressionLabTrial * compr_trial_1 = NULL;
						
						//Естественная влажность
						lab_trial_1 = FindLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, -1);
						if(!lab_trial_1)
							lab_trial_1 = this->AddNewLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, MEAN_VYPROB);
						compr_trial_1 = dynamic_cast<CompressionLabTrial *>(lab_trial_1);
						
			
						
						if (compr && compr_trial_1)
						{
							if ((*itc).second.data2_filled)
							{

		#if USE_LAB_LAYER_HOOP
								compr->hoop_height = (*itc).second.data2.h;
								compr->hoop_diameter = (*itc).second.data2.d;
		#else
								compr_trial_1->hoop_height = (*itc).second.data2.h;
								compr_trial_1->hoop_diameter = (*itc).second.data2.d;
		#endif
							}


							int n_press_1 = 0;
							bool zamach = false;
							// одна кривая с замачаванием
							for (vector<CompressVyprobData1>::iterator itd = (*itc).second.data1.begin();
								itd != (*itc).second.data1.end(); itd++)
							{
								if (!zamach)
								{
									if ((*itd).dh1 && !(*itd).dh2)
									{
										n_press_1++;
									}
									else if ((*itd).dh1 && (*itd).dh2)
									{
										n_press_1++;
										zamach = true;
										n_press_1++;
									}
								}
								else
								{
									if ((*itd).dh2)
									{
										n_press_1++;
									}
								}	
							}
							compr_trial_1->n_pressures = n_press_1;
							compr_trial_1->absolute_deformations = new trial_value[n_press_1];
							compr_trial_1->pressures = new double[n_press_1];
							
							int i = 0;
							zamach = false;
							for (vector<CompressVyprobData1>::iterator itd = (*itc).second.data1.begin();
								itd != (*itc).second.data1.end(); itd++)
							{
								if (!zamach)
								{
									if ((*itd).dh1 && !(*itd).dh2)
									{
										if (compr_trial_1)
										{
											if (i < n_press_1)
											{
												compr_trial_1->absolute_deformations[i] = (*itd).dh1;
												compr_trial_1->pressures[i] = (*itd).sigma;
											}
										}
										i++;
									}
									else if ((*itd).dh1 && (*itd).dh2)
									{
										if (compr_trial_1)
										{
											if (i < n_press_1)
											{
												compr_trial_1->absolute_deformations[i] = (*itd).dh1;
												compr_trial_1->pressures[i] = (*itd).sigma;
											}
										}
										i++;
										zamach = true;
										if (compr_trial_1)
										{
											if (i < n_press_1)
											{
												compr_trial_1->absolute_deformations[i] = (*itd).dh2;
												compr_trial_1->pressures[i] = (*itd).sigma;
											}
										}
										i++;
									}
								}
								else
								{
									if ((*itd).dh2)
									{
										if (compr_trial_1)
										{
											if (i < n_press_1)
											{
												compr_trial_1->absolute_deformations[i] = (*itd).dh2;
												compr_trial_1->pressures[i] = (*itd).sigma;
											}
										}
										i++;
									}
								}	
							}

						}
					}
					break;
				}

			}
		}
	}

	return true;
}

#if 1
int LabNumber::SaveLabInputFileLine(FILE * stream, char* szBuff, int & type_line, Laboratory * m_laboratory, LabLayer * m_lablayer, LabExperiment *& m_lab_experiment, LabTrial *& m_lab_trial)
{
	LabNumber * m_lab_number = this;
	//printf("ParseLabInputFileLine(szBuff = \"%s\", type_line = %d)\)\n", szBuff, type_line);

	/*

г.Харьков
2008
2
3,3,11000,
лит,56.00,20.,од.,водонас.,0.,0.,6.,0.,
0.05,0.10,0.15,0.2,0.25,0.3,
лит,56.,20.,консолид,водонас.,0.0,0.,3.,0.05,0.1,0.15,
414,скв.,1003,1.3,1,2,5,8,0,
0.35,0.22,0.33,0.,0.,0.,2.50,1.70,
0,0,0.02,0,0,0.07,0,0,0,
0.38,0.67,1.00,1.24,2.56,2.85,
0.030,0.050,0.065,
415,скв.,1003,2.0,1,2,5,8,0,
0.43,0.28,0.34,0.,0.,0.,2.37,1.76,
0,0,0.04,0,0,0.06,0,0,0,
0.49,0.94,1.53,2.01,2.33,2.65,
0.045,0.080,0.105,
416,скв.,1003,3.0,1,2,5,8,0,
0.45,0.28,0.44,0.,0.,0.,2.25,1.58,
0,0,0.06,0,0,0.13,0,0,0,
0.64,1.43,2.04,2.64,2.95,3.66,
0.040,0.070,0.100,
417,скв.,1011,1.5,1,2,5,8,0,
0.32,0.15,0.23,0.,0.,0.,2.54,1.90,
0,0,0.04,0,0,0.03,0,0,0,
0.49,0.94,1.53,2.01,2.33,2.65,
0.031,0.050,0.065,
418,скв.,1011,2.0,1,2,5,8,0,
0.42,0.29,0.33,0.,0.,0.,2.60,1.94,
0,0,0.07,0,0,0.04,0,0,0,
0.45,0.65,0.97,1.29,1.35,1.40,
0.035,0.055,0.075,
419,скв.,1011,3.0,1,2,5,8,0,
0.23,0.16,0.20,0.,0.,0.,2.56,1.98,
0,0,0.08,0,0,0.04,0,0,0,
0.06,0.12,0.21,0.37,0.43,0.68,
0.032,0.053,0.072,
420,скв.,1013,1.5,1,2,5,8,0,
0.38,0.27,0.35,0.,0.,0.,2.58,1.82,
0,0,0.07,0,0,0.07,0,0,0,
0.64,1.43,2.04,2.64,2.95,3.64,
0.037,0.070,0.095,
421,скв.,1013,2.5,1,2,5,8,0,
0.43,0.28,0.34,0.,0.,0.,2.40,1.78,
0,0,0.04,0,0,0.05,0,0,0,
0.62,1.07,1.86,2.21,2.56,2.92,
0.040,0.070,0.100,
422,скв.,1013,3.0,1,2,5,8,0,
0.35,0.22,0.33,0.,0.,0.,2.45,1.93,
0,0,0.09,0,0,0.04,0,0,0,
0.40,1.12,1.59,2.02,2.30,2.75,
0.050,0.080,0.105,
423,скв.,1040,1.5,1,2,5,8,0,
0.41,0.25,0.36,0.,0.,0.,2.50,1.77,
0,0,0.07,0,0,0.09,0,0,0,
0.60,1.40,2.00,2.60,2.90,3.61,
0.044,0.079,0.104,
**
3,6,11000,
лит,56.00,20.,од.,водонас.,0.,0.,7.,0.,
0.1,0.15,0.2,0.25,0.3,0.35,0.40,
лит,56.,20.,консолид,водонас.,0.0,0.,3.,0.1,0.2,0.3,
381,скв.,1001,7.1,1,5,8,0,
0.65,0.42,0.38,0.,0.,0.,2.65,1.80,
0.34,0.57,0.76,0.92,1.07,1.22,1.36,
0.105,0.150,0.195,
382,скв.,1001,7.8,1,5,8,0,
0.61,0.40,0.34,0.,0.,0.,2.65,1.86,
0.10,0.27,0.40,0.52,0.64,0.76,0.87,
0.095,0.145,0.195,
383,скв.,1013,8.2,1,5,8,0,
0.42,0.24,0.23,0.,0.,0.,2.66,1.95,
0.18,0.34,0.48,0.60,0.71,0.82,0.92,
0.115,0.160,0.205,
384,скв.,1013,9.3,1,5,8,0,
0.28,0.17,0.18,0.,0.,0.,2.66,1.97,
0.24,0.40,0.53,0.66,0.77,0.88,0.95,
0.105,0.165,0.205,
403,скв.,1025,6.0,1,5,8,0,
0.63,0.40,0.36,0.,0.,0.,2.65,1.79,
0.20,0.45,0.65,0.81,0.99,1.02,1.18,
0.100,0.140,0.185,
404,скв.,1025,7.0,1,5,8,0,
0.60,0.39,0.30,0.,0.,0.,2.65,1.84,
0.15,0.32,0.45,0.57,0.69,0.81,0.92,
0.097,0.147,0.197,
405,скв.,1025,8.0,1,5,8,0,
0.42,0.24,0.25,0.,0.,0.,2.66,1.96,
0.17,0.33,0.47,0.59,0.70,0.81,0.91,
0.100,0.145,0.190,
406,скв.,1025,9.0,1,5,8,0,
0.35,0.18,0.21,0.,0.,0.,2.66,1.98,
0.25,0.41,0.54,0.67,0.78,0.89,0.96,
0.110,0.170,0.210,
407,скв.,1023,6.0,1,5,8,0,
0.39,0.21,0.23,0.,0.,0.,2.66,1.96,
0.24,0.40,0.53,0.66,0.77,0.88,0.95,
0.105,0.165,0.205,
408,скв.,1023,7.0,1,5,8,0,
0.61,0.34,0.36,0.,0.,0.,2.65,1.81,
0.28,0.41,0.49,0.59,0.70,0.80,0.89,
0.083,0.138,0.195,
409,скв.,1023,8.0,1,5,8,0,
0.63,0.36,0.38,0.,0.,0.,2.65,1.86,
0.25,0.34,0.42,0.51,0.65,0.73,0.85,
0.095,0.135,0.185,
410,скв.,1023,9.0,1,5,8,0,
0.43,0.24,0.25,0.,0.,0.,2.65,1.91,
0.20,0.45,0.64,0.80,1.11,1.22,1.32,
0.100,0.150,0.190,
411,скв.,1023,10.0,1,5,8,0,
0.64,0.36,0.34,0.,0.,0.,2.66,1.84,
0.14,0.31,0.44,0.56,0.68,0.79,0.90,
0.105,0.150,0.195,
412,скв.,1027,7.0,1,5,8,0,
0.60,0.36,0.36,0.,0.,0.,2.65,1.87,
0.21,0.37,0.51,0.63,0.74,0.85,0.92,
0.090,0.135,0.175,
413,скв.,1027,8.0,1,5,8,0,
0.56,0.28,0.30,0.,0.,0.,2.66,1.90,
0.20,0.45,0.65,0.80,1.11,1.33,1.40,
0.105,0.155,0.200,
**
1,8,11000,
лит,56.00,20.,од.,водонас.,0.,0.,6.,0.,
0.1,0.2,0.3,0.4,0.5,0.6,
лит,56.,20.,консолид,водонас.,0.0,0.,3.,0.1,0.3,0.5,
388,скв.,1001,22.6,1,5,8,0,
0.47,0.26,0.25,0.,0.,0.,2.65,1.90,
0.19,0.40,0.57,0.71,0.83,0.93,
0.101,0.196,0.286,
389,скв.,1001,23.0,1,5,8,0,
0.42,0.24,0.25,0.,0.,0.,2.65,1.91,
0.14,0.35,0.53,0.69,0.81,0.91,
0.115,0.205,0.295,
390,скв.,1001,22.5,1,5,8,0,
0.42,0.24,0.24,0.,0.,0.,2.65,1.92,
0.18,0.39,0.56,0.70,0.82,0.92,
0.100,0.195,0.285,
391,скв.,1022,19.0,1,5,8,0,
0.33,0.20,0.27,0.,0.,0.,2.66,1.96,
0.16,0.33,0.49,0.65,0.81,0.96,
0.102,0.197,0.293,
392,скв.,1022,20.0,1,5,8,0,
0.36,0.21,0.26,0.,0.,0.,2.66,1.91,
0.29,0.54,0.75,0.92,1.08,1.20,
0.105,0.205,0.300,
393,скв.,1022,20.5,1,5,8,0,
0.36,0.21,0.28,0.,0.,0.,2.65,1.93,
0.20,0.42,0.61,0.76,0.90,1.01,
0.105,0.200,0.295,
394,скв.,1013,22.5,1,5,8,0,
0.38,0.22,0.26,0.,0.,0.,2.65,1.91,
0.15,0.36,0.54,0.70,0.82,0.93,
0.115,0.205,0.295,
395,скв.,1035,21.0,1,5,8,0,
0.34,0.20,0.28,0.,0.,0.,2.65,1.90,
0.23,0.51,0.74,0.92,1.09,1.22,
0.085,0.165,0.240,
396,скв.,1035,21.5,1,5,8,0,
0.35,0.21,0.25,0.,0.,0.,2.66,1.93,
0.27,0.48,0.69,0.84,0.98,1.09,
0.115,0.220,0.325,
397,скв.,1035,22.0,1,5,8,0,
0.36,0.21,0.26,0.,0.,0.,2.65,1.90,
0.29,0.53,0.75,0.93,1.10,1.24,
0.095,0.180,0.270,
398,скв.,1013,23.0,1,5,8,0,
0.49,0.28,0.28,0.,0.,0.,2.66,1.90,
0.17,0.38,0.55,0.69,0.81,0.91,
0.102,0.197,0.287,
399,скв.,1013,24.0,1,5,8,0,
0.43,0.25,0.26,0.,0.,0.,2.66,1.92,
0.18,0.35,0.51,0.67,0.79,0.89,
0.110,0.200,0.290,
400,скв.,1013,25.0,1,5,8,0,
0.42,0.24,0.25,0.,0.,0.,2.66,1.91,
0.19,0.40,0.57,0.71,0.83,0.93,
0.100,0.195,0.285,
401,скв.,1028,23.0,1,5,8,0,
0.41,0.23,0.25,0.,0.,0.,2.66,1.94,
0.18,0.39,0.56,0.70,0.82,0.92,
0.100,0.195,0.285,
402,скв.,1028,24.0,1,5,8,0,
0.46,0.24,0.26,0.,0.,0.,2.66,1.90,
0.17,0.36,0.53,0.68,0.82,0.94,
0.100,0.195,0.285,
**
***

*/
	//printf(szBuff);
	//char * p = szBuff;
#if 1

	while (true)
	{
		if (type_line == 5)
		{	
			if (m_lablayer->is_compression)
				break;
			else
				type_line = 9;
		}		
		if (type_line == 6)
		{	
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);
			if (compression)
			{
#if 0
#if USE_LAB_LAYER_PRESSURES
				if (compression->n_pressures_in_nature_condition)
#else
				if (compression->lab_layer_n_pressures_in_nature_condition)
#endif
					break;
				else
					type_line = 7;
#else
				CompressionLabTrial3 * com_lab_trial3 = dynamic_cast<CompressionLabTrial3 *>(this->FindLabTrial(LabTrial::indication::compression_3, -1));
				if (com_lab_trial3)
				{
					if (com_lab_trial3->p_trial_1 && com_lab_trial3->p_trial_1->n_pressures)
						break;
					else
						type_line = 7;
				}
				else
				{
					CompressionLabTrial * com_lab_trial_1 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, -1));
					CompressionLabTrial * com_lab_trial_2 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_task_condition_absolute_deformation, -1));
					CompressionLabTrial * com_lab_trial_3 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_shrinkage_absolute_deformation, -1));

					if (com_lab_trial_1 && com_lab_trial_1->n_pressures)
						break;
					else
						type_line = 7;
				}
#endif
			}
			else
				return -2;
		}
		if (type_line == 7)
		{	
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);
			if (compression)
			{
#if 0
#if USE_LAB_LAYER_PRESSURES
				if (compression->n_pressures_in_task_condition)
#else
				if (compression->lab_layer_n_pressures_in_task_condition)
#endif
					break;
				else
					type_line = 8;
#else
				CompressionLabTrial3 * com_lab_trial3 = dynamic_cast<CompressionLabTrial3 *>(this->FindLabTrial(LabTrial::indication::compression_3, -1));
				if (com_lab_trial3)
				{
					if (com_lab_trial3->p_trial_1 && com_lab_trial3->p_trial_1->n_pressures)
						break;
					else
						type_line = 8;
				}
				else
				{
					CompressionLabTrial * com_lab_trial_1 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, -1));
					CompressionLabTrial * com_lab_trial_2 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_task_condition_absolute_deformation, -1));
					CompressionLabTrial * com_lab_trial_3 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_shrinkage_absolute_deformation, -1));

					if (com_lab_trial_1 && com_lab_trial_1->n_pressures)
						break;
					else
						type_line = 8;
				}
#endif
			}
			else
				return -2;
		}
		if (type_line == 8)
		{	
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);
			if (compression)
			{
#if 0
#if USE_LAB_LAYER_PRESSURES
				if (compression->n_pressures_on_shrinkage)
#else
				if (compression->lab_layer_n_pressures_on_shrinkage)
#endif
					break;
				else
					type_line = 9;
#else
				CompressionLabTrial3 * com_lab_trial3 = dynamic_cast<CompressionLabTrial3 *>(this->FindLabTrial(LabTrial::indication::compression_3, -1));
				if (com_lab_trial3)
				{
					if (com_lab_trial3->p_trial_1 && com_lab_trial3->p_trial_1->n_pressures)
						break;
					else
						type_line = 9;
				}
				else
				{
					CompressionLabTrial * com_lab_trial_1 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, -1));
					CompressionLabTrial * com_lab_trial_2 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_task_condition_absolute_deformation, -1));
					CompressionLabTrial * com_lab_trial_3 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_shrinkage_absolute_deformation, -1));

					if (com_lab_trial_1 && com_lab_trial_1->n_pressures)
						break;
					else
						type_line = 9;
				}
#endif
			}
			else
				return -2;
		}
		else if(type_line == 9)
		{
			if (m_lablayer->is_cut)
				break;
			else
				type_line = 10;
		}
		else if(type_line == 10)
		{
			if (m_lablayer->is_filtracion)
				break;
			else
				type_line = 11;
		}
		else if(type_line == 11)
		{
			if (m_lablayer->is_pressing)
				break;
			else
				type_line = 12;
		}
		else if(type_line == 12)
		{
			if (m_lablayer->is_fractions)
				break;
			else
				type_line = 13;
		}
		else if(type_line == 14)
		{
			if (m_lab_number)
			{
				if (m_lab_number->is_trial_indication_1)
					break;
				else
					type_line = 15;
			}
			else return -3;
		}
		else if(type_line == 15)
		{
			if (m_lab_number)
			{
				if (m_lab_number->is_trial_indication_2)
					break;
				else
					type_line = 16;
			}
			else return -3;
		}
		else if(type_line == 16)
		{
		   if (m_lab_number)
			{
				if (m_lab_number->is_trial_indication_3)
					break;
				else
					type_line = 18;
			}
			else return -3;
		}
		else if(type_line == 18)
		{
			if (m_lab_number)
			{
				if (m_lab_number->is_trial_indication_4)
					break;
				else
					type_line = 19;
			}
			else return -3;
		}
		else if(type_line == 19)
		{
			if (m_lab_number)
			{
				if (m_lab_number->is_trial_indication_5)
					break;
				else
					type_line = 20;
			}
			else return -3;
		}
		else if(type_line == 20)
		{
			if (m_lab_number)
			{
				if (m_lab_number->is_trial_indication_6)
					break;
				else
					type_line = 21;
			}
			else return -3;
		}
		else if(type_line == 21)
		{
			if (m_lab_number)
			{
				if (m_lab_number->is_trial_indication_7)
					break;
				else
					type_line = 22;
			}
			else return -3;
		}
		else if(type_line == 22)
		{
			if (m_lab_number)
			{
				if (m_lab_number->is_trial_indication_8)
					break;
				else
					type_line = 23;
			}
			else return -3;
		}
		else if(type_line == 23)
		{
			if (m_lab_number)
			{
				if (m_lab_number->is_trial_indication_9)
					break;
				else
					type_line = 24;
			}
			else return -3;
		}
		else if(type_line == 24)
		{
			if (m_lab_number)
			{
				if (m_lab_number->is_trial_indication_10)
					break;
				else
					type_line = 25;
			}
			else return -3;
		}
		else if(type_line == 25)
		{
			if (m_lab_number)
			{
				if (m_lab_number->is_trial_indication_11)
					break;
				else
					type_line = 26;
			}
			else return -3;
		}
		else if(type_line == 26)
		{
			fprintf(stream, "**\n***\n");
			return 3;
			type_line = 13;
		}
		else
			break;
	}

	/*if (!strncmp(p, "***", 3))
	{
		printf("(!strcmp(p, \"***\"))\n");
		return 3;
	}

	if (!strncmp(p, "**", 2))
	{
		type_line = 4;
		printf("(!strcmp(p, \"**\"))\n");
		return 0;
	}*/


#endif
	printf("type_line = %d\n", type_line);
	switch(type_line)
	{
	case 1:
		{
			// г.Харьков
			// наименование объекта
			sprintf(szBuff, "%s\n", m_laboratory->object_name.c_str());
			CharToOem(szBuff, szBuff);
			fprintf(stream, szBuff);
			return -1;
		}
		break;
	case 2:
		{
			// 2008
			// наименование договора
			sprintf(szBuff, "%s\n", m_laboratory->contract.c_str());
			CharToOem(szBuff, szBuff);
			fprintf(stream, szBuff);
			return -1;
		}
		break;
	case 3:
		{
			// 2
			// архивный номер
			sprintf(szBuff, "%d\n", m_laboratory->id_obj);
			fprintf(stream, szBuff);
			return -1;
		}
		break;
	case 4:
		{
			//3,3,11000,
			//идентификационный номер, номер слоя, схема испытания
			m_lablayer->FormExperimentsScheme();
			sprintf(szBuff, "%s,%s,%s,\n", m_lablayer->ID.c_str(), m_lablayer->layer_number.c_str(), m_lablayer->experiments_scheme.c_str());
			fprintf(stream, szBuff);
			return 1;
		}
		break;
	case 5:
		{
			// Компрессия 
			// лит,56.00,20.,од.,водонас.,0.,0.,6.,0.,
			// тип прибора,	диаметр кольца, высота кольца, метод испытания, заданная влажность, заданная плотность, количество давлений в природном состоянии, количество давлений в заданном состоянии, количество давлений на усадку
			m_lab_experiment = m_lablayer->FindLabExperiment(LabExperiment::type::compression);

			double hoop_d = 0.0;
			double hoop_h = 0.0;
			int n_1 = 0;
			int n_2 = 0;
			int n_3 = 0;

			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);
			if (compression)
			{
				CompressionLabTrial3 * com_lab_trial3 = dynamic_cast<CompressionLabTrial3 *>(this->FindLabTrial(LabTrial::indication::compression_3, -1));
				if (com_lab_trial3)
				{
					if (com_lab_trial3->p_trial_3)
					{
						hoop_d = com_lab_trial3->p_trial_3->hoop_diameter;
						hoop_h = com_lab_trial3->p_trial_3->hoop_height;
						n_3 = com_lab_trial3->p_trial_3->n_pressures;
					}					
					if (com_lab_trial3->p_trial_2)
					{
						hoop_d = com_lab_trial3->p_trial_2->hoop_diameter;
						hoop_h = com_lab_trial3->p_trial_2->hoop_height;
						n_2 = com_lab_trial3->p_trial_2->n_pressures;
					}
					if (com_lab_trial3->p_trial_1)
					{
						hoop_d = com_lab_trial3->p_trial_1->hoop_diameter;
						hoop_h = com_lab_trial3->p_trial_1->hoop_height;
						n_1 = com_lab_trial3->p_trial_1->n_pressures;
					}
				}
				else
				{
					CompressionLabTrial * com_lab_trial_1 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, -1));
					CompressionLabTrial * com_lab_trial_2 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_task_condition_absolute_deformation, -1));
					CompressionLabTrial * com_lab_trial_3 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_shrinkage_absolute_deformation, -1));
					if (com_lab_trial_3)
					{
						hoop_d = com_lab_trial_3->hoop_diameter;
						hoop_h = com_lab_trial_3->hoop_height;
						n_3 = com_lab_trial_3->n_pressures;
					}					
					if (com_lab_trial_2)
					{
						hoop_d = com_lab_trial_2->hoop_diameter;
						hoop_h = com_lab_trial_2->hoop_height;
						n_2 = com_lab_trial_2->n_pressures;
					}
					if (com_lab_trial_1)
					{
						hoop_d = com_lab_trial_1->hoop_diameter;
						hoop_h = com_lab_trial_1->hoop_height;
						n_1 = com_lab_trial_1->n_pressures;
					}
				}
				
				sprintf(szBuff, "%s,%0.2f,%0.2f,%s,%s,%0.2f,%d.,%d.,%d.,0.,\n", 
					compression->apparatus_type.c_str(), 
					hoop_d, hoop_h, 
					compression->trial_method.c_str(), 
					compression->task_moisture.c_str(),
					compression->task_density,
					n_1, n_2, n_3);	
				fprintf(stream, szBuff);

			}
			return 1;

		}
		break;
	case 6:
		{
			// 0.05,0.10,0.15,0.2,0.25,0.3,
			// массив давлений природного состояния
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);
			if (compression)
			{
				CompressionLabTrial3 * com_lab_trial3 = dynamic_cast<CompressionLabTrial3 *>(this->FindLabTrial(LabTrial::indication::compression_3, -1));
				if (com_lab_trial3)
				{
					if (com_lab_trial3->p_trial_1 && com_lab_trial3->p_trial_1->n_pressures)
					{
						for (int i = 0; i < com_lab_trial3->p_trial_1->n_pressures; i++)
						{
							sprintf(szBuff, "%0.2f,", com_lab_trial3->p_trial_1->pressures[i]);
							fprintf(stream, szBuff);
						}
						fprintf(stream, "\n");
					}
				}
				else
				{
					CompressionLabTrial * com_lab_trial_1 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, -1));
					CompressionLabTrial * com_lab_trial_2 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_task_condition_absolute_deformation, -1));
					CompressionLabTrial * com_lab_trial_3 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_shrinkage_absolute_deformation, -1));

					if (com_lab_trial_1 && com_lab_trial_1->n_pressures)
					{
						for (int i = 0; i < com_lab_trial_1->n_pressures; i++)
						{
							sprintf(szBuff, "%0.2f,", com_lab_trial3->p_trial_1->pressures[i]);
							fprintf(stream, szBuff);
						}
						fprintf(stream, "\n");
					}
				}
			}
			
			return 1;
		}
		break;
	case 7:
		{
			// 0.05,0.10,0.15,0.2,0.25,0.3,
			// массив давлений заданного состояния
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);
			if (compression)
			{
				CompressionLabTrial3 * com_lab_trial3 = dynamic_cast<CompressionLabTrial3 *>(this->FindLabTrial(LabTrial::indication::compression_3, -1));
				if (com_lab_trial3)
				{
					if (com_lab_trial3->p_trial_2 && com_lab_trial3->p_trial_2->n_pressures)
					{
						for (int i = 0; i < com_lab_trial3->p_trial_2->n_pressures; i++)
						{
							sprintf(szBuff, "%0.2f,", com_lab_trial3->p_trial_2->pressures[i]);
							fprintf(stream, szBuff);
						}
						fprintf(stream, "\n");
					}
				}
				else
				{
					CompressionLabTrial * com_lab_trial_1 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, -1));
					CompressionLabTrial * com_lab_trial_2 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_task_condition_absolute_deformation, -1));
					CompressionLabTrial * com_lab_trial_3 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_shrinkage_absolute_deformation, -1));

					if (com_lab_trial_2 && com_lab_trial_2->n_pressures)
					{
						for (int i = 0; i < com_lab_trial_2->n_pressures; i++)
						{
							sprintf(szBuff, "%0.2f,", com_lab_trial3->p_trial_2->pressures[i]);
							fprintf(stream, szBuff);
						}
						fprintf(stream, "\n");
					}
				}
			}
			
			return 1;
		}
		break;
	case 8:
		{
			// 0.05,0.10,0.15,0.2,0.25,0.3,
			// массив давлений на усадку
			CompressionLabExperiment * compression = dynamic_cast<CompressionLabExperiment *>(m_lab_experiment);
			if (compression)
			{
				CompressionLabTrial3 * com_lab_trial3 = dynamic_cast<CompressionLabTrial3 *>(this->FindLabTrial(LabTrial::indication::compression_3, -1));
				if (com_lab_trial3)
				{
					if (com_lab_trial3->p_trial_3 && com_lab_trial3->p_trial_3->n_pressures)
					{
						for (int i = 0; i < com_lab_trial3->p_trial_3->n_pressures; i++)
						{
							sprintf(szBuff, "%0.2f,", com_lab_trial3->p_trial_3->pressures[i]);
							fprintf(stream, szBuff);
						}
						fprintf(stream, "\n");
					}
				}
				else
				{
					CompressionLabTrial * com_lab_trial_1 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, -1));
					CompressionLabTrial * com_lab_trial_2 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_task_condition_absolute_deformation, -1));
					CompressionLabTrial * com_lab_trial_3 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_shrinkage_absolute_deformation, -1));

					if (com_lab_trial_3 && com_lab_trial_3->n_pressures)
					{
						for (int i = 0; i < com_lab_trial_3->n_pressures; i++)
						{
							sprintf(szBuff, "%0.2f,", com_lab_trial3->p_trial_3->pressures[i]);
							fprintf(stream, szBuff);
						}
						fprintf(stream, "\n");
					}
				}
			}
			return 1;
		}
		break;
	case 9:
		{
			// лит,56.,20.,консолид,водонас.,0.0,0.,3.,0.05,0.1,0.15,
			// СРЕЗ
			// тип прибора, диаметр кольца, высота кольца, метод испытания, заданная влажность, заданная плотность, колич. давлений природного состояния, кол. давл. в зад. сост., массив давлений природного состояния, массив давлений заданного состояния
			// 
			m_lab_experiment = m_lablayer->FindLabExperiment(LabExperiment::type::cut);

			CutLabExperiment * cut = dynamic_cast<CutLabExperiment *>(m_lab_experiment);
			if (cut)
			{
				CutLabTrial * cut_lab_trial_1 = dynamic_cast<CutLabTrial *>(this->FindLabTrial(LabTrial::indication::cut_resistance_nature_condition, -1));
				CutLabTrial * cut_lab_trial_2 = dynamic_cast<CutLabTrial *>(this->FindLabTrial(LabTrial::indication::cut_resistance_task_condition, -1));
				
				sprintf(szBuff, "%s,%0.2f,%0.2f,%s,%s,%0.2f,%d.,%d.,", 
					cut->apparatus_type.c_str(), 
					cut->hoop_diameter,
					cut->hoop_height, 
					cut->trial_method.c_str(), 
					cut->task_moisture.c_str(),
					cut->task_density,
					cut_lab_trial_1 ? cut_lab_trial_1->n_pressures : 0,
					cut_lab_trial_2 ? cut_lab_trial_2->n_pressures : 0);	

				fprintf(stream, szBuff);



				if (cut_lab_trial_1 && cut_lab_trial_1->n_pressures)
				{
					for (int i = 0; i < cut_lab_trial_1->n_pressures; i++)
					{
						fprintf(stream, "%0.2f,", cut_lab_trial_1->pressures[i]);
					}
				}

				if (cut_lab_trial_2 && cut_lab_trial_2->n_pressures)
				{
					for (int i = 0; i < cut_lab_trial_2->n_pressures; i++)
					{
						fprintf(stream, "%0.2f,", cut_lab_trial_2->pressures[i]);
					}
				}
			}
			fprintf(stream, "\n");

			return 1;
		}
		break;
	case 10:
		{
			m_lab_experiment = m_lablayer->FindLabExperiment(LabExperiment::type::filtration);
			FiltrationLabExperiment * filtration = dynamic_cast<FiltrationLabExperiment *>(m_lab_experiment);

			if (filtration)
			{
				sprintf(szBuff, "%s,%0.2f,%0.2f,%0.2f,%0.2f,", 
					filtration->apparatus_type.c_str(), 
					filtration->tube_diameter, filtration->tube_lenght, 
					filtration->liquid_force_height, 
					filtration->task_density);	

				fprintf(stream, szBuff);
								
				for (int i = 0; i < 3; i++)
				{
					fprintf(stream, "%0.2f,", filtration->pressures[i]);
				}
			}			
			fprintf(stream, "\n");
			return 1;
		}
		break;
	case 11:
		{
			m_lab_experiment = m_lablayer->FindLabExperiment(LabExperiment::type::pressing);
			PressingLabExperiment * pressing = dynamic_cast<PressingLabExperiment *>(m_lab_experiment);

			if (pressing)
			{
				sprintf(szBuff, "%s,%s,%0.2f,\n", 
					pressing->apparatus_type.c_str(), 
					pressing->task_moisture.c_str(), 
					pressing->density);	

				fprintf(stream, szBuff);
			}
			return 1;
		}
		break;
	case 12:
		{
			m_lab_experiment = m_lablayer->FindLabExperiment(LabExperiment::type::fractions);
			
#if USE_LAB_LAYER_FRACTIONS
			FractionsLabExperiment * fractions = dynamic_cast<FractionsLabExperiment *>(m_lab_experiment);

			if(fractions)
			{
				sprintf(szBuff, "%d,", 
					fractions->n_fractions);	

				fprintf(stream, szBuff);
								
				if (fractions->n_fractions)
				{
					for (int i = 0; i < fractions->n_fractions; i++)
					{
						fprintf(stream, "%0.2f,", fractions->fractions_diameters[i]);
					}
				}
				fprintf(stream, "\n");
			}

#else

			FractionsLabTrial * frac_lab_trial = dynamic_cast<FractionsLabTrial *>(this->FindLabTrial(LabTrial::indication::fractions, -1));
			if(frac_lab_trial)
			{
				sprintf(szBuff, "%d,", 
					frac_lab_trial->n_fractions);	

				fprintf(stream, szBuff);
								
				if (frac_lab_trial->n_fractions)
				{
					for (int i = 0; i < frac_lab_trial->n_fractions; i++)
					{
						fprintf(stream, "%0.2f,", frac_lab_trial->fractions_diameters[i]);
					}
				}
				fprintf(stream, "\n");
			}

#endif
			return 1;
		}
		break;
	case 13:// 1
		{
			// заголовок данных по лабораторному номеру
			// 414,скв.,1003,1.3,1,2,5,8,0,
			// лабораторный идентификационный номер, наименование выработки, номер выработки, глубина пробы, признаки испытания

			if (m_lab_number)
			{
				char str[128];
				sprintf(str, "%s\0", m_lab_number->mine_working_number.c_str());
				CharToOem(str, str);

				sprintf(szBuff, "%s,%s,%s,%0.2f,", 
					m_lab_number->ID.c_str(), 
					m_lab_number->s_mine_working_type.c_str(), 
					str, 
					m_lab_number->depth);

				fprintf(stream, szBuff);

//				std::sort(m_lab_number->trial_indications.begin(), m_lab_number->trial_indications.end());
				
				for (map<LabTrial::indication, LabTrial::indication>::iterator it = m_lab_number->trial_indications.begin();
					it != m_lab_number->trial_indications.end(); it++)
				{
					fprintf(stream, "%d,", (*it).first);					
				}                
				fprintf(stream, "0,\n");
			}
			return 1;
		}
		break;
	case 14://2 - 1 признак - физические характеристики
		{
			m_lab_trial = m_lab_number->FindLabTrial(LabTrial::indication::physical, -1);
			PhysicalLabTrial * physical_trial = dynamic_cast<PhysicalLabTrial *>(m_lab_trial);

			if (physical_trial)
			{
				sprintf(szBuff, "%0.2f,%0.2f,%0.2f,%0.2f,%0.2f,%0.2f,%0.3f,%0.3f,\n", 
					physical_trial->moisture_on_fluidity_border.f ? physical_trial->moisture_on_fluidity_border.v : 0.0, 
					physical_trial->moisture_on_plasticity_border.f ? physical_trial->moisture_on_plasticity_border.v : 0.0, 
					physical_trial->moisture_of_nature_large_exchange.f ? physical_trial->moisture_of_nature_large_exchange.v : 0.0, 
					physical_trial->moisture_of_aggregate_sample.f ? physical_trial->moisture_of_aggregate_sample.v : 0.0,
					physical_trial->hygroscopic_moisture.f ? physical_trial->hygroscopic_moisture.v : 0.0,
					physical_trial->maximal_molecular_moisture_capacity.f ? physical_trial->maximal_molecular_moisture_capacity.v : 0.0,
					physical_trial->density_of_ground_particles.f ? physical_trial->density_of_ground_particles.v : 0.0,
					physical_trial->density_of_ground.f ? physical_trial->density_of_ground.v : 0.0);	

				fprintf(stream, szBuff);		
			}
			return 1;
		}
		break;
	case 15://3 - 2 признак - химические характеристики
		{
			m_lab_trial = m_lab_number->FindLabTrial(LabTrial::indication::chemical, -1);
			ChemicalLabTrial * chemical_trial = dynamic_cast<ChemicalLabTrial *>(m_lab_trial);

			if (chemical_trial)
			{
				sprintf(szBuff, "%0.2f,%0.2f,%0.2f,%0.2f,%0.2f,%0.2f,%0.2f,%0.2f,%0.2f,\n", 
					chemical_trial->common_salts_content.f ? chemical_trial->common_salts_content.v : 0.0, 
					chemical_trial->well_solutable_salts.f ? chemical_trial->well_solutable_salts.v : 0.0, 
					chemical_trial->vegetable_remains_content.f ? chemical_trial->vegetable_remains_content.v : 0.0, 
					chemical_trial->organic_matters.f ? chemical_trial->organic_matters.v : 0.0,
					chemical_trial->pH.f ? chemical_trial->pH.v : 0.0,
					chemical_trial->steel_mass_loss.f ? chemical_trial->steel_mass_loss.v : 0.0,
					chemical_trial->nitrogenic_matters.f ? chemical_trial->nitrogenic_matters.v : 0.0,
					chemical_trial->Cl_ion.f ? chemical_trial->Cl_ion.v : 0.0, 
					chemical_trial->Fe_ion.f ? chemical_trial->Fe_ion.v : 0.0);	

				fprintf(stream, szBuff);		
			}
			return 1;
		}
		break;
	case 16://4 - 3 признак - фракции 
		{
			m_lab_trial = m_lab_number->FindLabTrial(LabTrial::indication::fractions,-1);
			FractionsLabTrial * fractions_trial = dynamic_cast<FractionsLabTrial *>(m_lab_trial);
			LabLayer * lablayer = (LabLayer *) m_lab_number->GetLabLayer();
			if (lablayer)
			{
				m_lab_experiment = lablayer->FindLabExperiment(LabExperiment::type::fractions);
				FractionsLabExperiment * fractions = dynamic_cast<FractionsLabExperiment *>(m_lab_experiment);

				if(fractions_trial && fractions)
				{
					if (fractions_trial->n_fractions)
					{
						for (int i = 0; i < fractions_trial->n_fractions; i++)
						{							
							fprintf(stream, "%0.2f,", fractions_trial->fractions_content[i].v);
						}
					}
				}
			}
			fprintf(stream, "\n");
			return 1;
		}
		break;
	case 17://5 - 3 признак - фракции продолжение
		{
			FractionsLabTrial * fractions_trial = dynamic_cast<FractionsLabTrial *>(m_lab_trial);
			if(fractions_trial)
			{
				sprintf(szBuff, "%0.2f,%0.2f,%0.2f,%0.2f,%0.2f,%0.2f,\n", 
					fractions_trial->fractions_content_in_aggregate_sample.f ? fractions_trial->fractions_content_in_aggregate_sample : 0.0, 
					fractions_trial->particles_content_of_diameter_more_2.f ? fractions_trial->particles_content_of_diameter_more_2.v : 0.0, 
					fractions_trial->particles_content_of_diameter_less_1.f ? fractions_trial->particles_content_of_diameter_less_1.v : 0.0, 
					fractions_trial->pourness.f ? fractions_trial->pourness.v : 0.0,
					fractions_trial->slope_angle_of_dry_ground.f ? fractions_trial->slope_angle_of_dry_ground.v : 0.0,
					fractions_trial->slope_angle_under_water.f ? fractions_trial->slope_angle_under_water.v : 0.0);	

				fprintf(stream, szBuff);	
			}
			return 1;
		}
		break;
	case 18://6 - 4 признак - компрессия в природном состоянии
		{
			CompressionLabTrial3 * com_lab_trial3 = dynamic_cast<CompressionLabTrial3 *>(this->FindLabTrial(LabTrial::indication::compression_3, -1));
			if (com_lab_trial3)
			{
				if (com_lab_trial3->p_trial_1)
				{
					for (int i = 0; i < com_lab_trial3->p_trial_1->n_pressures; i++)
					{
						sprintf(szBuff, "%0.3f,", com_lab_trial3->p_trial_1->absolute_deformations[i].v);
						fprintf(stream, szBuff);
					}

				}
				m_lab_trial = com_lab_trial3->p_trial_1;
			}
			else
			{
				CompressionLabTrial * com_lab_trial_1 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, -1));
				CompressionLabTrial * com_lab_trial_2 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_task_condition_absolute_deformation, -1));
				CompressionLabTrial * com_lab_trial_3 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_shrinkage_absolute_deformation, -1));

				if (com_lab_trial_1)
				{
					for (int i = 0; i < com_lab_trial_1->n_pressures; i++)
					{
						sprintf(szBuff, "%0.3f,", com_lab_trial_1->absolute_deformations[i].v);
						fprintf(stream, szBuff);
					}
				}
				m_lab_trial = com_lab_trial_1;
			}
			fprintf(stream, "\n");
			return 1;
		}
		break;
	case 19://7 - 5 признак - компрессия в заданном состоянии
		{
			CompressionLabTrial3 * com_lab_trial3 = dynamic_cast<CompressionLabTrial3 *>(this->FindLabTrial(LabTrial::indication::compression_3, -1));
			if (com_lab_trial3)
			{
				if (com_lab_trial3->p_trial_2)
				{
					for (int i = 0; i < com_lab_trial3->p_trial_2->n_pressures; i++)
					{
						sprintf(szBuff, "%0.3f,", com_lab_trial3->p_trial_2->absolute_deformations[i].v);
						fprintf(stream, szBuff);
					}

				}
				m_lab_trial = com_lab_trial3->p_trial_2;
			}
			else
			{
				CompressionLabTrial * com_lab_trial_1 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, -1));
				CompressionLabTrial * com_lab_trial_2 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_task_condition_absolute_deformation, -1));
				CompressionLabTrial * com_lab_trial_3 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_shrinkage_absolute_deformation, -1));

				if (com_lab_trial_2)
				{
					for (int i = 0; i < com_lab_trial_2->n_pressures; i++)
					{
						sprintf(szBuff, "%0.3f,", com_lab_trial_2->absolute_deformations[i].v);
						fprintf(stream, szBuff);
					}
				}
				m_lab_trial = com_lab_trial_2;
			}
			fprintf(stream, "\n");
			return 1;
		}
		break;

	case 20://8 - 6 признак - компрессия на усадку
		{
			CompressionLabTrial3 * com_lab_trial3 = dynamic_cast<CompressionLabTrial3 *>(this->FindLabTrial(LabTrial::indication::compression_3, -1));
			if (com_lab_trial3)
			{
				if (com_lab_trial3->p_trial_3)
				{
					for (int i = 0; i < com_lab_trial3->p_trial_3->n_pressures; i++)
					{
						sprintf(szBuff, "%0.3f,", com_lab_trial3->p_trial_3->absolute_deformations[i].v);
						fprintf(stream, szBuff);
					}

				}
				m_lab_trial = com_lab_trial3->p_trial_3;
			}
			else
			{
				CompressionLabTrial * com_lab_trial_1 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_nature_condition_absolute_deformation, -1));
				CompressionLabTrial * com_lab_trial_2 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_task_condition_absolute_deformation, -1));
				CompressionLabTrial * com_lab_trial_3 = dynamic_cast<CompressionLabTrial *>(this->FindLabTrial(LabTrial::indication::compression_shrinkage_absolute_deformation, -1));

				if (com_lab_trial_3)
				{
					for (int i = 0; i < com_lab_trial_3->n_pressures; i++)
					{
						sprintf(szBuff, "%0.3f,", com_lab_trial_3->absolute_deformations[i].v);
						fprintf(stream, szBuff);
					}
				}
				m_lab_trial = com_lab_trial_3;
			}
			fprintf(stream, "\n");
			return 1;
		}
		break;
	case 21://9 - 7 признак - сопротивление срезу в природном состоянии
		{
			m_lab_trial = m_lab_number->FindLabTrial(LabTrial::indication::cut_resistance_nature_condition, -1);
			
			CutLabTrial * cut_trial = dynamic_cast<CutLabTrial *>(m_lab_trial);
			LabLayer * lablayer = (LabLayer *) m_lab_number->GetLabLayer();
			if (lablayer)
			{
				m_lab_experiment = lablayer->FindLabExperiment(LabExperiment::type::cut);

				if(cut_trial)
				{
					if (cut_trial->n_pressures)
					{
						for (int i = 0; i < cut_trial->n_pressures; i++)
						{
							sprintf(szBuff, "%0.3f,", cut_trial->cut_resistances[i].v);
							fprintf(stream, szBuff);
						}
					}
				}
			}
			fprintf(stream, "\n");
			return 1;
		}
		break;
	case 22://10 - 8 признак - сопротивление срезу заданном состояним
		{
			m_lab_trial = m_lab_number->FindLabTrial(LabTrial::indication::cut_resistance_task_condition, -1);
			CutLabTrial * cut_trial = dynamic_cast<CutLabTrial *>(m_lab_trial);
			LabLayer * lablayer = (LabLayer *) m_lab_number->GetLabLayer();
			if (lablayer)
			{
				m_lab_experiment = lablayer->FindLabExperiment(LabExperiment::type::cut);

				if(cut_trial)
				{
					if (cut_trial->n_pressures)
					{
						for (int i = 0; i < cut_trial->n_pressures; i++)
						{
							sprintf(szBuff, "%0.3f,", cut_trial->cut_resistances[i].v);
							fprintf(stream, szBuff);
						}
					}
				}
			}
			fprintf(stream, "\n");
			return 1;
		}
		break;
	case 23://11 - 9 признак - одноосное сжатие
		{
			m_lab_trial = m_lab_number->FindLabTrial(LabTrial::indication::pressing, -1);
			PressingLabTrial * pressing_trial = dynamic_cast<PressingLabTrial *>(m_lab_trial);

			if (pressing_trial)
			{
				for (int i = 0; i < 3; i++)
				{
					sprintf(szBuff, "%0.3f,%0.3f,", 
						pressing_trial->loads[i],
						pressing_trial->sections[i]);
					fprintf(stream, szBuff);
				}			
			}
			fprintf(stream, "\n");
			return 1;
		}
		break;
	case 24://12 - 10 признак - фильтрация при давлениях
		{
			m_lab_trial = m_lab_number->FindLabTrial(LabTrial::indication::filtration_coefficient_with_pressures, -1);
			FiltrationLabTrial * filtration_trial = dynamic_cast<FiltrationLabTrial *>(m_lab_trial);

			if (filtration_trial)
			{
				for (int i = 0; i < 3; i++)
				{
					sprintf(szBuff, "%0.3f,%0.3f,", 
						filtration_trial->expenditures[i],
						filtration_trial->densities[i]);
					fprintf(stream, szBuff);
				}			
			}
			fprintf(stream, "\n");
			return 1;
		}
		break;
	case 25://12 - 11 признак - фильтрация при плотностях
		{
			m_lab_trial = m_lab_number->FindLabTrial(LabTrial::indication::filtration_coefficient_with_densities, -1);
			FiltrationLabTrial * filtration_trial = dynamic_cast<FiltrationLabTrial *>(m_lab_trial);

			if (filtration_trial)
			{
				for (int i = 0; i < 3; i++)
				{
					sprintf(szBuff, "%0.3f,%0.3f,", 
						filtration_trial->expenditures[i],
						filtration_trial->densities[i]);
					fprintf(stream, szBuff);
				}			
			}
			fprintf(stream, "\n");
			return 1;
		}
		break;
	}
	return -1;
}

#endif
bool LabNumber::SaveAsLabInputFile(char *file)
{
	LabLayer * m_lablayer;
	LabExperiment * m_lab_experiment;
	Laboratory * m_laboratory;
	LabTrial * m_lab_trial;

	m_lablayer = (LabLayer *)this->GetLabLayer();
	m_laboratory = (Laboratory *)m_lablayer->GetLaboratory();
	m_lab_experiment = NULL;
	m_lab_trial = NULL;


	printf("SurfDoc::SaveAsLabInputFile(\"%s\")\n",file);

	const int n=16384; // length of buffer string line
	char* szBuff; // buffer string line
	if ((szBuff = (char *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,n*sizeof(char))) == NULL)
	{
		MessageBox(0, "vX - Not enough memory",
			"SaveAsLabInputFile()", 0);
		return false;
	}

	FILE *stream;
	if ((stream = fopen(file,"wt")) == NULL)
	{
		char errstr[2048];
		sprintf(errstr, "SurfDoc::SaveAsLabInputFile:fopen(%s)", file);
		MessageBox(0, errstr,"SaveAsLabInputFile()", 0);
		return false;
	}

	
	int type_line = 1;


	bool to_write = true;


	while (to_write)
	{
		int res = SaveLabInputFileLine(stream, szBuff, type_line, 
			m_laboratory, m_lablayer, m_lab_experiment, m_lab_trial);
		if (res == -1 || res == 1 || res == 2)
			type_line++;
		else if (res == 0)
		{
		}
		else if (res == 3)
		{
			break;
		}
	}

	fclose(stream);
	return true;
}

void LabNumber::SaveAs()
{
	//bool SaveAs()
	{
		bool status = false;
		TCHAR lpstrFile[256];
		TCHAR filter[] =  
			TEXT("Lab Files(*.*)\0*.*\0")
			TEXT("All Files (*.*)\0*.*\0");

		sprintf(lpstrFile, "\0");
		sprintf(lpstrFile, "%s\0", this->ID.c_str());

		DWORD nFilterIndex = 0;
		if (SaveFileDlg(0, lpstrFile, filter, nFilterIndex) != S_OK)
			return;
		if (nFilterIndex == 1)
		{
			status = SaveAsLabInputFile(lpstrFile);
		}
		else
		{
			FILE *stream;
			stream = fopen(lpstrFile,"wt");
			if (!stream)
			{
				return;
			}
			switch (nFilterIndex)
			{
			case 2:
//				status = SaveAsBln(stream);
				break;
			case 3:
//				status = SaveAsDat(stream);
				break;
			}
			fclose (stream);
		}
	}
}



void LabLayer::SaveAs()
{
}

const char * LabNormatives::TypeToString(LabNormatives::type t)
{
	switch(t)
	{
	case LabNormatives::type::normative:
		return "нормативное значение";
	case LabNormatives::type::raschotn_85:
		return "расчётное знач. 85%";
	case LabNormatives::type::raschotn_95:
		return "расчётное знач. 95%";
	case LabNormatives::type::raschotn_99:
		return "расчётное знач. 99%";

	case LabNormatives::type::srednekvadratic_otklonenie:
		return "среднеквадратическое отклонение";
	case LabNormatives::type::variacii_koefficient:
		return "коэффициент вариации";
	}
	return "";
}
